[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar HTTP = Package.http.HTTP;\nvar HTTPInternals = Package.http.HTTPInternals;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"meteortesting:mocha\":{\"server.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/meteortesting_mocha/server.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.export({\n  start: () => start\n});\nlet mochaInstance;\nmodule.link(\"meteor/meteortesting:mocha-core\", {\n  mochaInstance(v) {\n    mochaInstance = v;\n  }\n\n}, 0);\nlet startBrowser;\nmodule.link(\"meteor/meteortesting:browser-tests\", {\n  startBrowser(v) {\n    startBrowser = v;\n  }\n\n}, 1);\nlet fs;\nmodule.link(\"fs\", {\n  default(v) {\n    fs = v;\n  }\n\n}, 2);\nlet setArgs;\nmodule.link(\"./runtimeArgs\", {\n  default(v) {\n    setArgs = v;\n  }\n\n}, 3);\nlet handleCoverage;\nmodule.link(\"./server.handleCoverage\", {\n  default(v) {\n    handleCoverage = v;\n  }\n\n}, 4);\n\nif (Package['browser-policy-common'] && Package['browser-policy-content']) {\n  const {\n    BrowserPolicy\n  } = Package['browser-policy-common']; // Allow the remote mocha.css file to be inserted, in case any CSP stuff\n  // exists for the domain.\n\n  BrowserPolicy.content.allowInlineStyles();\n  BrowserPolicy.content.allowStyleOrigin('https://cdn.rawgit.com');\n}\n\nconst {\n  mochaOptions,\n  runnerOptions,\n  coverageOptions\n} = setArgs();\nconst {\n  grep,\n  invert,\n  reporter,\n  serverReporter,\n  serverOutput,\n  clientOutput\n} = mochaOptions || {}; // Since intermingling client and server log lines would be confusing,\n// the idea here is to buffer all client logs until server tests have\n// finished running and then dump the buffer to the screen and continue\n// logging in real time after that if client tests are still running.\n\nlet serverTestsDone = false;\nconst clientLines = [];\n\nfunction clientLogBuffer(line) {\n  if (serverTestsDone) {\n    // printing and removing the extra new-line character. The first was added by the client log, the second here.\n    console.log(line.replace(/\\n$/, ''));\n  } else {\n    clientLines.push(line);\n  }\n}\n\nfunction printHeader(type) {\n  const lines = ['\\n--------------------------------', Meteor.isAppTest ? `--- RUNNING APP ${type} TESTS ---` : `----- RUNNING ${type} TESTS -----`, '--------------------------------\\n'];\n  lines.forEach(line => {\n    if (type === 'CLIENT') {\n      clientLogBuffer(line);\n    } else {\n      console.log(line);\n    }\n  });\n}\n\nlet callCount = 0;\nlet clientFailures = 0;\nlet serverFailures = 0;\n\nfunction exitIfDone(type, failures) {\n  callCount++;\n\n  if (type === 'client') {\n    clientFailures = failures;\n  } else {\n    serverFailures = failures;\n    serverTestsDone = true;\n    clientLines.forEach(line => {\n      // printing and removing the extra new-line character. The first was added by the client log, the second here.\n      console.log(line.replace(/\\n$/, ''));\n    });\n  }\n\n  if (callCount === 2) {\n    // We only need to show this final summary if we ran both kinds of tests in the same console\n    if (runnerOptions.runServer && runnerOptions.runClient && runnerOptions.browserDriver) {\n      console.log('All tests finished!\\n');\n      console.log('--------------------------------');\n      console.log(`${Meteor.isAppTest ? 'APP ' : ''}SERVER FAILURES: ${serverFailures}`);\n      console.log(`${Meteor.isAppTest ? 'APP ' : ''}CLIENT FAILURES: ${clientFailures}`);\n      console.log('--------------------------------');\n    }\n\n    handleCoverage(coverageOptions).then(() => {\n      // if no env for TEST_WATCH, tests should exit when done\n      if (!runnerOptions.testWatch) {\n        if (clientFailures + serverFailures > 0) {\n          process.exit(1); // exit with non-zero status if there were failures\n        } else {\n          process.exit(0);\n        }\n      }\n    });\n  }\n}\n\nfunction serverTests(cb) {\n  if (!runnerOptions.runServer) {\n    console.log('SKIPPING SERVER TESTS BECAUSE TEST_SERVER=0');\n    exitIfDone('server', 0);\n    if (cb) cb();\n    return;\n  }\n\n  printHeader('SERVER');\n  if (grep) mochaInstance.grep(grep);\n  if (invert) mochaInstance.options.invert = invert;\n  mochaInstance.options.useColors = true; // We need to set the reporter when the tests actually run to ensure no conflicts with\n  // other test driver packages that may be added to the app but are not actually being\n  // used on this run.\n\n  mochaInstance.reporter(serverReporter || reporter || 'spec', {\n    output: serverOutput\n  });\n  mochaInstance.run(failureCount => {\n    if (typeof failureCount !== 'number') {\n      console.log('Mocha did not return a failure count for server tests as expected');\n      exitIfDone('server', 1);\n    } else {\n      exitIfDone('server', failureCount);\n    }\n\n    if (cb) cb();\n  });\n}\n\nfunction clientTests() {\n  if (!runnerOptions.runClient) {\n    console.log('SKIPPING CLIENT TESTS BECAUSE TEST_CLIENT=0');\n    exitIfDone('client', 0);\n    return;\n  }\n\n  if (!runnerOptions.browserDriver) {\n    console.log('Load the app in a browser to run client tests, or set the TEST_BROWSER_DRIVER environment variable. ' + 'See https://github.com/meteortesting/meteor-mocha/blob/master/README.md#run-app-tests');\n    exitIfDone('client', 0);\n    return;\n  }\n\n  printHeader('CLIENT');\n  startBrowser({\n    stdout(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n\n    writebuffer(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n\n    stderr(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n\n    done(failureCount) {\n      if (typeof failureCount !== 'number') {\n        console.log('The browser driver package did not return a failure count for server tests as expected');\n        exitIfDone('client', 1);\n      } else {\n        exitIfDone('client', failureCount);\n      }\n    }\n\n  });\n} // Before Meteor calls the `start` function, app tests will be parsed and loaded by Mocha\n\n\nfunction start() {\n  // Run in PARALLEL or SERIES\n  // Running in series is a better default since it avoids db and state conflicts for newbs.\n  // If you want parallel you will know these risks.\n  if (runnerOptions.runParallel) {\n    console.log('Warning: Running in parallel can cause side-effects from state/db sharing');\n    serverTests();\n    clientTests();\n  } else {\n    serverTests(() => {\n      clientTests();\n    });\n  }\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"runtimeArgs.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/meteortesting_mocha/runtimeArgs.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.export({\n  default: () => setArgs\n});\n\nfunction setArgs() {\n  const {\n    MOCHA_GREP,\n    MOCHA_INVERT,\n    MOCHA_REPORTER,\n    CLIENT_TEST_REPORTER,\n    SERVER_TEST_REPORTER,\n    TEST_BROWSER_DRIVER,\n    TEST_CLIENT,\n    TEST_PARALLEL,\n    TEST_SERVER,\n    TEST_WATCH,\n    METEOR_AUTO_RESTART,\n    // Introduced in Meteor 1.8.1 to indicate if this instance will automatically restart after exiting. https://github.com/meteor/meteor/pull/10465\n    XUNIT_FILE,\n    SERVER_MOCHA_OUTPUT,\n    CLIENT_MOCHA_OUTPUT,\n    COVERAGE,\n    COVERAGE_VERBOSE,\n    COVERAGE_IN_COVERAGE,\n    COVERAGE_OUT_COVERAGE,\n    COVERAGE_OUT_LCOVONLY,\n    COVERAGE_OUT_HTML,\n    COVERAGE_OUT_JSON,\n    COVERAGE_OUT_JSON_SUMMARY,\n    COVERAGE_OUT_TEXT_SUMMARY,\n    COVERAGE_OUT_REMAP\n  } = process.env;\n  const runtimeArgs = {\n    mochaOptions: {\n      grep: MOCHA_GREP || false,\n      invert: !!MOCHA_INVERT,\n      reporter: MOCHA_REPORTER,\n      serverReporter: SERVER_TEST_REPORTER || XUNIT_FILE,\n      // XUNIT_FILE is left in here for compatibility to older versions\n      clientReporter: CLIENT_TEST_REPORTER,\n      serverOutput: SERVER_MOCHA_OUTPUT,\n      clientOutput: CLIENT_MOCHA_OUTPUT\n    },\n    runnerOptions: {\n      runClient: TEST_CLIENT !== 'false' && TEST_CLIENT !== '0',\n      runServer: TEST_SERVER !== 'false' && TEST_SERVER !== '0',\n      browserDriver: TEST_BROWSER_DRIVER,\n      testWatch: TEST_WATCH || METEOR_AUTO_RESTART === 'true',\n      runParallel: !!TEST_PARALLEL\n    }\n  };\n\n  if (COVERAGE === '1') {\n    runtimeArgs.coverageOptions = {\n      verbose: COVERAGE_VERBOSE === '1',\n      in: {\n        coverage: COVERAGE_IN_COVERAGE === 'true' || COVERAGE_IN_COVERAGE === '1'\n      },\n      out: {\n        coverage: COVERAGE_OUT_COVERAGE === 'true' || COVERAGE_OUT_COVERAGE === '1',\n        lcovonly: COVERAGE_OUT_LCOVONLY === 'true' || COVERAGE_OUT_LCOVONLY === '1',\n        html: COVERAGE_OUT_HTML === 'true' || COVERAGE_OUT_HTML === '1',\n        json: COVERAGE_OUT_JSON === 'true' || COVERAGE_OUT_JSON === '1',\n        json_summary: COVERAGE_OUT_JSON_SUMMARY === 'true' || COVERAGE_OUT_JSON_SUMMARY === '1',\n        text_summary: COVERAGE_OUT_TEXT_SUMMARY === 'true' || COVERAGE_OUT_TEXT_SUMMARY === '1',\n        remap: COVERAGE_OUT_REMAP === 'true' || COVERAGE_OUT_REMAP === '1'\n      }\n    };\n  } // Set the variables for the client to access as well.\n\n\n  Meteor.settings.public = Meteor.settings.public || {};\n  Meteor.settings.public.mochaRuntimeArgs = runtimeArgs;\n  return runtimeArgs;\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"server.handleCoverage.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/meteortesting_mocha/server.handleCoverage.js                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nlet HTTP;\nmodule.link(\"meteor/http\", {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 0);\nmodule.exportDefault(coverageOptions => {\n  let promise = Promise.resolve(true);\n\n  if (coverageOptions) {\n    const cLog = (...args) => {\n      if (coverageOptions.verbose) {\n        console.log(...args);\n      }\n    };\n\n    cLog('Export code coverage');\n\n    const importCoverageDump = () => new Promise((resolve, reject) => {\n      cLog('- In coverage');\n      HTTP.get(Meteor.absoluteUrl('coverage/import'), (error, response) => {\n        if (error) {\n          reject(new Error('Failed to import coverage file'));\n          return;\n        }\n\n        const {\n          statusCode\n        } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error('Failed to import coverage file'));\n        }\n\n        resolve();\n      });\n    });\n\n    const exportReport = (fileType, reportType) => new Promise((resolve, reject) => {\n      cLog(`- Out ${fileType}`);\n      const url = Meteor.absoluteUrl(`/coverage/export/${fileType}`);\n      HTTP.get(url, (error, response) => {\n        if (error) {\n          reject(new Error(`Failed to save ${fileType} ${reportType}`));\n          return;\n        }\n\n        const {\n          statusCode\n        } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error(`Failed to save ${fileType} ${reportType}`));\n        }\n\n        resolve();\n      });\n    });\n\n    const exportRemap = () => new Promise((resolve, reject) => {\n      cLog('- Out remap');\n      HTTP.get(Meteor.absoluteUrl('/coverage/export/remap'), (error, response) => {\n        if (error) {\n          reject(new Error('Failed to remap your coverage'));\n          return;\n        }\n\n        const {\n          statusCode\n        } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error('Failed to remap your coverage'));\n        }\n\n        resolve();\n      });\n    });\n\n    if (coverageOptions.in.coverage) {\n      promise = promise.then(() => importCoverageDump());\n    }\n\n    if (coverageOptions.out.coverage) {\n      promise = promise.then(() => exportReport('coverage', 'dump'));\n    }\n\n    if (coverageOptions.out.lcovonly) {\n      promise = promise.then(() => exportReport('lcovonly', 'coverage'));\n    }\n\n    if (coverageOptions.out.html) {\n      promise = promise.then(() => exportReport('html', 'report'));\n    }\n\n    if (coverageOptions.out.json) {\n      promise = promise.then(() => exportReport('json', 'report'));\n    }\n\n    if (coverageOptions.out.text_summary) {\n      promise = promise.then(() => exportReport('text-summary', 'report'));\n    }\n\n    if (coverageOptions.out.remap) {\n      promise = promise.then(() => exportRemap());\n    }\n\n    if (coverageOptions.out.json_summary) {\n      promise = promise.then(() => exportReport('json-summary', 'dump'));\n    }\n\n    promise = promise.catch(console.error);\n  }\n\n  return promise;\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/meteortesting:mocha/server.js\");\n\n/* Exports */\nPackage._define(\"meteortesting:mocha\", exports);\n\n})();\n","servePath":"/packages/meteortesting_mocha.js","sourceMap":{"version":3,"sources":["packages/meteortesting:mocha/server.js","packages/meteortesting:mocha/runtimeArgs.js","packages/meteortesting:mocha/server.handleCoverage.js"],"names":["module","export","start","mochaInstance","link","v","startBrowser","fs","default","setArgs","handleCoverage","Package","BrowserPolicy","content","allowInlineStyles","allowStyleOrigin","mochaOptions","runnerOptions","coverageOptions","grep","invert","reporter","serverReporter","serverOutput","clientOutput","serverTestsDone","clientLines","clientLogBuffer","line","console","log","replace","push","printHeader","type","lines","Meteor","isAppTest","forEach","callCount","clientFailures","serverFailures","exitIfDone","failures","runServer","runClient","browserDriver","then","testWatch","process","exit","serverTests","cb","options","useColors","output","run","failureCount","clientTests","stdout","data","appendFileSync","toString","writebuffer","stderr","done","runParallel","MOCHA_GREP","MOCHA_INVERT","MOCHA_REPORTER","CLIENT_TEST_REPORTER","SERVER_TEST_REPORTER","TEST_BROWSER_DRIVER","TEST_CLIENT","TEST_PARALLEL","TEST_SERVER","TEST_WATCH","METEOR_AUTO_RESTART","XUNIT_FILE","SERVER_MOCHA_OUTPUT","CLIENT_MOCHA_OUTPUT","COVERAGE","COVERAGE_VERBOSE","COVERAGE_IN_COVERAGE","COVERAGE_OUT_COVERAGE","COVERAGE_OUT_LCOVONLY","COVERAGE_OUT_HTML","COVERAGE_OUT_JSON","COVERAGE_OUT_JSON_SUMMARY","COVERAGE_OUT_TEXT_SUMMARY","COVERAGE_OUT_REMAP","env","runtimeArgs","clientReporter","verbose","in","coverage","out","lcovonly","html","json","json_summary","text_summary","remap","settings","public","mochaRuntimeArgs","HTTP","exportDefault","promise","Promise","resolve","cLog","args","importCoverageDump","reject","get","absoluteUrl","error","response","Error","statusCode","exportReport","fileType","reportType","url","exportRemap","catch"],"mappings":"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","file":"/packages/meteortesting_mocha.js","sourcesContent":["/* global Package */\nimport { mochaInstance } from 'meteor/meteortesting:mocha-core';\nimport { startBrowser } from 'meteor/meteortesting:browser-tests';\n\nimport fs from 'fs';\n\nimport setArgs from './runtimeArgs';\nimport handleCoverage from './server.handleCoverage';\n\nif (Package['browser-policy-common'] && Package['browser-policy-content']) {\n  const { BrowserPolicy } = Package['browser-policy-common'];\n\n  // Allow the remote mocha.css file to be inserted, in case any CSP stuff\n  // exists for the domain.\n  BrowserPolicy.content.allowInlineStyles();\n  BrowserPolicy.content.allowStyleOrigin('https://cdn.rawgit.com');\n}\n\nconst { mochaOptions, runnerOptions, coverageOptions } = setArgs();\nconst { grep, invert, reporter, serverReporter, serverOutput, clientOutput } = mochaOptions || {};\n\n// Since intermingling client and server log lines would be confusing,\n// the idea here is to buffer all client logs until server tests have\n// finished running and then dump the buffer to the screen and continue\n// logging in real time after that if client tests are still running.\n\nlet serverTestsDone = false;\nconst clientLines = [];\nfunction clientLogBuffer(line) {\n  if (serverTestsDone) {\n    // printing and removing the extra new-line character. The first was added by the client log, the second here.\n    console.log(line.replace(/\\n$/, ''));\n  } else {\n    clientLines.push(line);\n  }\n}\n\nfunction printHeader(type) {\n  const lines = [\n    '\\n--------------------------------',\n    Meteor.isAppTest ? `--- RUNNING APP ${type} TESTS ---` : `----- RUNNING ${type} TESTS -----`,\n    '--------------------------------\\n',\n  ];\n  lines.forEach((line) => {\n    if (type === 'CLIENT') {\n      clientLogBuffer(line);\n    } else {\n      console.log(line);\n    }\n  });\n}\n\nlet callCount = 0;\nlet clientFailures = 0;\nlet serverFailures = 0;\nfunction exitIfDone(type, failures) {\n  callCount++;\n  if (type === 'client') {\n    clientFailures = failures;\n  } else {\n    serverFailures = failures;\n    serverTestsDone = true;\n    clientLines.forEach((line) => {\n      // printing and removing the extra new-line character. The first was added by the client log, the second here.\n      console.log(line.replace(/\\n$/, ''));\n    });\n  }\n\n  if (callCount === 2) {\n    // We only need to show this final summary if we ran both kinds of tests in the same console\n    if (runnerOptions.runServer && runnerOptions.runClient && runnerOptions.browserDriver) {\n      console.log('All tests finished!\\n');\n      console.log('--------------------------------');\n      console.log(`${Meteor.isAppTest ? 'APP ' : ''}SERVER FAILURES: ${serverFailures}`);\n      console.log(`${Meteor.isAppTest ? 'APP ' : ''}CLIENT FAILURES: ${clientFailures}`);\n      console.log('--------------------------------');\n    }\n\n    handleCoverage(coverageOptions).then(() => {\n      // if no env for TEST_WATCH, tests should exit when done\n      if (!runnerOptions.testWatch) {\n        if (clientFailures + serverFailures > 0) {\n          process.exit(1); // exit with non-zero status if there were failures\n        } else {\n          process.exit(0);\n        }\n      }\n    });\n  }\n}\n\nfunction serverTests(cb) {\n  if (!runnerOptions.runServer) {\n    console.log('SKIPPING SERVER TESTS BECAUSE TEST_SERVER=0');\n    exitIfDone('server', 0);\n    if (cb) cb();\n    return;\n  }\n\n  printHeader('SERVER');\n\n  if (grep) mochaInstance.grep(grep);\n  if (invert) mochaInstance.options.invert = invert;\n  mochaInstance.options.useColors = true;\n\n  // We need to set the reporter when the tests actually run to ensure no conflicts with\n  // other test driver packages that may be added to the app but are not actually being\n  // used on this run.\n  mochaInstance.reporter(serverReporter || reporter || 'spec', {\n    output: serverOutput,\n  });\n\n  mochaInstance.run((failureCount) => {\n    if (typeof failureCount !== 'number') {\n      console.log('Mocha did not return a failure count for server tests as expected');\n      exitIfDone('server', 1);\n    } else {\n      exitIfDone('server', failureCount);\n    }\n    if (cb) cb();\n  });\n}\n\nfunction clientTests() {\n  if (!runnerOptions.runClient) {\n    console.log('SKIPPING CLIENT TESTS BECAUSE TEST_CLIENT=0');\n    exitIfDone('client', 0);\n    return;\n  }\n\n  if (!runnerOptions.browserDriver) {\n    console.log('Load the app in a browser to run client tests, or set the TEST_BROWSER_DRIVER environment variable. '\n      + 'See https://github.com/meteortesting/meteor-mocha/blob/master/README.md#run-app-tests');\n    exitIfDone('client', 0);\n    return;\n  }\n\n  printHeader('CLIENT');\n\n  startBrowser({\n    stdout(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n    writebuffer(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n    stderr(data) {\n      if (clientOutput) {\n        fs.appendFileSync(clientOutput, data.toString());\n      } else {\n        clientLogBuffer(data.toString());\n      }\n    },\n    done(failureCount) {\n      if (typeof failureCount !== 'number') {\n        console.log('The browser driver package did not return a failure count for server tests as expected');\n        exitIfDone('client', 1);\n      } else {\n        exitIfDone('client', failureCount);\n      }\n    },\n  });\n}\n\n// Before Meteor calls the `start` function, app tests will be parsed and loaded by Mocha\nfunction start() {\n  // Run in PARALLEL or SERIES\n  // Running in series is a better default since it avoids db and state conflicts for newbs.\n  // If you want parallel you will know these risks.\n  if (runnerOptions.runParallel) {\n    console.log('Warning: Running in parallel can cause side-effects from state/db sharing');\n\n    serverTests();\n    clientTests();\n  } else {\n    serverTests(() => {\n      clientTests();\n    });\n  }\n}\n\nexport { start };\n","export default function setArgs() {\n  const {\n    MOCHA_GREP,\n    MOCHA_INVERT,\n    MOCHA_REPORTER,\n    CLIENT_TEST_REPORTER,\n    SERVER_TEST_REPORTER,\n    TEST_BROWSER_DRIVER,\n    TEST_CLIENT,\n    TEST_PARALLEL,\n    TEST_SERVER,\n    TEST_WATCH,\n    METEOR_AUTO_RESTART, // Introduced in Meteor 1.8.1 to indicate if this instance will automatically restart after exiting. https://github.com/meteor/meteor/pull/10465\n    XUNIT_FILE,\n    SERVER_MOCHA_OUTPUT,\n    CLIENT_MOCHA_OUTPUT,\n    COVERAGE,\n    COVERAGE_VERBOSE,\n    COVERAGE_IN_COVERAGE,\n    COVERAGE_OUT_COVERAGE,\n    COVERAGE_OUT_LCOVONLY,\n    COVERAGE_OUT_HTML,\n    COVERAGE_OUT_JSON,\n    COVERAGE_OUT_JSON_SUMMARY,\n    COVERAGE_OUT_TEXT_SUMMARY,\n    COVERAGE_OUT_REMAP,\n  } = process.env;\n\n  const runtimeArgs = {\n    mochaOptions: {\n      grep: MOCHA_GREP || false,\n      invert: !!MOCHA_INVERT,\n      reporter: MOCHA_REPORTER,\n      serverReporter: SERVER_TEST_REPORTER || XUNIT_FILE, // XUNIT_FILE is left in here for compatibility to older versions\n      clientReporter: CLIENT_TEST_REPORTER,\n      serverOutput: SERVER_MOCHA_OUTPUT,\n      clientOutput: CLIENT_MOCHA_OUTPUT,\n    },\n    runnerOptions: {\n      runClient: (TEST_CLIENT !== 'false' && TEST_CLIENT !== '0'),\n      runServer: (TEST_SERVER !== 'false' && TEST_SERVER !== '0'),\n      browserDriver: TEST_BROWSER_DRIVER,\n      testWatch: TEST_WATCH || METEOR_AUTO_RESTART === 'true',\n      runParallel: !!TEST_PARALLEL,\n    },\n  };\n\n  if (COVERAGE === '1') {\n    runtimeArgs.coverageOptions = {\n      verbose: COVERAGE_VERBOSE === '1',\n      in: {\n        coverage: COVERAGE_IN_COVERAGE === 'true' || COVERAGE_IN_COVERAGE === '1',\n      },\n      out: {\n        coverage: COVERAGE_OUT_COVERAGE === 'true' || COVERAGE_OUT_COVERAGE === '1',\n        lcovonly: COVERAGE_OUT_LCOVONLY === 'true' || COVERAGE_OUT_LCOVONLY === '1',\n        html: COVERAGE_OUT_HTML === 'true' || COVERAGE_OUT_HTML === '1',\n        json: COVERAGE_OUT_JSON === 'true' || COVERAGE_OUT_JSON === '1',\n        json_summary: COVERAGE_OUT_JSON_SUMMARY === 'true' || COVERAGE_OUT_JSON_SUMMARY === '1',\n        text_summary: COVERAGE_OUT_TEXT_SUMMARY === 'true' || COVERAGE_OUT_TEXT_SUMMARY === '1',\n        remap: COVERAGE_OUT_REMAP === 'true' || COVERAGE_OUT_REMAP === '1',\n      },\n    };\n  }\n\n  // Set the variables for the client to access as well.\n  Meteor.settings.public = Meteor.settings.public || {};\n  Meteor.settings.public.mochaRuntimeArgs = runtimeArgs;\n\n  return runtimeArgs;\n}\n","import { HTTP } from 'meteor/http';\n\nexport default (coverageOptions) => {\n  let promise = Promise.resolve(true);\n\n  if (coverageOptions) {\n    const cLog = (...args) => {\n      if (coverageOptions.verbose) {\n        console.log(...args);\n      }\n    };\n\n    cLog('Export code coverage');\n\n    const importCoverageDump = () => new Promise((resolve, reject) => {\n      cLog('- In coverage');\n      HTTP.get(Meteor.absoluteUrl('coverage/import'), (error, response) => {\n        if (error) {\n          reject(new Error('Failed to import coverage file'));\n          return;\n        }\n\n        const { statusCode } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error('Failed to import coverage file'));\n        }\n        resolve();\n      });\n    });\n\n    const exportReport = (fileType, reportType) => new Promise((resolve, reject) => {\n      cLog(`- Out ${fileType}`);\n      const url = Meteor.absoluteUrl(`/coverage/export/${fileType}`);\n      HTTP.get(url, (error, response) => {\n        if (error) {\n          reject(new Error(`Failed to save ${fileType} ${reportType}`));\n          return;\n        }\n\n        const { statusCode } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error(`Failed to save ${fileType} ${reportType}`));\n        }\n        resolve();\n      });\n    });\n\n    const exportRemap = () => new Promise((resolve, reject) => {\n      cLog('- Out remap');\n      HTTP.get(Meteor.absoluteUrl('/coverage/export/remap'), (error, response) => {\n        if (error) {\n          reject(new Error('Failed to remap your coverage'));\n          return;\n        }\n\n        const { statusCode } = response;\n\n        if (statusCode !== 200) {\n          reject(new Error('Failed to remap your coverage'));\n        }\n        resolve();\n      });\n    });\n\n    if (coverageOptions.in.coverage) {\n      promise = promise.then(() => importCoverageDump());\n    }\n\n    if (coverageOptions.out.coverage) {\n      promise = promise.then(() => exportReport('coverage', 'dump'));\n    }\n\n    if (coverageOptions.out.lcovonly) {\n      promise = promise.then(() => exportReport('lcovonly', 'coverage'));\n    }\n\n    if (coverageOptions.out.html) {\n      promise = promise.then(() => exportReport('html', 'report'));\n    }\n\n    if (coverageOptions.out.json) {\n      promise = promise.then(() => exportReport('json', 'report'));\n    }\n\n    if (coverageOptions.out.text_summary) {\n      promise = promise.then(() => exportReport('text-summary', 'report'));\n    }\n\n    if (coverageOptions.out.remap) {\n      promise = promise.then(() => exportRemap());\n    }\n\n    if (coverageOptions.out.json_summary) {\n      promise = promise.then(() => exportReport('json-summary', 'dump'));\n    }\n\n    promise = promise.catch(console.error);\n  }\n\n  return promise;\n};\n"]}}]