[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\nvar HTTP = Package.http.HTTP;\n\n/* Package-scope variables */\nvar Kadira, BaseErrorModel, Retry, Ntp, getBrowserInfo, getResolution, getErrorStack, getInfoArray, getTime, checkSizeAndPickFields, httpRequest, ErrorModel;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/common/unify.js                                                      //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nKadira = {};\r\nKadira.options = {};\r\n\r\nif(Meteor.wrapAsync) {\r\n  Kadira._wrapAsync = Meteor.wrapAsync;\r\n} else {\r\n  Kadira._wrapAsync = Meteor._wrapAsync;\r\n}\r\n\r\nif(Meteor.isServer) {\r\n  var EventEmitter = Npm.require('events').EventEmitter;\r\n  var eventBus = new EventEmitter();\r\n  eventBus.setMaxListeners(0);\r\n\r\n  var buildArgs = function(args) {\r\n    args = _.toArray(args);\r\n    var eventName = args[0] + '-' + args[1];\r\n    var args = args.slice(2);\r\n    args.unshift(eventName);\r\n    return args;\r\n  };\r\n  \r\n  Kadira.EventBus = {};\r\n  _.each(['on', 'emit', 'removeListener', 'removeAllListeners'], function(m) {\r\n    Kadira.EventBus[m] = function() {\r\n      var args = buildArgs(arguments);\r\n      return eventBus[m].apply(eventBus, args);\r\n    };\r\n  });\r\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/models/base_error.js                                                 //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nBaseErrorModel = function(options) {\r\n  this._filters = [];\r\n};\r\n\r\nBaseErrorModel.prototype.addFilter = function(filter) {\r\n  if(typeof filter === 'function') {\r\n    this._filters.push(filter);\r\n  } else {\r\n    throw new Error(\"Error filter must be a function\");\r\n  }\r\n};\r\n\r\nBaseErrorModel.prototype.removeFilter = function(filter) {\r\n  var index = this._filters.indexOf(filter);\r\n  if(index >= 0) {\r\n    this._filters.splice(index, 1);\r\n  }\r\n};\r\n\r\nBaseErrorModel.prototype.applyFilters = function(type, message, error, subType) {\r\n  for(var lc=0; lc<this._filters.length; lc++) {\r\n    var filter = this._filters[lc];\r\n    try {\r\n      var validated = filter(type, message, error, subType);\r\n      if(!validated) return false;\r\n    } catch (ex) {\r\n      // we need to remove this filter\r\n      // we may ended up in a error cycle\r\n      this._filters.splice(lc, 1);\r\n      throw new Error(\"an error thrown from a filter you've suplied\", ex.message);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/retry.js                                                             //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\n// Retry logic with an exponential backoff.\r\n//\r\n// options:\r\n//  baseTimeout: time for initial reconnect attempt (ms).\r\n//  exponent: exponential factor to increase timeout each attempt.\r\n//  maxTimeout: maximum time between retries (ms).\r\n//  minCount: how many times to reconnect \"instantly\".\r\n//  minTimeout: time to wait for the first `minCount` retries (ms).\r\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\r\n\r\n//TODO: remove this class and use Meteor Retry in a later version of meteor.\r\n\r\nRetry = function (options) {\r\n  var self = this;\r\n  _.extend(self, _.defaults(_.clone(options || {}), {\r\n    baseTimeout: 1000, // 1 second\r\n    exponent: 2.2,\r\n    // The default is high-ish to ensure a server can recover from a\r\n    // failure caused by load.\r\n    maxTimeout: 5 * 60000, // 5 minutes\r\n    minTimeout: 10,\r\n    minCount: 2,\r\n    fuzz: 0.5 // +- 25%\r\n  }));\r\n  self.retryTimer = null;\r\n};\r\n\r\n_.extend(Retry.prototype, {\r\n\r\n  // Reset a pending retry, if any.\r\n  clear: function () {\r\n    var self = this;\r\n    if(self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n    self.retryTimer = null;\r\n  },\r\n\r\n  // Calculate how long to wait in milliseconds to retry, based on the\r\n  // `count` of which retry this is.\r\n  _timeout: function (count) {\r\n    var self = this;\r\n\r\n    if(count < self.minCount)\r\n      return self.minTimeout;\r\n\r\n    var timeout = Math.min(\r\n      self.maxTimeout,\r\n      self.baseTimeout * Math.pow(self.exponent, count));\r\n    // fuzz the timeout randomly, to avoid reconnect storms when a\r\n    // server goes down.\r\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\r\n                         (1 - self.fuzz/2));\r\n    return Math.ceil(timeout);\r\n  },\r\n\r\n  // Call `fn` after a delay, based on the `count` of which retry this is.\r\n  retryLater: function (count, fn) {\r\n    var self = this;\r\n    var timeout = self._timeout(count);\r\n    if(self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n\r\n    self.retryTimer = setTimeout(fn, timeout);\r\n    return timeout;\r\n  }\r\n\r\n});\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/ntp.js                                                               //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nvar logger = getLogger();\r\n\r\nNtp = function (endpoint) {\r\n  this.setEndpoint(endpoint);\r\n  this.diff = 0;\r\n  this.synced = false;\r\n  this.reSyncCount = 0;\r\n  this.reSync = new Retry({\r\n    baseTimeout: 1000*60,\r\n    maxTimeout: 1000*60*10,\r\n    minCount: 0\r\n  });\r\n}\r\n\r\nNtp._now = function() {\r\n  var now = Date.now();\r\n  if(typeof now == 'number') {\r\n    return now;\r\n  } else if(now instanceof Date) {\r\n    // some extenal JS libraries override Date.now and returns a Date object\r\n    // which directly affect us. So we need to prepare for that\r\n    return now.getTime();\r\n  } else {\r\n    // trust me. I've seen now === undefined\r\n    return (new Date()).getTime();\r\n  }\r\n};\r\n\r\nNtp.prototype.setEndpoint = function(endpoint) {\r\n  this.endpoint = endpoint + '/simplentp/sync';\r\n};\r\n\r\nNtp.prototype.getTime = function() {\r\n  return Ntp._now() + Math.round(this.diff);\r\n};\r\n\r\nNtp.prototype.syncTime = function(localTime) {\r\n  return localTime + Math.ceil(this.diff);\r\n};\r\n\r\nNtp.prototype.sync = function() {\r\n  logger('init sync');\r\n  var self = this;\r\n  var retryCount = 0;\r\n  var retry = new Retry({\r\n    baseTimeout: 1000*20,\r\n    maxTimeout: 1000*60,\r\n    minCount: 1,\r\n    minTimeout: 0\r\n  });\r\n  syncTime();\r\n\r\n  function syncTime () {\r\n    if(retryCount<5) {\r\n      logger('attempt time sync with server', retryCount);\r\n      // if we send 0 to the retryLater, cacheDns will run immediately\r\n      retry.retryLater(retryCount++, cacheDns);\r\n    } else {\r\n      logger('maximum retries reached');\r\n      self.reSync.retryLater(self.reSyncCount++, function () {\r\n        var args = [].slice.call(arguments);\r\n        self.sync.apply(self, args);\r\n      });\r\n    }\r\n  }\r\n\r\n  // first attempt is to cache dns. So, calculation does not\r\n  // include DNS resolution time\r\n  function cacheDns () {\r\n    self.getServerTime(function(err) {\r\n      if(!err) {\r\n        calculateTimeDiff();\r\n      } else {\r\n        syncTime();\r\n      }\r\n    });\r\n  }\r\n\r\n  function calculateTimeDiff () {\r\n    var clientStartTime = (new Date()).getTime();\r\n    self.getServerTime(function(err, serverTime) {\r\n      if(!err && serverTime) {\r\n        // (Date.now() + clientStartTime)/2 : Midpoint between req and res\r\n        var networkTime = ((new Date()).getTime() - clientStartTime)/2\r\n        var serverStartTime = serverTime - networkTime;\r\n        self.diff = serverStartTime - clientStartTime;\r\n        self.synced = true;\r\n        // we need to send 1 into retryLater.\r\n        self.reSync.retryLater(self.reSyncCount++, function () {\r\n          var args = [].slice.call(arguments);\r\n          self.sync.apply(self, args);\r\n        });\r\n        logger('successfully updated diff value', self.diff);\r\n      } else {\r\n        syncTime();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nNtp.prototype.getServerTime = function(callback) {\r\n  var self = this;\r\n\r\n  if(Meteor.isServer) {\r\n    var Fiber = Npm.require('fibers');\r\n    new Fiber(function() {\r\n      HTTP.get(self.endpoint, function (err, res) {\r\n        if(err) {\r\n          callback(err);\r\n        } else {\r\n          var serverTime = parseInt(res.content);\r\n          callback(null, serverTime);\r\n        }\r\n      });\r\n    }).run();\r\n  } else {\r\n    httpRequest('GET', self.endpoint, function(err, res) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        var serverTime = parseInt(res.content);\r\n        callback(null, serverTime);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nfunction getLogger() {\r\n  if(Meteor.isServer) {\r\n    return Npm.require('debug')(\"kadira:ntp\");\r\n  } else {\r\n    return function(message) {\r\n      var canLogKadira =\r\n        Meteor._localStorage.getItem('LOG_KADIRA') !== null\r\n        && typeof console !== 'undefined';\r\n\r\n      if(canLogKadira) {\r\n        if(message) {\r\n          message = \"kadira:ntp \" + message;\r\n          arguments[0] = message;\r\n        }\r\n        console.log.apply(console, arguments);\r\n      }\r\n    }\r\n  }\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/utils.js                                                      //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\ngetBrowserInfo = function () {\r\n  return {\r\n    browser: window.navigator.userAgent,\r\n    userId: Meteor.userId && Meteor.userId(),\r\n    url: location.href,\r\n    resolution: getResolution()\r\n  };\r\n}\r\n\r\ngetResolution = function () {\r\n  if(screen && screen.width && screen.height) {\r\n    var resolution = screen.width + 'x' + screen.height;\r\n    return resolution;\r\n  }\r\n}\r\n\r\ngetErrorStack = function (zone, callback) {\r\n  var trace = [];\r\n  var eventMap = zone.eventMap || {};\r\n  var infoMap = zone.infoMap || {};\r\n\r\n  trace.push({\r\n    at: (new Date().getTime()),\r\n    stack: zone.erroredStack.get()\r\n  });\r\n\r\n  processZone();\r\n  function processZone() {\r\n    // we assume, first two zones are not interesting\r\n    // bacause, they are some internal meteor loading stuffs\r\n    if(zone && zone.depth > 2) {\r\n      var stack = \"\";\r\n      if(zone.currentStack) {\r\n        stack = zone.currentStack.get();\r\n      }\r\n\r\n      var events = eventMap[zone.id];\r\n      var info = getInfoArray(infoMap[zone.id]);\r\n      var ownerArgsEvent = events && events[0] && events[0].type == 'owner-args' && events.shift();\r\n      var runAt = (ownerArgsEvent)? ownerArgsEvent.at : zone.runAt;\r\n      var ownerArgs = (ownerArgsEvent)? _.toArray(ownerArgsEvent.args) : [];\r\n\r\n      // limiting\r\n      events = _.map(_.last(events, 5), checkSizeAndPickFields(100));\r\n      info = _.map(_.last(info, 5), checkSizeAndPickFields(100));\r\n      ownerArgs = checkSizeAndPickFields(200)(_.first(ownerArgs, 5));\r\n\r\n      zone.owner && delete zone.owner.zoneId;\r\n\r\n      trace.push({\r\n        createdAt: zone.createdAt,\r\n        runAt: runAt,\r\n        stack: stack,\r\n        owner: zone.owner,\r\n        ownerArgs: ownerArgs,\r\n        events: events,\r\n        info: info,\r\n        zoneId: zone.id\r\n      });\r\n      zone = zone.parent;\r\n\r\n      setTimeout(processZone, 0);\r\n    } else {\r\n      callback(trace);\r\n    }\r\n  }\r\n}\r\n\r\ngetInfoArray = function (info) {\r\n  return _(info || {}).map(function (value, type) {\r\n    value.type = type;\r\n    return value;\r\n  })\r\n}\r\n\r\ngetTime = function () {\r\n  if(Kadira && Kadira.syncedDate) {\r\n    return Kadira.syncedDate.getTime();\r\n  } else {\r\n    return (new Date().getTime());\r\n  }\r\n}\r\n\r\ncheckSizeAndPickFields = function(maxFieldSize) {\r\n  return function(obj) {\r\n    maxFieldSize = maxFieldSize || 100;\r\n    for(var key in obj) {\r\n      var value = obj[key];\r\n      try {\r\n        var valueStringified = JSON.stringify(value);\r\n        if(valueStringified.length > maxFieldSize) {\r\n          obj[key] = valueStringified.substr(0, maxFieldSize) + \" ...\";\r\n        } else {\r\n          obj[key] = value;\r\n        }\r\n      } catch(ex) {\r\n        obj[key] = 'Error: cannot stringify value';\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n}\r\n\r\nhttpRequest = function (method, url, options, callback) {\r\n  HTTP.call(method, url, options, callback);\r\n};\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/models/error.js                                               //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nErrorModel = function(options) {\r\n  BaseErrorModel.call(this);\r\n  options = options || {};\r\n  options.maxErrorsPerInterval = options.maxErrorsPerInterval || 10;\r\n  options.intervalInMillis = options.intervalInMillis || 1000 * 60 *2; //2 mins\r\n  options.waitForNtpSyncInterval = options.waitForNtpSyncInterval || 0;\r\n  var self = this;\r\n\r\n  self.options = options;\r\n\r\n  // errorsSentCount will be reseted at the start of the interval\r\n  self.errorsSentCount = 0;\r\n  self.errorsSent = Object.create(null);\r\n  self.intervalTimeoutHandler = setInterval(function() {\r\n    self.errorsSentCount = 0;\r\n    self._flushErrors();\r\n  }, self.options.intervalInMillis);\r\n};\r\n\r\n_.extend(ErrorModel.prototype, BaseErrorModel.prototype);\r\n\r\nErrorModel.prototype.sendError = function(errorDef, err, force) {\r\n  var self = this;\r\n  if(!this.applyFilters('client', errorDef.name, err, errorDef.subType)) {\r\n    return;\r\n  };\r\n\r\n  if(!this.canSendErrors()) {\r\n    // reached maximum error count for this interval (1 min)\r\n    return;\r\n  }\r\n\r\n  if(force) {\r\n    sendError();\r\n  } else {\r\n    if(Kadira.syncedDate.synced || self.options.waitForNtpSyncInterval == 0) {\r\n      sendError();\r\n    } else {\r\n      setTimeout(forceSendError, self.options.waitForNtpSyncInterval);\r\n    }\r\n  }\r\n\r\n  function forceSendError() {\r\n    self.sendError(errorDef, err, true);\r\n  }\r\n\r\n  function sendError() {\r\n    if(!self.errorsSent[errorDef.name]) {\r\n      // sync time with the server\r\n      if(errorDef.startTime) {\r\n        errorDef.startTime = Kadira.syncedDate.syncTime(errorDef.startTime);\r\n      }\r\n      errorDef.count = 1;\r\n      var payload = {host: Kadira.options.hostname, errors: [errorDef]}\r\n      Kadira.send(payload, '/errors');\r\n\r\n      self.errorsSent[errorDef.name] = _.clone(errorDef);\r\n      self.errorsSent[errorDef.name].count = 0;\r\n      self.errorsSentCount++;\r\n    } else {\r\n      self.increamentErrorCount(errorDef.name);\r\n    }\r\n  }\r\n};\r\n\r\nErrorModel.prototype._flushErrors = function() {\r\n  var self = this;\r\n  var errors = _.values(self.errorsSent);\r\n  errors = _.filter(errors, function(error) {\r\n    return error.count > 0;\r\n  });\r\n\r\n  if(errors.length > 0) {\r\n    Kadira.send({errors: errors}, '/errors');\r\n  }\r\n  self.errorsSent = Object.create(null);\r\n};\r\n\r\nErrorModel.prototype.isErrorExists = function(name) {\r\n  return !!this.errorsSent[name];\r\n};\r\n\r\nErrorModel.prototype.increamentErrorCount = function(name) {\r\n  var error = this.errorsSent[name];\r\n  if(error) {\r\n    error.count++;\r\n  }\r\n};\r\n\r\nErrorModel.prototype.canSendErrors = function() {\r\n  return this.errorsSentCount < this.options.maxErrorsPerInterval;\r\n};\r\n\r\nErrorModel.prototype.close = function() {\r\n  clearTimeout(this.intervalTimeoutHandler);\r\n};\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/error_reporters/zone.js                                       //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nif(window.Zone && Zone.inited) {\r\n  Zone.Reporters.add('kadira', kadiraZoneReporter);\r\n}\r\n\r\nfunction kadiraZoneReporter(zone) {\r\n  // track only if error tracking is enabled\r\n  if(!Kadira.options.enableErrorTracking) {\r\n    return;\r\n  }\r\n\r\n  var errorName = Zone.Reporters.getErrorMessage(zone.erroredStack._e);\r\n  if(Kadira.errors.isErrorExists(errorName)) {\r\n    Kadira.errors.increamentErrorCount(errorName);\r\n  } else if(Kadira.errors.canSendErrors()) {\r\n    getErrorStack(zone, function(stacks) {\r\n      Kadira.errors.sendError({\r\n        appId : Kadira.options.appId,\r\n        name : errorName,\r\n        type : 'client',\r\n        startTime : zone.runAt,\r\n        subType : 'zone',\r\n        info : getBrowserInfo(),\r\n        stacks : JSON.stringify(stacks),\r\n      });\r\n    });\r\n  }\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/error_reporters/window_error.js                               //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nvar prevWindowOnError = window.onerror || Function.prototype;\r\n\r\nwindow.onerror = function(message, url, line, col, error) {\r\n  // track only if error tracking is enabled\r\n  if(!Kadira.options.enableErrorTracking) {\r\n    return prevWindowOnError(message, url, line, col, error);\r\n  }\r\n\r\n  url = url || '<anonymous>';\r\n  line = line || 0;\r\n  col = col || 0;\r\n\r\n  if(error) {\r\n    var stack = error.stack;\r\n  } else {\r\n    var stack = 'Error:\\n    at window.onerror ('+url+':'+line+':'+col+')';\r\n  }\r\n\r\n  var now = (new Date().getTime());\r\n  Kadira.errors.sendError({\r\n    appId : Kadira.options.appId,\r\n    name : message,\r\n    type : 'client',\r\n    startTime : now,\r\n    subType : 'window.onerror',\r\n    info : getBrowserInfo(),\r\n    stacks : JSON.stringify([{at: now, events: [], stack: stack}]),\r\n  });\r\n\r\n  return prevWindowOnError(message, url, line, col, error);;\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/error_reporters/meteor_debug.js                               //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nvar originalMeteorDebug = Meteor._debug;\r\n\r\nMeteor._debug = function(m, s) {\r\n  // We need to asign variables like this. Otherwise, \r\n  // we can't see proper error messages.\r\n  // See: https://github.com/meteorhacks/kadira/issues/193\r\n  var message = m;\r\n  var stack = s;\r\n  \r\n  // track only if error tracking is enabled\r\n  if(!Kadira.options.enableErrorTracking) {\r\n    return originalMeteorDebug(message, stack);\r\n  }\r\n\r\n  // do not track if a zone is available (let zone handle the error)\r\n  if(window.zone) {\r\n    return originalMeteorDebug(message, stack);\r\n  }\r\n\r\n  // We hate Meteor._debug (no single usage pattern)\r\n  if(message instanceof Error) {\r\n    stack = message.stack;\r\n    message = message.message\r\n  } else if(typeof message == 'string' && stack === undefined) {\r\n    stack = getStackFromMessage(message);\r\n    message = firstLine(message);\r\n  }\r\n\r\n  // sometimes Meteor._debug is called with the stack concat to the message\r\n  // FIXME Meteor._debug can be called in many ways\r\n  if(message && stack === undefined) {\r\n    stack = getStackFromMessage(message);\r\n    message = firstLine(message);\r\n  }\r\n\r\n  var now = (new Date().getTime());\r\n  Kadira.errors.sendError({\r\n    appId : Kadira.options.appId,\r\n    name : message,\r\n    type : 'client',\r\n    startTime : now,\r\n    subType : 'meteor._debug',\r\n    info : getBrowserInfo(),\r\n    stacks : JSON.stringify([{at: now, events: [], stack: stack}]),\r\n  });\r\n\r\n  return originalMeteorDebug.apply(this, arguments);\r\n};\r\n\r\nvar stackRegex = /^\\s+at\\s.+$/gm;\r\nfunction getStackFromMessage (message) {\r\n  // add empty string to add the empty line at start\r\n  var stack = [''];\r\n  var match;\r\n  while(match = stackRegex.exec(message)) {\r\n    stack.push(match[0]);\r\n  }\r\n  return stack.join('\\n');\r\n}\r\n\r\nfunction firstLine (message) {\r\n  return message.split('\\n')[0];\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/client/kadira.js                                                     //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nKadira.enableErrorTracking = function () {\r\n  Kadira.options.enableErrorTracking = true;\r\n};\r\n\r\nKadira.disableErrorTracking = function () {\r\n  Kadira.options.enableErrorTracking = false;\r\n};\r\n\r\nKadira.trackError = function (type, message, options) {\r\n  if(Kadira.options.enableErrorTracking && type && message) {\r\n    var now = (new Date()).getTime();\r\n    options = options || {};\r\n    _.defaults(options, {subType: 'client', stacks: ''});\r\n    Kadira.errors.sendError({\r\n      appId : Kadira.options.appId,\r\n      name : message,\r\n      source : 'client',\r\n      startTime : now,\r\n      type : type,\r\n      subType : options.subType,\r\n      info : getBrowserInfo(),\r\n      stacks : JSON.stringify([{at: now, events: [], stack: options.stacks}]),\r\n    });\r\n  }\r\n};\r\n\r\n// Create new NTP object and error model immediately so it can be used\r\n// endpoints is set later using __meteor_runtime_config__ or publication\r\nKadira.syncedDate = new Ntp(null);\r\nKadira.errors = new ErrorModel({\r\n  waitForNtpSyncInterval: 1000 * 5, // 5 secs\r\n  intervalInMillis: 1000 * 60 * 1, // 1minutes\r\n  maxErrorsPerInterval: 5\r\n});\r\n\r\n// __meteor_runtime_config__ cannot be dynamically set for cordova apps\r\n// using a null subscription to send required options to client\r\nif(Meteor.isCordova) {\r\n  var SettingsCollection = new Meteor.Collection('kadira_settings');\r\n  SettingsCollection.find().observe({added: _.once(initialize)});\r\n} else {\r\n  initialize(__meteor_runtime_config__.kadira);\r\n}\r\n\r\nfunction initialize (options) {\r\n  Kadira.options = options || {};\r\n  _.defaults(Kadira.options, {\r\n    errorDumpInterval: 1000*60,\r\n    maxErrorsPerInterval: 10,\r\n    collectAllStacks: false,\r\n    enableErrorTracking: false,\r\n  });\r\n\r\n  if(Kadira.options.appId && Kadira.options.endpoint) {\r\n    // update endpoint after receiving correct data\r\n    Kadira.syncedDate.setEndpoint(Kadira.options.endpoint);\r\n    Kadira.connected = true;\r\n    Meteor.startup(function () {\r\n      // if we don't do this this might block the initial rendering\r\n      // or, it will show up bottom of the page, which is not cool\r\n      setTimeout(function() {\r\n        Kadira.syncedDate.sync();\r\n      }, Kadira.options.clientEngineSyncDelay);\r\n    });\r\n  }\r\n\r\n  if(Kadira.connected && Kadira.options.enableErrorTracking) {\r\n    Kadira.enableErrorTracking();\r\n  }\r\n\r\n  if(window.Zone && Zone.inited) {\r\n    Zone.collectAllStacks = Kadira.options.collectAllStacks;\r\n  }\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/profiler/client.js                                                   //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\n// For just making a notice\r\n// meteorhacks:kadira-profiler will override this method to add\r\n// actual functionality\r\nKadira.profileCpu = function profileCpu() {\r\n  var message =\r\n    \"Please install meteorhacks:kadira-profiler\" +\r\n    \" to take a CPU profile.\";\r\n  console.log(message);\r\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/common/default_error_filters.js                                      //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nvar commonErrRegExps = [\r\n  /connection timeout\\. no (\\w*) heartbeat received/i,\r\n  /INVALID_STATE_ERR/i,\r\n];\r\n\r\nKadira.errorFilters = {\r\n  filterValidationErrors: function(type, message, err) {\r\n    if(err && err instanceof Meteor.Error) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  },\r\n\r\n  filterCommonMeteorErrors: function(type, message) {\r\n    for(var lc=0; lc<commonErrRegExps.length; lc++) {\r\n      var regExp = commonErrRegExps[lc];\r\n      if(regExp.test(message)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                   //\n// packages/lmachens_kadira/lib/common/send.js                                                       //\n//                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                     //\nKadira.send = function (payload, path, callback) {\r\n  if(!Kadira.connected)  {\r\n    throw new Error(\"You need to connect with Kadira first, before sending messages!\");\r\n  }\r\n\r\n  path = (path.substr(0, 1) != '/')? \"/\" + path : path;\r\n  var endpoint = Kadira.options.endpoint + path;\r\n  var retryCount = 0;\r\n  var retry = new Retry({\r\n    minCount: 1,\r\n    minTimeout: 0,\r\n    baseTimeout: 1000*5,\r\n    maxTimeout: 1000*60,\r\n  });\r\n\r\n  var sendFunction = Kadira._getSendFunction();\r\n  tryToSend();\r\n\r\n  function tryToSend(err) {\r\n    if(retryCount < 5) {\r\n      retry.retryLater(retryCount++, send);\r\n    } else {\r\n      console.warn('Error sending error traces to kadira server');\r\n      if(callback) callback(err);\r\n    }\r\n  }\r\n\r\n  function send() {\r\n    sendFunction(endpoint, payload, function(err, content, statusCode) {\r\n      if(err) {\r\n        tryToSend(err);\r\n      } else if(statusCode == 200){\r\n        if(callback) callback(null, content);\r\n      } else {\r\n        if(callback) callback(new Meteor.Error(statusCode, content));\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nKadira._getSendFunction = function() {\r\n  return (Meteor.isServer)? Kadira._serverSend : Kadira._clientSend;\r\n};\r\n\r\nKadira._clientSend = function (endpoint, payload, callback) {\r\n  httpRequest('POST', endpoint, {\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    },\r\n    content: JSON.stringify(payload)\r\n  }, callback);\r\n}\r\n\r\nKadira._serverSend = function (endpoint, payload, callback) {\r\n  callback = callback || function() {};\r\n  var Fiber = Npm.require('fibers');\r\n  new Fiber(function() {\r\n    var httpOptions = {\r\n      data: payload,\r\n      headers: Kadira.options.authHeaders\r\n    };\r\n\r\n    HTTP.call('POST', endpoint, httpOptions, function(err, res) {\r\n      if(res) {\r\n        var content = (res.statusCode == 200)? res.data : res.content;\r\n        callback(null, content, res.statusCode);\r\n      } else {\r\n        callback(err);\r\n      }\r\n    });\r\n  }).run();\r\n}\r\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"lmachens:kadira\", {\n  Kadira: Kadira\n});\n\n})();\n","servePath":"/packages/lmachens_kadira.js"}]