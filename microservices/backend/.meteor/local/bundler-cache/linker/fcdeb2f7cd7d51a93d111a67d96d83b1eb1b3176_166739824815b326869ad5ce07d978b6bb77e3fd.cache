[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar MeteorX = Package['lamhieu:meteorx'].MeteorX;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar EJSON = Package.ejson.EJSON;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar _ = Package.underscore._;\nvar HTTP = Package.http.HTTP;\nvar HTTPInternals = Package.http.HTTPInternals;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\n\n/* Package-scope variables */\nvar Kadira, BaseErrorModel, Retry, HaveAsyncCallback, UniqueId, DefaultUniqueId, OptimizedApply, Ntp, WaitTimeBuilder, OplogCheck, Tracer, TracerStore, KadiraModel, MethodsModel, PubsubModel, collectionName, SystemModel, ErrorModel, DocSzCache, DocSzCacheItem, wrapServer, wrapSession, wrapSubscription, wrapOplogObserveDriver, wrapPollingObserveDriver, wrapMultiplexer, wrapForCountingObservers, wrapStringifyDDP, hijackDBOps, TrackUncaughtExceptions, TrackMeteorDebug, setLabels;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/common/unify.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nKadira = {};\r\nKadira.options = {};\r\n\r\nif(Meteor.wrapAsync) {\r\n  Kadira._wrapAsync = Meteor.wrapAsync;\r\n} else {\r\n  Kadira._wrapAsync = Meteor._wrapAsync;\r\n}\r\n\r\nif(Meteor.isServer) {\r\n  var EventEmitter = Npm.require('events').EventEmitter;\r\n  var eventBus = new EventEmitter();\r\n  eventBus.setMaxListeners(0);\r\n\r\n  var buildArgs = function(args) {\r\n    args = _.toArray(args);\r\n    var eventName = args[0] + '-' + args[1];\r\n    var args = args.slice(2);\r\n    args.unshift(eventName);\r\n    return args;\r\n  };\r\n  \r\n  Kadira.EventBus = {};\r\n  _.each(['on', 'emit', 'removeListener', 'removeAllListeners'], function(m) {\r\n    Kadira.EventBus[m] = function() {\r\n      var args = buildArgs(arguments);\r\n      return eventBus[m].apply(eventBus, args);\r\n    };\r\n  });\r\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/base_error.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nBaseErrorModel = function(options) {\r\n  this._filters = [];\r\n};\r\n\r\nBaseErrorModel.prototype.addFilter = function(filter) {\r\n  if(typeof filter === 'function') {\r\n    this._filters.push(filter);\r\n  } else {\r\n    throw new Error(\"Error filter must be a function\");\r\n  }\r\n};\r\n\r\nBaseErrorModel.prototype.removeFilter = function(filter) {\r\n  var index = this._filters.indexOf(filter);\r\n  if(index >= 0) {\r\n    this._filters.splice(index, 1);\r\n  }\r\n};\r\n\r\nBaseErrorModel.prototype.applyFilters = function(type, message, error, subType) {\r\n  for(var lc=0; lc<this._filters.length; lc++) {\r\n    var filter = this._filters[lc];\r\n    try {\r\n      var validated = filter(type, message, error, subType);\r\n      if(!validated) return false;\r\n    } catch (ex) {\r\n      // we need to remove this filter\r\n      // we may ended up in a error cycle\r\n      this._filters.splice(lc, 1);\r\n      throw new Error(\"an error thrown from a filter you've suplied\", ex.message);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/jobs.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Jobs = Kadira.Jobs = {};\r\n\r\nJobs.getAsync = function(id, callback) {\r\n  Kadira.coreApi.getJob(id)\r\n    .then(function(data) {\r\n      callback(null, data);\r\n    })\r\n    .catch(function(err) {\r\n      callback(err)\r\n    });\r\n};\r\n\r\n\r\nJobs.setAsync = function(id, changes, callback) {\r\n  Kadira.coreApi.updateJob(id, changes)\r\n    .then(function(data) {\r\n      callback(null, data);\r\n    })\r\n    .catch(function(err) {\r\n      callback(err)\r\n    });\r\n};\r\n\r\nJobs.set = Kadira._wrapAsync(Jobs.setAsync);\r\nJobs.get = Kadira._wrapAsync(Jobs.getAsync);\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/retry.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// Retry logic with an exponential backoff.\r\n//\r\n// options:\r\n//  baseTimeout: time for initial reconnect attempt (ms).\r\n//  exponent: exponential factor to increase timeout each attempt.\r\n//  maxTimeout: maximum time between retries (ms).\r\n//  minCount: how many times to reconnect \"instantly\".\r\n//  minTimeout: time to wait for the first `minCount` retries (ms).\r\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\r\n\r\n//TODO: remove this class and use Meteor Retry in a later version of meteor.\r\n\r\nRetry = function (options) {\r\n  var self = this;\r\n  _.extend(self, _.defaults(_.clone(options || {}), {\r\n    baseTimeout: 1000, // 1 second\r\n    exponent: 2.2,\r\n    // The default is high-ish to ensure a server can recover from a\r\n    // failure caused by load.\r\n    maxTimeout: 5 * 60000, // 5 minutes\r\n    minTimeout: 10,\r\n    minCount: 2,\r\n    fuzz: 0.5 // +- 25%\r\n  }));\r\n  self.retryTimer = null;\r\n};\r\n\r\n_.extend(Retry.prototype, {\r\n\r\n  // Reset a pending retry, if any.\r\n  clear: function () {\r\n    var self = this;\r\n    if(self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n    self.retryTimer = null;\r\n  },\r\n\r\n  // Calculate how long to wait in milliseconds to retry, based on the\r\n  // `count` of which retry this is.\r\n  _timeout: function (count) {\r\n    var self = this;\r\n\r\n    if(count < self.minCount)\r\n      return self.minTimeout;\r\n\r\n    var timeout = Math.min(\r\n      self.maxTimeout,\r\n      self.baseTimeout * Math.pow(self.exponent, count));\r\n    // fuzz the timeout randomly, to avoid reconnect storms when a\r\n    // server goes down.\r\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\r\n                         (1 - self.fuzz/2));\r\n    return Math.ceil(timeout);\r\n  },\r\n\r\n  // Call `fn` after a delay, based on the `count` of which retry this is.\r\n  retryLater: function (count, fn) {\r\n    var self = this;\r\n    var timeout = self._timeout(count);\r\n    if(self.retryTimer)\r\n      clearTimeout(self.retryTimer);\r\n\r\n    self.retryTimer = setTimeout(fn, timeout);\r\n    return timeout;\r\n  }\r\n\r\n});\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/utils.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Fiber = Npm.require('fibers');\r\n\r\nHaveAsyncCallback = function(args) {\r\n  var lastArg = args[args.length -1];\r\n  return (typeof lastArg) == 'function';\r\n};\r\n\r\nUniqueId = function(start) {\r\n  this.id = 0;\r\n}\r\n\r\nUniqueId.prototype.get = function() {\r\n  return \"\" + this.id++;\r\n};\r\n\r\nDefaultUniqueId = new UniqueId();\r\n\r\n// Optimized version of apply which tries to call as possible as it can\r\n// Then fall back to apply\r\n// This is because, v8 is very slow to invoke apply.\r\nOptimizedApply = function OptimizedApply(context, fn, args) {\r\n  var a = args;\r\n  switch(a.length) {\r\n    case 0:\r\n      return fn.call(context);\r\n    case 1:\r\n      return fn.call(context, a[0]);\r\n    case 2:\r\n      return fn.call(context, a[0], a[1]);\r\n    case 3:\r\n      return fn.call(context, a[0], a[1], a[2]);\r\n    case 4:\r\n      return fn.call(context, a[0], a[1], a[2], a[3]);\r\n    case 5:\r\n      return fn.call(context, a[0], a[1], a[2], a[3], a[4]);\r\n    default:\r\n      return fn.apply(context, a);\r\n  }\r\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/ntp.js                                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar logger = getLogger();\r\n\r\nNtp = function (endpoint) {\r\n  this.setEndpoint(endpoint);\r\n  this.diff = 0;\r\n  this.synced = false;\r\n  this.reSyncCount = 0;\r\n  this.reSync = new Retry({\r\n    baseTimeout: 1000*60,\r\n    maxTimeout: 1000*60*10,\r\n    minCount: 0\r\n  });\r\n}\r\n\r\nNtp._now = function() {\r\n  var now = Date.now();\r\n  if(typeof now == 'number') {\r\n    return now;\r\n  } else if(now instanceof Date) {\r\n    // some extenal JS libraries override Date.now and returns a Date object\r\n    // which directly affect us. So we need to prepare for that\r\n    return now.getTime();\r\n  } else {\r\n    // trust me. I've seen now === undefined\r\n    return (new Date()).getTime();\r\n  }\r\n};\r\n\r\nNtp.prototype.setEndpoint = function(endpoint) {\r\n  this.endpoint = endpoint + '/simplentp/sync';\r\n};\r\n\r\nNtp.prototype.getTime = function() {\r\n  return Ntp._now() + Math.round(this.diff);\r\n};\r\n\r\nNtp.prototype.syncTime = function(localTime) {\r\n  return localTime + Math.ceil(this.diff);\r\n};\r\n\r\nNtp.prototype.sync = function() {\r\n  logger('init sync');\r\n  var self = this;\r\n  var retryCount = 0;\r\n  var retry = new Retry({\r\n    baseTimeout: 1000*20,\r\n    maxTimeout: 1000*60,\r\n    minCount: 1,\r\n    minTimeout: 0\r\n  });\r\n  syncTime();\r\n\r\n  function syncTime () {\r\n    if(retryCount<5) {\r\n      logger('attempt time sync with server', retryCount);\r\n      // if we send 0 to the retryLater, cacheDns will run immediately\r\n      retry.retryLater(retryCount++, cacheDns);\r\n    } else {\r\n      logger('maximum retries reached');\r\n      self.reSync.retryLater(self.reSyncCount++, function () {\r\n        var args = [].slice.call(arguments);\r\n        self.sync.apply(self, args);\r\n      });\r\n    }\r\n  }\r\n\r\n  // first attempt is to cache dns. So, calculation does not\r\n  // include DNS resolution time\r\n  function cacheDns () {\r\n    self.getServerTime(function(err) {\r\n      if(!err) {\r\n        calculateTimeDiff();\r\n      } else {\r\n        syncTime();\r\n      }\r\n    });\r\n  }\r\n\r\n  function calculateTimeDiff () {\r\n    var clientStartTime = (new Date()).getTime();\r\n    self.getServerTime(function(err, serverTime) {\r\n      if(!err && serverTime) {\r\n        // (Date.now() + clientStartTime)/2 : Midpoint between req and res\r\n        var networkTime = ((new Date()).getTime() - clientStartTime)/2\r\n        var serverStartTime = serverTime - networkTime;\r\n        self.diff = serverStartTime - clientStartTime;\r\n        self.synced = true;\r\n        // we need to send 1 into retryLater.\r\n        self.reSync.retryLater(self.reSyncCount++, function () {\r\n          var args = [].slice.call(arguments);\r\n          self.sync.apply(self, args);\r\n        });\r\n        logger('successfully updated diff value', self.diff);\r\n      } else {\r\n        syncTime();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nNtp.prototype.getServerTime = function(callback) {\r\n  var self = this;\r\n\r\n  if(Meteor.isServer) {\r\n    var Fiber = Npm.require('fibers');\r\n    new Fiber(function() {\r\n      HTTP.get(self.endpoint, function (err, res) {\r\n        if(err) {\r\n          callback(err);\r\n        } else {\r\n          var serverTime = parseInt(res.content);\r\n          callback(null, serverTime);\r\n        }\r\n      });\r\n    }).run();\r\n  } else {\r\n    httpRequest('GET', self.endpoint, function(err, res) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        var serverTime = parseInt(res.content);\r\n        callback(null, serverTime);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nfunction getLogger() {\r\n  if(Meteor.isServer) {\r\n    return Npm.require('debug')(\"kadira:ntp\");\r\n  } else {\r\n    return function(message) {\r\n      var canLogKadira =\r\n        Meteor._localStorage.getItem('LOG_KADIRA') !== null\r\n        && typeof console !== 'undefined';\r\n\r\n      if(canLogKadira) {\r\n        if(message) {\r\n          message = \"kadira:ntp \" + message;\r\n          arguments[0] = message;\r\n        }\r\n        console.log.apply(console, arguments);\r\n      }\r\n    }\r\n  }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/wait_time_builder.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar WAITON_MESSAGE_FIELDS = ['msg', 'id', 'method', 'name', 'waitTime'];\r\n\r\n// This is way how we can build waitTime and it's breakdown\r\nWaitTimeBuilder = function() {\r\n  this._waitListStore = {};\r\n  this._currentProcessingMessages = {};\r\n  this._messageCache = {};\r\n};\r\n\r\nWaitTimeBuilder.prototype.register = function(session, msgId) {\r\n  var self = this;\r\n  var mainKey = self._getMessageKey(session.id, msgId);\r\n\r\n  var inQueue = session.inQueue || [];\r\n  if(typeof inQueue.toArray === 'function') {\r\n    // latest version of Meteor uses a double-ended-queue for the inQueue\r\n    // info: https://www.npmjs.com/package/double-ended-queue\r\n    inQueue = inQueue.toArray();\r\n  }\r\n\r\n  var waitList = inQueue.map(function(msg) {\r\n    var key = self._getMessageKey(session.id, msg.id);\r\n    return self._getCacheMessage(key, msg);\r\n  });\r\n\r\n  waitList = waitList || [];\r\n\r\n  //add currently processing ddp message if exists\r\n  var currentlyProcessingMessage = this._currentProcessingMessages[session.id];\r\n  if(currentlyProcessingMessage) {\r\n    var key = self._getMessageKey(session.id, currentlyProcessingMessage.id);\r\n    waitList.unshift(this._getCacheMessage(key, currentlyProcessingMessage));\r\n  }\r\n\r\n  this._waitListStore[mainKey] = waitList;\r\n};\r\n\r\nWaitTimeBuilder.prototype.build = function(session, msgId) {\r\n  var mainKey = this._getMessageKey(session.id, msgId);\r\n  var waitList = this._waitListStore[mainKey] || [];\r\n  delete this._waitListStore[mainKey];\r\n\r\n  var filteredWaitList =  waitList.map(this._cleanCacheMessage.bind(this));\r\n  return filteredWaitList;\r\n};\r\n\r\nWaitTimeBuilder.prototype._getMessageKey = function(sessionId, msgId) {\r\n  return sessionId + \"::\" + msgId;\r\n};\r\n\r\nWaitTimeBuilder.prototype._getCacheMessage = function(key, msg) {\r\n  var self = this;\r\n  var cachedMessage = self._messageCache[key];\r\n  if(!cachedMessage) {\r\n    self._messageCache[key] = cachedMessage = _.pick(msg, WAITON_MESSAGE_FIELDS);\r\n    cachedMessage._key = key;\r\n    cachedMessage._registered = 1;\r\n  } else {\r\n    cachedMessage._registered++;\r\n  }\r\n\r\n  return cachedMessage;\r\n};\r\n\r\nWaitTimeBuilder.prototype._cleanCacheMessage = function(msg) {\r\n  msg._registered--;\r\n  if(msg._registered == 0) {\r\n    delete this._messageCache[msg._key];\r\n  }\r\n\r\n  // need to send a clean set of objects\r\n  // otherwise register can go with this\r\n  return _.pick(msg, WAITON_MESSAGE_FIELDS);\r\n};\r\n\r\nWaitTimeBuilder.prototype.trackWaitTime = function(session, msg, unblock) {\r\n  var self = this;\r\n  var started = Date.now();\r\n  self._currentProcessingMessages[session.id] = msg;\r\n\r\n  var unblocked = false;\r\n  var wrappedUnblock = function() {\r\n    if(!unblocked) {\r\n      var waitTime = Date.now() - started;\r\n      var key = self._getMessageKey(session.id, msg.id);\r\n      var cachedMessage = self._messageCache[key];\r\n      if(cachedMessage) {\r\n        cachedMessage.waitTime = waitTime;\r\n      }\r\n      delete self._currentProcessingMessages[session.id];\r\n      unblocked = true;\r\n      unblock();\r\n    }\r\n  };\r\n\r\n  return wrappedUnblock;\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/check_for_oplog.js                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// expose for testing purpose\r\nOplogCheck = {};\r\n\r\nOplogCheck._070 = function(cursorDescription) {\r\n  var options = cursorDescription.options;\r\n  if (options.limit) {\r\n    return {\r\n      code: \"070_LIMIT_NOT_SUPPORTED\",\r\n      reason: \"Meteor 0.7.0 does not support limit with oplog.\",\r\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\r\n    }\r\n  };\r\n\r\n  var exists$ = _.any(cursorDescription.selector, function (value, field) {\r\n    if (field.substr(0, 1) === '$')\r\n      return true;\r\n  });\r\n\r\n  if(exists$) {\r\n    return {\r\n      code: \"070_$_NOT_SUPPORTED\",\r\n      reason: \"Meteor 0.7.0 supports only equal checks with oplog.\",\r\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\r\n    }\r\n  };\r\n\r\n  var onlyScalers = _.all(cursorDescription.selector, function (value, field) {\r\n    return typeof value === \"string\" ||\r\n      typeof value === \"number\" ||\r\n      typeof value === \"boolean\" ||\r\n      value === null ||\r\n      value instanceof Meteor.Collection.ObjectID;\r\n  });\r\n\r\n  if(!onlyScalers) {\r\n    return {\r\n      code: \"070_ONLY_SCALERS\",\r\n      reason: \"Meteor 0.7.0 only supports scalers as comparators.\",\r\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nOplogCheck._071 = function(cursorDescription) {\r\n  var options = cursorDescription.options;\r\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\r\n  if (options.limit) {\r\n    return {\r\n      code: \"071_LIMIT_NOT_SUPPORTED\",\r\n      reason: \"Meteor 0.7.1 does not support limit with oplog.\",\r\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\r\n    }\r\n  };\r\n\r\n  return true;\r\n};\r\n\r\n\r\nOplogCheck.env = function() {\r\n  if(!process.env.MONGO_OPLOG_URL) {\r\n    return {\r\n      code: \"NO_ENV\",\r\n      reason: \"You haven't added oplog support for your the Meteor app.\",\r\n      solution: \"Add oplog support for your Meteor app. see: http://goo.gl/Co1jJc\"\r\n    }\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nOplogCheck.disableOplog = function(cursorDescription) {\r\n  if(cursorDescription.options._disableOplog) {\r\n    return {\r\n      code: \"DISABLE_OPLOG\",\r\n      reason: \"You've disable oplog for this cursor explicitly with _disableOplog option.\"\r\n    };\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\n// when creating Minimongo.Matcher object, if that's throws an exception\r\n// meteor won't do the oplog support\r\nOplogCheck.miniMongoMatcher = function(cursorDescription) {\r\n  if(Minimongo.Matcher) {\r\n    try {\r\n      var matcher = new Minimongo.Matcher(cursorDescription.selector);\r\n      return true;\r\n    } catch(ex) {\r\n      return {\r\n        code: \"MINIMONGO_MATCHER_ERROR\",\r\n        reason: \"There's something wrong in your mongo query: \" +  ex.message,\r\n        solution: \"Check your selector and change it accordingly.\"\r\n      };\r\n    }\r\n  } else {\r\n    // If there is no Minimongo.Matcher, we don't need to check this\r\n    return true;\r\n  }\r\n};\r\n\r\nOplogCheck.miniMongoSorter = function(cursorDescription) {\r\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\r\n  if(Minimongo.Sorter && cursorDescription.options.sort) {\r\n    try {\r\n      var sorter = new Minimongo.Sorter(\r\n        cursorDescription.options.sort,\r\n        { matcher: matcher }\r\n      );\r\n      return true;\r\n    } catch(ex) {\r\n      return {\r\n        code: \"MINIMONGO_SORTER_ERROR\",\r\n        reason: \"Some of your sort specifiers are not supported: \" + ex.message,\r\n        solution: \"Check your sort specifiers and chage them accordingly.\"\r\n      }\r\n    }\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nOplogCheck.fields = function(cursorDescription) {\r\n  var options = cursorDescription.options;\r\n  if(options.fields) {\r\n    try {\r\n      LocalCollection._checkSupportedProjection(options.fields);\r\n      return true;\r\n    } catch (e) {\r\n      if (e.name === \"MinimongoError\") {\r\n        return {\r\n          code: \"NOT_SUPPORTED_FIELDS\",\r\n          reason: \"Some of the field filters are not supported: \" + e.message,\r\n          solution: \"Try removing those field filters.\"\r\n        };\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nOplogCheck.skip = function(cursorDescription) {\r\n  if(cursorDescription.options.skip) {\r\n    return {\r\n      code: \"SKIP_NOT_SUPPORTED\",\r\n      reason: \"Skip does not support with oplog.\",\r\n      solution: \"Try to avoid using skip. Use range queries instead: http://goo.gl/b522Av\"\r\n    };\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nOplogCheck.where = function(cursorDescription) {\r\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\r\n  if(matcher.hasWhere()) {\r\n    return {\r\n      code: \"WHERE_NOT_SUPPORTED\",\r\n      reason: \"Meteor does not support queries with $where.\",\r\n      solution: \"Try to remove $where from your query. Use some alternative.\"\r\n    }\r\n  };\r\n\r\n  return true;\r\n};\r\n\r\nOplogCheck.geo = function(cursorDescription) {\r\n  var matcher = new Minimongo.Matcher(cursorDescription.selector);\r\n\r\n  if(matcher.hasGeoQuery()) {\r\n    return {\r\n      code: \"GEO_NOT_SUPPORTED\",\r\n      reason: \"Meteor does not support queries with geo partial operators.\",\r\n      solution: \"Try to remove geo partial operators from your query if possible.\"\r\n    }\r\n  };\r\n\r\n  return true;\r\n};\r\n\r\nOplogCheck.limitButNoSort = function(cursorDescription) {\r\n  var options = cursorDescription.options;\r\n\r\n  if((options.limit && !options.sort)) {\r\n    return {\r\n      code: \"LIMIT_NO_SORT\",\r\n      reason: \"Meteor oplog implementation does not support limit without a sort specifier.\",\r\n      solution: \"Try adding a sort specifier.\"\r\n    }\r\n  };\r\n\r\n  return true;\r\n};\r\n\r\nOplogCheck.olderVersion = function(cursorDescription, driver) {\r\n  if(driver && !driver.constructor.cursorSupported) {\r\n    return {\r\n      code: \"OLDER_VERSION\",\r\n      reason: \"Your Meteor version does not have oplog support.\",\r\n      solution: \"Upgrade your app to Meteor version 0.7.2 or later.\"\r\n    };\r\n  }\r\n  return true;\r\n};\r\n\r\nOplogCheck.gitCheckout = function(cursorDescription, driver) {\r\n  if(!Meteor.release) {\r\n    return {\r\n      code: \"GIT_CHECKOUT\",\r\n      reason: \"Seems like your Meteor version is based on a Git checkout and it doesn't have the oplog support.\",\r\n      solution: \"Try to upgrade your Meteor version.\"\r\n    };\r\n  }\r\n  return true;\r\n};\r\n\r\nvar preRunningMatchers = [\r\n  OplogCheck.env,\r\n  OplogCheck.disableOplog,\r\n  OplogCheck.miniMongoMatcher\r\n];\r\n\r\nvar globalMatchers = [\r\n  OplogCheck.fields,\r\n  OplogCheck.skip,\r\n  OplogCheck.where,\r\n  OplogCheck.geo,\r\n  OplogCheck.limitButNoSort,\r\n  OplogCheck.miniMongoSorter,\r\n  OplogCheck.olderVersion,\r\n  OplogCheck.gitCheckout\r\n];\r\n\r\nvar versionMatchers = [\r\n  [/^0\\.7\\.1/, OplogCheck._071],\r\n  [/^0\\.7\\.0/, OplogCheck._070],\r\n];\r\n\r\nKadira.checkWhyNoOplog = function(cursorDescription, observerDriver) {\r\n  if(typeof Minimongo == 'undefined') {\r\n    return {\r\n      code: \"CANNOT_DETECT\",\r\n      reason: \"You are running an older Meteor version and Kadira can't check oplog state.\",\r\n      solution: \"Try updating your Meteor app\"\r\n    }\r\n  }\r\n\r\n  var result = runMatchers(preRunningMatchers, cursorDescription, observerDriver);\r\n  if(result !== true) {\r\n    return result;\r\n  }\r\n\r\n  var meteorVersion = Meteor.release;\r\n  for(var lc=0; lc<versionMatchers.length; lc++) {\r\n    var matcherInfo = versionMatchers[lc];\r\n    if(matcherInfo[0].test(meteorVersion)) {\r\n      var matched = matcherInfo[1](cursorDescription, observerDriver);\r\n      if(matched !== true) {\r\n        return matched;\r\n      }\r\n    }\r\n  }\r\n\r\n  result = runMatchers(globalMatchers, cursorDescription, observerDriver);\r\n  if(result !== true) {\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    code: \"OPLOG_SUPPORTED\",\r\n    reason: \"This query should support oplog. It's weird if it's not.\",\r\n    solution: \"Please contact Kadira support and let's discuss.\"\r\n  };\r\n};\r\n\r\nfunction runMatchers(matcherList, cursorDescription, observerDriver) {\r\n  for(var lc=0; lc<matcherList.length; lc++) {\r\n    var matcher = matcherList[lc];\r\n    var matched = matcher(cursorDescription, observerDriver);\r\n    if(matched !== true) {\r\n      return matched;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/tracer/tracer.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Fibers = Npm.require('fibers');\r\nvar eventLogger = Npm.require('debug')('kadira:tracer');\r\nvar REPITITIVE_EVENTS = {'db': true, 'http': true, 'email': true, 'wait': true, 'async': true};\r\n\r\nTracer = function Tracer() {\r\n  this._filters = [];\r\n};\r\n\r\n//In the future, we might wan't to track inner fiber events too.\r\n//Then we can't serialize the object with methods\r\n//That's why we use this method of returning the data\r\nTracer.prototype.start = function(session, msg) {\r\n  var traceInfo = {\r\n    _id: session.id + \"::\" + msg.id,\r\n    session: session.id,\r\n    userId: session.userId,\r\n    id: msg.id,\r\n    events: []\r\n  };\r\n\r\n  if(msg.msg == 'method') {\r\n    traceInfo.type = 'method';\r\n    traceInfo.name = msg.method;\r\n  } else if(msg.msg == 'sub') {\r\n    traceInfo.type = 'sub';\r\n    traceInfo.name = msg.name;\r\n  } else {\r\n    return null;\r\n  }\r\n\r\n  return traceInfo;\r\n};\r\n\r\nTracer.prototype.event = function(traceInfo, type, data) {\r\n  // do not allow to proceed, if already completed or errored\r\n  var lastEvent = this.getLastEvent(traceInfo);\r\n  if(lastEvent && ['complete', 'error'].indexOf(lastEvent.type) >= 0) {\r\n    return false;\r\n  }\r\n\r\n  //expecting a end event\r\n  var eventId = true;\r\n\r\n  //specially handling for repitivive events like db, http\r\n  if(REPITITIVE_EVENTS[type]) {\r\n    //can't accept a new start event\r\n    if(traceInfo._lastEventId) {\r\n      return false;\r\n    }\r\n    eventId = traceInfo._lastEventId = DefaultUniqueId.get();\r\n  }\r\n\r\n  var event = {type: type, at: Ntp._now()};\r\n  if(data) {\r\n    var info = _.pick(traceInfo, 'type', 'name')\r\n    event.data = this._applyFilters(type, data, info, \"start\");;\r\n  }\r\n\r\n  traceInfo.events.push(event);\r\n\r\n  eventLogger(\"%s %s\", type, traceInfo._id);\r\n  return eventId;\r\n};\r\n\r\nTracer.prototype.eventEnd = function(traceInfo, eventId, data) {\r\n  if(traceInfo._lastEventId && traceInfo._lastEventId == eventId) {\r\n    var lastEvent = this.getLastEvent(traceInfo);\r\n    var type = lastEvent.type + 'end';\r\n    var event = {type: type, at: Ntp._now()};\r\n    if(data) {\r\n      var info = _.pick(traceInfo, 'type', 'name')\r\n      event.data = this._applyFilters(type, data, info, \"end\");;\r\n    }\r\n    traceInfo.events.push(event);\r\n    eventLogger(\"%s %s\", type, traceInfo._id);\r\n\r\n    traceInfo._lastEventId = null;\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nTracer.prototype.getLastEvent = function(traceInfo) {\r\n  return traceInfo.events[traceInfo.events.length -1]\r\n};\r\n\r\nTracer.prototype.endLastEvent = function(traceInfo) {\r\n  var lastEvent = this.getLastEvent(traceInfo);\r\n  if(lastEvent && !/end$/.test(lastEvent.type)) {\r\n    traceInfo.events.push({\r\n      type: lastEvent.type + 'end',\r\n      at: Ntp._now()\r\n    });\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nTracer.prototype.buildTrace = function(traceInfo) {\r\n  var firstEvent = traceInfo.events[0];\r\n  var lastEvent = traceInfo.events[traceInfo.events.length - 1];\r\n  var processedEvents = [];\r\n\r\n  if(firstEvent.type != 'start') {\r\n    console.warn('Kadira: trace is not started yet');\r\n    return null;\r\n  } else if(lastEvent.type != 'complete' && lastEvent.type != 'error') {\r\n    //trace is not completed or errored yet\r\n    console.warn('Kadira: trace is not completed or errored yet');\r\n    return null;\r\n  } else {\r\n    //build the metrics\r\n    traceInfo.errored = lastEvent.type == 'error';\r\n    traceInfo.at = firstEvent.at;\r\n\r\n    var metrics = {\r\n      total: lastEvent.at - firstEvent.at,\r\n    };\r\n\r\n    var totalNonCompute = 0;\r\n\r\n    firstEvent = ['start', 0];\r\n    if(traceInfo.events[0].data) firstEvent.push(traceInfo.events[0].data);\r\n    processedEvents.push(firstEvent);\r\n\r\n    for(var lc=1; lc < traceInfo.events.length - 1; lc += 2) {\r\n      var prevEventEnd = traceInfo.events[lc-1];\r\n      var startEvent = traceInfo.events[lc];\r\n      var endEvent = traceInfo.events[lc+1];\r\n      var computeTime = startEvent.at - prevEventEnd.at;\r\n      if(computeTime > 0) processedEvents.push(['compute', computeTime]);\r\n      if(!endEvent) {\r\n        console.error('Kadira: no end event for type: ', startEvent.type);\r\n        return null;\r\n      } else if(endEvent.type != startEvent.type + 'end') {\r\n        console.error('Kadira: endevent type mismatch: ', startEvent.type, endEvent.type, JSON.stringify(traceInfo));\r\n        return null;\r\n      } else {\r\n        var elapsedTimeForEvent = endEvent.at - startEvent.at\r\n        var currentEvent = [startEvent.type, elapsedTimeForEvent];\r\n        currentEvent.push(_.extend({}, startEvent.data, endEvent.data));\r\n        processedEvents.push(currentEvent);\r\n        metrics[startEvent.type] = metrics[startEvent.type] || 0;\r\n        metrics[startEvent.type] += elapsedTimeForEvent;\r\n        totalNonCompute += elapsedTimeForEvent;\r\n      }\r\n    }\r\n\r\n    computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2];\r\n    if(computeTime > 0) processedEvents.push(['compute', computeTime]);\r\n\r\n    var lastEventData = [lastEvent.type, 0];\r\n    if(lastEvent.data) lastEventData.push(lastEvent.data);\r\n    processedEvents.push(lastEventData);\r\n\r\n    metrics.compute = metrics.total - totalNonCompute;\r\n    traceInfo.metrics = metrics;\r\n    traceInfo.events = processedEvents;\r\n    traceInfo.isEventsProcessed = true;\r\n    return traceInfo;\r\n  }\r\n};\r\n\r\nTracer.prototype.addFilter = function(filterFn) {\r\n  this._filters.push(filterFn);\r\n};\r\n\r\nTracer.prototype._applyFilters = function(eventType, data, info) {\r\n  this._filters.forEach(function(filterFn) {\r\n    data = filterFn(eventType, _.clone(data), info);\r\n  });\r\n\r\n  return data;\r\n};\r\n\r\nKadira.tracer = new Tracer();\r\n// need to expose Tracer to provide default set of filters\r\nKadira.Tracer = Tracer;\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/tracer/default_filters.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// strip sensitive data sent to kadia engine.\r\n// possible to limit types by providing an array of types to strip\r\n// possible types are: \"start\", \"db\", \"http\", \"email\"\r\nTracer.stripSensitive = function stripSensitive(typesToStrip, receiverType, name) {\r\n  typesToStrip =  typesToStrip || [];\r\n\r\n  var strippedTypes = {};\r\n  typesToStrip.forEach(function(type) {\r\n    strippedTypes[type] = true;\r\n  });\r\n\r\n  return function (type, data, info) {\r\n    if(typesToStrip.length > 0 && !strippedTypes[type])\r\n      return data;\r\n\r\n    if(receiverType && receiverType != info.type)\r\n      return data;\r\n\r\n    if(name && name != info.name)\r\n      return data;\r\n\r\n    if(type == \"start\") {\r\n      data.params = \"[stripped]\";\r\n    } else if(type == \"db\") {\r\n      data.selector = \"[stripped]\";\r\n    } else if(type == \"http\") {\r\n      data.url = \"[stripped]\";\r\n    } else if(type == \"email\") {\r\n      [\"from\", \"to\", \"cc\", \"bcc\", \"replyTo\"].forEach(function(item) {\r\n        if(data[item]) {\r\n          data[item] = \"[stripped]\";\r\n        }\r\n      });\r\n    }\r\n\r\n    return data;\r\n  };\r\n};\r\n\r\n// strip selectors only from the given list of collection names\r\nTracer.stripSelectors = function stripSelectors(collectionList, receiverType, name) {\r\n  collectionList = collectionList || [];\r\n\r\n  var collMap = {};\r\n  collectionList.forEach(function(collName) {\r\n    collMap[collName] = true;\r\n  });\r\n\r\n  return function(type, data, info) {\r\n    if(type != \"db\" || (data && !collMap[data.coll])) {\r\n      return data\r\n    }\r\n\r\n    if(receiverType && receiverType != info.type)\r\n      return data;\r\n\r\n    if(name && name != info.name)\r\n      return data;\r\n\r\n    data.selector = \"[stripped]\";\r\n    return data;\r\n  };\r\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/tracer/tracer_store.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar logger = Npm.require('debug')('kadira:ts');\r\n\r\nTracerStore = function TracerStore(options) {\r\n  options = options || {};\r\n\r\n  this.maxTotalPoints = options.maxTotalPoints || 30;\r\n  this.interval = options.interval || 1000 * 60;\r\n  this.archiveEvery = options.archiveEvery || this.maxTotalPoints / 6;\r\n\r\n  //store max total on the past 30 minutes (or past 30 items)\r\n  this.maxTotals = Object.create(null);\r\n  //store the max trace of the current interval\r\n  this.currentMaxTrace = Object.create(null);\r\n  //archive for the traces\r\n  this.traceArchive = [];\r\n\r\n  this.processedCnt = Object.create(null);\r\n\r\n  //group errors by messages between an interval\r\n  this.errorMap = Object.create(null);\r\n};\r\n\r\nTracerStore.prototype.addTrace = function(trace) {\r\n  var kind = [trace.type, trace.name].join('::');\r\n  if(!this.currentMaxTrace[kind]) {\r\n    this.currentMaxTrace[kind] = EJSON.clone(trace);\r\n  } else if(this.currentMaxTrace[kind].metrics.total < trace.metrics.total) {\r\n    this.currentMaxTrace[kind] = EJSON.clone(trace);\r\n  } else if(trace.errored) {\r\n    this._handleErrors(trace);\r\n  }\r\n};\r\n\r\nTracerStore.prototype.collectTraces = function() {\r\n  var traces = this.traceArchive;\r\n  this.traceArchive = [];\r\n\r\n  // convert at(timestamp) into the actual serverTime\r\n  traces.forEach(function(trace) {\r\n    trace.at = Kadira.syncedDate.syncTime(trace.at);\r\n  });\r\n  return traces;\r\n};\r\n\r\nTracerStore.prototype.start = function() {\r\n  this._timeoutHandler = setInterval(this.processTraces.bind(this), this.interval);\r\n};\r\n\r\nTracerStore.prototype.stop = function() {\r\n  if(this._timeoutHandler) {\r\n    clearInterval(this._timeoutHandler);\r\n  }\r\n};\r\n\r\nTracerStore.prototype._handleErrors = function(trace) {\r\n  // sending error requests as it is\r\n  var lastEvent = trace.events[trace.events.length -1];\r\n  if(lastEvent && lastEvent[2]) {\r\n    var error = lastEvent[2].error;\r\n\r\n    // grouping errors occured (reset after processTraces)\r\n    var errorKey = [trace.type, trace.name, error.message].join(\"::\");\r\n    if(!this.errorMap[errorKey]) {\r\n      var erroredTrace = EJSON.clone(trace);\r\n      this.errorMap[errorKey] = erroredTrace;\r\n\r\n      this.traceArchive.push(erroredTrace);\r\n    }\r\n  } else {\r\n    logger('last events is not an error: ', JSON.stringify(trace.events));\r\n  }\r\n};\r\n\r\nTracerStore.prototype.processTraces = function() {\r\n  var self = this;\r\n  var kinds = _.union(\r\n    _.keys(this.maxTotals),\r\n    _.keys(this.currentMaxTrace)\r\n  );\r\n\r\n  kinds.forEach(function(kind) {\r\n    self.processedCnt[kind] = self.processedCnt[kind] || 0;\r\n    var currentMaxTrace = self.currentMaxTrace[kind];\r\n    var currentMaxTotal = currentMaxTrace? currentMaxTrace.metrics.total : 0;\r\n\r\n    self.maxTotals[kind] = self.maxTotals[kind] || [];\r\n    //add the current maxPoint\r\n    self.maxTotals[kind].push(currentMaxTotal);\r\n    var exceedingPoints = self.maxTotals[kind].length - self.maxTotalPoints;\r\n    if(exceedingPoints > 0) {\r\n      self.maxTotals[kind].splice(0, exceedingPoints);\r\n    }\r\n\r\n    var archiveDefault = (self.processedCnt[kind] % self.archiveEvery) == 0;\r\n    self.processedCnt[kind]++;\r\n\r\n    var canArchive = archiveDefault\r\n      || self._isTraceOutlier(kind, currentMaxTrace);\r\n\r\n    if(canArchive && currentMaxTrace) {\r\n      self.traceArchive.push(currentMaxTrace);\r\n    }\r\n\r\n    //reset currentMaxTrace\r\n    self.currentMaxTrace[kind] = null;\r\n  });\r\n\r\n  //reset the errorMap\r\n  self.errorMap = Object.create(null);\r\n};\r\n\r\nTracerStore.prototype._isTraceOutlier = function(kind, trace) {\r\n  if(trace) {\r\n    var dataSet = this.maxTotals[kind];\r\n    return this._isOutlier(dataSet, trace.metrics.total, 3);\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/*\r\n  Data point must exists in the dataSet\r\n*/\r\nTracerStore.prototype._isOutlier = function(dataSet, dataPoint, maxMadZ) {\r\n  var median = this._getMedian(dataSet);\r\n  var mad = this._calculateMad(dataSet, median);\r\n  var madZ = this._funcMedianDeviation(median)(dataPoint) / mad;\r\n\r\n  return madZ > maxMadZ;\r\n};\r\n\r\nTracerStore.prototype._getMedian = function(dataSet) {\r\n  var sortedDataSet = _.clone(dataSet).sort(function(a, b) {\r\n    return a-b;\r\n  });\r\n  return this._pickQuartile(sortedDataSet, 2);\r\n};\r\n\r\nTracerStore.prototype._pickQuartile = function(dataSet, num) {\r\n  var pos = ((dataSet.length + 1) * num) / 4;\r\n  if(pos % 1 == 0) {\r\n    return dataSet[pos -1];\r\n  } else {\r\n    pos = pos - (pos % 1);\r\n    return (dataSet[pos -1] + dataSet[pos])/2\r\n  }\r\n};\r\n\r\nTracerStore.prototype._calculateMad = function(dataSet, median) {\r\n  var medianDeviations = _.map(dataSet, this._funcMedianDeviation(median));\r\n  var mad = this._getMedian(medianDeviations);\r\n\r\n  return mad;\r\n};\r\n\r\nTracerStore.prototype._funcMedianDeviation = function(median) {\r\n  return function(x) {\r\n    return Math.abs(median - x);\r\n  };\r\n};\r\n\r\nTracerStore.prototype._getMean = function(dataPoints) {\r\n  if(dataPoints.length > 0) {\r\n    var total = 0;\r\n    dataPoints.forEach(function(point) {\r\n      total += point;\r\n    });\r\n    return total/dataPoints.length;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/0model.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nKadiraModel = function() {\r\n\r\n};\r\n\r\nKadiraModel.prototype._getDateId = function(timestamp) {\r\n  var remainder = timestamp % (1000 * 60);\r\n  var dateId = timestamp - remainder;\r\n  return dateId;\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/methods.js                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\r\n\r\nMethodsModel = function (metricsThreshold) {\r\n  var self = this;\r\n\r\n  this.methodMetricsByMinute = Object.create(null);\r\n  this.errorMap = Object.create(null);\r\n\r\n  this._metricsThreshold = _.extend({\r\n    \"wait\": 100,\r\n    \"db\": 100,\r\n    \"http\": 1000,\r\n    \"email\": 100,\r\n    \"async\": 100,\r\n    \"compute\": 100,\r\n    \"total\": 200\r\n  }, metricsThreshold || Object.create(null));\r\n\r\n  //store max time elapsed methods for each method, event(metrics-field)\r\n  this.maxEventTimesForMethods = Object.create(null);\r\n\r\n  this.tracerStore = new TracerStore({\r\n    interval: 1000 * 60, //process traces every minute\r\n    maxTotalPoints: 30, //for 30 minutes\r\n    archiveEvery: 5 //always trace for every 5 minutes,\r\n  });\r\n\r\n  this.tracerStore.start();\r\n};\r\n\r\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\r\n\r\nMethodsModel.prototype._getMetrics = function(timestamp, method) {\r\n  var dateId = this._getDateId(timestamp);\r\n\r\n  if(!this.methodMetricsByMinute[dateId]) {\r\n    this.methodMetricsByMinute[dateId] = {\r\n      methods: Object.create(null)\r\n    };\r\n  }\r\n\r\n  var methods = this.methodMetricsByMinute[dateId].methods;\r\n\r\n  //initialize method\r\n  if(!methods[method]) {\r\n    methods[method] = {\r\n      count: 0,\r\n      errors: 0,\r\n      fetchedDocSize: 0,\r\n      sentMsgSize: 0\r\n    };\r\n\r\n    METHOD_METRICS_FIELDS.forEach(function(field) {\r\n      methods[method][field] = 0;\r\n    });\r\n  }\r\n\r\n  return this.methodMetricsByMinute[dateId].methods[method];\r\n};\r\n\r\nMethodsModel.prototype.setStartTime = function(timestamp) {\r\n  this.metricsByMinute[dateId].startTime = timestamp;\r\n}\r\n\r\nMethodsModel.prototype.processMethod = function(methodTrace) {\r\n  var dateId = this._getDateId(methodTrace.at);\r\n\r\n  //append metrics to previous values\r\n  this._appendMetrics(dateId, methodTrace);\r\n  if(methodTrace.errored) {\r\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors ++\r\n  }\r\n\r\n  this.tracerStore.addTrace(methodTrace);\r\n};\r\n\r\nMethodsModel.prototype._appendMetrics = function(id, methodTrace) {\r\n  var methodMetrics = this._getMetrics(id, methodTrace.name)\r\n\r\n  // startTime needs to be converted into serverTime before sending\r\n  if(!this.methodMetricsByMinute[id].startTime){\r\n    this.methodMetricsByMinute[id].startTime = methodTrace.at;\r\n  }\r\n\r\n  //merge\r\n  METHOD_METRICS_FIELDS.forEach(function(field) {\r\n    var value = methodTrace.metrics[field];\r\n    if(value > 0) {\r\n      methodMetrics[field] += value;\r\n    }\r\n  });\r\n\r\n  methodMetrics.count++;\r\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\r\n};\r\n\r\nMethodsModel.prototype.trackDocSize = function(method, size) {\r\n  var timestamp = Ntp._now();\r\n  var dateId = this._getDateId(timestamp);\r\n\r\n  var methodMetrics = this._getMetrics(dateId, method);\r\n  methodMetrics.fetchedDocSize += size;\r\n}\r\n\r\nMethodsModel.prototype.trackMsgSize = function(method, size) {\r\n  var timestamp = Ntp._now();\r\n  var dateId = this._getDateId(timestamp);\r\n\r\n  var methodMetrics = this._getMetrics(dateId, method);\r\n  methodMetrics.sentMsgSize += size;\r\n}\r\n\r\n/*\r\n  There are two types of data\r\n\r\n  1. methodMetrics - metrics about the methods (for every 10 secs)\r\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\r\n*/\r\nMethodsModel.prototype.buildPayload = function(buildDetailedInfo) {\r\n  var payload = {\r\n    methodMetrics: [],\r\n    methodRequests: []\r\n  };\r\n\r\n  //handling metrics\r\n  var methodMetricsByMinute = this.methodMetricsByMinute;\r\n  this.methodMetricsByMinute = Object.create(null);\r\n\r\n  //create final paylod for methodMetrics\r\n  for(var key in methodMetricsByMinute) {\r\n    var methodMetrics = methodMetricsByMinute[key];\r\n    // converting startTime into the actual serverTime\r\n    var startTime = methodMetrics.startTime;\r\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\r\n\r\n    for(var methodName in methodMetrics.methods) {\r\n      METHOD_METRICS_FIELDS.forEach(function(field) {\r\n        methodMetrics.methods[methodName][field] /=\r\n          methodMetrics.methods[methodName].count;\r\n      });\r\n    }\r\n\r\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\r\n  }\r\n\r\n  //collect traces and send them with the payload\r\n  payload.methodRequests = this.tracerStore.collectTraces();\r\n\r\n  return payload;\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/pubsub.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar logger = Npm.require('debug')('kadira:pubsub');\r\n\r\nPubsubModel = function() {\r\n  this.metricsByMinute = Object.create(null);\r\n  this.subscriptions = Object.create(null);\r\n\r\n  this.tracerStore = new TracerStore({\r\n    interval: 1000 * 60, //process traces every minute\r\n    maxTotalPoints: 30, //for 30 minutes\r\n    archiveEvery: 5 //always trace for every 5 minutes,\r\n  });\r\n\r\n  this.tracerStore.start();\r\n}\r\n\r\nPubsubModel.prototype._trackSub = function(session, msg) {\r\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\r\n  var publication = this._getPublicationName(msg.name);\r\n  var subscriptionId = msg.id;\r\n  var timestamp = Ntp._now();\r\n  var metrics = this._getMetrics(timestamp, publication);\r\n\r\n  metrics.subs++;\r\n  this.subscriptions[msg.id] = {\r\n    // We use localTime here, because when we used synedTime we might get\r\n    // minus or more than we've expected\r\n    //   (before serverTime diff changed overtime)\r\n    startTime: timestamp,\r\n    publication: publication,\r\n    params: msg.params,\r\n    id: msg.id\r\n  };\r\n\r\n  //set session startedTime\r\n  session._startTime = session._startTime || timestamp;\r\n};\r\n\r\n_.extend(PubsubModel.prototype, KadiraModel.prototype);\r\n\r\nPubsubModel.prototype._trackUnsub = function(session, sub) {\r\n  logger('UNSUB:', session.id, sub._subscriptionId);\r\n  var publication = this._getPublicationName(sub._name);\r\n  var subscriptionId = sub._subscriptionId;\r\n  var subscriptionState = this.subscriptions[subscriptionId];\r\n\r\n  var startTime = null;\r\n  //sometime, we don't have these states\r\n  if(subscriptionState) {\r\n    startTime = subscriptionState.startTime;\r\n  } else {\r\n    //if this is null subscription, which is started automatically\r\n    //hence, we don't have a state\r\n    startTime = session._startTime;\r\n  }\r\n\r\n  //in case, we can't get the startTime\r\n  if(startTime) {\r\n    var timestamp = Ntp._now();\r\n    var metrics = this._getMetrics(timestamp, publication);\r\n    //track the count\r\n    if(sub._name != null) {\r\n      // we can't track subs for `null` publications.\r\n      // so we should not track unsubs too\r\n      metrics.unsubs++;\r\n    }\r\n    //use the current date to get the lifeTime of the subscription\r\n    metrics.lifeTime += timestamp - startTime;\r\n    //this is place we can clean the subscriptionState if exists\r\n    delete this.subscriptions[subscriptionId];\r\n  }\r\n};\r\n\r\nPubsubModel.prototype._trackReady = function(session, sub, trace) {\r\n  logger('READY:', session.id, sub._subscriptionId);\r\n  //use the current time to track the response time\r\n  var publication = this._getPublicationName(sub._name);\r\n  var subscriptionId = sub._subscriptionId;\r\n  var timestamp = Ntp._now();\r\n  var metrics = this._getMetrics(timestamp, publication);\r\n\r\n  var subscriptionState = this.subscriptions[subscriptionId];\r\n  if(subscriptionState && !subscriptionState.readyTracked) {\r\n    metrics.resTime += timestamp - subscriptionState.startTime;\r\n    subscriptionState.readyTracked = true;\r\n  }\r\n\r\n  if(trace) {\r\n    this.tracerStore.addTrace(trace);\r\n  }\r\n};\r\n\r\nPubsubModel.prototype._trackError = function(session, sub, trace) {\r\n  logger('ERROR:', session.id, sub._subscriptionId);\r\n  //use the current time to track the response time\r\n  var publication = this._getPublicationName(sub._name);\r\n  var subscriptionId = sub._subscriptionId;\r\n  var timestamp = Ntp._now();\r\n  var metrics = this._getMetrics(timestamp, publication);\r\n\r\n  metrics.errors++;\r\n\r\n  if(trace) {\r\n    this.tracerStore.addTrace(trace);\r\n  }\r\n};\r\n\r\nPubsubModel.prototype._getMetrics = function(timestamp, publication) {\r\n  var dateId = this._getDateId(timestamp);\r\n\r\n  if(!this.metricsByMinute[dateId]) {\r\n    this.metricsByMinute[dateId] = {\r\n      // startTime needs to be convert to serverTime before sending to the server\r\n      startTime: timestamp,\r\n      pubs: Object.create(null)\r\n    };\r\n  }\r\n\r\n  if(!this.metricsByMinute[dateId].pubs[publication]) {\r\n    this.metricsByMinute[dateId].pubs[publication] = {\r\n      subs: 0,\r\n      unsubs: 0,\r\n      resTime: 0,\r\n      activeSubs: 0,\r\n      activeDocs: 0,\r\n      lifeTime: 0,\r\n      totalObservers: 0,\r\n      cachedObservers: 0,\r\n      createdObservers: 0,\r\n      deletedObservers: 0,\r\n      errors: 0,\r\n      observerLifetime: 0,\r\n      polledDocuments: 0,\r\n      oplogUpdatedDocuments: 0,\r\n      oplogInsertedDocuments: 0,\r\n      oplogDeletedDocuments: 0,\r\n      initiallyAddedDocuments: 0,\r\n      liveAddedDocuments: 0,\r\n      liveChangedDocuments: 0,\r\n      liveRemovedDocuments: 0,\r\n      polledDocSize: 0,\r\n      fetchedDocSize: 0,\r\n      initiallyFetchedDocSize: 0,\r\n      liveFetchedDocSize: 0,\r\n      initiallySentMsgSize: 0,\r\n      liveSentMsgSize: 0\r\n    };\r\n  }\r\n\r\n  return this.metricsByMinute[dateId].pubs[publication];\r\n};\r\n\r\nPubsubModel.prototype._getPublicationName = function(name) {\r\n  return name || \"null(autopublish)\";\r\n};\r\n\r\nPubsubModel.prototype._getSubscriptionInfo = function() {\r\n  var self = this;\r\n  var activeSubs = Object.create(null);\r\n  var activeDocs = Object.create(null);\r\n  var totalDocsSent = Object.create(null);\r\n  var totalDataSent = Object.create(null);\r\n  var totalObservers = Object.create(null);\r\n  var cachedObservers = Object.create(null);\r\n\r\n  for(var sessionId in Meteor.default_server.sessions) {\r\n    var session = Meteor.default_server.sessions[sessionId];\r\n    _.each(session._namedSubs, countSubData);\r\n    _.each(session._universalSubs, countSubData);\r\n  }\r\n\r\n  var avgObserverReuse = Object.create(null);\r\n  _.each(totalObservers, function(value, publication) {\r\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\r\n  });\r\n\r\n  return {\r\n    activeSubs: activeSubs,\r\n    activeDocs: activeDocs,\r\n    avgObserverReuse: avgObserverReuse\r\n  };\r\n\r\n  function countSubData (sub) {\r\n    var publication = self._getPublicationName(sub._name);\r\n    countSubscriptions(sub, publication);\r\n    countDocuments(sub, publication);\r\n    countObservers(sub, publication);\r\n  }\r\n\r\n  function countSubscriptions (sub, publication) {\r\n    activeSubs[publication] = activeSubs[publication] || 0;\r\n    activeSubs[publication]++;\r\n  }\r\n\r\n  function countDocuments (sub, publication) {\r\n    activeDocs[publication] = activeDocs[publication] || 0;\r\n    for(collectionName in sub._documents) {\r\n      activeDocs[publication] += _.keys(sub._documents[collectionName]).length;\r\n    }\r\n  }\r\n\r\n  function countObservers(sub, publication) {\r\n    totalObservers[publication] = totalObservers[publication] || 0;\r\n    cachedObservers[publication] = cachedObservers[publication] || 0;\r\n\r\n    totalObservers[publication] += sub._totalObservers;\r\n    cachedObservers[publication] += sub._cachedObservers;\r\n  }\r\n}\r\n\r\nPubsubModel.prototype.buildPayload = function(buildDetailInfo) {\r\n  var metricsByMinute = this.metricsByMinute;\r\n  this.metricsByMinute = Object.create(null);\r\n\r\n  var payload = {\r\n    pubMetrics: []\r\n  };\r\n\r\n  var subscriptionData = this._getSubscriptionInfo();\r\n  var activeSubs = subscriptionData.activeSubs;\r\n  var activeDocs = subscriptionData.activeDocs;\r\n  var avgObserverReuse = subscriptionData.avgObserverReuse;\r\n\r\n  //to the averaging\r\n  for(var dateId in metricsByMinute) {\r\n    var dateMetrics = metricsByMinute[dateId];\r\n    // We need to convert startTime into actual serverTime\r\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\r\n\r\n    for(var publication in metricsByMinute[dateId].pubs) {\r\n      var singlePubMetrics = metricsByMinute[dateId].pubs[publication];\r\n      // We only calculate resTime for new subscriptions\r\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\r\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\r\n      // We only track lifeTime in the unsubs\r\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\r\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\r\n\r\n      // Count the average for observer lifetime\r\n      if(singlePubMetrics.deletedObservers > 0) {\r\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\r\n      }\r\n\r\n      // If there are two ore more dateIds, we will be using the currentCount for all of them.\r\n      // We can come up with a better solution later on.\r\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\r\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\r\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\r\n    }\r\n\r\n    payload.pubMetrics.push(metricsByMinute[dateId]);\r\n  }\r\n\r\n  //collect traces and send them with the payload\r\n  payload.pubRequests = this.tracerStore.collectTraces();\r\n\r\n  return payload;\r\n};\r\n\r\nPubsubModel.prototype.incrementHandleCount = function(trace, isCached) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(trace.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n\r\n  var session = Meteor.default_server.sessions[trace.session];\r\n  if(session) {\r\n    var sub = session._namedSubs[trace.id];\r\n    if(sub) {\r\n      sub._totalObservers = sub._totalObservers || 0;\r\n      sub._cachedObservers = sub._cachedObservers || 0;\r\n    }\r\n  }\r\n  // not sure, we need to do this? But I don't need to break the however\r\n  sub = sub || {_totalObservers:0 , _cachedObservers: 0};\r\n\r\n  publication.totalObservers++;\r\n  sub._totalObservers++;\r\n  if(isCached) {\r\n    publication.cachedObservers++;\r\n    sub._cachedObservers++;\r\n  }\r\n}\r\n\r\nPubsubModel.prototype.trackCreatedObserver = function(info) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(info.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n  publication.createdObservers++;\r\n}\r\n\r\nPubsubModel.prototype.trackDeletedObserver = function(info) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(info.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n  publication.deletedObservers++;\r\n  publication.observerLifetime += (new Date()).getTime() - info.startTime;\r\n}\r\n\r\nPubsubModel.prototype.trackDocumentChanges = function(info, op) {\r\n  // It's possibel that info to be null\r\n  // Specially when getting changes at the very begining.\r\n  // This may be false, but nice to have a check\r\n  if(!info) {\r\n    return\r\n  }\r\n\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(info.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n  if(op.op === \"d\") {\r\n    publication.oplogDeletedDocuments++;\r\n  } else if(op.op === \"i\") {\r\n    publication.oplogInsertedDocuments++;\r\n  } else if(op.op === \"u\") {\r\n    publication.oplogUpdatedDocuments++;\r\n  }\r\n}\r\n\r\nPubsubModel.prototype.trackPolledDocuments = function(info, count) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(info.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n  publication.polledDocuments += count;\r\n}\r\n\r\nPubsubModel.prototype.trackLiveUpdates = function(info, type, count) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(info.name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n\r\n  if(type === \"_addPublished\") {\r\n    publication.liveAddedDocuments += count;\r\n  } else if(type === \"_removePublished\") {\r\n    publication.liveRemovedDocuments += count;\r\n  } else if(type === \"_changePublished\") {\r\n    publication.liveChangedDocuments += count;\r\n  } else if(type === \"_initialAdds\") {\r\n    publication.initiallyAddedDocuments += count;\r\n  } else {\r\n    throw new Error(\"Kadira: Unknown live update type\");\r\n  }\r\n}\r\n\r\nPubsubModel.prototype.trackDocSize = function(name, type, size) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n\r\n  if(type === \"polledFetches\") {\r\n    publication.polledDocSize += size;\r\n  } else if(type === \"liveFetches\") {\r\n    publication.liveFetchedDocSize += size;\r\n  } else if(type === \"cursorFetches\") {\r\n    publication.fetchedDocSize += size;\r\n  } else if(type === \"initialFetches\") {\r\n    publication.initiallyFetchedDocSize += size;\r\n  } else {\r\n    throw new Error(\"Kadira: Unknown docs fetched type\");\r\n  }\r\n}\r\n\r\nPubsubModel.prototype.trackMsgSize = function(name, type, size) {\r\n  var timestamp = Ntp._now();\r\n  var publicationName = this._getPublicationName(name);\r\n  var publication = this._getMetrics(timestamp, publicationName);\r\n\r\n  if(type === \"liveSent\") {\r\n    publication.liveSentMsgSize += size;\r\n  } else if(type === \"initialSent\") {\r\n    publication.initiallySentMsgSize += size;\r\n  } else {\r\n    throw new Error(\"Kadira: Unknown docs fetched type\");\r\n  }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/system.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar os = Npm.require('os');\r\nvar usage = Npm.require('pidusage');\r\nvar EventLoopMonitor = Npm.require('evloop-monitor');\r\n\r\nSystemModel = function () {\r\n  var self = this;\r\n  this.startTime = Ntp._now();\r\n  this.newSessions = 0;\r\n  this.sessionTimeout = 1000 * 60 * 30; //30 min\r\n\r\n  this.usageLookup = Kadira._wrapAsync(usage.stat.bind(usage));\r\n  this.evloopMonitor = new EventLoopMonitor(200);\r\n  this.evloopMonitor.start();\r\n}\r\n\r\n_.extend(SystemModel.prototype, KadiraModel.prototype);\r\n\r\nSystemModel.prototype.buildPayload = function() {\r\n  var metrics = {};\r\n  var now = Ntp._now();\r\n  metrics.startTime = Kadira.syncedDate.syncTime(this.startTime);\r\n  metrics.endTime = Kadira.syncedDate.syncTime(now);\r\n\r\n  metrics.sessions = _.keys(Meteor.default_server.sessions).length;\r\n  metrics.memory = process.memoryUsage().rss / (1024*1024);\r\n  metrics.newSessions = this.newSessions;\r\n  this.newSessions = 0;\r\n\r\n  var usage = this.getUsage();\r\n  metrics.pcpu = usage.cpu;\r\n  if(usage.cpuInfo) {\r\n    metrics.cputime = usage.cpuInfo.cpuTime;\r\n    metrics.pcpuUser = usage.cpuInfo.pcpuUser;\r\n    metrics.pcpuSystem = usage.cpuInfo.pcpuSystem;\r\n  }\r\n\r\n  // track eventloop blockness\r\n  metrics.pctEvloopBlock = this.evloopMonitor.status().pctBlock;\r\n\r\n  this.startTime = now;\r\n  return {systemMetrics: [metrics]};\r\n};\r\n\r\nSystemModel.prototype.getUsage = function() {\r\n  var usage = this.usageLookup(process.pid) || {};\r\n  Kadira.docSzCache.setPcpu(usage.cpu);\r\n  return usage;\r\n};\r\n\r\nSystemModel.prototype.handleSessionActivity = function(msg, session) {\r\n  if(msg.msg === 'connect' && !msg.session) {\r\n    this.countNewSession(session);\r\n  } else if(['sub', 'method'].indexOf(msg.msg) != -1) {\r\n    if(!this.isSessionActive(session)) {\r\n      this.countNewSession(session);\r\n    }\r\n  }\r\n  session._activeAt = Date.now();\r\n}\r\n\r\nSystemModel.prototype.countNewSession = function(session) {\r\n  if(!isLocalAddress(session.socket)) {\r\n    this.newSessions++;\r\n  }\r\n}\r\n\r\nSystemModel.prototype.isSessionActive = function(session) {\r\n  var inactiveTime = Date.now() - session._activeAt;\r\n  return inactiveTime < this.sessionTimeout;\r\n}\r\n\r\n// ------------------------------------------------------------------------- //\r\n\r\n// http://regex101.com/r/iF3yR3/2\r\nvar isLocalHostRegex = /^(?:.*\\.local|localhost)(?:\\:\\d+)?|127(?:\\.\\d{1,3}){3}|192\\.168(?:\\.\\d{1,3}){2}|10(?:\\.\\d{1,3}){3}|172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2}$/;\r\n\r\n// http://regex101.com/r/hM5gD8/1\r\nvar isLocalAddressRegex = /^127(?:\\.\\d{1,3}){3}|192\\.168(?:\\.\\d{1,3}){2}|10(?:\\.\\d{1,3}){3}|172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2}$/;\r\n\r\nfunction isLocalAddress (socket) {\r\n  var host = socket.headers['host'];\r\n  if(host) return isLocalHostRegex.test(host);\r\n  var address = socket.headers['x-forwarded-for'] || socket.remoteAddress;\r\n  if(address) return isLocalAddressRegex.test(address);\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/models/errors.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nErrorModel = function (appId) {\r\n  BaseErrorModel.call(this);\r\n  var self = this;\r\n  this.appId = appId;\r\n  this.errors = {};\r\n  this.startTime = Date.now();\r\n  this.maxErrors = 10;\r\n}\r\n\r\n_.extend(ErrorModel.prototype, KadiraModel.prototype);\r\n_.extend(ErrorModel.prototype, BaseErrorModel.prototype);\r\n\r\nErrorModel.prototype.buildPayload = function() {\r\n  var metrics = _.values(this.errors);\r\n  this.startTime = Ntp._now();\r\n\r\n  _.each(metrics, function (metric) {\r\n    metric.startTime = Kadira.syncedDate.syncTime(metric.startTime)\r\n  });\r\n\r\n  this.errors = {};\r\n  return {errors: metrics};\r\n};\r\n\r\nErrorModel.prototype.errorCount = function () {\r\n  return _.values(this.errors).length;\r\n};\r\n\r\nErrorModel.prototype.trackError = function(ex, trace) {\r\n  var key = trace.type + ':' + ex.message;\r\n  if(this.errors[key]) {\r\n    this.errors[key].count++;\r\n  } else if (this.errorCount() < this.maxErrors) {\r\n    var errorDef = this._formatError(ex, trace);\r\n    if(this.applyFilters(errorDef.type, errorDef.name, ex, errorDef.subType)) {\r\n      this.errors[key] = this._formatError(ex, trace);\r\n    }\r\n  }\r\n};\r\n\r\nErrorModel.prototype._formatError = function(ex, trace) {\r\n  var time = Date.now();\r\n  var stack = ex.stack;\r\n\r\n  // to get Meteor's Error details\r\n  if(ex.details) {\r\n    stack = \"Details: \" + ex.details + \"\\r\\n\" + stack;\r\n  }\r\n\r\n  // Update trace's error event with the next stack\r\n  var errorEvent = trace.events && trace.events[trace.events.length -1];\r\n  var errorObject = errorEvent && errorEvent[2] && errorEvent[2].error;\r\n\r\n  if(errorObject) {\r\n    errorObject.stack = stack;\r\n  }\r\n\r\n  return {\r\n    appId: this.appId,\r\n    name: ex.message,\r\n    type: trace.type,\r\n    startTime: time,\r\n    subType: trace.subType || trace.name,\r\n    trace: trace,\r\n    stacks: [{stack: stack}],\r\n    count: 1,\r\n  }\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/docsize_cache.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar LRU = Npm.require('lru-cache');\r\nvar crypto = Npm.require('crypto');\r\nvar jsonStringify = Npm.require('json-stringify-safe');\r\n\r\nDocSzCache = function (maxItems, maxValues) {\r\n  this.items = new LRU({max: maxItems});\r\n  this.maxValues = maxValues;\r\n  this.cpuUsage = 0;\r\n}\r\n\r\n// This is called from SystemModel.prototype.getUsage and saves cpu usage.\r\nDocSzCache.prototype.setPcpu = function (pcpu) {\r\n  this.cpuUsage = pcpu;\r\n};\r\n\r\nDocSzCache.prototype.getSize = function (coll, query, opts, data) {\r\n  // If the dataset is null or empty we can't calculate the size\r\n  // Do not process this data and return 0 as the document size.\r\n  if (!(data && (data.length || (data.size && data.size())))) {\r\n    return 0;\r\n  }\r\n\r\n  var key = this.getKey(coll, query, opts);\r\n  var item = this.items.get(key);\r\n\r\n  if (!item) {\r\n    item = new DocSzCacheItem(this.maxValues);\r\n    this.items.set(key, item);\r\n  }\r\n\r\n  if (this.needsUpdate(item)) {\r\n    var doc = {};\r\n    if(typeof data.get === 'function'){\r\n      // This is an IdMap\r\n      data.forEach(function(element){\r\n        doc = element;\r\n        return false; // return false to stop loop. We only need one doc.\r\n      })\r\n    } else {\r\n      doc = data[0];\r\n    }\r\n    var size = Buffer.byteLength(jsonStringify(doc), 'utf8');\r\n    item.addData(size);\r\n  }\r\n\r\n  return item.getValue();\r\n};\r\n\r\nDocSzCache.prototype.getKey = function (coll, query, opts) {\r\n  return jsonStringify([coll, query, opts]);\r\n};\r\n\r\n// returns a score between 0 and 1 for a cache item\r\n// this score is determined by:\r\n//  * availalbe cache item slots\r\n//  * time since last updated\r\n//  * cpu usage of the application\r\nDocSzCache.prototype.getItemScore = function (item) {\r\n  return [\r\n    (item.maxValues - item.values.length)/item.maxValues,\r\n    (Date.now() - item.updated) / 60000,\r\n    (100 - this.cpuUsage) / 100,\r\n  ].map(function (score) {\r\n    return score > 1 ? 1 : score;\r\n  }).reduce(function (total, score) {\r\n    return (total || 0) + score;\r\n  }) / 3;\r\n};\r\n\r\nDocSzCache.prototype.needsUpdate = function (item) {\r\n  // handle newly made items\r\n  if (!item.values.length) {\r\n    return true;\r\n  }\r\n\r\n  var currentTime = Date.now();\r\n  var timeSinceUpdate = currentTime - item.updated;\r\n  if (timeSinceUpdate > 1000*60) {\r\n    return true;\r\n  }\r\n\r\n  return this.getItemScore(item) > 0.5;\r\n};\r\n\r\n\r\nDocSzCacheItem = function (maxValues) {\r\n  this.maxValues = maxValues;\r\n  this.updated = 0;\r\n  this.values = [];\r\n}\r\n\r\nDocSzCacheItem.prototype.addData = function (value) {\r\n  this.values.push(value);\r\n  this.updated = Date.now();\r\n\r\n  if (this.values.length > this.maxValues) {\r\n    this.values.shift();\r\n  }\r\n};\r\n\r\nDocSzCacheItem.prototype.getValue = function () {\r\n  function sortNumber(a, b) {\r\n    return a - b;\r\n  }\r\n  var sorted = this.values.sort(sortNumber);\r\n  var median = 0;\r\n\r\n  if (sorted.length % 2 === 0) {\r\n    var idx = sorted.length / 2;\r\n    median = (sorted[idx] + sorted[idx-1]) / 2;\r\n  } else {\r\n    var idx = Math.floor(sorted.length / 2);\r\n    median = sorted[idx];\r\n  }\r\n\r\n  return median;\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/kadira.js                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar hostname = Npm.require('os').hostname();\r\nvar logger = Npm.require('debug')('kadira:apm');\r\nvar Fibers = Npm.require('fibers');\r\n\r\nvar KadiraCore = Npm.require('kadira-core').Kadira;\r\n\r\nKadira.models = {};\r\nKadira.options = {};\r\nKadira.env = {\r\n  currentSub: null, // keep current subscription inside ddp\r\n  kadiraInfo: new Meteor.EnvironmentVariable(),\r\n};\r\nKadira.waitTimeBuilder = new WaitTimeBuilder();\r\nKadira.errors = [];\r\nKadira.errors.addFilter = Kadira.errors.push.bind(Kadira.errors);\r\n\r\nKadira.models.methods = new MethodsModel();\r\nKadira.models.pubsub = new PubsubModel();\r\nKadira.models.system = new SystemModel();\r\nKadira.docSzCache = new DocSzCache(100000, 10);\r\n\r\n\r\nKadira.connect = function(appId, appSecret, options) {\r\n  options = options || {};\r\n  options.appId = appId;\r\n  options.appSecret = appSecret;\r\n  options.payloadTimeout = options.payloadTimeout || 1000 * 20;\r\n  options.endpoint = options.endpoint || \"https://enginex.kadira.io\";\r\n  options.clientEngineSyncDelay = options.clientEngineSyncDelay || 10000;\r\n  options.thresholds = options.thresholds || {};\r\n  options.isHostNameSet = !!options.hostname;\r\n  options.hostname = options.hostname || hostname;\r\n  options.proxy = options.proxy || null;\r\n\r\n  if(options.documentSizeCacheSize) {\r\n    Kadira.docSzCache = new DocSzCache(options.documentSizeCacheSize, 10);\r\n  }\r\n\r\n  // remove trailing slash from endpoint url (if any)\r\n  if(_.last(options.endpoint) === '/') {\r\n    options.endpoint = options.endpoint.substr(0, options.endpoint.length - 1);\r\n  }\r\n\r\n  // error tracking is enabled by default\r\n  if(options.enableErrorTracking === undefined) {\r\n    options.enableErrorTracking = true;\r\n  }\r\n\r\n  Kadira.options = options;\r\n  Kadira.options.authHeaders = {\r\n    'KADIRA-APP-ID': Kadira.options.appId,\r\n    'KADIRA-APP-SECRET': Kadira.options.appSecret\r\n  };\r\n\r\n  Kadira.syncedDate = new Ntp(options.endpoint);\r\n  Kadira.syncedDate.sync();\r\n  Kadira.models.error = new ErrorModel(appId);\r\n\r\n  // handle pre-added filters\r\n  var addFilterFn = Kadira.models.error.addFilter.bind(Kadira.models.error);\r\n  Kadira.errors.forEach(addFilterFn);\r\n  Kadira.errors = Kadira.models.error;\r\n\r\n  // setting runtime info, which will be sent to kadira\r\n  __meteor_runtime_config__.kadira = {\r\n    appId: appId,\r\n    endpoint: options.endpoint,\r\n    clientEngineSyncDelay: options.clientEngineSyncDelay,\r\n  };\r\n\r\n  if(options.enableErrorTracking) {\r\n    Kadira.enableErrorTracking();\r\n  } else {\r\n    Kadira.disableErrorTracking();\r\n  }\r\n\r\n  if(appId && appSecret) {\r\n    options.appId = options.appId.trim();\r\n    options.appSecret = options.appSecret.trim();\r\n\r\n    Kadira.coreApi = new KadiraCore({\r\n      appId: options.appId,\r\n      appSecret: options.appSecret,\r\n      endpoint: options.endpoint,\r\n      hostname: options.hostname\r\n    });\r\n\r\n    Kadira.coreApi._checkAuth()\r\n      .then(function() {\r\n        logger('connected to app: ', appId);\r\n        console.log('Kadira: Successfully connected');\r\n        Kadira._sendAppStats();\r\n        Kadira._schedulePayloadSend();\r\n      })\r\n      .catch(function(err) {\r\n        console.log('Kadira: authentication failed - check your appId & appSecret')\r\n      });\r\n  } else {\r\n    throw new Error('Kadira: required appId and appSecret');\r\n  }\r\n\r\n  // start tracking errors\r\n  Meteor.startup(function () {\r\n    TrackUncaughtExceptions();\r\n    TrackMeteorDebug();\r\n  })\r\n\r\n  Meteor.publish(null, function () {\r\n    var options = __meteor_runtime_config__.kadira;\r\n    this.added('kadira_settings', Random.id(), options);\r\n    this.ready();\r\n  });\r\n\r\n  // notify we've connected\r\n  Kadira.connected = true;\r\n};\r\n\r\n//track how many times we've sent the data (once per minute)\r\nKadira._buildPayload = function () {\r\n  var payload = {host: Kadira.options.hostname};\r\n  var buildDetailedInfo = Kadira._isDetailedInfo();\r\n  _.extend(payload, Kadira.models.methods.buildPayload(buildDetailedInfo));\r\n  _.extend(payload, Kadira.models.pubsub.buildPayload(buildDetailedInfo));\r\n  _.extend(payload, Kadira.models.system.buildPayload());\r\n  if(Kadira.options.enableErrorTracking) {\r\n    _.extend(payload, Kadira.models.error.buildPayload());\r\n  }\r\n\r\n  return payload;\r\n}\r\n\r\nKadira._countDataSent = 0;\r\nKadira._detailInfoSentInterval = Math.ceil((1000*60) / Kadira.options.payloadTimeout);\r\nKadira._isDetailedInfo = function () {\r\n  return (Kadira._countDataSent++ % Kadira._detailInfoSentInterval) == 0;\r\n}\r\n\r\nKadira._sendAppStats = function () {\r\n  var appStats = {};\r\n  appStats.release = Meteor.release;\r\n  appStats.protocolVersion = '1.0.0';\r\n  appStats.packageVersions = [];\r\n  appStats.appVersions = {\r\n    webapp: __meteor_runtime_config__['autoupdateVersion'],\r\n    refreshable: __meteor_runtime_config__['autoupdateVersionRefreshable'],\r\n    cordova: __meteor_runtime_config__['autoupdateVersionCordova']\r\n  }\r\n\r\n  // TODO get version number for installed packages\r\n  _.each(Package, function (v, name) {\r\n    appStats.packageVersions.push({name: name, version: null});\r\n  });\r\n\r\n  Kadira.coreApi.sendData({\r\n    startTime: new Date(),\r\n    appStats: appStats\r\n  }).catch(function(err) {\r\n    console.error('Kadira Error on sending appStats:', err.message);\r\n  });\r\n}\r\n\r\nKadira._schedulePayloadSend = function () {\r\n  setTimeout(function () {\r\n    Kadira._sendPayload(Kadira._schedulePayloadSend);\r\n  }, Kadira.options.payloadTimeout);\r\n}\r\n\r\nKadira._sendPayload = function (callback) {\r\n  new Fibers(function() {\r\n    var payload = Kadira._buildPayload();\r\n    Kadira.coreApi.sendData(payload)\r\n    .then(callback)\r\n    .catch(function(err) {\r\n      console.log('Kadira Error:', err.message);\r\n      callback();\r\n    });\r\n  }).run();\r\n}\r\n\r\n// this return the __kadiraInfo from the current Fiber by default\r\n// if called with 2nd argument as true, it will get the kadira info from\r\n// Meteor.EnvironmentVariable\r\n//\r\n// WARNNING: returned info object is the reference object.\r\n//  Changing it might cause issues when building traces. So use with care\r\nKadira._getInfo = function(currentFiber, useEnvironmentVariable) {\r\n  currentFiber = currentFiber || Fibers.current;\r\n  if(currentFiber) {\r\n    if(useEnvironmentVariable) {\r\n      return Kadira.env.kadiraInfo.get();\r\n    }\r\n    return currentFiber.__kadiraInfo;\r\n  }\r\n};\r\n\r\n// this does not clone the info object. So, use with care\r\nKadira._setInfo = function(info) {\r\n  Fibers.current.__kadiraInfo = info;\r\n};\r\n\r\nKadira.enableErrorTracking = function () {\r\n  __meteor_runtime_config__.kadira.enableErrorTracking = true;\r\n  Kadira.options.enableErrorTracking = true;\r\n};\r\n\r\nKadira.disableErrorTracking = function () {\r\n  __meteor_runtime_config__.kadira.enableErrorTracking = false;\r\n  Kadira.options.enableErrorTracking = false;\r\n};\r\n\r\nKadira.trackError = function (type, message, options) {\r\n  if(Kadira.options.enableErrorTracking && type && message) {\r\n    options = options || {};\r\n    options.subType = options.subType || 'server';\r\n    options.stacks = options.stacks || '';\r\n    var error = {message: message, stack: options.stacks};\r\n    var trace = {\r\n      type: type,\r\n      subType: options.subType,\r\n      name: message,\r\n      errored: true,\r\n      at: Kadira.syncedDate.getTime(),\r\n      events: [['start', 0, {}], ['error', 0, {error: error}]],\r\n      metrics: {total: 0}\r\n    };\r\n    Kadira.models.error.trackError(error, trace);\r\n  }\r\n}\r\n\r\nKadira.ignoreErrorTracking = function (err) {\r\n  err._skipKadira = true;\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/wrap_server.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Fiber = Npm.require('fibers');\r\n\r\nwrapServer = function(serverProto) {\r\n  var originalHandleConnect = serverProto._handleConnect\r\n  serverProto._handleConnect = function(socket, msg) {\r\n    originalHandleConnect.call(this, socket, msg);\r\n    var session = socket._meteorSession;\r\n    // sometimes it is possible for _meteorSession to be undefined\r\n    // one such reason would be if DDP versions are not matching\r\n    // if then, we should not process it\r\n    if(!session) {\r\n      return;\r\n    }\r\n\r\n    Kadira.EventBus.emit('system', 'createSession', msg, socket._meteorSession);\r\n\r\n    if(Kadira.connected) {\r\n      Kadira.models.system.handleSessionActivity(msg, socket._meteorSession);\r\n    }\r\n  };\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/wrap_session.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nwrapSession = function(sessionProto) {\r\n  var originalProcessMessage = sessionProto.processMessage;\r\n  sessionProto.processMessage = function(msg) {\r\n    if(true) {\r\n      var kadiraInfo = {\r\n        session: this.id,\r\n        userId: this.userId\r\n      };\r\n\r\n      if(msg.msg == 'method' || msg.msg == 'sub') {\r\n        kadiraInfo.trace = Kadira.tracer.start(this, msg);\r\n        Kadira.waitTimeBuilder.register(this, msg.id);\r\n\r\n        //use JSON stringify to save the CPU\r\n        var startData = { userId: this.userId, params: JSON.stringify(msg.params) };\r\n        Kadira.tracer.event(kadiraInfo.trace, 'start', startData);\r\n        var waitEventId = Kadira.tracer.event(kadiraInfo.trace, 'wait', {}, kadiraInfo);\r\n        msg._waitEventId = waitEventId;\r\n        msg.__kadiraInfo = kadiraInfo;\r\n\r\n        if(msg.msg == 'sub') {\r\n          // start tracking inside processMessage allows us to indicate\r\n          // wait time as well\r\n          Kadira.EventBus.emit('pubsub', 'subReceived', this, msg);\r\n          Kadira.models.pubsub._trackSub(this, msg);\r\n        }\r\n      }\r\n\r\n      // Update session last active time\r\n      Kadira.EventBus.emit('system', 'ddpMessageReceived', this, msg);\r\n      Kadira.models.system.handleSessionActivity(msg, this);\r\n    }\r\n\r\n    return originalProcessMessage.call(this, msg);\r\n  };\r\n\r\n  //adding the method context to the current fiber\r\n  var originalMethodHandler = sessionProto.protocol_handlers.method;\r\n  sessionProto.protocol_handlers.method = function(msg, unblock) {\r\n    var self = this;\r\n    //add context\r\n    var kadiraInfo = msg.__kadiraInfo;\r\n    if(kadiraInfo) {\r\n      Kadira._setInfo(kadiraInfo);\r\n\r\n      // end wait event\r\n      var waitList = Kadira.waitTimeBuilder.build(this, msg.id);\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\r\n\r\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\r\n      var response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\r\n        return originalMethodHandler.call(self, msg, unblock);\r\n      });\r\n      unblock();\r\n    } else {\r\n      var response = originalMethodHandler.call(self, msg, unblock);\r\n    }\r\n\r\n    return response;\r\n  };\r\n\r\n  //to capture the currently processing message\r\n  var orginalSubHandler = sessionProto.protocol_handlers.sub;\r\n  sessionProto.protocol_handlers.sub = function(msg, unblock) {\r\n    var self = this;\r\n    //add context\r\n    var kadiraInfo = msg.__kadiraInfo;\r\n    if(kadiraInfo) {\r\n      Kadira._setInfo(kadiraInfo);\r\n\r\n      // end wait event\r\n      var waitList = Kadira.waitTimeBuilder.build(this, msg.id);\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\r\n\r\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\r\n      var response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\r\n        return orginalSubHandler.call(self, msg, unblock);\r\n      });\r\n      unblock();\r\n    } else {\r\n      var response = orginalSubHandler.call(self, msg, unblock);\r\n    }\r\n\r\n    return response;\r\n  };\r\n\r\n  //to capture the currently processing message\r\n  var orginalUnSubHandler = sessionProto.protocol_handlers.unsub;\r\n  sessionProto.protocol_handlers.unsub = function(msg, unblock) {\r\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\r\n    var response = orginalUnSubHandler.call(this, msg, unblock);\r\n    unblock();\r\n    return response;\r\n  };\r\n\r\n  //track method ending (to get the result of error)\r\n  var originalSend = sessionProto.send;\r\n  sessionProto.send = function(msg) {\r\n    if(msg.msg == 'result') {\r\n      var kadiraInfo = Kadira._getInfo();\r\n      if(kadiraInfo) {\r\n        if(msg.error) {\r\n          var error = _.pick(msg.error, ['message', 'stack']);\r\n\r\n          // pick the error from the wrapped method handler\r\n          if(kadiraInfo && kadiraInfo.currentError) {\r\n            // the error stack is wrapped so Meteor._debug can identify\r\n            // this as a method error.\r\n            error = _.pick(kadiraInfo.currentError, ['message', 'stack']);\r\n            // see wrapMethodHanderForErrors() method def for more info\r\n            if(error.stack && error.stack.stack) {\r\n              error.stack = error.stack.stack;\r\n            }\r\n          }\r\n\r\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\r\n          Kadira.tracer.event(kadiraInfo.trace, 'error', {error: error});\r\n        } else {\r\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\r\n          Kadira.tracer.event(kadiraInfo.trace, 'complete');\r\n        }\r\n\r\n        //processing the message\r\n        var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\r\n        Kadira.EventBus.emit('method', 'methodCompleted', trace, this);\r\n        Kadira.models.methods.processMethod(trace);\r\n\r\n        // error may or may not exist and error tracking can be disabled\r\n        if(error && Kadira.options.enableErrorTracking) {\r\n          Kadira.models.error.trackError(error, trace);\r\n        }\r\n\r\n        //clean and make sure, fiber is clean\r\n        //not sure we need to do this, but a preventive measure\r\n        Kadira._setInfo(null);\r\n      }\r\n    }\r\n\r\n    return originalSend.call(this, msg);\r\n  };\r\n};\r\n\r\n// wrap existing method handlers for capturing errors\r\n_.each(Meteor.default_server.method_handlers, function(handler, name) {\r\n  wrapMethodHanderForErrors(name, handler, Meteor.default_server.method_handlers);\r\n});\r\n\r\n// wrap future method handlers for capturing errors\r\nvar originalMeteorMethods = Meteor.methods;\r\nMeteor.methods = function(methodMap) {\r\n  _.each(methodMap, function(handler, name) {\r\n    wrapMethodHanderForErrors(name, handler, methodMap);\r\n  });\r\n  originalMeteorMethods(methodMap);\r\n};\r\n\r\n\r\nfunction wrapMethodHanderForErrors(name, originalHandler, methodMap) {\r\n  methodMap[name] = function() {\r\n    try{\r\n      return originalHandler.apply(this, arguments);\r\n    } catch(ex) {\r\n      if(ex && Kadira._getInfo()) {\r\n        // sometimes error may be just an string or a primitive\r\n        // in that case, we need to make it a psuedo error\r\n        if(typeof ex !== 'object') {\r\n          ex = {message: ex, stack: ex};\r\n        }\r\n        // Now we are marking this error to get tracked via methods\r\n        // But, this also triggers a Meteor.debug call and \r\n        // it only gets the stack\r\n        // We also track Meteor.debug errors and want to stop \r\n        // tracking this error. That's why we do this\r\n        // See Meteor.debug error tracking code for more\r\n        if (Kadira.options.enableErrorTracking) {\r\n          ex.stack = {stack: ex.stack, source: 'method'};\r\n        }\r\n        Kadira._getInfo().currentError = ex;\r\n      }\r\n      throw ex;\r\n    }\r\n  }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/wrap_subscription.js                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Fiber = Npm.require(\"fibers\");\r\n\r\nwrapSubscription = function(subscriptionProto) {\r\n  // If the ready event runs outside the Fiber, Kadira._getInfo() doesn't work.\r\n  // we need some other way to store kadiraInfo so we can use it at ready hijack.\r\n  var originalRunHandler = subscriptionProto._runHandler;\r\n  subscriptionProto._runHandler = function() {\r\n    var kadiraInfo = Kadira._getInfo();\r\n    if (kadiraInfo) {\r\n      this.__kadiraInfo = kadiraInfo;\r\n    }\r\n    originalRunHandler.call(this);\r\n  };\r\n\r\n  var originalReady = subscriptionProto.ready;\r\n  subscriptionProto.ready = function() {\r\n    // meteor has a field called `_ready` which tracks this\r\n    // but we need to make it future proof\r\n    if (!this._apmReadyTracked) {\r\n      var kadiraInfo = Kadira._getInfo() || this.__kadiraInfo;\r\n      delete this.__kadiraInfo;\r\n      //sometime .ready can be called in the context of the method\r\n      //then we have some problems, that's why we are checking this\r\n      //eg:- Accounts.createUser\r\n      if (kadiraInfo && this._subscriptionId == kadiraInfo.trace.id) {\r\n        Kadira.tracer.endLastEvent(kadiraInfo.trace);\r\n        Kadira.tracer.event(kadiraInfo.trace, \"complete\");\r\n        var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\r\n      }\r\n\r\n      Kadira.EventBus.emit(\r\n        \"pubsub\",\r\n        \"subCompleted\",\r\n        trace,\r\n        this._session,\r\n        this\r\n      );\r\n      Kadira.models.pubsub._trackReady(this._session, this, trace);\r\n      this._apmReadyTracked = true;\r\n    }\r\n\r\n    // we still pass the control to the original implementation\r\n    // since multiple ready calls are handled by itself\r\n    originalReady.call(this);\r\n  };\r\n\r\n  var originalError = subscriptionProto.error;\r\n  subscriptionProto.error = function(err) {\r\n    if (typeof err === \"string\") {\r\n      err = { message: err };\r\n    }\r\n\r\n    var kadiraInfo = Kadira._getInfo();\r\n\r\n    if (kadiraInfo && this._subscriptionId == kadiraInfo.trace.id) {\r\n      Kadira.tracer.endLastEvent(kadiraInfo.trace);\r\n\r\n      var errorForApm = _.pick(err, \"message\", \"stack\");\r\n      Kadira.tracer.event(kadiraInfo.trace, \"error\", { error: errorForApm });\r\n      var trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\r\n\r\n      Kadira.models.pubsub._trackError(this._session, this, trace);\r\n\r\n      // error tracking can be disabled and if there is a trace\r\n      // trace should be avaialble all the time, but it won't\r\n      // if something wrong happened on the trace building\r\n      if (Kadira.options.enableErrorTracking && trace) {\r\n        Kadira.models.error.trackError(err, trace);\r\n      }\r\n    }\r\n\r\n    // wrap error stack so Meteor._debug can identify and ignore it\r\n    if (Kadira.options.enableErrorTracking) {\r\n      err.stack = { stack: err.stack, source: \"subscription\" };\r\n    }\r\n    originalError.call(this, err);\r\n  };\r\n\r\n  var originalDeactivate = subscriptionProto._deactivate;\r\n  subscriptionProto._deactivate = function() {\r\n    Kadira.EventBus.emit(\"pubsub\", \"subDeactivated\", this._session, this);\r\n    Kadira.models.pubsub._trackUnsub(this._session, this);\r\n    originalDeactivate.call(this);\r\n  };\r\n\r\n  //adding the currenSub env variable\r\n  [\"added\", \"changed\", \"removed\"].forEach(function(funcName) {\r\n    var originalFunc = subscriptionProto[funcName];\r\n    subscriptionProto[funcName] = function(collectionName, id, fields) {\r\n      var self = this;\r\n\r\n      // we need to run this code in a fiber and that's how we track\r\n      // subscription info. May be we can figure out, some other way to do this\r\n      // We use this currently to get the publication info when tracking message\r\n      // sizes at wrap_ddp_stringify.js\r\n      Kadira.env.currentSub = self;\r\n      var res = originalFunc.call(self, collectionName, id, fields);\r\n      Kadira.env.currentSub = null;\r\n\r\n      return res;\r\n    };\r\n  });\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/wrap_observers.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nwrapOplogObserveDriver = function(proto) {\r\n  // Track the polled documents. This is reflect to the RAM size and\r\n  // for the CPU usage directly\r\n  var originalPublishNewResults = proto._publishNewResults;\r\n  proto._publishNewResults = function(newResults, newBuffer) {\r\n    var coll = this._cursorDescription.collectionName;\r\n    var query = this._cursorDescription.selector;\r\n    var opts = this._cursorDescription.options;\r\n    var docSize = Kadira.docSzCache.getSize(coll, query, opts, newResults);\r\n    var docSize = Kadira.docSzCache.getSize(coll, query, opts, newBuffer);\r\n    var count = newResults.size() + newBuffer.size();\r\n    if(this._ownerInfo) {\r\n      Kadira.models.pubsub.trackPolledDocuments(this._ownerInfo, count);\r\n      Kadira.models.pubsub.trackDocSize(this._ownerInfo.name, \"polledFetches\", docSize*count);\r\n    } else {\r\n      this._polledDocuments = count;\r\n      this._docSize = {\r\n        polledFetches: docSize*count\r\n      }\r\n    }\r\n    return originalPublishNewResults.call(this, newResults, newBuffer);\r\n  };\r\n\r\n  var originalHandleOplogEntryQuerying = proto._handleOplogEntryQuerying;\r\n  proto._handleOplogEntryQuerying = function(op) {\r\n    Kadira.models.pubsub.trackDocumentChanges(this._ownerInfo, op);\r\n    return originalHandleOplogEntryQuerying.call(this, op);\r\n  };\r\n\r\n  var originalHandleOplogEntrySteadyOrFetching = proto._handleOplogEntrySteadyOrFetching;\r\n  proto._handleOplogEntrySteadyOrFetching = function(op) {\r\n    Kadira.models.pubsub.trackDocumentChanges(this._ownerInfo, op);\r\n    return originalHandleOplogEntrySteadyOrFetching.call(this, op);\r\n  };\r\n\r\n  // track live updates\r\n  ['_addPublished', '_removePublished', '_changePublished'].forEach(function(fnName) {\r\n    var originalFn = proto[fnName];\r\n    proto[fnName] = function(a, b, c) {\r\n      if(this._ownerInfo) {\r\n        Kadira.models.pubsub.trackLiveUpdates(this._ownerInfo, fnName, 1);\r\n\r\n        if(fnName === \"_addPublished\") {\r\n          var coll = this._cursorDescription.collectionName;\r\n          var query = this._cursorDescription.selector;\r\n          var opts = this._cursorDescription.options;\r\n          var docSize = Kadira.docSzCache.getSize(coll, query, opts, [b]);\r\n\r\n          Kadira.models.pubsub.trackDocSize(this._ownerInfo.name, \"liveFetches\", docSize);\r\n        }\r\n      } else {\r\n        // If there is no ownerInfo, that means this is the initial adds\r\n        if(!this._liveUpdatesCounts) {\r\n          this._liveUpdatesCounts = {\r\n            _initialAdds: 0\r\n          };\r\n        }\r\n\r\n        this._liveUpdatesCounts._initialAdds++;\r\n\r\n        if(fnName === \"_addPublished\") {\r\n          if(!this._docSize) {\r\n            this._docSize = {\r\n              initialFetches: 0\r\n            };\r\n          }\r\n\r\n          if(!this._docSize.initialFetches) {\r\n            this._docSize.initialFetches = 0;\r\n          }\r\n\r\n          var coll = this._cursorDescription.collectionName;\r\n          var query = this._cursorDescription.selector;\r\n          var opts = this._cursorDescription.options;\r\n          var docSize = Kadira.docSzCache.getSize(coll, query, opts, [b]);\r\n\r\n          this._docSize.initialFetches += docSize;\r\n        }\r\n      }\r\n\r\n      return originalFn.call(this, a, b, c);\r\n    };\r\n  });\r\n\r\n  var originalStop = proto.stop;\r\n  proto.stop = function() {\r\n    if(this._ownerInfo && this._ownerInfo.type === 'sub') {\r\n      Kadira.EventBus.emit('pubsub', 'observerDeleted', this._ownerInfo);\r\n      Kadira.models.pubsub.trackDeletedObserver(this._ownerInfo);\r\n    }\r\n\r\n    return originalStop.call(this);\r\n  };\r\n};\r\n\r\nwrapPollingObserveDriver = function(proto) {\r\n  var originalPollMongo = proto._pollMongo;\r\n  proto._pollMongo = function() {\r\n    var start = Date.now();\r\n    originalPollMongo.call(this);\r\n\r\n    // Current result is stored in the following variable.\r\n    // So, we can use that\r\n    // Sometimes, it's possible to get size as undefined.\r\n    // May be something with different version. We don't need to worry about\r\n    // this now\r\n    var count = 0;\r\n    var docSize = 0;\r\n\r\n    if(this._results && this._results.size) {\r\n      count = this._results.size() || 0;\r\n\r\n      var coll = this._cursorDescription.collectionName;\r\n      var query = this._cursorDescription.selector;\r\n      var opts = this._cursorDescription.options;\r\n\r\n      docSize = Kadira.docSzCache.getSize(coll, query, opts, this._results._map)*count;\r\n    }\r\n\r\n    if(this._ownerInfo) {\r\n      Kadira.models.pubsub.trackPolledDocuments(this._ownerInfo, count);\r\n      Kadira.models.pubsub.trackDocSize(this._ownerInfo.name, \"polledFetches\", docSize);\r\n    } else {\r\n      this._polledDocuments = count;\r\n      this._polledDocSize = docSize;\r\n    }\r\n  };\r\n\r\n  var originalStop = proto.stop;\r\n  proto.stop = function() {\r\n    if(this._ownerInfo && this._ownerInfo.type === 'sub') {\r\n      Kadira.EventBus.emit('pubsub', 'observerDeleted', this._ownerInfo);\r\n      Kadira.models.pubsub.trackDeletedObserver(this._ownerInfo);\r\n    }\r\n\r\n    return originalStop.call(this);\r\n  };\r\n};\r\n\r\nwrapMultiplexer = function(proto) {\r\n  var originalInitalAdd = proto.addHandleAndSendInitialAdds;\r\n   proto.addHandleAndSendInitialAdds = function(handle) {\r\n    if(!this._firstInitialAddTime) {\r\n      this._firstInitialAddTime = Date.now();\r\n    }\r\n\r\n    handle._wasMultiplexerReady = this._ready();\r\n    handle._queueLength = this._queue._taskHandles.length;\r\n\r\n    if(!handle._wasMultiplexerReady) {\r\n      handle._elapsedPollingTime = Date.now() - this._firstInitialAddTime;\r\n    }\r\n    return originalInitalAdd.call(this, handle);\r\n  };\r\n};\r\n\r\nwrapForCountingObservers = function() {\r\n  // to count observers\r\n  var mongoConnectionProto = MeteorX.MongoConnection.prototype;\r\n  var originalObserveChanges = mongoConnectionProto._observeChanges;\r\n  mongoConnectionProto._observeChanges = function(cursorDescription, ordered, callbacks) {\r\n    var ret = originalObserveChanges.call(this, cursorDescription, ordered, callbacks);\r\n    // get the Kadira Info via the Meteor.EnvironmentalVariable\r\n    var kadiraInfo = Kadira._getInfo(null, true);\r\n\r\n    if(kadiraInfo && ret._multiplexer) {\r\n      if(!ret._multiplexer.__kadiraTracked) {\r\n        // new multiplexer\r\n        ret._multiplexer.__kadiraTracked = true;\r\n        Kadira.EventBus.emit('pubsub', 'newSubHandleCreated', kadiraInfo.trace);\r\n        Kadira.models.pubsub.incrementHandleCount(kadiraInfo.trace, false);\r\n        if(kadiraInfo.trace.type == 'sub') {\r\n          var ownerInfo = {\r\n            type: kadiraInfo.trace.type,\r\n            name: kadiraInfo.trace.name,\r\n            startTime: (new Date()).getTime()\r\n          };\r\n\r\n          var observerDriver = ret._multiplexer._observeDriver;\r\n          observerDriver._ownerInfo = ownerInfo;\r\n          Kadira.EventBus.emit('pubsub', 'observerCreated', ownerInfo);\r\n          Kadira.models.pubsub.trackCreatedObserver(ownerInfo);\r\n\r\n          // We need to send initially polled documents if there are\r\n          if(observerDriver._polledDocuments) {\r\n            Kadira.models.pubsub.trackPolledDocuments(ownerInfo, observerDriver._polledDocuments);\r\n            observerDriver._polledDocuments = 0;\r\n          }\r\n\r\n          // We need to send initially polled documents if there are\r\n          if(observerDriver._polledDocSize) {\r\n            Kadira.models.pubsub.trackDocSize(ownerInfo.name, \"polledFetches\", observerDriver._polledDocSize);\r\n            observerDriver._polledDocSize = 0;\r\n          }\r\n\r\n          // Process _liveUpdatesCounts\r\n          _.each(observerDriver._liveUpdatesCounts, function(count, key) {\r\n            Kadira.models.pubsub.trackLiveUpdates(ownerInfo, key, count);\r\n          });\r\n\r\n          // Process docSize\r\n          _.each(observerDriver._docSize, function(count, key) {\r\n            Kadira.models.pubsub.trackDocSize(ownerInfo.name, key, count);\r\n          });\r\n        }\r\n      } else {\r\n        Kadira.EventBus.emit('pubsub', 'cachedSubHandleCreated', kadiraInfo.trace);\r\n        Kadira.models.pubsub.incrementHandleCount(kadiraInfo.trace, true);\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/wrap_ddp_stringify.js                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nwrapStringifyDDP = function() {\r\n  var originalStringifyDDP = DDPCommon.stringifyDDP;\r\n\r\n  DDPCommon.stringifyDDP = function(msg) {\r\n    var msgString = originalStringifyDDP(msg);\r\n    var msgSize = Buffer.byteLength(msgString, 'utf8');\r\n\r\n    var kadiraInfo = Kadira._getInfo(null, true);\r\n\r\n    if(kadiraInfo) {\r\n      if(kadiraInfo.trace.type === 'method') {\r\n        Kadira.models.methods.trackMsgSize(kadiraInfo.trace.name, msgSize);\r\n      }\r\n\r\n      return msgString;\r\n    }\r\n\r\n    // 'currentSub' is set when we wrap Subscription object and override\r\n    // handlers for 'added', 'changed', 'removed' events. (see lib/hijack/wrap_subscription.js)\r\n    if(Kadira.env.currentSub) {\r\n      if(Kadira.env.currentSub.__kadiraInfo){\r\n        Kadira.models.pubsub.trackMsgSize(Kadira.env.currentSub._name, \"initialSent\", msgSize);\r\n        return msgString;\r\n      }\r\n      Kadira.models.pubsub.trackMsgSize(Kadira.env.currentSub._name, \"liveSent\", msgSize);\r\n      return msgString;\r\n    }\r\n\r\n    Kadira.models.methods.trackMsgSize(\"<not-a-method-or-a-pub>\", msgSize);\r\n    return msgString;\r\n  }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/instrument.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar logger = Npm.require('debug')('kadira:hijack:instrument');\r\n\r\nvar instrumented = false;\r\nKadira._startInstrumenting = function(callback) {\r\n  if(instrumented) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  instrumented = true;\r\n  wrapStringifyDDP()\r\n  MeteorX.onReady(function() {\r\n    //instrumenting session\r\n    wrapServer(MeteorX.Server.prototype);\r\n    wrapSession(MeteorX.Session.prototype);\r\n    wrapSubscription(MeteorX.Subscription.prototype);\r\n\r\n    if(MeteorX.MongoOplogDriver) {\r\n      wrapOplogObserveDriver(MeteorX.MongoOplogDriver.prototype);\r\n    }\r\n\r\n    if(MeteorX.MongoPollingDriver) {\r\n      wrapPollingObserveDriver(MeteorX.MongoPollingDriver.prototype);\r\n    }\r\n\r\n    if(MeteorX.Multiplexer) {\r\n      wrapMultiplexer(MeteorX.Multiplexer.prototype);\r\n    }\r\n\r\n    wrapForCountingObservers();\r\n    hijackDBOps();\r\n\r\n    setLabels();\r\n    callback();\r\n  });\r\n};\r\n\r\n// We need to instrument this rightaway and it's okay\r\n// One reason for this is to call `setLables()` function\r\n// Otherwise, CPU profile can't see all our custom labeling\r\nKadira._startInstrumenting(function() {\r\n  console.log('Kadira: completed instrumenting the app')\r\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/db.js                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n// This hijack is important to make sure, collections created before\r\n// we hijack dbOps, even gets tracked.\r\n//  Meteor does not simply expose MongoConnection object to the client\r\n//  It picks methods which are necessory and make a binded object and\r\n//  assigned to the Mongo.Collection\r\n//  so, even we updated prototype, we can't track those collections\r\n//  but, this will fix it.\r\nvar originalOpen = MongoInternals.RemoteCollectionDriver.prototype.open;\r\nMongoInternals.RemoteCollectionDriver.prototype.open = function open(name) {\r\n  var self = this;\r\n  var ret = originalOpen.call(self, name);\r\n\r\n  _.each(ret, function(fn, m) {\r\n    // make sure, it's in the actual mongo connection object\r\n    // meteorhacks:mongo-collection-utils package add some arbitary methods\r\n    // which does not exist in the mongo connection\r\n    if(self.mongo[m]) {\r\n      ret[m] = function() {\r\n        Array.prototype.unshift.call(arguments, name);\r\n        return OptimizedApply(self.mongo, self.mongo[m], arguments);\r\n      };\r\n    }\r\n  });\r\n\r\n  return ret;\r\n};\r\n\r\nhijackDBOps = function hijackDBOps() {\r\n  var mongoConnectionProto = MeteorX.MongoConnection.prototype;\r\n  //findOne is handled by find - so no need to track it\r\n  //upsert is handles by update\r\n  ['find', 'update', 'remove', 'insert', '_ensureIndex', '_dropIndex'].forEach(function(func) {\r\n    var originalFunc = mongoConnectionProto[func];\r\n    mongoConnectionProto[func] = function(collName, selector, mod, options) {\r\n      var payload = {\r\n        coll: collName,\r\n        func: func,\r\n      };\r\n\r\n      if(func == 'insert') {\r\n        //add nothing more to the payload\r\n      } else if(func == '_ensureIndex' || func == '_dropIndex') {\r\n        //add index\r\n        payload.index = JSON.stringify(selector);\r\n      } else if(func == 'update' && options && options.upsert) {\r\n        payload.func = 'upsert';\r\n        payload.selector = JSON.stringify(selector);\r\n      } else {\r\n        //all the other functions have selectors\r\n        payload.selector = JSON.stringify(selector);\r\n      }\r\n\r\n      var kadiraInfo = Kadira._getInfo();\r\n      if(kadiraInfo) {\r\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\r\n      }\r\n\r\n      //this cause V8 to avoid any performance optimizations, but this is must to use\r\n      //otherwise, if the error adds try catch block our logs get messy and didn't work\r\n      //see: issue #6\r\n      try{\r\n        var ret = originalFunc.apply(this, arguments);\r\n        //handling functions which can be triggered with an asyncCallback\r\n        var endOptions = {};\r\n\r\n        if(HaveAsyncCallback(arguments)) {\r\n          endOptions.async = true;\r\n        }\r\n\r\n        if(func == 'update') {\r\n          // upsert only returns an object when called `upsert` directly\r\n          // otherwise it only act an update command\r\n          if(options && options.upsert && typeof ret == 'object') {\r\n            endOptions.updatedDocs = ret.numberAffected;\r\n            endOptions.insertedId = ret.insertedId;\r\n          } else {\r\n            endOptions.updatedDocs = ret;\r\n          }\r\n        } else if(func == 'remove') {\r\n          endOptions.removedDocs = ret;\r\n        }\r\n\r\n        if(eventId) {\r\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\r\n        }\r\n      } catch(ex) {\r\n        if(eventId) {\r\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\r\n        }\r\n        throw ex;\r\n      }\r\n\r\n      return ret;\r\n    };\r\n  });\r\n\r\n  var cursorProto = MeteorX.MongoCursor.prototype;\r\n  ['forEach', 'map', 'fetch', 'count', 'observeChanges', 'observe', 'rewind'].forEach(function(type) {\r\n    var originalFunc = cursorProto[type];\r\n    cursorProto[type] = function() {\r\n      var cursorDescription = this._cursorDescription;\r\n      var payload = Object.assign(Object.create(null), {\r\n        coll: cursorDescription.collectionName,\r\n        selector: JSON.stringify(cursorDescription.selector),\r\n        func: type,\r\n        cursor: true\r\n      });\r\n\r\n      if(cursorDescription.options) {\r\n        var cursorOptions = _.pick(cursorDescription.options, ['fields', 'sort', 'limit']);\r\n        for(var field in cursorOptions) {\r\n          var value = cursorOptions[field]\r\n          if(typeof value == 'object') {\r\n            value = JSON.stringify(value);\r\n          }\r\n          payload[field] = value;\r\n        }\r\n      };\r\n\r\n      var kadiraInfo = Kadira._getInfo();\r\n      if(kadiraInfo) {\r\n        var eventId = Kadira.tracer.event(kadiraInfo.trace, 'db', payload);\r\n      }\r\n\r\n      try{\r\n        var ret = originalFunc.apply(this, arguments);\r\n\r\n        var endData = {};\r\n        if(type == 'observeChanges' || type == 'observe') {\r\n          var observerDriver;\r\n          endData.oplog = false;\r\n          // get data written by the multiplexer\r\n          endData.wasMultiplexerReady = ret._wasMultiplexerReady;\r\n          endData.queueLength = ret._queueLength;\r\n          endData.elapsedPollingTime = ret._elapsedPollingTime;\r\n\r\n          if(ret._multiplexer) {\r\n            // older meteor versions done not have an _multiplexer value\r\n            observerDriver = ret._multiplexer._observeDriver;\r\n            if(observerDriver) {\r\n              observerDriver = ret._multiplexer._observeDriver;\r\n              var observerDriverClass = observerDriver.constructor;\r\n              var usesOplog = typeof observerDriverClass.cursorSupported == 'function';\r\n              endData.oplog = usesOplog;\r\n              var size = 0;\r\n              ret._multiplexer._cache.docs.forEach(function() {size++});\r\n              endData.noOfCachedDocs = size;\r\n\r\n              // if multiplexerWasNotReady, we need to get the time spend for the polling\r\n              if(!ret._wasMultiplexerReady) {\r\n                endData.initialPollingTime = observerDriver._lastPollTime;\r\n              }\r\n            }\r\n          }\r\n\r\n          if(!endData.oplog) {\r\n            // let's try to find the reason\r\n            var reasonInfo = Kadira.checkWhyNoOplog(cursorDescription, observerDriver);\r\n            endData.noOplogCode = reasonInfo.code;\r\n            endData.noOplogReason = reasonInfo.reason;\r\n            endData.noOplogSolution = reasonInfo.solution;\r\n          }\r\n        } else if(type == 'fetch' || type == 'map'){\r\n          //for other cursor operation\r\n\r\n          endData.docsFetched = ret.length;\r\n\r\n          if(type == 'fetch') {\r\n            var coll = cursorDescription.collectionName;\r\n            var query = cursorDescription.selector;\r\n            var opts = cursorDescription.options;\r\n            var docSize = Kadira.docSzCache.getSize(coll, query, opts, ret) * ret.length;\r\n            endData.docSize = docSize;\r\n\r\n            if(kadiraInfo) {\r\n              if(kadiraInfo.trace.type === 'method') {\r\n                Kadira.models.methods.trackDocSize(kadiraInfo.trace.name, docSize);\r\n              } else if(kadiraInfo.trace.type === 'sub') {\r\n                Kadira.models.pubsub.trackDocSize(kadiraInfo.trace.name, \"cursorFetches\", docSize);\r\n              }\r\n            } else {\r\n              // Fetch with no kadira info are tracked as from a null method\r\n              Kadira.models.methods.trackDocSize(\"<not-a-method-or-a-pub>\", docSize);\r\n            }\r\n\r\n            // TODO: Add doc size tracking to `map` as well.\r\n          }\r\n        }\r\n\r\n        if(eventId) {\r\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endData);\r\n        }\r\n        return ret;\r\n      } catch(ex) {\r\n        if(eventId) {\r\n          Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\r\n        }\r\n        throw ex;\r\n      }\r\n    };\r\n  });\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/http.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar originalCall = HTTP.call;\r\n\r\nHTTP.call = function(method, url) {\r\n  var kadiraInfo = Kadira._getInfo();\r\n  if(kadiraInfo) {\r\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'http', {method: method, url: url});\r\n  }\r\n\r\n  try {\r\n    var response = originalCall.apply(this, arguments);\r\n\r\n    //if the user supplied an asynCallback, we don't have a response object and it handled asynchronously\r\n    //we need to track it down to prevent issues like: #3\r\n    var endOptions = HaveAsyncCallback(arguments)? {async: true}: {statusCode: response.statusCode};\r\n    if(eventId) {\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, endOptions);\r\n    }\r\n    return response;\r\n  } catch(ex) {\r\n    if(eventId) {\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\r\n    }\r\n    throw ex;\r\n  }\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/email.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar originalSend = Email.send;\r\n\r\nEmail.send = function(options) {\r\n  var kadiraInfo = Kadira._getInfo();\r\n  if(kadiraInfo) {\r\n    var data = _.pick(options, 'from', 'to', 'cc', 'bcc', 'replyTo');\r\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'email', data);\r\n  }\r\n  try {\r\n    var ret = originalSend.call(this, options);\r\n    if(eventId) {\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId);\r\n    }\r\n    return ret;\r\n  } catch(ex) {\r\n    if(eventId) {\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, eventId, {err: ex.message});\r\n    }\r\n    throw ex;\r\n  }\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/async.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar Fibers = Npm.require('fibers');\r\n\r\nvar originalYield = Fibers.yield;\r\nFibers.yield = function() {\r\n  var kadiraInfo = Kadira._getInfo();\r\n  if(kadiraInfo) {\r\n    var eventId = Kadira.tracer.event(kadiraInfo.trace, 'async');;\r\n    if(eventId) {\r\n      Fibers.current._apmEventId = eventId;\r\n    }\r\n  }\r\n\r\n  return originalYield();\r\n};\r\n\r\nvar originalRun = Fibers.prototype.run;\r\nFibers.prototype.run = function(val) {\r\n  if(this._apmEventId) {\r\n    var kadiraInfo = Kadira._getInfo(this);\r\n    if(kadiraInfo) {\r\n      Kadira.tracer.eventEnd(kadiraInfo.trace, this._apmEventId);\r\n      this._apmEventId = null;\r\n    }\r\n  }\r\n  return originalRun.call(this, val);\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/error.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nTrackUncaughtExceptions = function () {\r\n  process.on('uncaughtException', function (err) {\r\n    // skip errors with `_skipKadira` flag\r\n    if(err._skipKadira) {\r\n      return;\r\n    }\r\n\r\n    // let the server crash normally if error tracking is disabled\r\n    if(!Kadira.options.enableErrorTracking) {\r\n      printErrorAndKill(err);\r\n    }\r\n\r\n    // looking for already tracked errors and throw them immediately\r\n    // throw error immediately if kadira is not ready\r\n    if(err._tracked || !Kadira.connected) {\r\n      printErrorAndKill(err);\r\n    }\r\n\r\n    var trace = getTrace(err, 'server-crash', 'uncaughtException');\r\n    Kadira.models.error.trackError(err, trace);\r\n    Kadira._sendPayload(function () {\r\n      clearTimeout(timer);\r\n      throwError(err);\r\n    });\r\n\r\n    var timer = setTimeout(function () {\r\n      throwError(err);\r\n    }, 1000*10);\r\n\r\n    function throwError(err) {\r\n      // sometimes error came back from a fiber.\r\n      // But we don't fibers to track that error for us\r\n      // That's why we throw the error on the nextTick\r\n      process.nextTick(function() {\r\n        // we need to mark this error where we really need to throw\r\n        err._tracked = true;\r\n        printErrorAndKill(err);\r\n      });\r\n    }\r\n  });\r\n\r\n  function printErrorAndKill(err) {\r\n    // since we are capturing error, we are also on the error message.\r\n    // so developers think we are also reponsible for the error.\r\n    // But we are not. This will fix that.\r\n    console.error(err.stack);\r\n    process.exit(7);\r\n  }\r\n}\r\n\r\nTrackMeteorDebug = function () {\r\n  var originalMeteorDebug = Meteor._debug;\r\n  Meteor._debug = function (message, stack) {\r\n    if(!Kadira.options.enableErrorTracking) {\r\n      return originalMeteorDebug.call(this, message, stack);\r\n    }\r\n\r\n    // We've changed `stack` into an object at method and sub handlers so we can\r\n    // ignore them here. These errors are already tracked so don't track again.\r\n    if(stack && stack.stack) {\r\n      stack = stack.stack;\r\n      // Restore so origionalMeteorDebug shows the stack as a string instead as an object\r\n      arguments[1] = stack;\r\n    } else {\r\n      // only send to the server, if only connected to kadira\r\n      if(Kadira.connected) {\r\n        var error = new Error(message);\r\n        error.stack = stack;\r\n        var trace = getTrace(error, 'server-internal', 'Meteor._debug');\r\n        Kadira.models.error.trackError(error, trace);\r\n      }\r\n    }\r\n\r\n    return originalMeteorDebug.apply(this, arguments);\r\n  }\r\n}\r\n\r\nfunction getTrace(err, type, subType) {\r\n  return {\r\n    type: type,\r\n    subType: subType,\r\n    name: err.message,\r\n    errored: true,\r\n    at: Kadira.syncedDate.getTime(),\r\n    events: [\r\n      ['start', 0, {}],\r\n      ['error', 0, {error: {message: err.message, stack: err.stack}}]\r\n    ],\r\n    metrics: {\r\n      total: 0\r\n    }\r\n  };\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/hijack/set_labels.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nsetLabels = function () {\r\n  // name Session.prototype.send\r\n  var originalSend = MeteorX.Session.prototype.send;\r\n  MeteorX.Session.prototype.send = function kadira_Session_send (msg) {\r\n    return originalSend.call(this, msg);\r\n  }\r\n\r\n  // name Multiplexer initial adds\r\n  var originalSendAdds = MeteorX.Multiplexer.prototype._sendAdds;\r\n  MeteorX.Multiplexer.prototype._sendAdds = function kadira_Multiplexer_sendAdds (handle) {\r\n    return originalSendAdds.call(this, handle);\r\n  }\r\n\r\n  // name MongoConnection insert\r\n  var originalMongoInsert = MeteorX.MongoConnection.prototype._insert;\r\n  MeteorX.MongoConnection.prototype._insert = function kadira_MongoConnection_insert (coll, doc, cb) {\r\n    return originalMongoInsert.call(this, coll, doc, cb);\r\n  }\r\n\r\n  // name MongoConnection update\r\n  var originalMongoUpdate = MeteorX.MongoConnection.prototype._update;\r\n  MeteorX.MongoConnection.prototype._update = function kadira_MongoConnection_update (coll, selector, mod, options, cb) {\r\n    return originalMongoUpdate.call(this, coll, selector, mod, options, cb);\r\n  }\r\n\r\n  // name MongoConnection remove\r\n  var originalMongoRemove = MeteorX.MongoConnection.prototype._remove;\r\n  MeteorX.MongoConnection.prototype._remove = function kadira_MongoConnection_remove (coll, selector, cb) {\r\n    return originalMongoRemove.call(this, coll, selector, cb);\r\n  }\r\n\r\n  // name Pubsub added\r\n  var originalPubsubAdded = MeteorX.Session.prototype.sendAdded;\r\n  MeteorX.Session.prototype.sendAdded = function kadira_Session_sendAdded (coll, id, fields) {\r\n    return originalPubsubAdded.call(this, coll, id, fields);\r\n  }\r\n\r\n  // name Pubsub changed\r\n  var originalPubsubChanged = MeteorX.Session.prototype.sendChanged;\r\n  MeteorX.Session.prototype.sendChanged = function kadira_Session_sendChanged (coll, id, fields) {\r\n    return originalPubsubChanged.call(this, coll, id, fields);\r\n  }\r\n\r\n  // name Pubsub removed\r\n  var originalPubsubRemoved = MeteorX.Session.prototype.sendRemoved;\r\n  MeteorX.Session.prototype.sendRemoved = function kadira_Session_sendRemoved (coll, id) {\r\n    return originalPubsubRemoved.call(this, coll, id);\r\n  }\r\n\r\n  // name MongoCursor forEach\r\n  var originalCursorForEach = MeteorX.MongoCursor.prototype.forEach;\r\n  MeteorX.MongoCursor.prototype.forEach = function kadira_Cursor_forEach () {\r\n    return originalCursorForEach.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor map\r\n  var originalCursorMap = MeteorX.MongoCursor.prototype.map;\r\n  MeteorX.MongoCursor.prototype.map = function kadira_Cursor_map () {\r\n    return originalCursorMap.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor fetch\r\n  var originalCursorFetch = MeteorX.MongoCursor.prototype.fetch;\r\n  MeteorX.MongoCursor.prototype.fetch = function kadira_Cursor_fetch () {\r\n    return originalCursorFetch.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor count\r\n  var originalCursorCount = MeteorX.MongoCursor.prototype.count;\r\n  MeteorX.MongoCursor.prototype.count = function kadira_Cursor_count () {\r\n    return originalCursorCount.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor observeChanges\r\n  var originalCursorObserveChanges = MeteorX.MongoCursor.prototype.observeChanges;\r\n  MeteorX.MongoCursor.prototype.observeChanges = function kadira_Cursor_observeChanges () {\r\n    return originalCursorObserveChanges.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor observe\r\n  var originalCursorObserve = MeteorX.MongoCursor.prototype.observe;\r\n  MeteorX.MongoCursor.prototype.observe = function kadira_Cursor_observe () {\r\n    return originalCursorObserve.apply(this, arguments);\r\n  }\r\n\r\n  // name MongoCursor rewind\r\n  var originalCursorRewind = MeteorX.MongoCursor.prototype.rewind;\r\n  MeteorX.MongoCursor.prototype.rewind = function kadira_Cursor_rewind () {\r\n    return originalCursorRewind.apply(this, arguments);\r\n  }\r\n\r\n  // name CrossBar listen\r\n  var originalCrossbarListen = DDPServer._Crossbar.prototype.listen;\r\n  DDPServer._Crossbar.prototype.listen = function kadira_Crossbar_listen (trigger, callback) {\r\n    return originalCrossbarListen.call(this, trigger, callback);\r\n  }\r\n\r\n  // name CrossBar fire\r\n  var originalCrossbarFire = DDPServer._Crossbar.prototype.fire;\r\n  DDPServer._Crossbar.prototype.fire = function kadira_Crossbar_fire (notification) {\r\n    return originalCrossbarFire.call(this, notification);\r\n  }\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/environment_variables.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nKadira._parseEnv = function (env) {\r\n  var options = {};\r\n  for(var name in env) {\r\n    var info = Kadira._parseEnv._options[name];\r\n    var value = env[name];\r\n    if(info && value) {\r\n      options[info.name] = info.parser(value);\r\n    }\r\n  }\r\n\r\n  return options;\r\n};\r\n\r\n\r\nKadira._parseEnv.parseInt = function (str) {\r\n  var num = parseInt(str);\r\n  if(num || num === 0) return num;\r\n  throw new Error('Kadira: Match Error: \"'+num+'\" is not a number');\r\n};\r\n\r\n\r\nKadira._parseEnv.parseBool = function (str) {\r\n  str = str.toLowerCase();\r\n  if(str === 'true') return true;\r\n  if(str === 'false') return false;\r\n  throw new Error('Kadira: Match Error: '+str+' is not a boolean');\r\n};\r\n\r\n\r\nKadira._parseEnv.parseUrl = function (str) {\r\n  return str;\r\n};\r\n\r\n\r\nKadira._parseEnv.parseString = function (str) {\r\n  return str;\r\n};\r\n\r\n\r\nKadira._parseEnv._options = {\r\n  // delay to send the initial ping to the kadira engine after page loads\r\n  KADIRA_OPTIONS_CLIENT_ENGINE_SYNC_DELAY: {\r\n    name: 'clientEngineSyncDelay',\r\n    parser: Kadira._parseEnv.parseInt,\r\n  },\r\n  // time between sending errors to the engine\r\n  KADIRA_OPTIONS_ERROR_DUMP_INTERVAL: {\r\n    name: 'errorDumpInterval',\r\n    parser: Kadira._parseEnv.parseInt,\r\n  },\r\n  // no of errors allowed in a given interval\r\n  KADIRA_OPTIONS_MAX_ERRORS_PER_INTERVAL: {\r\n    name: 'maxErrorsPerInterval',\r\n    parser: Kadira._parseEnv.parseInt,\r\n  },\r\n  // a zone.js specific option to collect the full stack trace(which is not much useful)\r\n  KADIRA_OPTIONS_COLLECT_ALL_STACKS: {\r\n    name: 'collectAllStacks',\r\n    parser: Kadira._parseEnv.parseBool,\r\n  },\r\n  // enable error tracking (which is turned on by default)\r\n  KADIRA_OPTIONS_ENABLE_ERROR_TRACKING: {\r\n    name: 'enableErrorTracking',\r\n    parser: Kadira._parseEnv.parseBool,\r\n  },\r\n  // kadira engine endpoint\r\n  KADIRA_OPTIONS_ENDPOINT: {\r\n    name: 'endpoint',\r\n    parser: Kadira._parseEnv.parseUrl,\r\n  },\r\n  // define the hostname of the current running process\r\n  KADIRA_OPTIONS_HOSTNAME: {\r\n    name: 'hostname',\r\n    parser: Kadira._parseEnv.parseString,\r\n  },\r\n  // interval between sending data to the kadira engine from the server\r\n  KADIRA_OPTIONS_PAYLOAD_TIMEOUT: {\r\n    name: 'payloadTimeout',\r\n    parser: Kadira._parseEnv.parseInt,\r\n  },\r\n  // set HTTP/HTTPS proxy\r\n  KADIRA_OPTIONS_PROXY: {\r\n    name: 'proxy',\r\n    parser: Kadira._parseEnv.parseUrl,\r\n  },\r\n  // number of items cached for tracking document size\r\n  KADIRA_OPTIONS_DOCUMENT_SIZE_CACHE_SIZE: {\r\n    name: 'documentSizeCacheSize',\r\n    parser: Kadira._parseEnv.parseInt,\r\n  },\r\n};\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/auto_connect.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nKadira._connectWithEnv = function() {\r\n  if(process.env.KADIRA_APP_ID && process.env.KADIRA_APP_SECRET) {\r\n    var options = Kadira._parseEnv(process.env);\r\n\r\n    Kadira.connect(\r\n      process.env.KADIRA_APP_ID,\r\n      process.env.KADIRA_APP_SECRET,\r\n      options\r\n    );\r\n\r\n    Kadira.connect = function() {\r\n      throw new Error('Kadira has been already connected using credentials from Environment Variables');\r\n    };\r\n  }\r\n};\r\n\r\n\r\nKadira._connectWithSettings = function () {\r\n  if(\r\n    Meteor.settings.kadira &&\r\n    Meteor.settings.kadira.appId &&\r\n    Meteor.settings.kadira.appSecret\r\n  ) {\r\n    Kadira.connect(\r\n      Meteor.settings.kadira.appId,\r\n      Meteor.settings.kadira.appSecret,\r\n      Meteor.settings.kadira.options || {}\r\n    );\r\n\r\n    Kadira.connect = function() {\r\n      throw new Error('Kadira has been already connected using credentials from Meteor.settings');\r\n    };\r\n  }\r\n};\r\n\r\n\r\n// Try to connect automatically\r\nKadira._connectWithEnv();\r\nKadira._connectWithSettings();\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/common/default_error_filters.js                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar commonErrRegExps = [\r\n  /connection timeout\\. no (\\w*) heartbeat received/i,\r\n  /INVALID_STATE_ERR/i,\r\n];\r\n\r\nKadira.errorFilters = {\r\n  filterValidationErrors: function(type, message, err) {\r\n    if(err && err instanceof Meteor.Error) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  },\r\n\r\n  filterCommonMeteorErrors: function(type, message) {\r\n    for(var lc=0; lc<commonErrRegExps.length; lc++) {\r\n      var regExp = commonErrRegExps[lc];\r\n      if(regExp.test(message)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/lmachens_kadira/lib/common/send.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nKadira.send = function (payload, path, callback) {\r\n  if(!Kadira.connected)  {\r\n    throw new Error(\"You need to connect with Kadira first, before sending messages!\");\r\n  }\r\n\r\n  path = (path.substr(0, 1) != '/')? \"/\" + path : path;\r\n  var endpoint = Kadira.options.endpoint + path;\r\n  var retryCount = 0;\r\n  var retry = new Retry({\r\n    minCount: 1,\r\n    minTimeout: 0,\r\n    baseTimeout: 1000*5,\r\n    maxTimeout: 1000*60,\r\n  });\r\n\r\n  var sendFunction = Kadira._getSendFunction();\r\n  tryToSend();\r\n\r\n  function tryToSend(err) {\r\n    if(retryCount < 5) {\r\n      retry.retryLater(retryCount++, send);\r\n    } else {\r\n      console.warn('Error sending error traces to kadira server');\r\n      if(callback) callback(err);\r\n    }\r\n  }\r\n\r\n  function send() {\r\n    sendFunction(endpoint, payload, function(err, content, statusCode) {\r\n      if(err) {\r\n        tryToSend(err);\r\n      } else if(statusCode == 200){\r\n        if(callback) callback(null, content);\r\n      } else {\r\n        if(callback) callback(new Meteor.Error(statusCode, content));\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nKadira._getSendFunction = function() {\r\n  return (Meteor.isServer)? Kadira._serverSend : Kadira._clientSend;\r\n};\r\n\r\nKadira._clientSend = function (endpoint, payload, callback) {\r\n  httpRequest('POST', endpoint, {\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    },\r\n    content: JSON.stringify(payload)\r\n  }, callback);\r\n}\r\n\r\nKadira._serverSend = function (endpoint, payload, callback) {\r\n  callback = callback || function() {};\r\n  var Fiber = Npm.require('fibers');\r\n  new Fiber(function() {\r\n    var httpOptions = {\r\n      data: payload,\r\n      headers: Kadira.options.authHeaders\r\n    };\r\n\r\n    HTTP.call('POST', endpoint, httpOptions, function(err, res) {\r\n      if(res) {\r\n        var content = (res.statusCode == 200)? res.data : res.content;\r\n        callback(null, content, res.statusCode);\r\n      } else {\r\n        callback(err);\r\n      }\r\n    });\r\n  }).run();\r\n}\r\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"lmachens:kadira\", {\n  Kadira: Kadira\n});\n\n})();\n","servePath":"/packages/lmachens_kadira.js"}]