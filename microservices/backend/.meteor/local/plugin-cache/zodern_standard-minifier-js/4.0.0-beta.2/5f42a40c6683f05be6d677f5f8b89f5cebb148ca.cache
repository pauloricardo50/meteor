{"code":"!function(){var e=Package.meteor.Meteor,n=Package.meteor.global,r=Package.meteor.meteorEnv,i=Package.ejson.EJSON,a=Package.modules.meteorInstall,o=Package[\"babel-runtime\"].meteorBabelHelpers,d=Package.promise.Promise,t=Package[\"ecmascript-runtime-client\"].Symbol,f=Package[\"ecmascript-runtime-client\"].Map,c=Package[\"ecmascript-runtime-client\"].Set,l,u,s=a({node_modules:{meteor:{\"diff-sequence\":{\"diff.js\":function(n,r,a){a.export({DiffSequence:function(){return d}});var d={},t=Object.prototype.hasOwnProperty;function f(e){for(var n in o.sanitizeForInObject(Object(e)))if(t.call(e,n))return!1;return!0}d.diffQueryChanges=function(e,n,r,i,a){e?d.diffQueryOrderedChanges(n,r,i,a):d.diffQueryUnorderedChanges(n,r,i,a)},d.diffQueryUnorderedChanges=function(e,n,r,a){var o=(a=a||{}).projectionFn||i.clone;if(r.movedBefore)throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");n.forEach(function(n,a){var t=e.get(a);if(t){if(r.changed&&!i.equals(t,n)){var c=o(n),l=o(t),u=d.makeChangedFields(c,l);f(u)||r.changed(a,u)}}else if(r.added){var s=o(n);delete s._id,r.added(n._id,s)}}),r.removed&&e.forEach(function(e,i){n.has(i)||r.removed(i)})},d.diffQueryOrderedChanges=function(n,r,a,o){var c=(o=o||{}).projectionFn||i.clone,l={};r.forEach(function(n){l[n._id]&&e._debug(\"Duplicate _id in new_results\"),l[n._id]=!0});var u={};n.forEach(function(n,r){n._id in u&&e._debug(\"Duplicate _id in old_results\"),u[n._id]=r});for(var s=[],h=0,g=r.length,m=new Array(g),v=new Array(g),_=function(e){return u[r[e]._id]},y=0;y<g;y++)if(void 0!==u[r[y]._id]){for(var O=h;O>0&&!(_(m[O-1])<_(y));)O--;v[y]=0===O?-1:m[O-1],m[O]=y,O+1>h&&(h=O+1)}for(var b=0===h?-1:m[h-1];b>=0;)s.push(b),b=v[b];s.reverse(),s.push(r.length),n.forEach(function(e){l[e._id]||a.removed&&a.removed(e._id)});var p=0;s.forEach(function(e){for(var i=r[e]?r[e]._id:null,o,l,s,h,g,m=p;m<e;m++)l=r[m],t.call(u,l._id)?(o=n[u[l._id]],h=c(l),g=c(o),f(s=d.makeChangedFields(h,g))||a.changed&&a.changed(l._id,s),a.movedBefore&&a.movedBefore(l._id,i)):(delete(s=c(l))._id,a.addedBefore&&a.addedBefore(l._id,s,i),a.added&&a.added(l._id,s));i&&(l=r[e],o=n[u[l._id]],h=c(l),g=c(o),f(s=d.makeChangedFields(h,g))||a.changed&&a.changed(l._id,s)),p=e+1})},d.diffObjects=function(e,n,r){Object.keys(e).forEach(function(i){var a=e[i];t.call(n,i)?r.both&&r.both(i,a,n[i]):r.leftOnly&&r.leftOnly(i,a)}),r.rightOnly&&Object.keys(n).forEach(function(i){var a=n[i];t.call(e,i)||r.rightOnly(i,a)})},d.diffMaps=function(e,n,r){e.forEach(function(e,i){n.has(i)?r.both&&r.both(i,e,n.get(i)):r.leftOnly&&r.leftOnly(i,e)}),r.rightOnly&&n.forEach(function(n,i){e.has(i)||r.rightOnly(i,n)})},d.makeChangedFields=function(e,n){var r={};return d.diffObjects(n,e,{leftOnly:function(e,n){r[e]=void 0},rightOnly:function(e,n){r[e]=n},both:function(e,n,a){i.equals(n,a)||(r[e]=a)}}),r},d.applyChanges=function(e,n){Object.keys(n).forEach(function(r){var i=n[r];void 0===i?delete e[r]:e[r]=i})}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/diff-sequence/diff.js\");Package._define(\"diff-sequence\",s,{DiffSequence:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/diff-sequence/diff.js\"],\"names\":[\"module\",\"export\",\"DiffSequence\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"isObjEmpty\",\"obj\",\"key\",\"meteorBabelHelpers\",\"sanitizeForInObject\",\"call\",\"diffQueryChanges\",\"ordered\",\"oldResults\",\"newResults\",\"observer\",\"options\",\"diffQueryOrderedChanges\",\"diffQueryUnorderedChanges\",\"projectionFn\",\"EJSON\",\"clone\",\"movedBefore\",\"Error\",\"forEach\",\"newDoc\",\"id\",\"oldDoc\",\"get\",\"changed\",\"equals\",\"projectedNew\",\"projectedOld\",\"changedFields\",\"makeChangedFields\",\"added\",\"fields\",\"_id\",\"removed\",\"has\",\"old_results\",\"new_results\",\"new_presence_of_id\",\"doc\",\"Meteor\",\"_debug\",\"old_index_of_id\",\"i\",\"unmoved\",\"max_seq_len\",\"N\",\"length\",\"seq_ends\",\"Array\",\"ptrs\",\"old_idx_seq\",\"i_new\",\"undefined\",\"j\",\"idx\",\"push\",\"reverse\",\"startOfGroup\",\"endOfGroup\",\"groupId\",\"addedBefore\",\"diffObjects\",\"left\",\"right\",\"callbacks\",\"keys\",\"leftValue\",\"both\",\"leftOnly\",\"rightOnly\",\"rightValue\",\"diffMaps\",\"value\",\"applyChanges\",\"changeFields\"],\"mappings\":\"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\",\"sourcesContent\":[\"export const DiffSequence = {};\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nfunction isObjEmpty(obj) {\\n  for (let key in Object(obj)) {\\n    if (hasOwn.call(obj, key)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n// ordered: bool.\\n// old_results and new_results: collections of documents.\\n//    if ordered, they are arrays.\\n//    if unordered, they are IdMaps\\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,\\n                                              observer, options) {\\n  if (ordered)\\n    DiffSequence.diffQueryOrderedChanges(\\n      oldResults, newResults, observer, options);\\n  else\\n    DiffSequence.diffQueryUnorderedChanges(\\n      oldResults, newResults, observer, options);\\n};\\n\\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,\\n                                                       observer, options) {\\n  options = options || {};\\n  var projectionFn = options.projectionFn || EJSON.clone;\\n\\n  if (observer.movedBefore) {\\n    throw new Error(\\\"_diffQueryUnordered called with a movedBefore observer!\\\");\\n  }\\n\\n  newResults.forEach(function (newDoc, id) {\\n    var oldDoc = oldResults.get(id);\\n    if (oldDoc) {\\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\\n        var projectedNew = projectionFn(newDoc);\\n        var projectedOld = projectionFn(oldDoc);\\n        var changedFields =\\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n        if (! isObjEmpty(changedFields)) {\\n          observer.changed(id, changedFields);\\n        }\\n      }\\n    } else if (observer.added) {\\n      var fields = projectionFn(newDoc);\\n      delete fields._id;\\n      observer.added(newDoc._id, fields);\\n    }\\n  });\\n\\n  if (observer.removed) {\\n    oldResults.forEach(function (oldDoc, id) {\\n      if (!newResults.has(id))\\n        observer.removed(id);\\n    });\\n  }\\n};\\n\\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,\\n                                                     observer, options) {\\n  options = options || {};\\n  var projectionFn = options.projectionFn || EJSON.clone;\\n\\n  var new_presence_of_id = {};\\n  new_results.forEach(function (doc) {\\n    if (new_presence_of_id[doc._id])\\n      Meteor._debug(\\\"Duplicate _id in new_results\\\");\\n    new_presence_of_id[doc._id] = true;\\n  });\\n\\n  var old_index_of_id = {};\\n  old_results.forEach(function (doc, i) {\\n    if (doc._id in old_index_of_id)\\n      Meteor._debug(\\\"Duplicate _id in old_results\\\");\\n    old_index_of_id[doc._id] = i;\\n  });\\n\\n  // ALGORITHM:\\n  //\\n  // To determine which docs should be considered \\\"moved\\\" (and which\\n  // merely change position because of other docs moving) we run\\n  // a \\\"longest common subsequence\\\" (LCS) algorithm.  The LCS of the\\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\\n  // considered moved.\\n\\n  // To actually call the appropriate callbacks to get from the old state to the\\n  // new state:\\n\\n  // First, we call removed() on all the items that only appear in the old\\n  // state.\\n\\n  // Then, once we have the items that should not move, we walk through the new\\n  // results array group-by-group, where a \\\"group\\\" is a set of items that have\\n  // moved, anchored on the end by an item that should not move.  One by one, we\\n  // move each of those elements into place \\\"before\\\" the anchoring end-of-group\\n  // item, and fire changed events on them if necessary.  Then we fire a changed\\n  // event on the anchor, and move on to the next group.  There is always at\\n  // least one group; the last group is anchored by a virtual \\\"null\\\" id at the\\n  // end.\\n\\n  // Asymptotically: O(N k) where k is number of ops, or potentially\\n  // O(N log N) if inner loop of LCS were made to be binary search.\\n\\n\\n  //////// LCS (longest common sequence, with respect to _id)\\n  // (see Wikipedia article on Longest Increasing Subsequence,\\n  // where the LIS is taken of the sequence of old indices of the\\n  // docs in new_results)\\n  //\\n  // unmoved: the output of the algorithm; members of the LCS,\\n  // in the form of indices into new_results\\n  var unmoved = [];\\n  // max_seq_len: length of LCS found so far\\n  var max_seq_len = 0;\\n  // seq_ends[i]: the index into new_results of the last doc in a\\n  // common subsequence of length of i+1 <= max_seq_len\\n  var N = new_results.length;\\n  var seq_ends = new Array(N);\\n  // ptrs:  the common subsequence ending with new_results[n] extends\\n  // a common subsequence ending with new_results[ptr[n]], unless\\n  // ptr[n] is -1.\\n  var ptrs = new Array(N);\\n  // virtual sequence of old indices of new results\\n  var old_idx_seq = function(i_new) {\\n    return old_index_of_id[new_results[i_new]._id];\\n  };\\n  // for each item in new_results, use it to extend a common subsequence\\n  // of length j <= max_seq_len\\n  for(var i=0; i<N; i++) {\\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\\n      var j = max_seq_len;\\n      // this inner loop would traditionally be a binary search,\\n      // but scanning backwards we will likely find a subseq to extend\\n      // pretty soon, bounded for example by the total number of ops.\\n      // If this were to be changed to a binary search, we'd still want\\n      // to scan backwards a bit as an optimization.\\n      while (j > 0) {\\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))\\n          break;\\n        j--;\\n      }\\n\\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);\\n      seq_ends[j] = i;\\n      if (j+1 > max_seq_len)\\n        max_seq_len = j+1;\\n    }\\n  }\\n\\n  // pull out the LCS/LIS into unmoved\\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);\\n  while (idx >= 0) {\\n    unmoved.push(idx);\\n    idx = ptrs[idx];\\n  }\\n  // the unmoved item list is built backwards, so fix that\\n  unmoved.reverse();\\n\\n  // the last group is always anchored by the end of the result list, which is\\n  // an id of \\\"null\\\"\\n  unmoved.push(new_results.length);\\n\\n  old_results.forEach(function (doc) {\\n    if (!new_presence_of_id[doc._id])\\n      observer.removed && observer.removed(doc._id);\\n  });\\n\\n  // for each group of things in the new_results that is anchored by an unmoved\\n  // element, iterate through the things before it.\\n  var startOfGroup = 0;\\n  unmoved.forEach(function (endOfGroup) {\\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\\n    for (var i = startOfGroup; i < endOfGroup; i++) {\\n      newDoc = new_results[i];\\n      if (!hasOwn.call(old_index_of_id, newDoc._id)) {\\n        fields = projectionFn(newDoc);\\n        delete fields._id;\\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\\n        observer.added && observer.added(newDoc._id, fields);\\n      } else {\\n        // moved\\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\\n        projectedNew = projectionFn(newDoc);\\n        projectedOld = projectionFn(oldDoc);\\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n        if (!isObjEmpty(fields)) {\\n          observer.changed && observer.changed(newDoc._id, fields);\\n        }\\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\\n      }\\n    }\\n    if (groupId) {\\n      newDoc = new_results[endOfGroup];\\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\\n      projectedNew = projectionFn(newDoc);\\n      projectedOld = projectionFn(oldDoc);\\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n      if (!isObjEmpty(fields)) {\\n        observer.changed && observer.changed(newDoc._id, fields);\\n      }\\n    }\\n    startOfGroup = endOfGroup+1;\\n  });\\n\\n\\n};\\n\\n\\n// General helper for diff-ing two objects.\\n// callbacks is an object like so:\\n// { leftOnly: function (key, leftValue) {...},\\n//   rightOnly: function (key, rightValue) {...},\\n//   both: function (key, leftValue, rightValue) {...},\\n// }\\nDiffSequence.diffObjects = function (left, right, callbacks) {\\n  Object.keys(left).forEach(key => {\\n    const leftValue = left[key];\\n    if (hasOwn.call(right, key)) {\\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\\n    } else {\\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\\n    }\\n  });\\n\\n  if (callbacks.rightOnly) {\\n    Object.keys(right).forEach(key => {\\n      const rightValue = right[key];\\n      if (! hasOwn.call(left, key)) {\\n        callbacks.rightOnly(key, rightValue);\\n      }\\n    });\\n  }\\n};\\n\\nDiffSequence.diffMaps = function (left, right, callbacks) {\\n  left.forEach(function (leftValue, key) {\\n    if (right.has(key)){\\n      callbacks.both && callbacks.both(key, leftValue, right.get(key));\\n    } else {\\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\\n    }\\n  });\\n\\n  if (callbacks.rightOnly) {\\n    right.forEach(function (rightValue, key) {\\n      if (!left.has(key)){\\n        callbacks.rightOnly(key, rightValue);\\n      }\\n    });\\n  }\\n};\\n\\n\\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\\n  var fields = {};\\n  DiffSequence.diffObjects(oldDoc, newDoc, {\\n    leftOnly: function (key, value) {\\n      fields[key] = undefined;\\n    },\\n    rightOnly: function (key, value) {\\n      fields[key] = value;\\n    },\\n    both: function (key, leftValue, rightValue) {\\n      if (!EJSON.equals(leftValue, rightValue))\\n        fields[key] = rightValue;\\n    }\\n  });\\n  return fields;\\n};\\n\\nDiffSequence.applyChanges = function (doc, changeFields) {\\n  Object.keys(changeFields).forEach(key => {\\n    const value = changeFields[key];\\n    if (typeof value === \\\"undefined\\\") {\\n      delete doc[key];\\n    } else {\\n      doc[key] = value;\\n    }\\n  });\\n};\\n\\n\"]}","minifier":"terser"}