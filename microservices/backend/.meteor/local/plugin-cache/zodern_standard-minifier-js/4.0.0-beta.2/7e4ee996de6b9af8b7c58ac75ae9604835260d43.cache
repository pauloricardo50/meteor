{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,i=Package.meteor.meteorEnv,r=Package.random.Random,n=Package.modules.meteorInstall,o=Package[\"babel-runtime\"].meteorBabelHelpers,m=Package.promise.Promise,a=Package[\"ecmascript-runtime-client\"].Symbol,u=Package[\"ecmascript-runtime-client\"].Map,s=Package[\"ecmascript-runtime-client\"].Set,c,h,l=n({node_modules:{meteor:{retry:{\"retry.js\":function(t,i,n){n.export({Retry:function(){return o}});var o=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.baseTimeout,i=void 0===t?1e3:t,r=e.exponent,n=void 0===r?2.2:r,o=e.maxTimeout,m=void 0===o?3e5:o,a=e.minTimeout,u=void 0===a?10:a,s=e.minCount,c=void 0===s?2:s,h=e.fuzz,l=void 0===h?.5:h;this.baseTimeout=i,this.exponent=n,this.maxTimeout=m,this.minTimeout=u,this.minCount=c,this.fuzz=l,this.retryTimer=null}var i=t.prototype;return i.clear=function(){function e(){this.retryTimer&&clearTimeout(this.retryTimer),this.retryTimer=null}return e}(),i._timeout=function(){function e(e){return e<this.minCount?this.minTimeout:Math.min(this.maxTimeout,this.baseTimeout*Math.pow(this.exponent,e))*(r.fraction()*this.fuzz+(1-this.fuzz/2));var t}return e}(),i.retryLater=function(){function t(t,i){var r=this._timeout(t);return this.retryTimer&&clearTimeout(this.retryTimer),this.retryTimer=e.setTimeout(i,r),r}return t}(),t}()}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/retry/retry.js\");Package._define(\"retry\",l,{Retry:c})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/retry/retry.js\"],\"names\":[\"module\",\"export\",\"Retry\",\"_ref\",\"arguments\",\"length\",\"undefined\",\"_ref$baseTimeout\",\"baseTimeout\",\"_ref$exponent\",\"exponent\",\"_ref$maxTimeout\",\"maxTimeout\",\"_ref$minTimeout\",\"minTimeout\",\"_ref$minCount\",\"minCount\",\"_ref$fuzz\",\"fuzz\",\"this\",\"retryTimer\",\"clear\",\"clearTimeout\",\"_timeout\",\"count\",\"Math\",\"min\",\"pow\",\"Random\",\"fraction\",\"timeout\",\"retryLater\",\"fn\",\"Meteor\",\"setTimeout\"],\"mappings\":\"gaAAAA,EAAOC,QAAQC,MAAM,WAAA,OAAIA,SAUZA,aACX,SAAAA,IASQ,IAAAC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,MAAAG,EAAAJ,EARNK,YAAAA,OAQM,IAAAD,EARQ,IAQRA,EAAAE,EAAAN,EAPNO,SAAAA,OAOM,IAAAD,EAPK,IAOLA,EAAAE,EAAAR,EAJNS,WAAAA,OAIM,IAAAD,EAJO,IAIPA,EAAAE,EAAAV,EAHNW,WAAAA,OAGM,IAAAD,EAHO,GAGPA,EAAAE,EAAAZ,EAFNa,SAAAA,OAEM,IAAAD,EAFK,EAELA,EAAAE,EAAAd,EADNe,KAAAA,OACM,IAAAD,EADC,GACDA,EACNE,KAAKX,YAAcA,EACnBW,KAAKT,SAAWA,EAChBS,KAAKP,WAAaA,EAClBO,KAAKL,WAAaA,EAClBK,KAAKH,SAAWA,EAChBG,KAAKD,KAAOA,EACZC,KAAKC,WAAa,gCAIpBC,iBAAA,SAAAA,IACMF,KAAKC,YACPE,aAAaH,KAAKC,YAEpBD,KAAKC,WAAa,mBAKpBG,oBAAA,SAAAA,EAASC,GACP,OAAIA,EAAQL,KAAKH,SACRG,KAAKL,WAKAW,KAAKC,IACjBP,KAAKP,WACLO,KAAKX,YAAciB,KAAKE,IAAIR,KAAKT,SAAUc,KAE3CI,EAAOC,WAAaV,KAAKD,MAAQ,EAAIC,KAAKD,KAAO,IAJnD,IAAIY,gBAWNC,sBAAA,SAAAA,EAAWP,EAAOQ,GAChB,IAAIF,EAAUX,KAAKI,SAASC,GAI5B,OAHIL,KAAKC,YACPE,aAAaH,KAAKC,YACpBD,KAAKC,WAAaa,EAAOC,WAAWF,EAAIF,GACjCA\",\"sourcesContent\":[\"// Retry logic with an exponential backoff.\\n//\\n// options:\\n//  baseTimeout: time for initial reconnect attempt (ms).\\n//  exponent: exponential factor to increase timeout each attempt.\\n//  maxTimeout: maximum time between retries (ms).\\n//  minCount: how many times to reconnect \\\"instantly\\\".\\n//  minTimeout: time to wait for the first `minCount` retries (ms).\\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\\n\\nexport class Retry {\\n  constructor({\\n    baseTimeout = 1000,\\n    exponent = 2.2,\\n    // The default is high-ish to ensure a server can recover from a\\n    // failure caused by load.\\n    maxTimeout = 5 * 60 * 1000,\\n    minTimeout = 10,\\n    minCount = 2,\\n    fuzz = 0.5,\\n  } = {}) {\\n    this.baseTimeout = baseTimeout;\\n    this.exponent = exponent;\\n    this.maxTimeout = maxTimeout;\\n    this.minTimeout = minTimeout;\\n    this.minCount = minCount;\\n    this.fuzz = fuzz;\\n    this.retryTimer = null;\\n  }\\n\\n  // Reset a pending retry, if any.\\n  clear() {\\n    if (this.retryTimer) {\\n      clearTimeout(this.retryTimer);\\n    }\\n    this.retryTimer = null;\\n  }\\n\\n  // Calculate how long to wait in milliseconds to retry, based on the\\n  // `count` of which retry this is.\\n  _timeout(count) {\\n    if (count < this.minCount) {\\n      return this.minTimeout;\\n    }\\n\\n    // fuzz the timeout randomly, to avoid reconnect storms when a\\n    // server goes down.\\n    var timeout = Math.min(\\n      this.maxTimeout,\\n      this.baseTimeout * Math.pow(this.exponent, count)\\n    ) * (\\n      Random.fraction() * this.fuzz + (1 - this.fuzz / 2)\\n    );\\n\\n    return timeout;\\n  }\\n\\n  // Call `fn` after a delay, based on the `count` of which retry this is.\\n  retryLater(count, fn) {\\n    var timeout = this._timeout(count);\\n    if (this.retryTimer)\\n      clearTimeout(this.retryTimer);\\n    this.retryTimer = Meteor.setTimeout(fn, timeout);\\n    return timeout;\\n  }\\n}\\n\"]}","minifier":"terser"}