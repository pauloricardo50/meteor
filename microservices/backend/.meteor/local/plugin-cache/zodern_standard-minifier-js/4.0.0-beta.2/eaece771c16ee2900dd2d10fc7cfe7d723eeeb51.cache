{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,r=Package.meteor.meteorEnv,n=Package[\"diff-sequence\"].DiffSequence,o=Package.ejson.EJSON,i=Package[\"geojson-utils\"].GeoJSON,s=Package[\"id-map\"].IdMap,a=Package[\"mongo-id\"].MongoID,c=Package[\"ordered-dict\"].OrderedDict,l=Package.random.Random,d=Package.tracker.Tracker,u=Package.tracker.Deps,h=Package.modules.meteorInstall,f=Package[\"babel-runtime\"].meteorBabelHelpers,p=Package.promise.Promise,m,y,_,g,b,w,v,E,$,j,O,A,k,I,S=h({node_modules:{meteor:{minimongo:{\"minimongo_client.js\":function(e,t,r){r.link(\"./minimongo_common.js\")},\"common.js\":function(e,t,r){let n;r.export({hasOwn:()=>s,ELEMENT_OPERATORS:()=>a,compileDocumentSelector:()=>p,equalityElementMatcher:()=>w,expandArraysInBranches:()=>E,isIndexable:()=>k,isNumericKey:()=>I,isOperatorObject:()=>S,makeLookupFunction:()=>C,nothingMatcher:()=>P,pathsToTree:()=>q,populateDocumentWithQueryFields:()=>D,projectionDetails:()=>T,regexpElementMatcher:()=>U}),r.link(\"./local_collection.js\",{default(e){n=e}},0);const s=Object.prototype.hasOwnProperty,a={$lt:M(e=>e<0),$gt:M(e=>e>0),$lte:M(e=>e<=0),$gte:M(e=>e>=0),$mod:{compileElementSelector(e){if(!Array.isArray(e)||2!==e.length||\"number\"!=typeof e[0]||\"number\"!=typeof e[1])throw Error(\"argument to $mod must be an array of two numbers\");const t=e[0],r=e[1];return e=>\"number\"==typeof e&&e%t===r}},$in:{compileElementSelector(e){if(!Array.isArray(e))throw Error(\"$in needs an array\");const t=e.map(e=>{if(e instanceof RegExp)return U(e);if(S(e))throw Error(\"cannot nest $ under $in\");return w(e)});return e=>(void 0===e&&(e=null),t.some(t=>t(e)))}},$size:{dontExpandLeafArrays:!0,compileElementSelector(e){if(\"string\"==typeof e)e=0;else if(\"number\"!=typeof e)throw Error(\"$size needs a number\");return t=>Array.isArray(t)&&t.length===e}},$type:{dontIncludeLeafArrays:!0,compileElementSelector(e){if(\"string\"==typeof e){const t={double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127};if(!s.call(t,e))throw Error(\"unknown string alias for $type: \".concat(e));e=t[e]}else{if(\"number\"!=typeof e)throw Error(\"argument to $type is not a number or a string\");if(0===e||e<-1||e>19&&127!==e)throw Error(\"Invalid numerical $type code: \".concat(e))}return t=>void 0!==t&&n._f._type(t)===e}},$bitsAllSet:{compileElementSelector(e){const t=$(e,\"$bitsAllSet\");return e=>{const r=j(e,t.length);return r&&t.every((e,t)=>(r[t]&e)===e)}}},$bitsAnySet:{compileElementSelector(e){const t=$(e,\"$bitsAnySet\");return e=>{const r=j(e,t.length);return r&&t.some((e,t)=>(~r[t]&e)!==e)}}},$bitsAllClear:{compileElementSelector(e){const t=$(e,\"$bitsAllClear\");return e=>{const r=j(e,t.length);return r&&t.every((e,t)=>!(r[t]&e))}}},$bitsAnyClear:{compileElementSelector(e){const t=$(e,\"$bitsAnyClear\");return e=>{const r=j(e,t.length);return r&&t.some((e,t)=>(r[t]&e)!==e)}}},$regex:{compileElementSelector(e,t){if(!(\"string\"==typeof e||e instanceof RegExp))throw Error(\"$regex has to be a string or RegExp\");let r;if(void 0!==t.$options){if(/[^gim]/.test(t.$options))throw new Error(\"Only the i, m, and g regexp options are supported\");const n=e instanceof RegExp?e.source:e;r=new RegExp(n,t.$options)}else r=e instanceof RegExp?e:new RegExp(e);return U(r)}},$elemMatch:{dontExpandLeafArrays:!0,compileElementSelector(e,t,r){if(!n._isPlainObject(e))throw Error(\"$elemMatch need an object\");const o=!S(Object.keys(e).filter(e=>!s.call(c,e)).reduce((t,r)=>Object.assign(t,{[r]:e[r]}),{}),!0);let i;return i=o?p(e,r,{inElemMatch:!0}):m(e,r),e=>{if(!Array.isArray(e))return!1;for(let t=0;t<e.length;++t){const r=e[t];let n;if(o){if(!k(r))return!1;n=r}else n=[{value:r,dontIterate:!0}];if(i(n).result)return t}return!1}}}},c={$and:(e,t,r)=>u(f(e,t,r)),$or(e,t,r){const n=f(e,t,r);return 1===n.length?n[0]:e=>{const t=n.some(t=>t(e).result);return{result:t}}},$nor(e,t,r){const n=f(e,t,r);return e=>{const t=n.every(t=>!t(e).result);return{result:t}}},$where:(e,t)=>(t._recordPathUsed(\"\"),t._hasWhere=!0,e instanceof Function||(e=Function(\"obj\",\"return \".concat(e))),t=>({result:e.call(t,t)})),$comment:()=>()=>({result:!0})},l={$eq:e=>y(w(e)),$not:(e,t,r)=>A(m(e,r)),$ne:e=>A(y(w(e))),$nin:e=>A(y(a.$in.compileElementSelector(e))),$exists(e){const t=y(e=>void 0!==e);return e?t:A(t)},$options(e,t){if(!s.call(t,\"$regex\"))throw Error(\"$options needs a $regex\");return v},$maxDistance(e,t){if(!t.$near)throw Error(\"$maxDistance needs a $near\");return v},$all(e,t,r){if(!Array.isArray(e))throw Error(\"$all requires array\");if(0===e.length)return P;const n=e.map(e=>{if(S(e))throw Error(\"no $ expressions in $all\");return m(e,r)});return h(n)},$near(e,t,r,o){if(!o)throw Error(\"$near can't be inside another $ operator\");let a,c,l;if(r._hasGeoQuery=!0,n._isPlainObject(e)&&s.call(e,\"$geometry\"))a=e.$maxDistance,c=e.$geometry,l=(e=>e?e.type?\"Point\"===e.type?i.pointDistance(c,e):i.geometryWithinRadius(e,c,a)?0:a+1:i.pointDistance(c,{type:\"Point\",coordinates:B(e)}):null);else{if(a=t.$maxDistance,!k(e))throw Error(\"$near argument must be coordinate pair or GeoJSON\");c=B(e),l=(e=>k(e)?b(c,e):null)}return e=>{const t={result:!1};return E(e).every(e=>{let n;if(!r._isUpdate){if(\"object\"!=typeof e.value)return!0;if(null===(n=l(e.value))||n>a)return!0;if(void 0!==t.distance&&t.distance<=n)return!0}return t.result=!0,t.distance=n,e.arrayIndices?t.arrayIndices=e.arrayIndices:delete t.arrayIndices,!r._isUpdate}),t}}};function d(e){return 0===e.length?v:1===e.length?e[0]:t=>{const r={};return r.result=e.every(e=>{const n=e(t);return n.result&&void 0!==n.distance&&void 0===r.distance&&(r.distance=n.distance),n.result&&n.arrayIndices&&(r.arrayIndices=n.arrayIndices),n.result}),r.result||(delete r.distance,delete r.arrayIndices),r}}const u=d,h=d;function f(e,t,r){if(!Array.isArray(e)||0===e.length)throw Error(\"$and/$or/$nor must be nonempty array\");return e.map(e=>{if(!n._isPlainObject(e))throw Error(\"$or/$and/$nor entries need to be full objects\");return p(e,t,{inElemMatch:r})})}function p(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=Object.keys(e).map(n=>{const o=e[n];if(\"$\"===n.substr(0,1)){if(!s.call(c,n))throw new Error(\"Unrecognized logical operator: \".concat(n));return t._isSimple=!1,c[n](o,t,r.inElemMatch)}if(r.inElemMatch||t._recordPathUsed(n),\"function\"==typeof o)return;const i=C(n),a=m(o,t,r.isRoot);return e=>a(i(e))}).filter(Boolean);return u(n)}function m(e,t,r){return e instanceof RegExp?(t._isSimple=!1,y(U(e))):S(e)?x(e,t,r):y(w(e))}function y(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return r=>{const n=t.dontExpandLeafArrays?r:E(r,t.dontIncludeLeafArrays),o={};return o.result=n.some(t=>{let r=e(t.value);return\"number\"==typeof r&&(t.arrayIndices||(t.arrayIndices=[r]),r=!0),r&&t.arrayIndices&&(o.arrayIndices=t.arrayIndices),r}),o}}function b(e,t){const r=B(e),n=B(t);return Math.hypot(r[0]-n[0],r[1]-n[1])}function w(e){if(S(e))throw Error(\"Can't create equalityValueSelector for operator object\");return null==e?e=>null==e:t=>n._f._equal(e,t)}function v(e){return{result:!0}}function E(e,t){const r=[];return e.forEach(e=>{const n=Array.isArray(e.value);t&&n&&!e.dontIterate||r.push({arrayIndices:e.arrayIndices,value:e.value}),n&&!e.dontIterate&&e.value.forEach((t,n)=>{r.push({arrayIndices:(e.arrayIndices||[]).concat(n),value:t})})}),r}function $(e,t){if(Number.isInteger(e)&&e>=0)return new Uint8Array(new Int32Array([e]).buffer);if(o.isBinary(e))return new Uint8Array(e.buffer);if(Array.isArray(e)&&e.every(e=>Number.isInteger(e)&&e>=0)){const t=new ArrayBuffer(1+(Math.max(...e)>>3)),r=new Uint8Array(t);return e.forEach(e=>{r[e>>3]|=1<<(7&e)}),r}throw Error(\"operand to \".concat(t,\" must be a numeric bitmask (representable as a \")+\"non-negative 32-bit signed integer), a bindata bitmask or an array with bit positions (non-negative integers)\")}function j(e,t){if(Number.isSafeInteger(e)){const r=new ArrayBuffer(Math.max(t,2*Uint32Array.BYTES_PER_ELEMENT));let n=new Uint32Array(r,0,2);return n[0]=e%4294967296|0,n[1]=e/4294967296|0,e<0&&(n=new Uint8Array(r,2)).forEach((e,t)=>{n[t]=255}),new Uint8Array(r)}return!!o.isBinary(e)&&new Uint8Array(e.buffer)}function O(e,t,r){Object.keys(e).forEach(e=>{if(e.length>t.length&&0===e.indexOf(\"\".concat(t,\".\"))||t.length>e.length&&0===t.indexOf(\"\".concat(e,\".\")))throw new Error(\"cannot infer query fields to set, both paths '\".concat(e,\"' and \")+\"'\".concat(t,\"' are matched\"));if(e===t)throw new Error(\"cannot infer query fields to set, path '\".concat(t,\"' is matched twice\"))}),e[t]=r}function A(e){return t=>({result:!e(t).result})}function k(e){return Array.isArray(e)||n._isPlainObject(e)}function I(e){return/^[0-9]+$/.test(e)}function S(e,t){if(!n._isPlainObject(e))return!1;let r=void 0;return Object.keys(e).forEach(n=>{const o=\"$\"===n.substr(0,1);if(void 0===r)r=o;else if(r!==o){if(!t)throw new Error(\"Inconsistent operator: \".concat(JSON.stringify(e)));r=!1}}),!!r}function M(e){return{compileElementSelector(t){if(Array.isArray(t))return()=>!1;void 0===t&&(t=null);const r=n._f._type(t);return o=>(void 0===o&&(o=null),n._f._type(o)===r&&e(n._f._cmp(o,t)))}}}function C(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=e.split(\".\"),o=r.length?r[0]:\"\",i=r.length>1&&C(r.slice(1).join(\".\"),t),s=e=>(e.dontIterate||delete e.dontIterate,e.arrayIndices&&!e.arrayIndices.length&&delete e.arrayIndices,e);return function(e){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(Array.isArray(e)){if(!(I(o)&&o<e.length))return[];a=a.concat(+o,\"x\")}const c=e[o];if(!i)return[s({arrayIndices:a,dontIterate:Array.isArray(e)&&Array.isArray(c),value:c})];if(!k(c))return Array.isArray(e)?[]:[s({arrayIndices:a,value:void 0})];const l=[],d=e=>{l.push(...e)};return d(i(c,a)),!Array.isArray(c)||I(r[1])&&t.forSort||c.forEach((e,t)=>{n._isPlainObject(e)&&d(i(e,a.concat(t)))}),l}}function P(e){return{result:!1}}function x(e,t,r){const n=Object.keys(e).map(n=>{const o=e[n],i=[\"$lt\",\"$lte\",\"$gt\",\"$gte\"].includes(n)&&\"number\"==typeof o,c=[\"$ne\",\"$eq\"].includes(n)&&o!==Object(o),d=[\"$in\",\"$nin\"].includes(n)&&Array.isArray(o)&&!o.some(e=>e===Object(e));if(i||d||c||(t._isSimple=!1),s.call(l,n))return l[n](o,e,t,r);if(s.call(a,n)){const r=a[n];return y(r.compileElementSelector(o,e,t),r)}throw new Error(\"Unrecognized operator: \".concat(n))});return h(n)}function q(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return e.forEach(e=>{const o=e.split(\".\");let i=n;const a=o.slice(0,-1).every((t,n)=>{if(s.call(i,t)){if(i[t]!==Object(i[t])&&(i[t]=r(i[t],o.slice(0,n+1).join(\".\"),e),i[t]!==Object(i[t])))return!1}else i[t]={};return i=i[t],!0});if(a){const n=o[o.length-1];s.call(i,n)?i[n]=r(i[n],e,e):i[n]=t(e)}}),n}function B(e){return Array.isArray(e)?e.slice():[e.x,e.y]}function F(e,t,r){r&&Object.getPrototypeOf(r)===Object.prototype?R(e,t,r):r instanceof RegExp||O(e,t,r)}function R(e,t,r){const n=Object.keys(r),o=n.filter(e=>\"$\"!==e[0]);if(o.length>0||!n.length){if(n.length!==o.length)throw new Error(\"unknown operator: \".concat(o[0]));L(r,t),O(e,t,r)}else Object.keys(r).forEach(n=>{const o=r[n];\"$eq\"===n?F(e,t,o):\"$all\"===n&&o.forEach(r=>F(e,t,r))})}function D(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Object.getPrototypeOf(e)===Object.prototype?Object.keys(e).forEach(r=>{const n=e[r];\"$and\"===r?n.forEach(e=>D(e,t)):\"$or\"===r?1===n.length&&D(n[0],t):\"$\"!==r[0]&&F(t,r,n)}):n._selectorIsId(e)&&O(t,\"_id\",e),t}function T(e){let t=Object.keys(e).sort();1===t.length&&\"_id\"===t[0]||t.includes(\"_id\")&&e._id||(t=t.filter(e=>\"_id\"!==e));let r=null;t.forEach(t=>{const n=!!e[t];if(null===r&&(r=n),r!==n)throw g(\"You cannot currently mix including and excluding fields.\")});const n=q(t,e=>r,(e,t,r)=>{const n=r,o=t;throw g(\"both \".concat(n,\" and \").concat(o,\" found in fields option, \")+\"using both of them may trigger unexpected behavior. Did you mean to use only one of them?\")});return{including:r,tree:n}}function U(e){return t=>t instanceof RegExp?t.toString()===e.toString():\"string\"==typeof t&&(e.lastIndex=0,e.test(t))}function Q(e,t){if(e.includes(\".\"))throw new Error(\"The dotted field '\".concat(e,\"' in '\").concat(t,\".\").concat(e,\" is not valid for storage.\"));if(\"$\"===e[0])throw new Error(\"The dollar ($) prefixed field  '\".concat(t,\".\").concat(e,\" is not valid for storage.\"))}function L(e,t){e&&Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).forEach(r=>{Q(r,t),L(e[r],t+\".\"+r)})}_={makeLookupFunction:C},g=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};\"string\"==typeof e&&t.field&&(e+=\" for field '\".concat(t.field,\"'\"));const r=new Error(e);return r.name=\"MinimongoError\",r}},\"cursor.js\":function(e,t,r){let n,i;r.export({default:()=>s}),r.link(\"./local_collection.js\",{default(e){n=e}},0),r.link(\"./common.js\",{hasOwn(e){i=e}},1);class s{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.collection=e,this.sorter=null,this.matcher=new k.Matcher(t),n._selectorIsIdPerhapsAsObject(t)?this._selectorId=i.call(t,\"_id\")?t._id:t:(this._selectorId=void 0,(this.matcher.hasGeoQuery()||r.sort)&&(this.sorter=new k.Sorter(r.sort||[]))),this.skip=r.skip||0,this.limit=r.limit,this.fields=r.fields,this._projectionFn=n._compileProjection(this.fields||{}),this._transform=n.wrapTransform(r.transform),void 0!==d&&(this.reactive=void 0===r.reactive||r.reactive)}count(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.reactive&&this._depend({added:!0,removed:!0},!0),this._getRawObjects({ordered:!0,applySkipLimit:e}).length}fetch(){const e=[];return this.forEach(t=>{e.push(t)}),e}[Symbol.iterator](){this.reactive&&this._depend({addedBefore:!0,removed:!0,changed:!0,movedBefore:!0});let e=0;const t=this._getRawObjects({ordered:!0});return{next:()=>{if(e<t.length){let r=this._projectionFn(t[e++]);return this._transform&&(r=this._transform(r)),{value:r}}return{done:!0}}}}forEach(e,t){this.reactive&&this._depend({addedBefore:!0,removed:!0,changed:!0,movedBefore:!0}),this._getRawObjects({ordered:!0}).forEach((r,n)=>{r=this._projectionFn(r),this._transform&&(r=this._transform(r)),e.call(t,r,n,this)})}getTransform(){return this._transform}map(e,t){const r=[];return this.forEach((n,o)=>{r.push(e.call(t,n,o,this))}),r}observe(e){return n._observeFromObserveChanges(this,e)}observeChanges(e){const t=n._observeChangesCallbacksAreOrdered(e);if(!e._allow_unordered&&!t&&(this.skip||this.limit))throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' for observeChanges or 'addedAt' for observe, instead of 'added').\");if(this.fields&&(0===this.fields._id||!1===this.fields._id))throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");const r=this.matcher.hasGeoQuery()&&t&&new n._IdMap,i={cursor:this,dirty:!1,distances:r,matcher:this.matcher,ordered:t,projectionFn:this._projectionFn,resultsSnapshot:null,sorter:t&&this.sorter};let s;this.reactive&&(s=this.collection.next_qid++,this.collection.queries[s]=i),i.results=this._getRawObjects({ordered:t,distances:i.distances}),this.collection.paused&&(i.resultsSnapshot=t?[]:new n._IdMap);const a=e=>{if(!e)return()=>{};const t=this;return function(){if(t.collection.paused)return;const r=arguments;t.collection._observeQueue.queueTask(()=>{e.apply(this,r)})}};i.added=a(e.added),i.changed=a(e.changed),i.removed=a(e.removed),t&&(i.addedBefore=a(e.addedBefore),i.movedBefore=a(e.movedBefore)),e._suppress_initial||this.collection.paused||i.results.forEach(e=>{const r=o.clone(e);delete r._id,t&&i.addedBefore(e._id,this._projectionFn(r),null),i.added(e._id,this._projectionFn(r))});const c=Object.assign(new n.ObserveHandle,{collection:this.collection,stop:()=>{this.reactive&&delete this.collection.queries[s]}});return this.reactive&&d.active&&d.onInvalidate(()=>{c.stop()}),this.collection._observeQueue.drain(),c}rewind(){}_depend(e,t){if(d.active){const r=new d.Dependency,n=r.changed.bind(r);r.depend();const o={_allow_unordered:t,_suppress_initial:!0};[\"added\",\"addedBefore\",\"changed\",\"movedBefore\",\"removed\"].forEach(t=>{e[t]&&(o[t]=n)}),this.observeChanges(o)}}_getCollectionName(){return this.collection.name}_getRawObjects(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=!1!==e.applySkipLimit,r=e.ordered?[]:new n._IdMap;if(void 0!==this._selectorId){if(t&&this.skip)return r;const n=this.collection._docs.get(this._selectorId);return n&&(e.ordered?r.push(n):r.set(this._selectorId,n)),r}let o;return this.matcher.hasGeoQuery()&&e.ordered&&(e.distances?(o=e.distances).clear():o=new n._IdMap),this.collection._docs.forEach((n,i)=>{const s=this.matcher.documentMatches(n);return s.result&&(e.ordered?(r.push(n),o&&void 0!==s.distance&&o.set(i,s.distance)):r.set(i,n)),!t||(!this.limit||this.skip||this.sorter||r.length!==this.limit)}),e.ordered?(this.sorter&&r.sort(this.sorter.getComparator({distances:o})),t&&(this.limit||this.skip)?r.slice(this.skip,this.limit?this.limit+this.skip:r.length):r):r}_publishCursor(e){if(!Package.mongo)throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");if(!this.collection.name)throw new Error(\"Can't publish a cursor from a collection without a name.\");return Package.mongo.Mongo.Collection._publishCursor(this,e,this.collection.name)}}},\"local_collection.js\":function(t,r,i){let u,h,f,p,m,y,_,b;i.export({default:()=>w}),i.link(\"./cursor.js\",{default(e){u=e}},0),i.link(\"./observe_handle.js\",{default(e){h=e}},1),i.link(\"./common.js\",{hasOwn(e){f=e},isIndexable(e){p=e},isNumericKey(e){m=e},isOperatorObject(e){y=e},populateDocumentWithQueryFields(e){_=e},projectionDetails(e){b=e}},2);class w{constructor(t){this.name=t,this._docs=new w._IdMap,this._observeQueue=new e._SynchronousQueue,this.next_qid=1,this.queries=Object.create(null),this._savedOriginals=null,this.paused=!1}find(e,t){return 0===arguments.length&&(e={}),new w.Cursor(this,e,t)}findOne(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return 0===arguments.length&&(e={}),t.limit=1,this.find(e,t).fetch()[0]}insert(t,r){j(t=o.clone(t)),f.call(t,\"_id\")||(t._id=w._useOID?new a.ObjectID:l.id());const n=t._id;if(this._docs.has(n))throw g(\"Duplicate _id '\".concat(n,\"'\"));this._saveOriginal(n,void 0),this._docs.set(n,t);const i=[];return Object.keys(this.queries).forEach(e=>{const r=this.queries[e];if(r.dirty)return;const o=r.matcher.documentMatches(t);o.result&&(r.distances&&void 0!==o.distance&&r.distances.set(n,o.distance),r.cursor.skip||r.cursor.limit?i.push(e):w._insertInResults(r,t))}),i.forEach(e=>{this.queries[e]&&this._recomputeResults(this.queries[e])}),this._observeQueue.drain(),r&&e.defer(()=>{r(null,n)}),n}pauseObservers(){this.paused||(this.paused=!0,Object.keys(this.queries).forEach(e=>{const t=this.queries[e];t.resultsSnapshot=o.clone(t.results)}))}remove(t,r){if(this.paused&&!this._savedOriginals&&o.equals(t,{})){const t=this._docs.size();return this._docs.clear(),Object.keys(this.queries).forEach(e=>{const t=this.queries[e];t.ordered?t.results=[]:t.results.clear()}),r&&e.defer(()=>{r(null,t)}),t}const n=new k.Matcher(t),i=[];this._eachPossiblyMatchingDoc(t,(e,t)=>{n.documentMatches(e).result&&i.push(t)});const s=[],a=[];for(let e=0;e<i.length;e++){const t=i[e],r=this._docs.get(t);Object.keys(this.queries).forEach(e=>{const t=this.queries[e];t.dirty||t.matcher.documentMatches(r).result&&(t.cursor.skip||t.cursor.limit?s.push(e):a.push({qid:e,doc:r}))}),this._saveOriginal(t,r),this._docs.remove(t)}a.forEach(e=>{const t=this.queries[e.qid];t&&(t.distances&&t.distances.remove(e.doc._id),w._removeFromResults(t,e.doc))}),s.forEach(e=>{const t=this.queries[e];t&&this._recomputeResults(t)}),this._observeQueue.drain();const c=i.length;return r&&e.defer(()=>{r(null,c)}),c}resumeObservers(){this.paused&&(this.paused=!1,Object.keys(this.queries).forEach(e=>{const t=this.queries[e];t.dirty?(t.dirty=!1,this._recomputeResults(t,t.resultsSnapshot)):w._diffQueryChanges(t.ordered,t.resultsSnapshot,t.results,t,{projectionFn:t.projectionFn}),t.resultsSnapshot=null}),this._observeQueue.drain())}retrieveOriginals(){if(!this._savedOriginals)throw new Error(\"Called retrieveOriginals without saveOriginals\");const e=this._savedOriginals;return this._savedOriginals=null,e}saveOriginals(){if(this._savedOriginals)throw new Error(\"Called saveOriginals twice without retrieveOriginals\");this._savedOriginals=new w._IdMap}update(t,r,n,i){!i&&n instanceof Function&&(i=n,n=null),n||(n={});const s=new k.Matcher(t,!0),a={},c=new w._IdMap,l=w._idsMatchedBySelector(t);Object.keys(this.queries).forEach(e=>{const t=this.queries[e];if((t.cursor.skip||t.cursor.limit)&&!this.paused){if(t.results instanceof w._IdMap)return void(a[e]=t.results.clone());if(!(t.results instanceof Array))throw new Error(\"Assertion failed: query.results not an array\");const r=e=>{if(c.has(e._id))return c.get(e._id);const t=l&&!l.some(t=>o.equals(t,e._id))?e:o.clone(e);return c.set(e._id,t),t};a[e]=t.results.map(r)}});const d={};let u=0,h,f;if(this._eachPossiblyMatchingDoc(t,(e,t)=>{const o=s.documentMatches(e);return!(o.result&&(this._saveOriginal(t,e),this._modifyAndNotify(e,r,d,o.arrayIndices),++u,!n.multi))}),Object.keys(d).forEach(e=>{const t=this.queries[e];t&&this._recomputeResults(t,a[e])}),this._observeQueue.drain(),0===u&&n.upsert){const e=w._createUpsertDocument(t,r);!e._id&&n.insertedId&&(e._id=n.insertedId),h=this.insert(e),u=1}return n._returnObject?(f={numberAffected:u},void 0!==h&&(f.insertedId=h)):f=u,i&&e.defer(()=>{i(null,f)}),f}upsert(e,t,r,n){return n||\"function\"!=typeof r||(n=r,r={}),this.update(e,t,Object.assign({},r,{upsert:!0,_returnObject:!0}),n)}_eachPossiblyMatchingDoc(e,t){const r=w._idsMatchedBySelector(e);r?r.some(e=>{const r=this._docs.get(e);if(r)return!1===t(r,e)}):this._docs.forEach(t)}_modifyAndNotify(e,t,r,n){const i={};Object.keys(this.queries).forEach(t=>{const r=this.queries[t];r.dirty||(r.ordered?i[t]=r.matcher.documentMatches(e).result:i[t]=r.results.has(e._id))});const s=o.clone(e);w._modify(e,t,{arrayIndices:n}),Object.keys(this.queries).forEach(t=>{const n=this.queries[t];if(n.dirty)return;const o=n.matcher.documentMatches(e),a=o.result,c=i[t];a&&n.distances&&void 0!==o.distance&&n.distances.set(e._id,o.distance),n.cursor.skip||n.cursor.limit?(c||a)&&(r[t]=!0):c&&!a?w._removeFromResults(n,e):!c&&a?w._insertInResults(n,e):c&&a&&w._updateInResults(n,e,s)})}_recomputeResults(e,t){this.paused?e.dirty=!0:(this.paused||t||(t=e.results),e.distances&&e.distances.clear(),e.results=e.cursor._getRawObjects({distances:e.distances,ordered:e.ordered}),this.paused||w._diffQueryChanges(e.ordered,t,e.results,e,{projectionFn:e.projectionFn}))}_saveOriginal(e,t){this._savedOriginals&&(this._savedOriginals.has(e)||this._savedOriginals.set(e,o.clone(t)))}}w.Cursor=u,w.ObserveHandle=h,w._CachingChangeObserver=class e{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e.callbacks&&w._observeChangesCallbacksAreOrdered(e.callbacks);if(f.call(e,\"ordered\")){if(this.ordered=e.ordered,e.callbacks&&e.ordered!==t)throw Error(\"ordered option doesn't match callbacks\")}else{if(!e.callbacks)throw Error(\"must provide ordered or callbacks\");this.ordered=t}const r=e.callbacks||{};this.ordered?(this.docs=new c(a.idStringify),this.applyChange={addedBefore:(e,t,n)=>{const i=o.clone(t);i._id=e,r.addedBefore&&r.addedBefore.call(this,e,t,n),r.added&&r.added.call(this,e,t),this.docs.putBefore(e,i,n||null)},movedBefore:(e,t)=>{const n=this.docs.get(e);r.movedBefore&&r.movedBefore.call(this,e,t),this.docs.moveBefore(e,t||null)}}):(this.docs=new w._IdMap,this.applyChange={added:(e,t)=>{const n=o.clone(t);r.added&&r.added.call(this,e,t),n._id=e,this.docs.set(e,n)}}),this.applyChange.changed=((e,t)=>{const i=this.docs.get(e);if(!i)throw new Error(\"Unknown id for changed: \".concat(e));r.changed&&r.changed.call(this,e,o.clone(t)),n.applyChanges(i,t)}),this.applyChange.removed=(e=>{r.removed&&r.removed.call(this,e),this.docs.remove(e)})}},w._IdMap=class e extends s{constructor(){super(a.idStringify,a.idParse)}},w.wrapTransform=(e=>{if(!e)return null;if(e.__wrappedTransform__)return e;const t=t=>{if(!f.call(t,\"_id\"))throw new Error(\"can only transform documents with _id\");const r=t._id,n=d.nonreactive(()=>e(t));if(!w._isPlainObject(n))throw new Error(\"transform must return object\");if(f.call(n,\"_id\")){if(!o.equals(n._id,r))throw new Error(\"transformed document can't have different _id\")}else n._id=r;return n};return t.__wrappedTransform__=!0,t}),w._binarySearch=((e,t,r)=>{let n=0,o=t.length;for(;o>0;){const i=Math.floor(o/2);e(r,t[n+i])>=0?(n+=i+1,o-=i+1):o=i}return n}),w._checkSupportedProjection=(e=>{if(e!==Object(e)||Array.isArray(e))throw g(\"fields option must be an object\");Object.keys(e).forEach(t=>{if(t.split(\".\").includes(\"$\"))throw g(\"Minimongo doesn't support $ operator in projections yet.\");const r=e[t];if(\"object\"==typeof r&&[\"$elemMatch\",\"$meta\",\"$slice\"].some(e=>f.call(r,e)))throw g(\"Minimongo doesn't support operators in projections yet.\");if(![1,0,!0,!1].includes(r))throw g(\"Projection values should be one of 1, 0, true, or false\")})}),w._compileProjection=(e=>{w._checkSupportedProjection(e);const t=void 0===e._id||e._id,r=b(e),n=(e,t)=>{if(Array.isArray(e))return e.map(e=>n(e,t));const i=r.including?{}:o.clone(e);return Object.keys(t).forEach(s=>{if(!f.call(e,s))return;const a=t[s];a===Object(a)?e[s]===Object(e[s])&&(i[s]=n(e[s],a)):r.including?i[s]=o.clone(e[s]):delete i[s]}),i};return e=>{const o=n(e,r.tree);return t&&f.call(e,\"_id\")&&(o._id=e._id),!t&&f.call(o,\"_id\")&&delete o._id,o}}),w._createUpsertDocument=((e,t)=>{const r=_(e),n=w._isModificationMod(t),o={};if(r._id&&(o._id=r._id,delete r._id),w._modify(o,{$set:r}),w._modify(o,t,{isInsert:!0}),n)return o;const i=Object.assign({},t);return o._id&&(i._id=o._id),i}),w._diffObjects=((e,t,r)=>n.diffObjects(e,t,r)),w._diffQueryChanges=((e,t,r,o,i)=>n.diffQueryChanges(e,t,r,o,i)),w._diffQueryOrderedChanges=((e,t,r,o)=>n.diffQueryOrderedChanges(e,t,r,o)),w._diffQueryUnorderedChanges=((e,t,r,o)=>n.diffQueryUnorderedChanges(e,t,r,o)),w._findInOrderedResults=((e,t)=>{if(!e.ordered)throw new Error(\"Can't call _findInOrderedResults on unordered query\");for(let r=0;r<e.results.length;r++)if(e.results[r]===t)return r;throw Error(\"object missing from query\")}),w._idsMatchedBySelector=(e=>{if(w._selectorIsId(e))return[e];if(!e)return null;if(f.call(e,\"_id\"))return w._selectorIsId(e._id)?[e._id]:e._id&&Array.isArray(e._id.$in)&&e._id.$in.length&&e._id.$in.every(w._selectorIsId)?e._id.$in:null;if(Array.isArray(e.$and))for(let t=0;t<e.$and.length;++t){const r=w._idsMatchedBySelector(e.$and[t]);if(r)return r}return null}),w._insertInResults=((e,t)=>{const r=o.clone(t);if(delete r._id,e.ordered){if(e.sorter){const n=w._insertInSortedList(e.sorter.getComparator({distances:e.distances}),e.results,t);let o=e.results[n+1];o=o?o._id:null,e.addedBefore(t._id,e.projectionFn(r),o)}else e.addedBefore(t._id,e.projectionFn(r),null),e.results.push(t);e.added(t._id,e.projectionFn(r))}else e.added(t._id,e.projectionFn(r)),e.results.set(t._id,t)}),w._insertInSortedList=((e,t,r)=>{if(0===t.length)return t.push(r),0;const n=w._binarySearch(e,t,r);return t.splice(n,0,r),n}),w._isModificationMod=(e=>{let t=!1,r=!1;if(Object.keys(e).forEach(e=>{\"$\"===e.substr(0,1)?t=!0:r=!0}),t&&r)throw new Error(\"Update parameter cannot have both modifier and non-modifier fields.\");return t}),w._isPlainObject=(e=>e&&3===w._f._type(e)),w._modify=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!w._isPlainObject(t))throw g(\"Modifier must be an object\");t=o.clone(t);const n=y(t),i=n?o.clone(e):t;if(n){if(Object.keys(t).forEach(e=>{const n=r.isInsert&&\"$setOnInsert\"===e,o=v[n?\"$set\":e],s=t[e];if(!o)throw g(\"Invalid modifier specified \".concat(e));Object.keys(s).forEach(t=>{const n=s[t];if(\"\"===t)throw g(\"An empty update path is not valid.\");const a=t.split(\".\");if(!a.every(Boolean))throw g(\"The update path '\".concat(t,\"' contains an empty field name, \")+\"which is not allowed.\");const c=A(i,a,{arrayIndices:r.arrayIndices,forbidArray:\"$rename\"===e,noCreate:E[e]});o(c,a.pop(),n,t,i)})}),e._id&&!o.equals(e._id,i._id))throw g('After applying the update to the document {_id: \"'.concat(e._id,'\", ...},')+\" the (immutable) field '_id' was found to have been altered to \"+'_id: \"'.concat(i._id,'\"'))}else{if(e._id&&t._id&&!o.equals(e._id,t._id))throw g('The _id field cannot be changed from {_id: \"'.concat(e._id,'\"} to ')+'{_id: \"'.concat(t._id,'\"}'));j(t)}Object.keys(e).forEach(t=>{\"_id\"!==t&&delete e[t]}),Object.keys(i).forEach(t=>{e[t]=i[t]})},w._observeFromObserveChanges=((e,t)=>{const r=e.getTransform()||(e=>e);let i=!!t._suppress_initial,s;if(w._observeCallbacksAreOrdered(t)){const e=!t._no_indices;s={addedBefore(n,o,s){if(i||!t.addedAt&&!t.added)return;const a=r(Object.assign(o,{_id:n}));t.addedAt?t.addedAt(a,e?s?this.docs.indexOf(s):this.docs.size():-1,s):t.added(a)},changed(i,s){if(!t.changedAt&&!t.changed)return;let a=o.clone(this.docs.get(i));if(!a)throw new Error(\"Unknown id for changed: \".concat(i));const c=r(o.clone(a));n.applyChanges(a,s),t.changedAt?t.changedAt(r(a),c,e?this.docs.indexOf(i):-1):t.changed(r(a),c)},movedBefore(n,i){if(!t.movedTo)return;const s=e?this.docs.indexOf(n):-1;let a=e?i?this.docs.indexOf(i):this.docs.size():-1;a>s&&--a,t.movedTo(r(o.clone(this.docs.get(n))),s,a,i||null)},removed(n){if(!t.removedAt&&!t.removed)return;const o=r(this.docs.get(n));t.removedAt?t.removedAt(o,e?this.docs.indexOf(n):-1):t.removed(o)}}}else s={added(e,n){!i&&t.added&&t.added(r(Object.assign(n,{_id:e})))},changed(e,i){if(t.changed){const s=this.docs.get(e),a=o.clone(s);n.applyChanges(a,i),t.changed(r(a),r(o.clone(s)))}},removed(e){t.removed&&t.removed(r(this.docs.get(e)))}};const a=new w._CachingChangeObserver({callbacks:s}),c=e.observeChanges(a.applyChange);return i=!1,c}),w._observeCallbacksAreOrdered=(e=>{if(e.added&&e.addedAt)throw new Error(\"Please specify only one of added() and addedAt()\");if(e.changed&&e.changedAt)throw new Error(\"Please specify only one of changed() and changedAt()\");if(e.removed&&e.removedAt)throw new Error(\"Please specify only one of removed() and removedAt()\");return!!(e.addedAt||e.changedAt||e.movedTo||e.removedAt)}),w._observeChangesCallbacksAreOrdered=(e=>{if(e.added&&e.addedBefore)throw new Error(\"Please specify only one of added() and addedBefore()\");return!(!e.addedBefore&&!e.movedBefore)}),w._removeFromResults=((e,t)=>{if(e.ordered){const r=w._findInOrderedResults(e,t);e.removed(t._id),e.results.splice(r,1)}else{const r=t._id;e.removed(t._id),e.results.remove(r)}}),w._selectorIsId=(e=>\"number\"==typeof e||\"string\"==typeof e||e instanceof a.ObjectID),w._selectorIsIdPerhapsAsObject=(e=>w._selectorIsId(e)||w._selectorIsId(e&&e._id)&&1===Object.keys(e).length),w._updateInResults=((e,t,r)=>{if(!o.equals(t._id,r._id))throw new Error(\"Can't change a doc's _id while updating\");const i=e.projectionFn,s=n.makeChangedFields(i(t),i(r));if(!e.ordered)return void(Object.keys(s).length&&(e.changed(t._id,s),e.results.set(t._id,t)));const a=w._findInOrderedResults(e,t);if(Object.keys(s).length&&e.changed(t._id,s),!e.sorter)return;e.results.splice(a,1);const c=w._insertInSortedList(e.sorter.getComparator({distances:e.distances}),e.results,t);if(a!==c){let r=e.results[c+1];r=r?r._id:null,e.movedBefore&&e.movedBefore(t._id,r)}});const v={$currentDate(e,t,r){if(\"object\"==typeof r&&f.call(r,\"$type\")){if(\"date\"!==r.$type)throw g(\"Minimongo does currently only support the date type in $currentDate modifiers\",{field:t})}else if(!0!==r)throw g(\"Invalid $currentDate modifier\",{field:t});e[t]=new Date},$min(e,t,r){if(\"number\"!=typeof r)throw g(\"Modifier $min allowed for numbers only\",{field:t});if(t in e){if(\"number\"!=typeof e[t])throw g(\"Cannot apply $min modifier to non-number\",{field:t});e[t]>r&&(e[t]=r)}else e[t]=r},$max(e,t,r){if(\"number\"!=typeof r)throw g(\"Modifier $max allowed for numbers only\",{field:t});if(t in e){if(\"number\"!=typeof e[t])throw g(\"Cannot apply $max modifier to non-number\",{field:t});e[t]<r&&(e[t]=r)}else e[t]=r},$inc(e,t,r){if(\"number\"!=typeof r)throw g(\"Modifier $inc allowed for numbers only\",{field:t});if(t in e){if(\"number\"!=typeof e[t])throw g(\"Cannot apply $inc modifier to non-number\",{field:t});e[t]+=r}else e[t]=r},$set(e,t,r){if(e!==Object(e)){const e=g(\"Cannot set property on non-object field\",{field:t});throw e.setPropertyError=!0,e}if(null===e){const e=g(\"Cannot set property on null\",{field:t});throw e.setPropertyError=!0,e}j(r),e[t]=r},$setOnInsert(e,t,r){},$unset(e,t,r){void 0!==e&&(e instanceof Array?t in e&&(e[t]=null):delete e[t])},$push(e,t,r){if(void 0===e[t]&&(e[t]=[]),!(e[t]instanceof Array))throw g(\"Cannot apply $push modifier to non-array\",{field:t});if(!r||!r.$each)return j(r),void e[t].push(r);const n=r.$each;if(!(n instanceof Array))throw g(\"$each must be an array\",{field:t});j(n);let o=void 0;if(\"$position\"in r){if(\"number\"!=typeof r.$position)throw g(\"$position must be a numeric value\",{field:t});if(r.$position<0)throw g(\"$position in $push must be zero or positive\",{field:t});o=r.$position}let i=void 0;if(\"$slice\"in r){if(\"number\"!=typeof r.$slice)throw g(\"$slice must be a numeric value\",{field:t});i=r.$slice}let s=void 0;if(r.$sort){if(void 0===i)throw g(\"$sort requires $slice to be present\",{field:t});s=new k.Sorter(r.$sort).getComparator(),n.forEach(e=>{if(3!==w._f._type(e))throw g(\"$push like modifiers using $sort require all elements to be objects\",{field:t})})}if(void 0===o)n.forEach(r=>{e[t].push(r)});else{const r=[o,0];n.forEach(e=>{r.push(e)}),e[t].splice(...r)}s&&e[t].sort(s),void 0!==i&&(e[t]=0===i?[]:i<0?e[t].slice(i):e[t].slice(0,i))},$pushAll(e,t,r){if(!(\"object\"==typeof r&&r instanceof Array))throw g(\"Modifier $pushAll/pullAll allowed for arrays only\");j(r);const n=e[t];if(void 0===n)e[t]=r;else{if(!(n instanceof Array))throw g(\"Cannot apply $pushAll modifier to non-array\",{field:t});n.push(...r)}},$addToSet(e,t,r){let n=!1;if(\"object\"==typeof r){const e=Object.keys(r);\"$each\"===e[0]&&(n=!0)}const o=n?r.$each:[r];j(o);const i=e[t];if(void 0===i)e[t]=o;else{if(!(i instanceof Array))throw g(\"Cannot apply $addToSet modifier to non-array\",{field:t});o.forEach(e=>{i.some(t=>w._f._equal(e,t))||i.push(e)})}},$pop(e,t,r){if(void 0===e)return;const n=e[t];if(void 0!==n){if(!(n instanceof Array))throw g(\"Cannot apply $pop modifier to non-array\",{field:t});\"number\"==typeof r&&r<0?n.splice(0,1):n.pop()}},$pull(e,t,r){if(void 0===e)return;const n=e[t];if(void 0===n)return;if(!(n instanceof Array))throw g(\"Cannot apply $pull/pullAll modifier to non-array\",{field:t});let o;if(null==r||\"object\"!=typeof r||r instanceof Array)o=n.filter(e=>!w._f._equal(e,r));else{const e=new k.Matcher(r);o=n.filter(t=>!e.documentMatches(t).result)}e[t]=o},$pullAll(e,t,r){if(!(\"object\"==typeof r&&r instanceof Array))throw g(\"Modifier $pushAll/pullAll allowed for arrays only\",{field:t});if(void 0===e)return;const n=e[t];if(void 0!==n){if(!(n instanceof Array))throw g(\"Cannot apply $pull/pullAll modifier to non-array\",{field:t});e[t]=n.filter(e=>!r.some(t=>w._f._equal(e,t)))}},$rename(e,t,r,n,o){if(n===r)throw g(\"$rename source must differ from target\",{field:t});if(null===e)throw g(\"$rename source field invalid\",{field:t});if(\"string\"!=typeof r)throw g(\"$rename target must be a string\",{field:t});if(r.includes(\"\\0\"))throw g(\"The 'to' field for $rename cannot contain an embedded null byte\",{field:t});if(void 0===e)return;const i=e[t];delete e[t];const s=r.split(\".\"),a=A(o,s,{forbidArray:!0});if(null===a)throw g(\"$rename target field invalid\",{field:t});a[s.pop()]=i},$bit(e,t,r){throw g(\"$bit is not supported\",{field:t})},$v(){}},E={$pop:!0,$pull:!0,$pullAll:!0,$rename:!0,$unset:!0},$={$:\"start with '$'\",\".\":\"contain '.'\",\"\\0\":\"contain null bytes\"};function j(e){e&&\"object\"==typeof e&&JSON.stringify(e,(e,t)=>(O(e),t))}function O(e){let t;if(\"string\"==typeof e&&(t=e.match(/^\\$|\\.|\\0/)))throw g(\"Key \".concat(e,\" must not \").concat($[t[0]]))}function A(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=!1;for(let o=0;o<t.length;o++){const i=o===t.length-1;let s=t[o];if(!p(e)){if(r.noCreate)return;const t=g(\"cannot use the part '\".concat(s,\"' to traverse \").concat(e));throw t.setPropertyError=!0,t}if(e instanceof Array){if(r.forbidArray)return null;if(\"$\"===s){if(n)throw g(\"Too many positional (i.e. '$') elements\");if(!r.arrayIndices||!r.arrayIndices.length)throw g(\"The positional operator did not find the match needed from the query\");s=r.arrayIndices[0],n=!0}else{if(!m(s)){if(r.noCreate)return;throw g(\"can't append to array using string field name [\".concat(s,\"]\"))}s=parseInt(s)}if(i&&(t[o]=s),r.noCreate&&s>=e.length)return;for(;e.length<s;)e.push(null);if(!i)if(e.length===s)e.push({});else if(\"object\"!=typeof e[s])throw g(\"can't modify field '\".concat(t[o+1],\"' of list value \")+JSON.stringify(e[s]))}else if(O(s),!(s in e)){if(r.noCreate)return;i||(e[s]={})}if(i)return e;e=e[s]}}},\"matcher.js\":function(e,t,r){let n,i,s,c;r.export({default:()=>l}),r.link(\"./local_collection.js\",{default(e){n=e}},0),r.link(\"./common.js\",{compileDocumentSelector(e){i=e},hasOwn(e){s=e},nothingMatcher(e){c=e}},1);class l{constructor(e,t){this._paths={},this._hasGeoQuery=!1,this._hasWhere=!1,this._isSimple=!0,this._matchingDocument=void 0,this._selector=null,this._docMatcher=this._compileSelector(e),this._isUpdate=t}documentMatches(e){if(e!==Object(e))throw Error(\"documentMatches needs a document\");return this._docMatcher(e)}hasGeoQuery(){return this._hasGeoQuery}hasWhere(){return this._hasWhere}isSimple(){return this._isSimple}_compileSelector(e){if(e instanceof Function)return this._isSimple=!1,this._selector=e,this._recordPathUsed(\"\"),t=>({result:!!e.call(t)});if(n._selectorIsId(e))return this._selector={_id:e},this._recordPathUsed(\"_id\"),t=>({result:o.equals(t._id,e)});if(!e||s.call(e,\"_id\")&&!e._id)return this._isSimple=!1,c;if(Array.isArray(e)||o.isBinary(e)||\"boolean\"==typeof e)throw new Error(\"Invalid selector: \".concat(e));return this._selector=o.clone(e),i(e,this,{isRoot:!0})}_getPaths(){return Object.keys(this._paths)}_recordPathUsed(e){this._paths[e]=!0}}n._f={_type:e=>\"number\"==typeof e?1:\"string\"==typeof e?2:\"boolean\"==typeof e?8:Array.isArray(e)?4:null===e?10:e instanceof RegExp?11:\"function\"==typeof e?13:e instanceof Date?9:o.isBinary(e)?5:e instanceof a.ObjectID?7:3,_equal:(e,t)=>o.equals(e,t,{keyOrderSensitive:!0}),_typeorder:e=>[-1,1,2,3,4,5,-1,6,7,8,0,9,-1,100,2,100,1,8,1][e],_cmp(e,t){if(void 0===e)return void 0===t?0:-1;if(void 0===t)return 1;let r=n._f._type(e),o=n._f._type(t);const i=n._f._typeorder(r),s=n._f._typeorder(o);if(i!==s)return i<s?-1:1;if(r!==o)throw Error(\"Missing type coercion logic in _cmp\");if(7===r&&(r=o=2,e=e.toHexString(),t=t.toHexString()),9===r&&(r=o=1,e=e.getTime(),t=t.getTime()),1===r)return e-t;if(2===o)return e<t?-1:e===t?0:1;if(3===r){const r=e=>{const t=[];return Object.keys(e).forEach(r=>{t.push(r,e[r])}),t};return n._f._cmp(r(e),r(t))}if(4===r)for(let a=0;;a++){if(a===e.length)return a===t.length?0:-1;if(a===t.length)return 1;const r=n._f._cmp(e[a],t[a]);if(0!==r)return r}if(5===r){if(e.length!==t.length)return e.length-t.length;for(let r=0;r<e.length;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0}if(8===r)return e?t?0:1:t?-1:0;if(10===r)return 0;if(11===r)throw Error(\"Sorting not supported on regular expression\");if(13===r)throw Error(\"Sorting not supported on Javascript code\");throw Error(\"Unknown type to sort\")}}},\"minimongo_common.js\":function(e,t,r){let n,o,i;r.link(\"./local_collection.js\",{default(e){n=e}},0),r.link(\"./matcher.js\",{default(e){o=e}},1),r.link(\"./sorter.js\",{default(e){i=e}},2),A=n,k={LocalCollection:n,Matcher:o,Sorter:i}},\"observe_handle.js\":function(e,t,r){r.export({default:()=>n});class n{}},\"sorter.js\":function(e,t,r){let n,o,i,s,a,c,l;r.export({default:()=>d}),r.link(\"./common.js\",{ELEMENT_OPERATORS(e){n=e},equalityElementMatcher(e){o=e},expandArraysInBranches(e){i=e},hasOwn(e){s=e},isOperatorObject(e){a=e},makeLookupFunction(e){c=e},regexpElementMatcher(e){l=e}},0);class d{constructor(e){this._sortSpecParts=[],this._sortFunction=null;const t=(e,t)=>{if(!e)throw Error(\"sort keys must be non-empty\");if(\"$\"===e.charAt(0))throw Error(\"unsupported sort key: \".concat(e));this._sortSpecParts.push({ascending:t,lookup:c(e,{forSort:!0}),path:e})};if(e instanceof Array)e.forEach(e=>{\"string\"==typeof e?t(e,!0):t(e[0],\"desc\"!==e[1])});else if(\"object\"==typeof e)Object.keys(e).forEach(r=>{t(r,e[r]>=0)});else{if(\"function\"!=typeof e)throw Error(\"Bad sort specification: \".concat(JSON.stringify(e)));this._sortFunction=e}if(!this._sortFunction){if(this.affectedByModifier){const e={};this._sortSpecParts.forEach(t=>{e[t.path]=1}),this._selectorForAffectedByModifier=new k.Matcher(e)}this._keyComparator=u(this._sortSpecParts.map((e,t)=>this._keyFieldComparator(t)))}}getComparator(e){if(this._sortSpecParts.length||!e||!e.distances)return this._getBaseComparator();const t=e.distances;return(e,r)=>{if(!t.has(e._id))throw Error(\"Missing distance for \".concat(e._id));if(!t.has(r._id))throw Error(\"Missing distance for \".concat(r._id));return t.get(e._id)-t.get(r._id)}}_compareKeys(e,t){if(e.length!==this._sortSpecParts.length||t.length!==this._sortSpecParts.length)throw Error(\"Key has wrong length\");return this._keyComparator(e,t)}_generateKeysFromDoc(e,t){if(0===this._sortSpecParts.length)throw new Error(\"can't generate keys without a spec\");const r=e=>\"\".concat(e.join(\",\"),\",\");let n=null;const o=this._sortSpecParts.map(t=>{let o=i(t.lookup(e),!0);o.length||(o=[{value:void 0}]);const a=Object.create(null);let c=!1;if(o.forEach(e=>{if(!e.arrayIndices){if(o.length>1)throw Error(\"multiple branches but no array used?\");return void(a[\"\"]=e.value)}c=!0;const t=r(e.arrayIndices);if(s.call(a,t))throw Error(\"duplicate path: \".concat(t));if(a[t]=e.value,n&&!s.call(n,t))throw Error(\"cannot index parallel arrays\")}),n){if(!s.call(a,\"\")&&Object.keys(n).length!==Object.keys(a).length)throw Error(\"cannot index parallel arrays!\")}else c&&(n={},Object.keys(a).forEach(e=>{n[e]=!0}));return a});if(n)Object.keys(n).forEach(e=>{const r=o.map(t=>{if(s.call(t,\"\"))return t[\"\"];if(!s.call(t,e))throw Error(\"missing path?\");return t[e]});t(r)});else{const e=o.map(e=>{if(!s.call(e,\"\"))throw Error(\"no value in sole key case?\");return e[\"\"]});t(e)}}_getBaseComparator(){return this._sortFunction?this._sortFunction:this._sortSpecParts.length?(e,t)=>{const r=this._getMinKeyFromDoc(e),n=this._getMinKeyFromDoc(t);return this._compareKeys(r,n)}:(e,t)=>0}_getMinKeyFromDoc(e){let t=null;return this._generateKeysFromDoc(e,e=>{null!==t?this._compareKeys(e,t)<0&&(t=e):t=e}),t}_getPaths(){return this._sortSpecParts.map(e=>e.path)}_keyFieldComparator(e){const t=!this._sortSpecParts[e].ascending;return(r,n)=>{const o=A._f._cmp(r[e],n[e]);return t?-o:o}}}function u(e){return(t,r)=>{for(let n=0;n<e.length;++n){const o=e[n](t,r);if(0!==o)return o}return 0}}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/minimongo/minimongo_client.js\");Package._define(\"minimongo\",S,{LocalCollection:A,Minimongo:k,MinimongoTest:_,MinimongoError:g})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/minimongo/minimongo_client.js\",\"packages/minimongo/common.js\",\"packages/minimongo/cursor.js\",\"packages/minimongo/local_collection.js\",\"packages/minimongo/matcher.js\",\"packages/minimongo/minimongo_common.js\",\"packages/minimongo/observe_handle.js\",\"packages/minimongo/sorter.js\"],\"names\":[\"module\",\"link\",\"LocalCollection\",\"export\",\"hasOwn\",\"ELEMENT_OPERATORS\",\"compileDocumentSelector\",\"equalityElementMatcher\",\"expandArraysInBranches\",\"isIndexable\",\"isNumericKey\",\"isOperatorObject\",\"makeLookupFunction\",\"nothingMatcher\",\"pathsToTree\",\"populateDocumentWithQueryFields\",\"projectionDetails\",\"regexpElementMatcher\",\"default\",\"v\",\"Object\",\"prototype\",\"hasOwnProperty\",\"$lt\",\"makeInequality\",\"cmpValue\",\"$gt\",\"$lte\",\"$gte\",\"$mod\",\"compileElementSelector\",\"operand\",\"Array\",\"isArray\",\"length\",\"Error\",\"divisor\",\"remainder\",\"value\",\"$in\",\"elementMatchers\",\"map\",\"option\",\"RegExp\",\"undefined\",\"some\",\"matcher\",\"$size\",\"dontExpandLeafArrays\",\"$type\",\"dontIncludeLeafArrays\",\"operandAliasMap\",\"double\",\"string\",\"object\",\"array\",\"binData\",\"objectId\",\"bool\",\"date\",\"null\",\"regex\",\"dbPointer\",\"javascript\",\"symbol\",\"javascriptWithScope\",\"int\",\"timestamp\",\"long\",\"decimal\",\"minKey\",\"maxKey\",\"call\",\"concat\",\"_f\",\"_type\",\"$bitsAllSet\",\"mask\",\"getOperandBitmask\",\"bitmask\",\"getValueBitmask\",\"every\",\"byte\",\"i\",\"$bitsAnySet\",\"$bitsAllClear\",\"$bitsAnyClear\",\"$regex\",\"valueSelector\",\"regexp\",\"$options\",\"test\",\"source\",\"$elemMatch\",\"_isPlainObject\",\"isDocMatcher\",\"keys\",\"filter\",\"key\",\"LOGICAL_OPERATORS\",\"reduce\",\"a\",\"b\",\"assign\",\"[object Object]\",\"subMatcher\",\"inElemMatch\",\"compileValueSelector\",\"arrayElement\",\"arg\",\"dontIterate\",\"result\",\"$and\",\"subSelector\",\"andDocumentMatchers\",\"compileArrayOfDocumentSelectors\",\"$or\",\"matchers\",\"doc\",\"fn\",\"$nor\",\"$where\",\"selectorValue\",\"_recordPathUsed\",\"_hasWhere\",\"Function\",\"$comment\",\"VALUE_OPERATORS\",\"$eq\",\"convertElementMatcherToBranchedMatcher\",\"$not\",\"invertBranchedMatcher\",\"$ne\",\"$nin\",\"$exists\",\"exists\",\"everythingMatcher\",\"$maxDistance\",\"$near\",\"$all\",\"branchedMatchers\",\"criterion\",\"andBranchedMatchers\",\"isRoot\",\"maxDistance\",\"point\",\"distance\",\"_hasGeoQuery\",\"$geometry\",\"type\",\"GeoJSON\",\"pointDistance\",\"geometryWithinRadius\",\"coordinates\",\"pointToArray\",\"distanceCoordinatePairs\",\"branchedValues\",\"branch\",\"curDistance\",\"_isUpdate\",\"arrayIndices\",\"andSomeMatchers\",\"subMatchers\",\"docOrBranches\",\"match\",\"subResult\",\"selectors\",\"docSelector\",\"options\",\"arguments\",\"docMatchers\",\"substr\",\"_isSimple\",\"lookUpByIndex\",\"valueMatcher\",\"Boolean\",\"operatorBranchedMatcher\",\"elementMatcher\",\"branches\",\"expanded\",\"element\",\"matched\",\"pointA\",\"pointB\",\"Math\",\"hypot\",\"elementSelector\",\"_equal\",\"docOrBranchedValues\",\"skipTheArrays\",\"branchesOut\",\"forEach\",\"thisIsArray\",\"push\",\"selector\",\"Number\",\"isInteger\",\"Uint8Array\",\"Int32Array\",\"buffer\",\"EJSON\",\"isBinary\",\"x\",\"ArrayBuffer\",\"max\",\"view\",\"isSafeInteger\",\"Uint32Array\",\"BYTES_PER_ELEMENT\",\"insertIntoDocument\",\"document\",\"existingKey\",\"indexOf\",\"branchedMatcher\",\"branchValues\",\"obj\",\"s\",\"inconsistentOK\",\"theseAreOperators\",\"selKey\",\"thisIsOperator\",\"JSON\",\"stringify\",\"cmpValueComparator\",\"operandType\",\"_cmp\",\"parts\",\"split\",\"firstPart\",\"lookupRest\",\"slice\",\"join\",\"omitUnnecessaryFields\",\"firstLevel\",\"appendToResult\",\"more\",\"forSort\",\"arrayIndex\",\"operatorMatchers\",\"operator\",\"simpleRange\",\"includes\",\"simpleEquality\",\"simpleInclusion\",\"paths\",\"newLeafFn\",\"conflictFn\",\"root\",\"path\",\"pathArray\",\"tree\",\"success\",\"lastKey\",\"y\",\"populateDocumentWithKeyValue\",\"getPrototypeOf\",\"populateDocumentWithObject\",\"unprefixedKeys\",\"op\",\"validateObject\",\"query\",\"_selectorIsId\",\"fields\",\"fieldsKeys\",\"sort\",\"_id\",\"including\",\"keyPath\",\"rule\",\"MinimongoError\",\"projectionRulesTree\",\"node\",\"fullPath\",\"currentPath\",\"anotherPath\",\"toString\",\"lastIndex\",\"validateKeyInPath\",\"MinimongoTest\",\"message\",\"field\",\"error\",\"name\",\"Cursor\",\"constructor\",\"collection\",\"this\",\"sorter\",\"Minimongo\",\"Matcher\",\"_selectorIsIdPerhapsAsObject\",\"_selectorId\",\"hasGeoQuery\",\"Sorter\",\"skip\",\"limit\",\"_projectionFn\",\"_compileProjection\",\"_transform\",\"wrapTransform\",\"transform\",\"Tracker\",\"reactive\",\"count\",\"applySkipLimit\",\"_depend\",\"added\",\"removed\",\"_getRawObjects\",\"ordered\",\"fetch\",\"Symbol\",\"iterator\",\"addedBefore\",\"changed\",\"movedBefore\",\"index\",\"objects\",\"next\",\"done\",\"callback\",\"thisArg\",\"getTransform\",\"observe\",\"_observeFromObserveChanges\",\"observeChanges\",\"_observeChangesCallbacksAreOrdered\",\"_allow_unordered\",\"distances\",\"_IdMap\",\"cursor\",\"dirty\",\"projectionFn\",\"resultsSnapshot\",\"qid\",\"next_qid\",\"queries\",\"results\",\"paused\",\"wrapCallback\",\"self\",\"args\",\"_observeQueue\",\"queueTask\",\"apply\",\"_suppress_initial\",\"clone\",\"handle\",\"ObserveHandle\",\"stop\",\"active\",\"onInvalidate\",\"drain\",\"rewind\",\"changers\",\"dependency\",\"Dependency\",\"notify\",\"bind\",\"depend\",\"_getCollectionName\",\"selectedDoc\",\"_docs\",\"get\",\"set\",\"clear\",\"id\",\"matchResult\",\"documentMatches\",\"getComparator\",\"_publishCursor\",\"subscription\",\"Package\",\"mongo\",\"Mongo\",\"Collection\",\"Meteor\",\"_SynchronousQueue\",\"create\",\"_savedOriginals\",\"find\",\"findOne\",\"insert\",\"assertHasValidFieldNames\",\"_useOID\",\"MongoID\",\"ObjectID\",\"Random\",\"has\",\"_saveOriginal\",\"queriesToRecompute\",\"_insertInResults\",\"_recomputeResults\",\"defer\",\"pauseObservers\",\"remove\",\"equals\",\"size\",\"_eachPossiblyMatchingDoc\",\"queryRemove\",\"removeId\",\"removeDoc\",\"_removeFromResults\",\"resumeObservers\",\"_diffQueryChanges\",\"retrieveOriginals\",\"originals\",\"saveOriginals\",\"update\",\"mod\",\"qidToOriginalResults\",\"docMap\",\"idsMatched\",\"_idsMatchedBySelector\",\"memoizedCloneIfNeeded\",\"docToMemoize\",\"recomputeQids\",\"updateCount\",\"insertedId\",\"queryResult\",\"_modifyAndNotify\",\"multi\",\"upsert\",\"_createUpsertDocument\",\"_returnObject\",\"numberAffected\",\"specificIds\",\"matched_before\",\"old_doc\",\"_modify\",\"afterMatch\",\"after\",\"before\",\"_updateInResults\",\"oldResults\",\"_CachingChangeObserver\",\"orderedFromCallbacks\",\"callbacks\",\"docs\",\"OrderedDict\",\"idStringify\",\"applyChange\",\"putBefore\",\"moveBefore\",\"DiffSequence\",\"applyChanges\",\"IdMap\",\"super\",\"idParse\",\"__wrappedTransform__\",\"wrapped\",\"transformed\",\"nonreactive\",\"_binarySearch\",\"cmp\",\"first\",\"range\",\"halfRange\",\"floor\",\"_checkSupportedProjection\",\"_idProjection\",\"details\",\"ruleTree\",\"subdoc\",\"modifier\",\"selectorDocument\",\"isModify\",\"_isModificationMod\",\"newDoc\",\"$set\",\"isInsert\",\"replacement\",\"_diffObjects\",\"left\",\"right\",\"diffObjects\",\"newResults\",\"observer\",\"diffQueryChanges\",\"_diffQueryOrderedChanges\",\"diffQueryOrderedChanges\",\"_diffQueryUnorderedChanges\",\"diffQueryUnorderedChanges\",\"_findInOrderedResults\",\"subIds\",\"_insertInSortedList\",\"splice\",\"isReplace\",\"isModifier\",\"setOnInsert\",\"modFunc\",\"MODIFIERS\",\"keypath\",\"keyparts\",\"target\",\"findModTarget\",\"forbidArray\",\"noCreate\",\"NO_CREATE_MODIFIERS\",\"pop\",\"observeCallbacks\",\"suppressed\",\"observeChangesCallbacks\",\"_observeCallbacksAreOrdered\",\"indices\",\"_no_indices\",\"addedAt\",\"changedAt\",\"oldDoc\",\"movedTo\",\"from\",\"to\",\"removedAt\",\"changeObserver\",\"changedFields\",\"makeChangedFields\",\"old_idx\",\"new_idx\",\"$currentDate\",\"Date\",\"$min\",\"$max\",\"$inc\",\"setPropertyError\",\"$setOnInsert\",\"$unset\",\"$push\",\"$each\",\"toPush\",\"position\",\"$position\",\"$slice\",\"sortFunction\",\"$sort\",\"spliceArguments\",\"$pushAll\",\"$addToSet\",\"isEach\",\"values\",\"toAdd\",\"$pop\",\"toPop\",\"$pull\",\"toPull\",\"out\",\"$pullAll\",\"$rename\",\"target2\",\"$bit\",\"$v\",\"invalidCharMsg\",\"$\",\".\",\"\\u0000\",\"assertIsValidFieldName\",\"usedArrayIndex\",\"last\",\"keypart\",\"parseInt\",\"isUpdate\",\"_paths\",\"_matchingDocument\",\"_selector\",\"_docMatcher\",\"_compileSelector\",\"hasWhere\",\"isSimple\",\"_getPaths\",\"keyOrderSensitive\",\"_typeorder\",\"t\",\"ta\",\"tb\",\"oa\",\"ob\",\"toHexString\",\"getTime\",\"toArray\",\"LocalCollection_\",\"spec\",\"_sortSpecParts\",\"_sortFunction\",\"addSpecPart\",\"ascending\",\"charAt\",\"lookup\",\"affectedByModifier\",\"_selectorForAffectedByModifier\",\"_keyComparator\",\"composeComparators\",\"_keyFieldComparator\",\"_getBaseComparator\",\"_compareKeys\",\"key1\",\"key2\",\"_generateKeysFromDoc\",\"cb\",\"pathFromIndices\",\"knownPaths\",\"valuesByIndexAndPath\",\"usedPaths\",\"soleKey\",\"doc1\",\"doc2\",\"_getMinKeyFromDoc\",\"part\",\"invert\",\"compare\",\"comparatorArray\"],\"mappings\":\"mjBAAAA,EAAOC,KAAK,sDCAyjB,IAAIC,EAAzkBF,EAAOG,QAAQC,OAAO,IAAIA,EAAOC,kBAAkB,IAAIA,EAAkBC,wBAAwB,IAAIA,EAAwBC,uBAAuB,IAAIA,EAAuBC,uBAAuB,IAAIA,EAAuBC,YAAY,IAAIA,EAAYC,aAAa,IAAIA,EAAaC,iBAAiB,IAAIA,EAAiBC,mBAAmB,IAAIA,EAAmBC,eAAe,IAAIA,EAAeC,YAAY,IAAIA,EAAYC,gCAAgC,IAAIA,EAAgCC,kBAAkB,IAAIA,EAAkBC,qBAAqB,IAAIA,IAA2CjB,EAAOC,KAAK,yBAAyBiB,QAAQC,GAAGjB,EAAgBiB,IAAI,GAEtpB,MAAMf,EAASgB,OAAOC,UAAUC,eAc1BjB,GACXkB,IAAKC,EAAeC,GAAYA,EAAW,GAC3CC,IAAKF,EAAeC,GAAYA,EAAW,GAC3CE,KAAMH,EAAeC,GAAYA,GAAY,GAC7CG,KAAMJ,EAAeC,GAAYA,GAAY,GAC7CI,MACEC,uBAAuBC,GACrB,IAAMC,MAAMC,QAAQF,IAA+B,IAAnBA,EAAQG,QACT,iBAAfH,EAAQ,IACO,iBAAfA,EAAQ,GACtB,MAAMI,MAAM,oDAId,MAAMC,EAAUL,EAAQ,GAClBM,EAAYN,EAAQ,GAC1B,OAAOO,GACY,iBAAVA,GAAsBA,EAAQF,IAAYC,IAIvDE,KACET,uBAAuBC,GACrB,IAAKC,MAAMC,QAAQF,GACjB,MAAMI,MAAM,sBAGd,MAAMK,EAAkBT,EAAQU,IAAIC,IAClC,GAAIA,aAAkBC,OACpB,OAAO1B,EAAqByB,GAG9B,GAAI/B,EAAiB+B,GACnB,MAAMP,MAAM,2BAGd,OAAO5B,EAAuBmC,KAGhC,OAAOJ,SAESM,IAAVN,IACFA,EAAQ,MAGHE,EAAgBK,KAAKC,GAAWA,EAAQR,OAIrDS,OAIEC,sBAAsB,EACtBlB,uBAAuBC,GACrB,GAAuB,iBAAZA,EAGTA,EAAU,OACL,GAAuB,iBAAZA,EAChB,MAAMI,MAAM,wBAGd,OAAOG,GAASN,MAAMC,QAAQK,IAAUA,EAAMJ,SAAWH,IAG7DkB,OAKEC,uBAAuB,EACvBpB,uBAAuBC,GACrB,GAAuB,iBAAZA,EAAsB,CAC/B,MAAMoB,GACJC,OAAU,EACVC,OAAU,EACVC,OAAU,EACVC,MAAS,EACTC,QAAW,EACXZ,UAAa,EACba,SAAY,EACZC,KAAQ,EACRC,KAAQ,EACRC,KAAQ,GACRC,MAAS,GACTC,UAAa,GACbC,WAAc,GACdC,OAAU,GACVC,oBAAuB,GACvBC,IAAO,GACPC,UAAa,GACbC,KAAQ,GACRC,QAAW,GACXC,QAAW,EACXC,OAAU,KAEZ,IAAKnE,EAAOoE,KAAKrB,EAAiBpB,GAChC,MAAMI,MAAK,mCAAAsC,OAAoC1C,IAEjDA,EAAUoB,EAAgBpB,OACrB,CAAA,GAAuB,iBAAZA,EAMhB,MAAMI,MAAM,iDALZ,GAAgB,IAAZJ,GAAiBA,GAAW,GAC1BA,EAAU,IAAkB,MAAZA,EACpB,MAAMI,MAAK,iCAAAsC,OAAkC1C,IAMjD,OAAOO,QACKM,IAAVN,GAAuBpC,EAAgBwE,GAAGC,MAAMrC,KAAWP,IAIjE6C,aACE9C,uBAAuBC,GACrB,MAAM8C,EAAOC,EAAkB/C,EAAS,eACxC,OAAOO,IACL,MAAMyC,EAAUC,EAAgB1C,EAAOuC,EAAK3C,QAC5C,OAAO6C,GAAWF,EAAKI,MAAM,CAACC,EAAMC,KAAOJ,EAAQI,GAAKD,KAAUA,MAIxEE,aACEtD,uBAAuBC,GACrB,MAAM8C,EAAOC,EAAkB/C,EAAS,eACxC,OAAOO,IACL,MAAMyC,EAAUC,EAAgB1C,EAAOuC,EAAK3C,QAC5C,OAAO6C,GAAWF,EAAKhC,KAAK,CAACqC,EAAMC,MAAQJ,EAAQI,GAAKD,KAAUA,MAIxEG,eACEvD,uBAAuBC,GACrB,MAAM8C,EAAOC,EAAkB/C,EAAS,iBACxC,OAAOO,IACL,MAAMyC,EAAUC,EAAgB1C,EAAOuC,EAAK3C,QAC5C,OAAO6C,GAAWF,EAAKI,MAAM,CAACC,EAAMC,MAAQJ,EAAQI,GAAKD,OAI/DI,eACExD,uBAAuBC,GACrB,MAAM8C,EAAOC,EAAkB/C,EAAS,iBACxC,OAAOO,IACL,MAAMyC,EAAUC,EAAgB1C,EAAOuC,EAAK3C,QAC5C,OAAO6C,GAAWF,EAAKhC,KAAK,CAACqC,EAAMC,KAAOJ,EAAQI,GAAKD,KAAUA,MAIvEK,QACEzD,uBAAuBC,EAASyD,GAC9B,KAAyB,iBAAZzD,GAAwBA,aAAmBY,QACtD,MAAMR,MAAM,uCAGd,IAAIsD,EACJ,QAA+B7C,IAA3B4C,EAAcE,SAAwB,CAOxC,GAAI,SAASC,KAAKH,EAAcE,UAC9B,MAAM,IAAIvD,MAAM,qDAGlB,MAAMyD,EAAS7D,aAAmBY,OAASZ,EAAQ6D,OAAS7D,EAC5D0D,EAAS,IAAI9C,OAAOiD,EAAQJ,EAAcE,eAE1CD,EADS1D,aAAmBY,OACnBZ,EAEA,IAAIY,OAAOZ,GAGtB,OAAOd,EAAqBwE,KAGhCI,YACE7C,sBAAsB,EACtBlB,uBAAuBC,EAASyD,EAAe1C,GAC7C,IAAK5C,EAAgB4F,eAAe/D,GAClC,MAAMI,MAAM,6BAGd,MAAM4D,GAAgBpF,EACpBS,OAAO4E,KAAKjE,GACTkE,OAAOC,IAAQ9F,EAAOoE,KAAK2B,EAAmBD,IAC9CE,OAAO,CAACC,EAAGC,IAAMlF,OAAOmF,OAAOF,GAAIG,CAACF,GAAIvE,EAAQuE,UACnD,GAEF,IAAIG,EAYJ,OANEA,EALEV,EAMAzF,EAAwByB,EAASe,GAAU4D,aAAa,IAE7CC,EAAqB5E,EAASe,GAGtCR,IACL,IAAKN,MAAMC,QAAQK,GACjB,OAAO,EAGT,IAAK,IAAI6C,EAAI,EAAGA,EAAI7C,EAAMJ,SAAUiD,EAAG,CACrC,MAAMyB,EAAetE,EAAM6C,GAC3B,IAAI0B,EACJ,GAAId,EAAc,CAIhB,IAAKtF,EAAYmG,GACf,OAAO,EAGTC,EAAMD,OAINC,IAAQvE,MAAOsE,EAAcE,aAAa,IAG5C,GAAIL,EAAWI,GAAKE,OAClB,OAAO5B,EAIX,OAAO,MAOTgB,GACJa,KAAI,CAACC,EAAanE,EAAS4D,IAClBQ,EACLC,EAAgCF,EAAanE,EAAS4D,IAI1DU,IAAIH,EAAanE,EAAS4D,GACxB,MAAMW,EAAWF,EACfF,EACAnE,EACA4D,GAKF,OAAwB,IAApBW,EAASnF,OACJmF,EAAS,GAGXC,IACL,MAAMP,EAASM,EAASxE,KAAK0E,GAAMA,EAAGD,GAAKP,QAG3C,OAAQA,OAAAA,KAIZS,KAAKP,EAAanE,EAAS4D,GACzB,MAAMW,EAAWF,EACfF,EACAnE,EACA4D,GAEF,OAAOY,IACL,MAAMP,EAASM,EAASpC,MAAMsC,IAAOA,EAAGD,GAAKP,QAG7C,OAAQA,OAAAA,KAIZU,OAAM,CAACC,EAAe5E,KAEpBA,EAAQ6E,gBAAgB,IACxB7E,EAAQ8E,WAAY,EAEdF,aAAyBG,WAG7BH,EAAgBG,SAAS,MAAD,UAAApD,OAAkBiD,KAKrCJ,KAASP,OAAQW,EAAclD,KAAK8C,EAAKA,MAKlDQ,SAAQ,IACC,MAAQf,QAAQ,KAQrBgB,GACJC,IAAIjG,GACKkG,EACL1H,EAAuBwB,IAG3BmG,KAAI,CAACnG,EAASyD,EAAe1C,IACpBqF,EAAsBxB,EAAqB5E,EAASe,IAE7DsF,IAAIrG,GACKoG,EACLF,EAAuC1H,EAAuBwB,KAGlEsG,KAAKtG,GACIoG,EACLF,EACE5H,EAAkBkC,IAAIT,uBAAuBC,KAInDuG,QAAQvG,GACN,MAAMwG,EAASN,EACb3F,QAAmBM,IAAVN,GAEX,OAAOP,EAAUwG,EAASJ,EAAsBI,IAGlD7C,SAAS3D,EAASyD,GAChB,IAAKpF,EAAOoE,KAAKgB,EAAe,UAC9B,MAAMrD,MAAM,2BAGd,OAAOqG,GAGTC,aAAa1G,EAASyD,GACpB,IAAKA,EAAckD,MACjB,MAAMvG,MAAM,8BAGd,OAAOqG,GAETG,KAAK5G,EAASyD,EAAe1C,GAC3B,IAAKd,MAAMC,QAAQF,GACjB,MAAMI,MAAM,uBAId,GAAuB,IAAnBJ,EAAQG,OACV,OAAOrB,EAGT,MAAM+H,EAAmB7G,EAAQU,IAAIoG,IAEnC,GAAIlI,EAAiBkI,GACnB,MAAM1G,MAAM,4BAId,OAAOwE,EAAqBkC,EAAW/F,KAKzC,OAAOgG,EAAoBF,IAE7BF,MAAM3G,EAASyD,EAAe1C,EAASiG,GACrC,IAAKA,EACH,MAAM5G,MAAM,4CASd,IAAI6G,EAAaC,EAAOC,EACxB,GAPApG,EAAQqG,cAAe,EAOnBjJ,EAAgB4F,eAAe/D,IAAY3B,EAAOoE,KAAKzC,EAAS,aAElEiH,EAAcjH,EAAQ0G,aACtBQ,EAAQlH,EAAQqH,UAChBF,EAAW5G,CAAAA,GAIJA,EAIAA,EAAM+G,KAOQ,UAAf/G,EAAM+G,KACDC,EAAQC,cAAcN,EAAO3G,GAG/BgH,EAAQE,qBAAqBlH,EAAO2G,EAAOD,GAC9C,EACAA,EAAc,EAZTM,EAAQC,cACbN,GACCI,KAAM,QAASI,YAAaC,EAAapH,KANrC,UAkBN,CAGL,GAFA0G,EAAcxD,EAAciD,cAEvBhI,EAAYsB,GACf,MAAMI,MAAM,qDAGd8G,EAAQS,EAAa3H,GAErBmH,EAAW5G,CAAAA,GACJ7B,EAAY6B,GAIVqH,EAAwBV,EAAO3G,GAH7B,MAOb,OAAOsH,IASL,MAAM7C,GAAUA,QAAQ,GAmCxB,OAlCAvG,EAAuBoJ,GAAgB3E,MAAM4E,IAG3C,IAAIC,EACJ,IAAKhH,EAAQiH,UAAW,CACtB,GAA8B,iBAAjBF,EAAOvH,MAClB,OAAO,EAMT,GAAoB,QAHpBwH,EAAcZ,EAASW,EAAOvH,SAGFwH,EAAcd,EACxC,OAAO,EAIT,QAAwBpG,IAApBmE,EAAOmC,UAA0BnC,EAAOmC,UAAYY,EACtD,OAAO,EAaX,OATA/C,EAAOA,QAAS,EAChBA,EAAOmC,SAAWY,EAEdD,EAAOG,aACTjD,EAAOiD,aAAeH,EAAOG,oBAEtBjD,EAAOiD,cAGRlH,EAAQiH,YAGXhD,KASb,SAASkD,EAAgBC,GACvB,OAA2B,IAAvBA,EAAYhI,OACPsG,EAGkB,IAAvB0B,EAAYhI,OACPgI,EAAY,GAGdC,IACL,MAAMC,KA8BN,OA7BAA,EAAMrD,OAASmD,EAAYjF,MAAMsC,IAC/B,MAAM8C,EAAY9C,EAAG4C,GAmBrB,OAbIE,EAAUtD,aACanE,IAAvByH,EAAUnB,eACStG,IAAnBwH,EAAMlB,WACRkB,EAAMlB,SAAWmB,EAAUnB,UAMzBmB,EAAUtD,QAAUsD,EAAUL,eAChCI,EAAMJ,aAAeK,EAAUL,cAG1BK,EAAUtD,SAIdqD,EAAMrD,gBACFqD,EAAMlB,gBACNkB,EAAMJ,cAGRI,GAIX,MAAMlD,EAAsB+C,EACtBnB,EAAsBmB,EAE5B,SAAS9C,EAAgCmD,EAAWxH,EAAS4D,GAC3D,IAAK1E,MAAMC,QAAQqI,IAAmC,IAArBA,EAAUpI,OACzC,MAAMC,MAAM,wCAGd,OAAOmI,EAAU7H,IAAIwE,IACnB,IAAK/G,EAAgB4F,eAAemB,GAClC,MAAM9E,MAAM,iDAGd,OAAO7B,EAAwB2G,EAAanE,GAAU4D,YAAAA,MAWnD,SAASpG,EAAwBiK,EAAazH,GAAuB,IAAd0H,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAC1E,MAAMC,EAActJ,OAAO4E,KAAKuE,GAAa9H,IAAIyD,IAC/C,MAAMe,EAAcsD,EAAYrE,GAEhC,GAAyB,MAArBA,EAAIyE,OAAO,EAAG,GAAY,CAG5B,IAAKvK,EAAOoE,KAAK2B,EAAmBD,GAClC,MAAM,IAAI/D,MAAJ,kCAAAsC,OAA4CyB,IAIpD,OADApD,EAAQ8H,WAAY,EACbzE,EAAkBD,GAAKe,EAAanE,EAAS0H,EAAQ9D,aAa9D,GAPK8D,EAAQ9D,aACX5D,EAAQ6E,gBAAgBzB,GAMC,mBAAhBe,EACT,OAGF,MAAM4D,EAAgBjK,EAAmBsF,GACnC4E,EAAenE,EACnBM,EACAnE,EACA0H,EAAQzB,QAGV,OAAOzB,GAAOwD,EAAaD,EAAcvD,MACxCrB,OAAO8E,SAEV,OAAO7D,EAAoBwD,GAO7B,SAAS/D,EAAqBnB,EAAe1C,EAASiG,GACpD,OAAIvD,aAAyB7C,QAC3BG,EAAQ8H,WAAY,EACb3C,EACLhH,EAAqBuE,KAIrB7E,EAAiB6E,GACZwF,EAAwBxF,EAAe1C,EAASiG,GAGlDd,EACL1H,EAAuBiF,IAO3B,SAASyC,EAAuCgD,GAA8B,IAAdT,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAC5E,OAAOS,IACL,MAAMC,EAAWX,EAAQxH,qBACrBkI,EACA1K,EAAuB0K,EAAUV,EAAQtH,uBAEvCkH,KA0BN,OAzBAA,EAAMrD,OAASoE,EAAStI,KAAKuI,IAC3B,IAAIC,EAAUJ,EAAeG,EAAQ9I,OAqBrC,MAjBuB,iBAAZ+I,IAIJD,EAAQpB,eACXoB,EAAQpB,cAAgBqB,IAG1BA,GAAU,GAKRA,GAAWD,EAAQpB,eACrBI,EAAMJ,aAAeoB,EAAQpB,cAGxBqB,IAGFjB,GAKX,SAAST,EAAwBtD,EAAGC,GAClC,MAAMgF,EAAS5B,EAAarD,GACtBkF,EAAS7B,EAAapD,GAE5B,OAAOkF,KAAKC,MAAMH,EAAO,GAAKC,EAAO,GAAID,EAAO,GAAKC,EAAO,IAKvD,SAAShL,EAAuBmL,GACrC,GAAI/K,EAAiB+K,GACnB,MAAMvJ,MAAM,0DAOd,OAAuB,MAAnBuJ,EACKpJ,GAAkB,MAATA,EAGXA,GAASpC,EAAgBwE,GAAGiH,OAAOD,EAAiBpJ,GAG7D,SAASkG,EAAkBoD,GACzB,OAAQ7E,QAAQ,GAGX,SAASvG,EAAuB0K,EAAUW,GAC/C,MAAMC,KAuBN,OArBAZ,EAASa,QAAQlC,IACf,MAAMmC,EAAchK,MAAMC,QAAQ4H,EAAOvH,OAMnCuJ,GAAiBG,IAAgBnC,EAAO/C,aAC5CgF,EAAYG,MAAMjC,aAAcH,EAAOG,aAAc1H,MAAOuH,EAAOvH,QAGjE0J,IAAgBnC,EAAO/C,aACzB+C,EAAOvH,MAAMyJ,QAAQ,CAACzJ,EAAO6C,KAC3B2G,EAAYG,MACVjC,cAAeH,EAAOG,kBAAoBvF,OAAOU,GACjD7C,MAAAA,QAMDwJ,EAIT,SAAShH,EAAkB/C,EAASmK,GAKlC,GAAIC,OAAOC,UAAUrK,IAAYA,GAAW,EAC1C,OAAO,IAAIsK,WAAW,IAAIC,YAAYvK,IAAUwK,QAKlD,GAAIC,EAAMC,SAAS1K,GACjB,OAAO,IAAIsK,WAAWtK,EAAQwK,QAMhC,GAAIvK,MAAMC,QAAQF,IACdA,EAAQkD,MAAMyH,GAAKP,OAAOC,UAAUM,IAAMA,GAAK,GAAI,CACrD,MAAMH,EAAS,IAAII,YAA0C,GAA7BnB,KAAKoB,OAAO7K,IAAY,IAClD8K,EAAO,IAAIR,WAAWE,GAM5B,OAJAxK,EAAQgK,QAAQW,IACdG,EAAKH,GAAK,IAAM,IAAU,EAAJA,KAGjBG,EAIT,MAAM1K,MACJ,cAAAsC,OAAcyH,EAAd,mDACA,iHAKJ,SAASlH,EAAgB1C,EAAOJ,GAK9B,GAAIiK,OAAOW,cAAcxK,GAAQ,CAK/B,MAAMiK,EAAS,IAAII,YACjBnB,KAAKoB,IAAI1K,EAAQ,EAAI6K,YAAYC,oBAGnC,IAAIH,EAAO,IAAIE,YAAYR,EAAQ,EAAG,GAYtC,OAXAM,EAAK,GAAKvK,EAAK,WAA6B,EAC5CuK,EAAK,GAAKvK,EAAK,WAA6B,EAGxCA,EAAQ,IACVuK,EAAO,IAAIR,WAAWE,EAAQ,IACzBR,QAAQ,CAAC7G,EAAMC,KAClB0H,EAAK1H,GAAK,MAIP,IAAIkH,WAAWE,GAIxB,QAAIC,EAAMC,SAASnK,IACV,IAAI+J,WAAW/J,EAAMiK,QAUhC,SAASU,EAAmBC,EAAUhH,EAAK5D,GACzClB,OAAO4E,KAAKkH,GAAUnB,QAAQoB,IAC5B,GACGA,EAAYjL,OAASgE,EAAIhE,QAA6C,IAAnCiL,EAAYC,QAAZ,GAAA3I,OAAuByB,EAAvB,OACnCA,EAAIhE,OAASiL,EAAYjL,QAA6C,IAAnCgE,EAAIkH,QAAJ,GAAA3I,OAAe0I,EAAf,MAEpC,MAAM,IAAIhL,MACR,iDAAAsC,OAAiD0I,EAAjD,UAAA,IAAA1I,OACIyB,EADJ,kBAGG,GAAIiH,IAAgBjH,EACzB,MAAM,IAAI/D,MAAJ,2CAAAsC,OACuCyB,EADvC,yBAMVgH,EAAShH,GAAO5D,EAMlB,SAAS6F,EAAsBkF,GAC7B,OAAOC,KAIGvG,QAASsG,EAAgBC,GAAcvG,SAI5C,SAAStG,EAAY8M,GAC1B,OAAOvL,MAAMC,QAAQsL,IAAQrN,EAAgB4F,eAAeyH,GAGvD,SAAS7M,EAAa8M,GAC3B,MAAO,WAAW7H,KAAK6H,GAMlB,SAAS7M,EAAiB6E,EAAeiI,GAC9C,IAAKvN,EAAgB4F,eAAeN,GAClC,OAAO,EAGT,IAAIkI,OAAoB9K,EAiBxB,OAhBAxB,OAAO4E,KAAKR,GAAeuG,QAAQ4B,IACjC,MAAMC,EAAyC,MAAxBD,EAAOhD,OAAO,EAAG,GAExC,QAA0B/H,IAAtB8K,EACFA,EAAoBE,OACf,GAAIF,IAAsBE,EAAgB,CAC/C,IAAKH,EACH,MAAM,IAAItL,MAAJ,0BAAAsC,OACsBoJ,KAAKC,UAAUtI,KAI7CkI,GAAoB,OAIfA,EAIX,SAASlM,EAAeuM,GACtB,OACEjM,uBAAuBC,GAKrB,GAAIC,MAAMC,QAAQF,GAChB,MAAO,KAAM,OAKCa,IAAZb,IACFA,EAAU,MAGZ,MAAMiM,EAAc9N,EAAgBwE,GAAGC,MAAM5C,GAE7C,OAAOO,SACSM,IAAVN,IACFA,EAAQ,MAKNpC,EAAgBwE,GAAGC,MAAMrC,KAAW0L,GAIjCD,EAAmB7N,EAAgBwE,GAAGuJ,KAAK3L,EAAOP,OA0D1D,SAASnB,EAAmBsF,GAAmB,IAAdsE,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MACpD,MAAMyD,EAAQhI,EAAIiI,MAAM,KAClBC,EAAYF,EAAMhM,OAASgM,EAAM,GAAK,GACtCG,EACJH,EAAMhM,OAAS,GACftB,EAAmBsN,EAAMI,MAAM,GAAGC,KAAK,KAAM/D,GAGzCgE,EAAwBzH,IACvBA,EAAOD,oBACHC,EAAOD,YAGZC,EAAOiD,eAAiBjD,EAAOiD,aAAa9H,eACvC6E,EAAOiD,aAGTjD,GAKT,OAAO,SAACO,GAA2B,IAAtB0C,EAAsBS,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MACjC,GAAIzI,MAAMC,QAAQqF,GAAM,CAItB,KAAM5G,EAAa0N,IAAcA,EAAY9G,EAAIpF,QAC/C,SAMF8H,EAAeA,EAAavF,QAAQ2J,EAAW,KAIjD,MAAMK,EAAanH,EAAI8G,GAcvB,IAAKC,EACH,OAAQG,GACNxE,aAAAA,EACAlD,YAAa9E,MAAMC,QAAQqF,IAAQtF,MAAMC,QAAQwM,GACjDnM,MAAOmM,KAUX,IAAKhO,EAAYgO,GACf,OAAIzM,MAAMC,QAAQqF,OAIVkH,GAAuBxE,aAAAA,EAAc1H,WAAOM,KAGtD,MAAMmE,KACA2H,EAAiBC,IACrB5H,EAAOkF,QAAQ0C,IAgCjB,OA1BAD,EAAeL,EAAWI,EAAYzE,KAiBlChI,MAAMC,QAAQwM,IACZ/N,EAAawN,EAAM,KAAO1D,EAAQoE,SACtCH,EAAW1C,QAAQ,CAAClC,EAAQgF,KACtB3O,EAAgB4F,eAAe+D,IACjC6E,EAAeL,EAAWxE,EAAQG,EAAavF,OAAOoK,OAKrD9H,GAiBJ,SAASlG,EAAe+K,GAC7B,OAAQ7E,QAAQ,GAKlB,SAASiE,EAAwBxF,EAAe1C,EAASiG,GAIvD,MAAM+F,EAAmB1N,OAAO4E,KAAKR,GAAe/C,IAAIsM,IACtD,MAAMhN,EAAUyD,EAAcuJ,GAExBC,GACH,MAAO,OAAQ,MAAO,QAAQC,SAASF,IACrB,iBAAZhN,EAGHmN,GACH,MAAO,OAAOD,SAASF,IACxBhN,IAAYX,OAAOW,GAGfoN,GACH,MAAO,QAAQF,SAASF,IACtB/M,MAAMC,QAAQF,KACbA,EAAQc,KAAK6J,GAAKA,IAAMtL,OAAOsL,IAOrC,GAJMsC,GAAeG,GAAmBD,IACtCpM,EAAQ8H,WAAY,GAGlBxK,EAAOoE,KAAKuD,EAAiBgH,GAC/B,OAAOhH,EAAgBgH,GAAUhN,EAASyD,EAAe1C,EAASiG,GAGpE,GAAI3I,EAAOoE,KAAKnE,EAAmB0O,GAAW,CAC5C,MAAMvE,EAAUnK,EAAkB0O,GAClC,OAAO9G,EACLuC,EAAQ1I,uBAAuBC,EAASyD,EAAe1C,GACvD0H,GAIJ,MAAM,IAAIrI,MAAJ,0BAAAsC,OAAoCsK,MAG5C,OAAOjG,EAAoBgG,GAYtB,SAAShO,EAAYsO,EAAOC,EAAWC,GAAuB,IAAXC,EAAW9E,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAqCnE,OApCA2E,EAAMrD,QAAQyD,IACZ,MAAMC,EAAYD,EAAKrB,MAAM,KAC7B,IAAIuB,EAAOH,EAGX,MAAMI,EAAUF,EAAUnB,MAAM,GAAI,GAAGrJ,MAAM,CAACiB,EAAKf,KACjD,GAAK/E,EAAOoE,KAAKkL,EAAMxJ,IAEhB,GAAIwJ,EAAKxJ,KAAS9E,OAAOsO,EAAKxJ,MACnCwJ,EAAKxJ,GAAOoJ,EACVI,EAAKxJ,GACLuJ,EAAUnB,MAAM,EAAGnJ,EAAI,GAAGoJ,KAAK,KAC/BiB,GAIEE,EAAKxJ,KAAS9E,OAAOsO,EAAKxJ,KAC5B,OAAO,OAVTwJ,EAAKxJ,MAgBP,OAFAwJ,EAAOA,EAAKxJ,IAEL,IAGT,GAAIyJ,EAAS,CACX,MAAMC,EAAUH,EAAUA,EAAUvN,OAAS,GACzC9B,EAAOoE,KAAKkL,EAAME,GACpBF,EAAKE,GAAWN,EAAWI,EAAKE,GAAUJ,EAAMA,GAEhDE,EAAKE,GAAWP,EAAUG,MAKzBD,EAMT,SAAS7F,EAAaT,GACpB,OAAOjH,MAAMC,QAAQgH,GAASA,EAAMqF,SAAWrF,EAAMyD,EAAGzD,EAAM4G,GAuBhE,SAASC,EAA6B5C,EAAUhH,EAAK5D,GAC/CA,GAASlB,OAAO2O,eAAezN,KAAWlB,OAAOC,UACnD2O,EAA2B9C,EAAUhH,EAAK5D,GAC/BA,aAAiBK,QAC5BsK,EAAmBC,EAAUhH,EAAK5D,GAMtC,SAAS0N,EAA2B9C,EAAUhH,EAAK5D,GACjD,MAAM0D,EAAO5E,OAAO4E,KAAK1D,GACnB2N,EAAiBjK,EAAKC,OAAOiK,GAAgB,MAAVA,EAAG,IAE5C,GAAID,EAAe/N,OAAS,IAAM8D,EAAK9D,OAAQ,CAG7C,GAAI8D,EAAK9D,SAAW+N,EAAe/N,OACjC,MAAM,IAAIC,MAAJ,qBAAAsC,OAA+BwL,EAAe,KAGtDE,EAAe7N,EAAO4D,GACtB+G,EAAmBC,EAAUhH,EAAK5D,QAElClB,OAAO4E,KAAK1D,GAAOyJ,QAAQmE,IACzB,MAAM5M,EAAShB,EAAM4N,GAEV,QAAPA,EACFJ,EAA6B5C,EAAUhH,EAAK5C,GAC5B,SAAP4M,GAET5M,EAAOyI,QAAQX,GACb0E,EAA6B5C,EAAUhH,EAAKkF,MAQ/C,SAASrK,EAAgCqP,GAAsB,IAAflD,EAAezC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MA4BpE,OA3BIrJ,OAAO2O,eAAeK,KAAWhP,OAAOC,UAE1CD,OAAO4E,KAAKoK,GAAOrE,QAAQ7F,IACzB,MAAM5D,EAAQ8N,EAAMlK,GAER,SAARA,EAEF5D,EAAMyJ,QAAQX,GACZrK,EAAgCqK,EAAS8B,IAE1B,QAARhH,EAEY,IAAjB5D,EAAMJ,QACRnB,EAAgCuB,EAAM,GAAI4K,GAExB,MAAXhH,EAAI,IAEb4J,EAA6B5C,EAAUhH,EAAK5D,KAK5CpC,EAAgBmQ,cAAcD,IAChCnD,EAAmBC,EAAU,MAAOkD,GAIjClD,EASF,SAASlM,EAAkBsP,GAIhC,IAAIC,EAAanP,OAAO4E,KAAKsK,GAAQE,OAQT,IAAtBD,EAAWrO,QAAkC,QAAlBqO,EAAW,IACtCA,EAAWtB,SAAS,QAAUqB,EAAOG,MACzCF,EAAaA,EAAWtK,OAAOC,GAAe,QAARA,IAGxC,IAAIwK,EAAY,KAEhBH,EAAWxE,QAAQ4E,IACjB,MAAMC,IAASN,EAAOK,GAOtB,GALkB,OAAdD,IACFA,EAAYE,GAIVF,IAAcE,EAChB,MAAMC,EACJ,8DAKN,MAAMC,EAAsBhQ,EAC1ByP,EACAf,GAAQkB,EACR,CAACK,EAAMvB,EAAMwB,KAiBX,MAAMC,EAAcD,EACdE,EAAc1B,EACpB,MAAMqB,EACJ,QAAApM,OAAQwM,EAAR,SAAAxM,OAA2ByM,EAA3B,6BACA,+FAKN,OAAQR,UAAAA,EAAWhB,KAAMoB,GAIpB,SAAS7P,EAAqBwE,GACnC,OAAOnD,GACDA,aAAiBK,OACZL,EAAM6O,aAAe1L,EAAO0L,WAIhB,iBAAV7O,IASXmD,EAAO2L,UAAY,EAEZ3L,EAAOE,KAAKrD,IAOvB,SAAS+O,EAAkBnL,EAAKsJ,GAC9B,GAAItJ,EAAI+I,SAAS,KACf,MAAM,IAAI9M,MAAJ,qBAAAsC,OACiByB,EADjB,UAAAzB,OAC6B+K,EAD7B,KAAA/K,OACqCyB,EADrC,+BAKR,GAAe,MAAXA,EAAI,GACN,MAAM,IAAI/D,MAAJ,mCAAAsC,OAC+B+K,EAD/B,KAAA/K,OACuCyB,EADvC,+BAOV,SAASiK,EAAe7M,EAAQkM,GAC1BlM,GAAUlC,OAAO2O,eAAezM,KAAYlC,OAAOC,WACrDD,OAAO4E,KAAK1C,GAAQyI,QAAQ7F,IAC1BmL,EAAkBnL,EAAKsJ,GACvBW,EAAe7M,EAAO4C,GAAMsJ,EAAO,IAAMtJ,KAtU/CoL,GAAiB1Q,mBAAAA,GACjBiQ,EAAiB,SAACU,GAA0B,IAAjB/G,EAAiBC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MACnB,iBAAZ8G,GAAwB/G,EAAQgH,QACzCD,GAAO,eAAA9M,OAAmB+F,EAAQgH,MAA3B,MAGT,MAAMC,EAAQ,IAAItP,MAAMoP,GAExB,OADAE,EAAMC,KAAO,iBACND,gCChkC2B,IAAIvR,EAA2FE,EAAnIJ,EAAOG,QAAQe,QAAQ,IAAIyQ,IAA6B3R,EAAOC,KAAK,yBAAyBiB,QAAQC,GAAGjB,EAAgBiB,IAAI,GAAcnB,EAAOC,KAAK,eAAeG,OAAOe,GAAGf,EAAOe,IAAI,SAKrKwQ,EAEnBC,YAAYC,EAAY3F,GAAwB,IAAd1B,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAC9CqH,KAAKD,WAAaA,EAClBC,KAAKC,OAAS,KACdD,KAAKhP,QAAU,IAAIkP,EAAUC,QAAQ/F,GAEjChM,EAAgBgS,6BAA6BhG,GAE/C4F,KAAKK,YAAc/R,EAAOoE,KAAK0H,EAAU,OACrCA,EAASuE,IACTvE,GAEJ4F,KAAKK,iBAAcvP,GAEfkP,KAAKhP,QAAQsP,eAAiB5H,EAAQgG,QACxCsB,KAAKC,OAAS,IAAIC,EAAUK,OAAO7H,EAAQgG,YAI/CsB,KAAKQ,KAAO9H,EAAQ8H,MAAQ,EAC5BR,KAAKS,MAAQ/H,EAAQ+H,MACrBT,KAAKxB,OAAS9F,EAAQ8F,OAEtBwB,KAAKU,cAAgBtS,EAAgBuS,mBAAmBX,KAAKxB,YAE7DwB,KAAKY,WAAaxS,EAAgByS,cAAcnI,EAAQoI,gBAGjC,IAAZC,IACTf,KAAKgB,cAAgClQ,IAArB4H,EAAQsI,UAAgCtI,EAAQsI,UAiBpEC,QAA6B,IAAvBC,IAAuBvI,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,KAAAA,UAAA,GAM3B,OALIqH,KAAKgB,UAEPhB,KAAKmB,SAASC,OAAO,EAAMC,SAAS,IAAO,GAGtCrB,KAAKsB,gBACVC,SAAS,EACTL,eAAAA,IACC9Q,OAWLoR,QACE,MAAMvM,KAMN,OAJA+K,KAAK/F,QAAQzE,IACXP,EAAOkF,KAAK3E,KAGPP,EAGTP,CAAC+M,OAAOC,YACF1B,KAAKgB,UACPhB,KAAKmB,SACHQ,aAAa,EACbN,SAAS,EACTO,SAAS,EACTC,aAAa,IAGjB,IAAIC,EAAQ,EACZ,MAAMC,EAAU/B,KAAKsB,gBAAgBC,SAAS,IAE9C,OACES,KAAM,KACJ,GAAIF,EAAQC,EAAQ3R,OAAQ,CAE1B,IAAIkJ,EAAU0G,KAAKU,cAAcqB,EAAQD,MAKzC,OAHI9B,KAAKY,aACPtH,EAAU0G,KAAKY,WAAWtH,KAEpB9I,MAAO8I,GAGjB,OAAQ2I,MAAM,KAwBpBhI,QAAQiI,EAAUC,GACZnC,KAAKgB,UACPhB,KAAKmB,SACHQ,aAAa,EACbN,SAAS,EACTO,SAAS,EACTC,aAAa,IAGjB7B,KAAKsB,gBAAgBC,SAAS,IAAOtH,QAAQ,CAACX,EAASjG,KAErDiG,EAAU0G,KAAKU,cAAcpH,GAEzB0G,KAAKY,aACPtH,EAAU0G,KAAKY,WAAWtH,IAG5B4I,EAASxP,KAAKyP,EAAS7I,EAASjG,EAAG2M,QAIvCoC,eACE,OAAOpC,KAAKY,WAgBdjQ,IAAIuR,EAAUC,GACZ,MAAMlN,KAMN,OAJA+K,KAAK/F,QAAQ,CAACzE,EAAKnC,KACjB4B,EAAOkF,KAAK+H,EAASxP,KAAKyP,EAAS3M,EAAKnC,EAAG2M,SAGtC/K,EAgCToN,QAAQ3J,GACN,OAAOtK,EAAgBkU,2BAA2BtC,KAAMtH,GAa1D6J,eAAe7J,GACb,MAAM6I,EAAUnT,EAAgBoU,mCAAmC9J,GAMnE,IAAKA,EAAQ+J,mBAAqBlB,IAAYvB,KAAKQ,MAAQR,KAAKS,OAC9D,MAAM,IAAIpQ,MACR,wIAKJ,GAAI2P,KAAKxB,SAA+B,IAApBwB,KAAKxB,OAAOG,MAAiC,IAApBqB,KAAKxB,OAAOG,KACvD,MAAMtO,MAAM,wDAGd,MAAMqS,EACJ1C,KAAKhP,QAAQsP,eACbiB,GACA,IAAInT,EAAgBuU,OAGhBrE,GACJsE,OAAQ5C,KACR6C,OAAO,EACPH,UAAAA,EACA1R,QAASgP,KAAKhP,QACduQ,QAAAA,EACAuB,aAAc9C,KAAKU,cACnBqC,gBAAiB,KACjB9C,OAAQsB,GAAWvB,KAAKC,QAG1B,IAAI+C,EAIAhD,KAAKgB,WACPgC,EAAMhD,KAAKD,WAAWkD,WACtBjD,KAAKD,WAAWmD,QAAQF,GAAO1E,GAGjCA,EAAM6E,QAAUnD,KAAKsB,gBAAgBC,QAAAA,EAASmB,UAAWpE,EAAMoE,YAE3D1C,KAAKD,WAAWqD,SAClB9E,EAAMyE,gBAAkBxB,KAAe,IAAInT,EAAgBuU,QAU7D,MAAMU,EAAe5N,IACnB,IAAKA,EACH,MAAO,OAGT,MAAM6N,EAAOtD,KACb,OAAO,WACL,GAAIsD,EAAKvD,WAAWqD,OAClB,OAGF,MAAMG,EAAO5K,UAEb2K,EAAKvD,WAAWyD,cAAcC,UAAU,KACtChO,EAAGiO,MAAM1D,KAAMuD,OAKrBjF,EAAM8C,MAAQiC,EAAa3K,EAAQ0I,OACnC9C,EAAMsD,QAAUyB,EAAa3K,EAAQkJ,SACrCtD,EAAM+C,QAAUgC,EAAa3K,EAAQ2I,SAEjCE,IACFjD,EAAMqD,YAAc0B,EAAa3K,EAAQiJ,aACzCrD,EAAMuD,YAAcwB,EAAa3K,EAAQmJ,cAGtCnJ,EAAQiL,mBAAsB3D,KAAKD,WAAWqD,QACjD9E,EAAM6E,QAAQlJ,QAAQzE,IACpB,MAAMgJ,EAAS9D,EAAMkJ,MAAMpO,UAEpBgJ,EAAOG,IAEV4C,GACFjD,EAAMqD,YAAYnM,EAAImJ,IAAKqB,KAAKU,cAAclC,GAAS,MAGzDF,EAAM8C,MAAM5L,EAAImJ,IAAKqB,KAAKU,cAAclC,MAI5C,MAAMqF,EAASvU,OAAOmF,OAAO,IAAIrG,EAAgB0V,eAC/C/D,WAAYC,KAAKD,WACjBgE,KAAM,KACA/D,KAAKgB,iBACAhB,KAAKD,WAAWmD,QAAQF,MAoBrC,OAfIhD,KAAKgB,UAAYD,EAAQiD,QAM3BjD,EAAQkD,aAAa,KACnBJ,EAAOE,SAMX/D,KAAKD,WAAWyD,cAAcU,QAEvBL,EAOTM,UAIAhD,QAAQiD,EAAU3B,GAChB,GAAI1B,EAAQiD,OAAQ,CAClB,MAAMK,EAAa,IAAItD,EAAQuD,WACzBC,EAASF,EAAWzC,QAAQ4C,KAAKH,GAEvCA,EAAWI,SAEX,MAAM/L,GAAW+J,iBAAAA,EAAkBkB,mBAAmB,IAErD,QAAS,cAAe,UAAW,cAAe,WAChD1J,QAAQxE,IACH2O,EAAS3O,KACXiD,EAAQjD,GAAM8O,KAKpBvE,KAAKuC,eAAe7J,IAIxBgM,qBACE,OAAO1E,KAAKD,WAAWH,KAoBzB0B,iBAA6B,IAAd5I,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAK3B,MAAMuI,GAA4C,IAA3BxI,EAAQwI,eAIzBiC,EAAUzK,EAAQ6I,WAAe,IAAInT,EAAgBuU,OAG3D,QAAyB7R,IAArBkP,KAAKK,YAA2B,CAGlC,GAAIa,GAAkBlB,KAAKQ,KACzB,OAAO2C,EAGT,MAAMwB,EAAc3E,KAAKD,WAAW6E,MAAMC,IAAI7E,KAAKK,aAUnD,OARIsE,IACEjM,EAAQ6I,QACV4B,EAAQhJ,KAAKwK,GAEbxB,EAAQ2B,IAAI9E,KAAKK,YAAasE,IAI3BxB,EAQT,IAAIT,EAwCJ,OAvCI1C,KAAKhP,QAAQsP,eAAiB5H,EAAQ6I,UACpC7I,EAAQgK,WACVA,EAAYhK,EAAQgK,WACVqC,QAEVrC,EAAY,IAAItU,EAAgBuU,QAIpC3C,KAAKD,WAAW6E,MAAM3K,QAAQ,CAACzE,EAAKwP,KAClC,MAAMC,EAAcjF,KAAKhP,QAAQkU,gBAAgB1P,GAejD,OAbIyP,EAAYhQ,SACVyD,EAAQ6I,SACV4B,EAAQhJ,KAAK3E,GAETkN,QAAsC5R,IAAzBmU,EAAY7N,UAC3BsL,EAAUoC,IAAIE,EAAIC,EAAY7N,WAGhC+L,EAAQ2B,IAAIE,EAAIxP,KAKf0L,KAOFlB,KAAKS,OACNT,KAAKQ,MACLR,KAAKC,QACLkD,EAAQ/S,SAAW4P,KAAKS,SAIvB/H,EAAQ6I,SAITvB,KAAKC,QACPkD,EAAQzE,KAAKsB,KAAKC,OAAOkF,eAAezC,UAAAA,KAKrCxB,IAAoBlB,KAAKS,OAAUT,KAAKQ,MAItC2C,EAAQ3G,MACbwD,KAAKQ,KACLR,KAAKS,MAAQT,KAAKS,MAAQT,KAAKQ,KAAO2C,EAAQ/S,QALvC+S,GAVAA,EAmBXiC,eAAeC,GAEb,IAAKC,QAAQC,MACX,MAAM,IAAIlV,MACR,6DAIJ,IAAK2P,KAAKD,WAAWH,KACnB,MAAM,IAAIvP,MACR,4DAIJ,OAAOiV,QAAQC,MAAMC,MAAMC,WAAWL,eACpCpF,KACAqF,EACArF,KAAKD,WAAWH,+CC/fuB,IAAIC,EAA+DiE,EAAqFxV,EAAOK,EAAYC,EAAaC,EAAiBI,EAAgCC,EAAtRhB,EAAOG,QAAQe,QAAQ,IAAIhB,IAA6BF,EAAOC,KAAK,eAAeiB,QAAQC,GAAGwQ,EAAOxQ,IAAI,GAAqBnB,EAAOC,KAAK,uBAAuBiB,QAAQC,GAAGyU,EAAczU,IAAI,GAA0GnB,EAAOC,KAAK,eAAeG,OAAOe,GAAGf,EAAOe,GAAGV,YAAYU,GAAGV,EAAYU,GAAGT,aAAaS,GAAGT,EAAaS,GAAGR,iBAAiBQ,GAAGR,EAAiBQ,GAAGJ,gCAAgCI,GAAGJ,EAAgCI,GAAGH,kBAAkBG,GAAGH,EAAkBG,IAAI,SAczhBjB,EACnB0R,YAAYF,GACVI,KAAKJ,KAAOA,EAEZI,KAAK4E,MAAQ,IAAIxW,EAAgBuU,OAEjC3C,KAAKwD,cAAgB,IAAIkC,EAAOC,kBAEhC3F,KAAKiD,SAAW,EAShBjD,KAAKkD,QAAU5T,OAAOsW,OAAO,MAI7B5F,KAAK6F,gBAAkB,KAGvB7F,KAAKoD,QAAS,EAqBhB0C,KAAK1L,EAAU1B,GAQb,OAJyB,IAArBC,UAAUvI,SACZgK,MAGK,IAAIhM,EAAgByR,OAAOG,KAAM5F,EAAU1B,GAGpDqN,QAAQ3L,GAAwB,IAAd1B,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAe9B,OAdyB,IAArBA,UAAUvI,SACZgK,MAWF1B,EAAQ+H,MAAQ,EAETT,KAAK8F,KAAK1L,EAAU1B,GAAS8I,QAAQ,GAK9CwE,OAAOxQ,EAAK0M,GAGV+D,EAFAzQ,EAAMkF,EAAMkJ,MAAMpO,IAMblH,EAAOoE,KAAK8C,EAAK,SACpBA,EAAImJ,IAAMvQ,EAAgB8X,QAAU,IAAIC,EAAQC,SAAaC,EAAOrB,MAGtE,MAAMA,EAAKxP,EAAImJ,IAEf,GAAIqB,KAAK4E,MAAM0B,IAAItB,GACjB,MAAMjG,EAAc,kBAAApM,OAAmBqS,EAAnB,MAGtBhF,KAAKuG,cAAcvB,OAAIlU,GACvBkP,KAAK4E,MAAME,IAAIE,EAAIxP,GAEnB,MAAMgR,KAyCN,OAtCAlX,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAE3B,GAAI1E,EAAMuE,MACR,OAGF,MAAMoC,EAAc3G,EAAMtN,QAAQkU,gBAAgB1P,GAE9CyP,EAAYhQ,SACVqJ,EAAMoE,gBAAsC5R,IAAzBmU,EAAY7N,UACjCkH,EAAMoE,UAAUoC,IAAIE,EAAIC,EAAY7N,UAGlCkH,EAAMsE,OAAOpC,MAAQlC,EAAMsE,OAAOnC,MACpC+F,EAAmBrM,KAAK6I,GAExB5U,EAAgBqY,iBAAiBnI,EAAO9I,MAK9CgR,EAAmBvM,QAAQ+I,IACrBhD,KAAKkD,QAAQF,IACfhD,KAAK0G,kBAAkB1G,KAAKkD,QAAQF,MAIxChD,KAAKwD,cAAcU,QAIfhC,GACFwD,EAAOiB,MAAM,KACXzE,EAAS,KAAM8C,KAIZA,EAKT4B,iBAEM5G,KAAKoD,SAKTpD,KAAKoD,QAAS,EAGd9T,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAC3B1E,EAAMyE,gBAAkBrI,EAAMkJ,MAAMtF,EAAM6E,YAI9C0D,OAAOzM,EAAU8H,GAIf,GAAIlC,KAAKoD,SAAWpD,KAAK6F,iBAAmBnL,EAAMoM,OAAO1M,MAAe,CACtE,MAAMnF,EAAS+K,KAAK4E,MAAMmC,OAoB1B,OAlBA/G,KAAK4E,MAAMG,QAEXzV,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,EAAMiD,QACRjD,EAAM6E,WAEN7E,EAAM6E,QAAQ4B,UAId7C,GACFwD,EAAOiB,MAAM,KACXzE,EAAS,KAAMjN,KAIZA,EAGT,MAAMjE,EAAU,IAAIkP,EAAUC,QAAQ/F,GAChCyM,KAEN7G,KAAKgH,yBAAyB5M,EAAU,CAAC5E,EAAKwP,KACxChU,EAAQkU,gBAAgB1P,GAAKP,QAC/B4R,EAAO1M,KAAK6K,KAIhB,MAAMwB,KACAS,KAEN,IAAK,IAAI5T,EAAI,EAAGA,EAAIwT,EAAOzW,OAAQiD,IAAK,CACtC,MAAM6T,EAAWL,EAAOxT,GAClB8T,EAAYnH,KAAK4E,MAAMC,IAAIqC,GAEjC5X,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,EAAMuE,OAINvE,EAAMtN,QAAQkU,gBAAgBiC,GAAWlS,SACvCqJ,EAAMsE,OAAOpC,MAAQlC,EAAMsE,OAAOnC,MACpC+F,EAAmBrM,KAAK6I,GAExBiE,EAAY9M,MAAM6I,IAAAA,EAAKxN,IAAK2R,OAKlCnH,KAAKuG,cAAcW,EAAUC,GAC7BnH,KAAK4E,MAAMiC,OAAOK,GAIpBD,EAAYhN,QAAQ4M,IAClB,MAAMvI,EAAQ0B,KAAKkD,QAAQ2D,EAAO7D,KAE9B1E,IACFA,EAAMoE,WAAapE,EAAMoE,UAAUmE,OAAOA,EAAOrR,IAAImJ,KACrDvQ,EAAgBgZ,mBAAmB9I,EAAOuI,EAAOrR,QAIrDgR,EAAmBvM,QAAQ+I,IACzB,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,GACF0B,KAAK0G,kBAAkBpI,KAI3B0B,KAAKwD,cAAcU,QAEnB,MAAMjP,EAAS4R,EAAOzW,OAQtB,OANI8R,GACFwD,EAAOiB,MAAM,KACXzE,EAAS,KAAMjN,KAIZA,EAOToS,kBAEOrH,KAAKoD,SAMVpD,KAAKoD,QAAS,EAEd9T,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,EAAMuE,OACRvE,EAAMuE,OAAQ,EAId7C,KAAK0G,kBAAkBpI,EAAOA,EAAMyE,kBAIpC3U,EAAgBkZ,kBACdhJ,EAAMiD,QACNjD,EAAMyE,gBACNzE,EAAM6E,QACN7E,GACCwE,aAAcxE,EAAMwE,eAIzBxE,EAAMyE,gBAAkB,OAG1B/C,KAAKwD,cAAcU,SAGrBqD,oBACE,IAAKvH,KAAK6F,gBACR,MAAM,IAAIxV,MAAM,kDAGlB,MAAMmX,EAAYxH,KAAK6F,gBAIvB,OAFA7F,KAAK6F,gBAAkB,KAEhB2B,EAUTC,gBACE,GAAIzH,KAAK6F,gBACP,MAAM,IAAIxV,MAAM,wDAGlB2P,KAAK6F,gBAAkB,IAAIzX,EAAgBuU,OAK7C+E,OAAOtN,EAAUuN,EAAKjP,EAASwJ,IACvBA,GAAYxJ,aAAmB3C,WACnCmM,EAAWxJ,EACXA,EAAU,MAGPA,IACHA,MAGF,MAAM1H,EAAU,IAAIkP,EAAUC,QAAQ/F,GAAU,GAO1CwN,KAIAC,EAAS,IAAIzZ,EAAgBuU,OAC7BmF,EAAa1Z,EAAgB2Z,sBAAsB3N,GAEzD9K,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAE3B,IAAK1E,EAAMsE,OAAOpC,MAAQlC,EAAMsE,OAAOnC,SAAYT,KAAKoD,OAAQ,CAM9D,GAAI9E,EAAM6E,mBAAmB/U,EAAgBuU,OAE3C,YADAiF,EAAqB5E,GAAO1E,EAAM6E,QAAQS,SAI5C,KAAMtF,EAAM6E,mBAAmBjT,OAC7B,MAAM,IAAIG,MAAM,gDAOlB,MAAM2X,EAAwBxS,IAC5B,GAAIqS,EAAOvB,IAAI9Q,EAAImJ,KACjB,OAAOkJ,EAAOhD,IAAIrP,EAAImJ,KAGxB,MAAMsJ,EACJH,IACCA,EAAW/W,KAAKiU,GAAMtK,EAAMoM,OAAO9B,EAAIxP,EAAImJ,MAC1CnJ,EAAMkF,EAAMkJ,MAAMpO,GAItB,OAFAqS,EAAO/C,IAAItP,EAAImJ,IAAKsJ,GAEbA,GAGTL,EAAqB5E,GAAO1E,EAAM6E,QAAQxS,IAAIqX,MAIlD,MAAME,KAEN,IAAIC,EAAc,EAsCdC,EAcAnT,EAbJ,GArCA+K,KAAKgH,yBAAyB5M,EAAU,CAAC5E,EAAKwP,KAC5C,MAAMqD,EAAcrX,EAAQkU,gBAAgB1P,GAE5C,QAAI6S,EAAYpT,SAEd+K,KAAKuG,cAAcvB,EAAIxP,GACvBwK,KAAKsI,iBACH9S,EACAmS,EACAO,EACAG,EAAYnQ,gBAGZiQ,GAEGzP,EAAQ6P,UAQjBjZ,OAAO4E,KAAKgU,GAAejO,QAAQ+I,IACjC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,GACF0B,KAAK0G,kBAAkBpI,EAAOsJ,EAAqB5E,MAIvDhD,KAAKwD,cAAcU,QAMC,IAAhBiE,GAAqBzP,EAAQ8P,OAAQ,CACvC,MAAMhT,EAAMpH,EAAgBqa,sBAAsBrO,EAAUuN,IACtDnS,EAAImJ,KAAOjG,EAAQ0P,aACvB5S,EAAImJ,IAAMjG,EAAQ0P,YAGpBA,EAAapI,KAAKgG,OAAOxQ,GACzB2S,EAAc,EAuBhB,OAhBIzP,EAAQgQ,eACVzT,GAAU0T,eAAgBR,QAEPrX,IAAfsX,IACFnT,EAAOmT,WAAaA,IAGtBnT,EAASkT,EAGPjG,GACFwD,EAAOiB,MAAM,KACXzE,EAAS,KAAMjN,KAIZA,EAMTuT,OAAOpO,EAAUuN,EAAKjP,EAASwJ,GAM7B,OALKA,GAA+B,mBAAZxJ,IACtBwJ,EAAWxJ,EACXA,MAGKsH,KAAK0H,OACVtN,EACAuN,EACArY,OAAOmF,UAAWiE,GAAU8P,QAAQ,EAAME,eAAe,IACzDxG,GAQJ8E,yBAAyB5M,EAAU3E,GACjC,MAAMmT,EAAcxa,EAAgB2Z,sBAAsB3N,GAEtDwO,EACFA,EAAY7X,KAAKiU,IACf,MAAMxP,EAAMwK,KAAK4E,MAAMC,IAAIG,GAE3B,GAAIxP,EACF,OAAuB,IAAhBC,EAAGD,EAAKwP,KAInBhF,KAAK4E,MAAM3K,QAAQxE,GAIvB6S,iBAAiB9S,EAAKmS,EAAKO,EAAehQ,GACxC,MAAM2Q,KAENvZ,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAEvB1E,EAAMuE,QAINvE,EAAMiD,QACRsH,EAAe7F,GAAO1E,EAAMtN,QAAQkU,gBAAgB1P,GAAKP,OAIzD4T,EAAe7F,GAAO1E,EAAM6E,QAAQmD,IAAI9Q,EAAImJ,QAIhD,MAAMmK,EAAUpO,EAAMkJ,MAAMpO,GAE5BpH,EAAgB2a,QAAQvT,EAAKmS,GAAMzP,aAAAA,IAEnC5I,OAAO4E,KAAK8L,KAAKkD,SAASjJ,QAAQ+I,IAChC,MAAM1E,EAAQ0B,KAAKkD,QAAQF,GAE3B,GAAI1E,EAAMuE,MACR,OAGF,MAAMmG,EAAa1K,EAAMtN,QAAQkU,gBAAgB1P,GAC3CyT,EAAQD,EAAW/T,OACnBiU,EAASL,EAAe7F,GAE1BiG,GAAS3K,EAAMoE,gBAAqC5R,IAAxBkY,EAAW5R,UACzCkH,EAAMoE,UAAUoC,IAAItP,EAAImJ,IAAKqK,EAAW5R,UAGtCkH,EAAMsE,OAAOpC,MAAQlC,EAAMsE,OAAOnC,OAQhCyI,GAAUD,KACZf,EAAclF,IAAO,GAEdkG,IAAWD,EACpB7a,EAAgBgZ,mBAAmB9I,EAAO9I,IAChC0T,GAAUD,EACpB7a,EAAgBqY,iBAAiBnI,EAAO9I,GAC/B0T,GAAUD,GACnB7a,EAAgB+a,iBAAiB7K,EAAO9I,EAAKsT,KAgBnDpC,kBAAkBpI,EAAO8K,GACnBpJ,KAAKoD,OAIP9E,EAAMuE,OAAQ,GAIX7C,KAAKoD,QAAWgG,IACnBA,EAAa9K,EAAM6E,SAGjB7E,EAAMoE,WACRpE,EAAMoE,UAAUqC,QAGlBzG,EAAM6E,QAAU7E,EAAMsE,OAAOtB,gBAC3BoB,UAAWpE,EAAMoE,UACjBnB,QAASjD,EAAMiD,UAGZvB,KAAKoD,QACRhV,EAAgBkZ,kBACdhJ,EAAMiD,QACN6H,EACA9K,EAAM6E,QACN7E,GACCwE,aAAcxE,EAAMwE,gBAK3ByD,cAAcvB,EAAIxP,GAEXwK,KAAK6F,kBAON7F,KAAK6F,gBAAgBS,IAAItB,IAI7BhF,KAAK6F,gBAAgBf,IAAIE,EAAItK,EAAMkJ,MAAMpO,MAI7CpH,EAAgByR,OAASA,EAEzBzR,EAAgB0V,cAAgBA,EAWhC1V,EAAgBib,6BAA+BA,EAC7CvJ,cAA0B,IAAdpH,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MACxB,MAAM2Q,EACJ5Q,EAAQ6Q,WACRnb,EAAgBoU,mCAAmC9J,EAAQ6Q,WAG7D,GAAIjb,EAAOoE,KAAKgG,EAAS,YAGvB,GAFAsH,KAAKuB,QAAU7I,EAAQ6I,QAEnB7I,EAAQ6Q,WAAa7Q,EAAQ6I,UAAY+H,EAC3C,MAAMjZ,MAAM,8CAET,CAAA,IAAIqI,EAAQ6Q,UAGjB,MAAMlZ,MAAM,qCAFZ2P,KAAKuB,QAAU+H,EAKjB,MAAMC,EAAY7Q,EAAQ6Q,cAEtBvJ,KAAKuB,SACPvB,KAAKwJ,KAAO,IAAIC,EAAYtD,EAAQuD,aACpC1J,KAAK2J,aACHhI,YAAa,CAACqD,EAAIxG,EAAQ0K,KACxB,MAAM1T,EAAMkF,EAAMkJ,MAAMpF,GAExBhJ,EAAImJ,IAAMqG,EAENuE,EAAU5H,aACZ4H,EAAU5H,YAAYjP,KAAKsN,KAAMgF,EAAIxG,EAAQ0K,GAI3CK,EAAUnI,OACZmI,EAAUnI,MAAM1O,KAAKsN,KAAMgF,EAAIxG,GAMjCwB,KAAKwJ,KAAKI,UAAU5E,EAAIxP,EAAK0T,GAAU,OAEzCrH,YAAa,CAACmD,EAAIkE,KAChB,MAAM1T,EAAMwK,KAAKwJ,KAAK3E,IAAIG,GAEtBuE,EAAU1H,aACZ0H,EAAU1H,YAAYnP,KAAKsN,KAAMgF,EAAIkE,GAGvClJ,KAAKwJ,KAAKK,WAAW7E,EAAIkE,GAAU,UAIvClJ,KAAKwJ,KAAO,IAAIpb,EAAgBuU,OAChC3C,KAAK2J,aACHvI,MAAO,CAAC4D,EAAIxG,KACV,MAAMhJ,EAAMkF,EAAMkJ,MAAMpF,GAEpB+K,EAAUnI,OACZmI,EAAUnI,MAAM1O,KAAKsN,KAAMgF,EAAIxG,GAGjChJ,EAAImJ,IAAMqG,EAEVhF,KAAKwJ,KAAK1E,IAAIE,EAAKxP,MAOzBwK,KAAK2J,YAAY/H,QAAU,EAACoD,EAAIxG,KAC9B,MAAMhJ,EAAMwK,KAAKwJ,KAAK3E,IAAIG,GAE1B,IAAKxP,EACH,MAAM,IAAInF,MAAJ,2BAAAsC,OAAqCqS,IAGzCuE,EAAU3H,SACZ2H,EAAU3H,QAAQlP,KAAKsN,KAAMgF,EAAItK,EAAMkJ,MAAMpF,IAG/CsL,EAAaC,aAAavU,EAAKgJ,KAGjCwB,KAAK2J,YAAYtI,QAAU2D,CAAAA,IACrBuE,EAAUlI,SACZkI,EAAUlI,QAAQ3O,KAAKsN,KAAMgF,GAG/BhF,KAAKwJ,KAAK3C,OAAO7B,OAKvB5W,EAAgBuU,aAAeA,UAAeqH,EAC5ClK,cACEmK,MAAM9D,EAAQuD,YAAavD,EAAQ+D,WAavC9b,EAAgByS,cAAgBC,CAAAA,IAC9B,IAAKA,EACH,OAAO,KAIT,GAAIA,EAAUqJ,qBACZ,OAAOrJ,EAGT,MAAMsJ,EAAU5U,IACd,IAAKlH,EAAOoE,KAAK8C,EAAK,OAGpB,MAAM,IAAInF,MAAM,yCAGlB,MAAM2U,EAAKxP,EAAImJ,IAIT0L,EAActJ,EAAQuJ,YAAY,IAAMxJ,EAAUtL,IAExD,IAAKpH,EAAgB4F,eAAeqW,GAClC,MAAM,IAAIha,MAAM,gCAGlB,GAAI/B,EAAOoE,KAAK2X,EAAa,QAC3B,IAAK3P,EAAMoM,OAAOuD,EAAY1L,IAAKqG,GACjC,MAAM,IAAI3U,MAAM,sDAGlBga,EAAY1L,IAAMqG,EAGpB,OAAOqF,GAKT,OAFAD,EAAQD,sBAAuB,EAExBC,IAWThc,EAAgBmc,cAAgB,EAACC,EAAK/Y,EAAOjB,KAC3C,IAAIia,EAAQ,EACRC,EAAQjZ,EAAMrB,OAElB,KAAOsa,EAAQ,GAAG,CAChB,MAAMC,EAAYjR,KAAKkR,MAAMF,EAAQ,GAEjCF,EAAIha,EAAOiB,EAAMgZ,EAAQE,KAAe,GAC1CF,GAASE,EAAY,EACrBD,GAASC,EAAY,GAErBD,EAAQC,EAIZ,OAAOF,IAGTrc,EAAgByc,0BAA4BrM,CAAAA,IAC1C,GAAIA,IAAWlP,OAAOkP,IAAWtO,MAAMC,QAAQqO,GAC7C,MAAMO,EAAe,mCAGvBzP,OAAO4E,KAAKsK,GAAQvE,QAAQ4E,IAC1B,GAAIA,EAAQxC,MAAM,KAAKc,SAAS,KAC9B,MAAM4B,EACJ,4DAIJ,MAAMvO,EAAQgO,EAAOK,GAErB,GAAqB,iBAAVrO,IACN,aAAc,QAAS,UAAUO,KAAKqD,GACrC9F,EAAOoE,KAAKlC,EAAO4D,IAEvB,MAAM2K,EACJ,2DAIJ,KAAM,EAAG,GAAG,GAAM,GAAO5B,SAAS3M,GAChC,MAAMuO,EACJ,+DAaR3Q,EAAgBuS,mBAAqBnC,CAAAA,IACnCpQ,EAAgByc,0BAA0BrM,GAE1C,MAAMsM,OAA+Bha,IAAf0N,EAAOG,KAA2BH,EAAOG,IACzDoM,EAAU7b,EAAkBsP,GAG5BsC,EAAY,CAACtL,EAAKwV,KAEtB,GAAI9a,MAAMC,QAAQqF,GAChB,OAAOA,EAAI7E,IAAIsa,GAAUnK,EAAUmK,EAAQD,IAG7C,MAAM/V,EAAS8V,EAAQnM,aAAiBlE,EAAMkJ,MAAMpO,GAsBpD,OApBAlG,OAAO4E,KAAK8W,GAAU/Q,QAAQ7F,IAC5B,IAAK9F,EAAOoE,KAAK8C,EAAKpB,GACpB,OAGF,MAAM0K,EAAOkM,EAAS5W,GAElB0K,IAASxP,OAAOwP,GAEdtJ,EAAIpB,KAAS9E,OAAOkG,EAAIpB,MAC1Ba,EAAOb,GAAO0M,EAAUtL,EAAIpB,GAAM0K,IAE3BiM,EAAQnM,UAEjB3J,EAAOb,GAAOsG,EAAMkJ,MAAMpO,EAAIpB,WAEvBa,EAAOb,KAIXa,GAGT,OAAOO,IACL,MAAMP,EAAS6L,EAAUtL,EAAKuV,EAAQnN,MAUtC,OARIkN,GAAiBxc,EAAOoE,KAAK8C,EAAK,SACpCP,EAAO0J,IAAMnJ,EAAImJ,MAGdmM,GAAiBxc,EAAOoE,KAAKuC,EAAQ,eACjCA,EAAO0J,IAGT1J,KAMX7G,EAAgBqa,sBAAwB,EAACrO,EAAU8Q,KACjD,MAAMC,EAAmBlc,EAAgCmL,GACnDgR,EAAWhd,EAAgBid,mBAAmBH,GAE9CI,KAaN,GAXIH,EAAiBxM,MACnB2M,EAAO3M,IAAMwM,EAAiBxM,WACvBwM,EAAiBxM,KAM1BvQ,EAAgB2a,QAAQuC,GAASC,KAAMJ,IACvC/c,EAAgB2a,QAAQuC,EAAQJ,GAAWM,UAAU,IAEjDJ,EACF,OAAOE,EAIT,MAAMG,EAAcnc,OAAOmF,UAAWyW,GAKtC,OAJII,EAAO3M,MACT8M,EAAY9M,IAAM2M,EAAO3M,KAGpB8M,IAGTrd,EAAgBsd,aAAe,EAACC,EAAMC,EAAOrC,IACpCO,EAAa+B,YAAYF,EAAMC,EAAOrC,IAO/Cnb,EAAgBkZ,kBAAoB,EAAC/F,EAAS6H,EAAY0C,EAAYC,EAAUrT,IAC9EoR,EAAakC,iBAAiBzK,EAAS6H,EAAY0C,EAAYC,EAAUrT,IAG3EtK,EAAgB6d,yBAA2B,EAAC7C,EAAY0C,EAAYC,EAAUrT,IAC5EoR,EAAaoC,wBAAwB9C,EAAY0C,EAAYC,EAAUrT,IAGzEtK,EAAgB+d,2BAA6B,EAAC/C,EAAY0C,EAAYC,EAAUrT,IAC9EoR,EAAasC,0BAA0BhD,EAAY0C,EAAYC,EAAUrT,IAG3EtK,EAAgBie,sBAAwB,EAAC/N,EAAO9I,KAC9C,IAAK8I,EAAMiD,QACT,MAAM,IAAIlR,MAAM,uDAGlB,IAAK,IAAIgD,EAAI,EAAGA,EAAIiL,EAAM6E,QAAQ/S,OAAQiD,IACxC,GAAIiL,EAAM6E,QAAQ9P,KAAOmC,EACvB,OAAOnC,EAIX,MAAMhD,MAAM,+BAQdjC,EAAgB2Z,sBAAwB3N,CAAAA,IAEtC,GAAIhM,EAAgBmQ,cAAcnE,GAChC,OAAQA,GAGV,IAAKA,EACH,OAAO,KAIT,GAAI9L,EAAOoE,KAAK0H,EAAU,OAExB,OAAIhM,EAAgBmQ,cAAcnE,EAASuE,MACjCvE,EAASuE,KAIfvE,EAASuE,KACNzO,MAAMC,QAAQiK,EAASuE,IAAIlO,MAC3B2J,EAASuE,IAAIlO,IAAIL,QACjBgK,EAASuE,IAAIlO,IAAI0C,MAAM/E,EAAgBmQ,eACrCnE,EAASuE,IAAIlO,IAGf,KAMT,GAAIP,MAAMC,QAAQiK,EAASlF,MACzB,IAAK,IAAI7B,EAAI,EAAGA,EAAI+G,EAASlF,KAAK9E,SAAUiD,EAAG,CAC7C,MAAMiZ,EAASle,EAAgB2Z,sBAAsB3N,EAASlF,KAAK7B,IAEnE,GAAIiZ,EACF,OAAOA,EAKb,OAAO,OAGTle,EAAgBqY,iBAAmB,EAACnI,EAAO9I,KACzC,MAAMgJ,EAAS9D,EAAMkJ,MAAMpO,GAI3B,UAFOgJ,EAAOG,IAEVL,EAAMiD,QAAS,CACjB,GAAKjD,EAAM2B,OAGJ,CACL,MAAM5M,EAAIjF,EAAgBme,oBACxBjO,EAAM2B,OAAOkF,eAAezC,UAAWpE,EAAMoE,YAC7CpE,EAAM6E,QACN3N,GAGF,IAAIwM,EAAO1D,EAAM6E,QAAQ9P,EAAI,GAE3B2O,EADEA,EACKA,EAAKrD,IAEL,KAGTL,EAAMqD,YAAYnM,EAAImJ,IAAKL,EAAMwE,aAAatE,GAASwD,QAhBvD1D,EAAMqD,YAAYnM,EAAImJ,IAAKL,EAAMwE,aAAatE,GAAS,MACvDF,EAAM6E,QAAQhJ,KAAK3E,GAkBrB8I,EAAM8C,MAAM5L,EAAImJ,IAAKL,EAAMwE,aAAatE,SAExCF,EAAM8C,MAAM5L,EAAImJ,IAAKL,EAAMwE,aAAatE,IACxCF,EAAM6E,QAAQ2B,IAAItP,EAAImJ,IAAKnJ,KAI/BpH,EAAgBme,oBAAsB,EAAC/B,EAAK/Y,EAAOjB,KACjD,GAAqB,IAAjBiB,EAAMrB,OAER,OADAqB,EAAM0I,KAAK3J,GACJ,EAGT,MAAM6C,EAAIjF,EAAgBmc,cAAcC,EAAK/Y,EAAOjB,GAIpD,OAFAiB,EAAM+a,OAAOnZ,EAAG,EAAG7C,GAEZ6C,IAGTjF,EAAgBid,mBAAqB1D,CAAAA,IACnC,IAAIyD,GAAW,EACXqB,GAAY,EAUhB,GARAnd,OAAO4E,KAAKyT,GAAK1N,QAAQ7F,IACE,MAArBA,EAAIyE,OAAO,EAAG,GAChBuS,GAAW,EAEXqB,GAAY,IAIZrB,GAAYqB,EACd,MAAM,IAAIpc,MACR,uEAIJ,OAAO+a,IAMThd,EAAgB4F,eAAiB4G,CAAAA,GACxBA,GAAqC,IAAhCxM,EAAgBwE,GAAGC,MAAM+H,IAevCxM,EAAgB2a,QAAU,SAACvT,EAAK0V,GAA2B,IAAjBxS,EAAiBC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MACzD,IAAKvK,EAAgB4F,eAAekX,GAClC,MAAMnM,EAAe,8BAIvBmM,EAAWxQ,EAAMkJ,MAAMsH,GAEvB,MAAMwB,EAAa7d,EAAiBqc,GAC9BI,EAASoB,EAAahS,EAAMkJ,MAAMpO,GAAO0V,EAE/C,GAAIwB,GAsCF,GApCApd,OAAO4E,KAAKgX,GAAUjR,QAAQgD,IAE5B,MAAM0P,EAAcjU,EAAQ8S,UAAyB,iBAAbvO,EAClC2P,EAAUC,EAAUF,EAAc,OAAS1P,GAC3ChN,EAAUib,EAASjO,GAEzB,IAAK2P,EACH,MAAM7N,EAAc,8BAAApM,OAA+BsK,IAGrD3N,OAAO4E,KAAKjE,GAASgK,QAAQ6S,IAC3B,MAAM/X,EAAM9E,EAAQ6c,GAEpB,GAAgB,KAAZA,EACF,MAAM/N,EAAe,sCAGvB,MAAMgO,EAAWD,EAAQzQ,MAAM,KAE/B,IAAK0Q,EAAS5Z,MAAM8F,SAClB,MAAM8F,EACJ,oBAAApM,OAAoBma,EAApB,oCACA,yBAIJ,MAAME,EAASC,EAAc3B,EAAQyB,GACnC7U,aAAcQ,EAAQR,aACtBgV,YAA0B,YAAbjQ,EACbkQ,SAAUC,EAAoBnQ,KAGhC2P,EAAQI,EAAQD,EAASM,MAAOtY,EAAK+X,EAASxB,OAI9C9V,EAAImJ,MAAQjE,EAAMoM,OAAOtR,EAAImJ,IAAK2M,EAAO3M,KAC3C,MAAMI,EACJ,oDAAApM,OAAoD6C,EAAImJ,IAAxD,YACA,kEADA,SAAAhM,OAES2Y,EAAO3M,IAFhB,UAKC,CACL,GAAInJ,EAAImJ,KAAOuM,EAASvM,MAAQjE,EAAMoM,OAAOtR,EAAImJ,IAAKuM,EAASvM,KAC7D,MAAMI,EACJ,+CAAApM,OAA+C6C,EAAImJ,IAAnD,UAAA,UAAAhM,OACUuY,EAASvM,IADnB,OAMJsH,EAAyBiF,GAI3B5b,OAAO4E,KAAKsB,GAAKyE,QAAQ7F,IAIX,QAARA,UACKoB,EAAIpB,KAIf9E,OAAO4E,KAAKoX,GAAQrR,QAAQ7F,IAC1BoB,EAAIpB,GAAOkX,EAAOlX,MAItBhG,EAAgBkU,2BAA6B,EAACM,EAAQ0K,KACpD,MAAMxM,EAAY8B,EAAOR,gBAAP,CAA0B5M,GAAOA,GACnD,IAAI+X,IAAeD,EAAiB3J,kBAEhC6J,EACJ,GAAIpf,EAAgBqf,4BAA4BH,GAAmB,CAKjE,MAAMI,GAAWJ,EAAiBK,YAElCH,GACE7L,YAAYqD,EAAIxG,EAAQ0K,GACtB,GAAIqE,IAAgBD,EAAiBM,UAAWN,EAAiBlM,MAC/D,OAGF,MAAM5L,EAAMsL,EAAUxR,OAAOmF,OAAO+J,GAASG,IAAKqG,KAE9CsI,EAAiBM,QACnBN,EAAiBM,QACfpY,EACAkY,EACIxE,EACElJ,KAAKwJ,KAAKlO,QAAQ4N,GAClBlJ,KAAKwJ,KAAKzC,QACX,EACLmC,GAGFoE,EAAiBlM,MAAM5L,IAG3BoM,QAAQoD,EAAIxG,GACV,IAAM8O,EAAiBO,YAAaP,EAAiB1L,QACnD,OAGF,IAAIpM,EAAMkF,EAAMkJ,MAAM5D,KAAKwJ,KAAK3E,IAAIG,IACpC,IAAKxP,EACH,MAAM,IAAInF,MAAJ,2BAAAsC,OAAqCqS,IAG7C,MAAM8I,EAAShN,EAAUpG,EAAMkJ,MAAMpO,IAErCsU,EAAaC,aAAavU,EAAKgJ,GAE3B8O,EAAiBO,UACnBP,EAAiBO,UACf/M,EAAUtL,GACVsY,EACAJ,EAAU1N,KAAKwJ,KAAKlO,QAAQ0J,IAAO,GAGrCsI,EAAiB1L,QAAQd,EAAUtL,GAAMsY,IAG7CjM,YAAYmD,EAAIkE,GACd,IAAKoE,EAAiBS,QACpB,OAGF,MAAMC,EAAON,EAAU1N,KAAKwJ,KAAKlO,QAAQ0J,IAAO,EAChD,IAAIiJ,EAAKP,EACLxE,EACElJ,KAAKwJ,KAAKlO,QAAQ4N,GAClBlJ,KAAKwJ,KAAKzC,QACX,EAIDkH,EAAKD,KACLC,EAGJX,EAAiBS,QACfjN,EAAUpG,EAAMkJ,MAAM5D,KAAKwJ,KAAK3E,IAAIG,KACpCgJ,EACAC,EACA/E,GAAU,OAGd7H,QAAQ2D,GACN,IAAMsI,EAAiBY,YAAaZ,EAAiBjM,QACnD,OAKF,MAAM7L,EAAMsL,EAAUd,KAAKwJ,KAAK3E,IAAIG,IAEhCsI,EAAiBY,UACnBZ,EAAiBY,UAAU1Y,EAAKkY,EAAU1N,KAAKwJ,KAAKlO,QAAQ0J,IAAO,GAEnEsI,EAAiBjM,QAAQ7L,UAK/BgY,GACEpM,MAAM4D,EAAIxG,IACH+O,GAAcD,EAAiBlM,OAClCkM,EAAiBlM,MAAMN,EAAUxR,OAAOmF,OAAO+J,GAASG,IAAKqG,OAGjEpD,QAAQoD,EAAIxG,GACV,GAAI8O,EAAiB1L,QAAS,CAC5B,MAAMkM,EAAS9N,KAAKwJ,KAAK3E,IAAIG,GACvBxP,EAAMkF,EAAMkJ,MAAMkK,GAExBhE,EAAaC,aAAavU,EAAKgJ,GAE/B8O,EAAiB1L,QACfd,EAAUtL,GACVsL,EAAUpG,EAAMkJ,MAAMkK,OAI5BzM,QAAQ2D,GACFsI,EAAiBjM,SACnBiM,EAAiBjM,QAAQP,EAAUd,KAAKwJ,KAAK3E,IAAIG,OAMzD,MAAMmJ,EAAiB,IAAI/f,EAAgBib,wBACzCE,UAAWiE,IAGP3J,EAASjB,EAAOL,eAAe4L,EAAexE,aAIpD,OAFA4D,GAAa,EAEN1J,IAGTzV,EAAgBqf,4BAA8BlE,CAAAA,IAC5C,GAAIA,EAAUnI,OAASmI,EAAUqE,QAC/B,MAAM,IAAIvd,MAAM,oDAGlB,GAAIkZ,EAAU3H,SAAW2H,EAAUsE,UACjC,MAAM,IAAIxd,MAAM,wDAGlB,GAAIkZ,EAAUlI,SAAWkI,EAAU2E,UACjC,MAAM,IAAI7d,MAAM,wDAGlB,SACEkZ,EAAUqE,SACVrE,EAAUsE,WACVtE,EAAUwE,SACVxE,EAAU2E,aAId9f,EAAgBoU,mCAAqC+G,CAAAA,IACnD,GAAIA,EAAUnI,OAASmI,EAAU5H,YAC/B,MAAM,IAAItR,MAAM,wDAGlB,SAAUkZ,EAAU5H,cAAe4H,EAAU1H,eAG/CzT,EAAgBgZ,mBAAqB,EAAC9I,EAAO9I,KAC3C,GAAI8I,EAAMiD,QAAS,CACjB,MAAMlO,EAAIjF,EAAgBie,sBAAsB/N,EAAO9I,GAEvD8I,EAAM+C,QAAQ7L,EAAImJ,KAClBL,EAAM6E,QAAQqJ,OAAOnZ,EAAG,OACnB,CACL,MAAM2R,EAAKxP,EAAImJ,IAEfL,EAAM+C,QAAQ7L,EAAImJ,KAClBL,EAAM6E,QAAQ0D,OAAO7B,MAKzB5W,EAAgBmQ,cAAgBnE,CAAAA,GACV,iBAAbA,GACa,iBAAbA,GACPA,aAAoB+L,EAAQC,UAI9BhY,EAAgBgS,6BAA+BhG,CAAAA,GAC7ChM,EAAgBmQ,cAAcnE,IAC9BhM,EAAgBmQ,cAAcnE,GAAYA,EAASuE,MAClB,IAAjCrP,OAAO4E,KAAKkG,GAAUhK,QAGxBhC,EAAgB+a,iBAAmB,EAAC7K,EAAO9I,EAAKsT,KAC9C,IAAKpO,EAAMoM,OAAOtR,EAAImJ,IAAKmK,EAAQnK,KACjC,MAAM,IAAItO,MAAM,2CAGlB,MAAMyS,EAAexE,EAAMwE,aACrBsL,EAAgBtE,EAAauE,kBACjCvL,EAAatN,GACbsN,EAAagG,IAGf,IAAKxK,EAAMiD,QAMT,YALIjS,OAAO4E,KAAKka,GAAehe,SAC7BkO,EAAMsD,QAAQpM,EAAImJ,IAAKyP,GACvB9P,EAAM6E,QAAQ2B,IAAItP,EAAImJ,IAAKnJ,KAM/B,MAAM8Y,EAAUlgB,EAAgBie,sBAAsB/N,EAAO9I,GAM7D,GAJIlG,OAAO4E,KAAKka,GAAehe,QAC7BkO,EAAMsD,QAAQpM,EAAImJ,IAAKyP,IAGpB9P,EAAM2B,OACT,OAIF3B,EAAM6E,QAAQqJ,OAAO8B,EAAS,GAE9B,MAAMC,EAAUngB,EAAgBme,oBAC9BjO,EAAM2B,OAAOkF,eAAezC,UAAWpE,EAAMoE,YAC7CpE,EAAM6E,QACN3N,GAGF,GAAI8Y,IAAYC,EAAS,CACvB,IAAIvM,EAAO1D,EAAM6E,QAAQoL,EAAU,GAEjCvM,EADEA,EACKA,EAAKrD,IAEL,KAGTL,EAAMuD,aAAevD,EAAMuD,YAAYrM,EAAImJ,IAAKqD,MAIpD,MAAM6K,GACJ2B,aAAaxB,EAAQtN,EAAO3K,GAC1B,GAAmB,iBAARA,GAAoBzG,EAAOoE,KAAKqC,EAAK,UAC9C,GAAkB,SAAdA,EAAI5D,MACN,MAAM4N,EACJ,iFAECW,MAAAA,SAGA,IAAY,IAAR3K,EACT,MAAMgK,EAAe,iCAAkCW,MAAAA,IAGzDsN,EAAOtN,GAAS,IAAI+O,MAEtBC,KAAK1B,EAAQtN,EAAO3K,GAClB,GAAmB,iBAARA,EACT,MAAMgK,EAAe,0CAA2CW,MAAAA,IAGlE,GAAIA,KAASsN,EAAQ,CACnB,GAA6B,iBAAlBA,EAAOtN,GAChB,MAAMX,EACJ,4CACCW,MAAAA,IAIDsN,EAAOtN,GAAS3K,IAClBiY,EAAOtN,GAAS3K,QAGlBiY,EAAOtN,GAAS3K,GAGpB4Z,KAAK3B,EAAQtN,EAAO3K,GAClB,GAAmB,iBAARA,EACT,MAAMgK,EAAe,0CAA2CW,MAAAA,IAGlE,GAAIA,KAASsN,EAAQ,CACnB,GAA6B,iBAAlBA,EAAOtN,GAChB,MAAMX,EACJ,4CACCW,MAAAA,IAIDsN,EAAOtN,GAAS3K,IAClBiY,EAAOtN,GAAS3K,QAGlBiY,EAAOtN,GAAS3K,GAGpB6Z,KAAK5B,EAAQtN,EAAO3K,GAClB,GAAmB,iBAARA,EACT,MAAMgK,EAAe,0CAA2CW,MAAAA,IAGlE,GAAIA,KAASsN,EAAQ,CACnB,GAA6B,iBAAlBA,EAAOtN,GAChB,MAAMX,EACJ,4CACCW,MAAAA,IAILsN,EAAOtN,IAAU3K,OAEjBiY,EAAOtN,GAAS3K,GAGpBwW,KAAKyB,EAAQtN,EAAO3K,GAClB,GAAIiY,IAAW1d,OAAO0d,GAAS,CAC7B,MAAMrN,EAAQZ,EACZ,2CACCW,MAAAA,IAGH,MADAC,EAAMkP,kBAAmB,EACnBlP,EAGR,GAAe,OAAXqN,EAAiB,CACnB,MAAMrN,EAAQZ,EAAe,+BAAgCW,MAAAA,IAE7D,MADAC,EAAMkP,kBAAmB,EACnBlP,EAGRsG,EAAyBlR,GAEzBiY,EAAOtN,GAAS3K,GAElB+Z,aAAa9B,EAAQtN,EAAO3K,KAG5Bga,OAAO/B,EAAQtN,EAAO3K,QACLjE,IAAXkc,IACEA,aAAkB9c,MAChBwP,KAASsN,IACXA,EAAOtN,GAAS,aAGXsN,EAAOtN,KAIpBsP,MAAMhC,EAAQtN,EAAO3K,GAKnB,QAJsBjE,IAAlBkc,EAAOtN,KACTsN,EAAOtN,SAGHsN,EAAOtN,aAAkBxP,OAC7B,MAAM6O,EAAe,4CAA6CW,MAAAA,IAGpE,IAAM3K,IAAOA,EAAIka,MAMf,OAJAhJ,EAAyBlR,QAEzBiY,EAAOtN,GAAOvF,KAAKpF,GAMrB,MAAMma,EAASna,EAAIka,MACnB,KAAMC,aAAkBhf,OACtB,MAAM6O,EAAe,0BAA2BW,MAAAA,IAGlDuG,EAAyBiJ,GAGzB,IAAIC,OAAWre,EACf,GAAI,cAAeiE,EAAK,CACtB,GAA6B,iBAAlBA,EAAIqa,UACb,MAAMrQ,EAAe,qCAAsCW,MAAAA,IAI7D,GAAI3K,EAAIqa,UAAY,EAClB,MAAMrQ,EACJ,+CACCW,MAAAA,IAILyP,EAAWpa,EAAIqa,UAIjB,IAAI5S,OAAQ1L,EACZ,GAAI,WAAYiE,EAAK,CACnB,GAA0B,iBAAfA,EAAIsa,OACb,MAAMtQ,EAAe,kCAAmCW,MAAAA,IAI1DlD,EAAQzH,EAAIsa,OAId,IAAIC,OAAexe,EACnB,GAAIiE,EAAIwa,MAAO,CACb,QAAcze,IAAV0L,EACF,MAAMuC,EAAe,uCAAwCW,MAAAA,IAO/D4P,EAAe,IAAIpP,EAAUK,OAAOxL,EAAIwa,OAAOpK,gBAE/C+J,EAAOjV,QAAQX,IACb,GAA0C,IAAtClL,EAAgBwE,GAAGC,MAAMyG,GAC3B,MAAMyF,EACJ,uEAECW,MAAAA,MAOT,QAAiB5O,IAAbqe,EACFD,EAAOjV,QAAQX,IACb0T,EAAOtN,GAAOvF,KAAKb,SAEhB,CACL,MAAMkW,GAAmBL,EAAU,GAEnCD,EAAOjV,QAAQX,IACbkW,EAAgBrV,KAAKb,KAGvB0T,EAAOtN,GAAO8M,UAAUgD,GAItBF,GACFtC,EAAOtN,GAAOhB,KAAK4Q,QAIPxe,IAAV0L,IAEAwQ,EAAOtN,GADK,IAAVlD,KAEOA,EAAQ,EACDwQ,EAAOtN,GAAOlD,MAAMA,GAEpBwQ,EAAOtN,GAAOlD,MAAM,EAAGA,KAI7CiT,SAASzC,EAAQtN,EAAO3K,GACtB,KAAqB,iBAARA,GAAoBA,aAAe7E,OAC9C,MAAM6O,EAAe,qDAGvBkH,EAAyBlR,GAEzB,MAAMma,EAASlC,EAAOtN,GAEtB,QAAe5O,IAAXoe,EACFlC,EAAOtN,GAAS3K,MACX,CAAA,KAAMma,aAAkBhf,OAC7B,MAAM6O,EACJ,+CACCW,MAAAA,IAGHwP,EAAO/U,QAAQpF,KAGnB2a,UAAU1C,EAAQtN,EAAO3K,GACvB,IAAI4a,GAAS,EAEb,GAAmB,iBAAR5a,EAAkB,CAE3B,MAAMb,EAAO5E,OAAO4E,KAAKa,GACT,UAAZb,EAAK,KACPyb,GAAS,GAIb,MAAMC,EAASD,EAAS5a,EAAIka,OAASla,GAErCkR,EAAyB2J,GAEzB,MAAMC,EAAQ7C,EAAOtN,GACrB,QAAc5O,IAAV+e,EACF7C,EAAOtN,GAASkQ,MACX,CAAA,KAAMC,aAAiB3f,OAC5B,MAAM6O,EACJ,gDACCW,MAAAA,IAGHkQ,EAAO3V,QAAQzJ,IACTqf,EAAM9e,KAAKuI,GAAWlL,EAAgBwE,GAAGiH,OAAOrJ,EAAO8I,KAI3DuW,EAAM1V,KAAK3J,OAIjBsf,KAAK9C,EAAQtN,EAAO3K,GAClB,QAAejE,IAAXkc,EACF,OAGF,MAAM+C,EAAQ/C,EAAOtN,GAErB,QAAc5O,IAAVif,EAAJ,CAIA,KAAMA,aAAiB7f,OACrB,MAAM6O,EAAe,2CAA4CW,MAAAA,IAGhD,iBAAR3K,GAAoBA,EAAM,EACnCgb,EAAMvD,OAAO,EAAG,GAEhBuD,EAAM1C,QAGV2C,MAAMhD,EAAQtN,EAAO3K,GACnB,QAAejE,IAAXkc,EACF,OAGF,MAAMiD,EAASjD,EAAOtN,GACtB,QAAe5O,IAAXmf,EACF,OAGF,KAAMA,aAAkB/f,OACtB,MAAM6O,EACJ,oDACCW,MAAAA,IAIL,IAAIwQ,EACJ,GAAW,MAAPnb,GAA8B,iBAARA,GAAsBA,aAAe7E,MAc7DggB,EAAMD,EAAO9b,OAAOmF,IAAYlL,EAAgBwE,GAAGiH,OAAOP,EAASvE,QAdE,CAUrE,MAAM/D,EAAU,IAAIkP,EAAUC,QAAQpL,GAEtCmb,EAAMD,EAAO9b,OAAOmF,IAAYtI,EAAQkU,gBAAgB5L,GAASrE,QAKnE+X,EAAOtN,GAASwQ,GAElBC,SAASnD,EAAQtN,EAAO3K,GACtB,KAAqB,iBAARA,GAAoBA,aAAe7E,OAC9C,MAAM6O,EACJ,qDACCW,MAAAA,IAIL,QAAe5O,IAAXkc,EACF,OAGF,MAAMiD,EAASjD,EAAOtN,GAEtB,QAAe5O,IAAXmf,EAAJ,CAIA,KAAMA,aAAkB/f,OACtB,MAAM6O,EACJ,oDACCW,MAAAA,IAILsN,EAAOtN,GAASuQ,EAAO9b,OAAO3C,IAC3BuD,EAAIhE,KAAKuI,GAAWlL,EAAgBwE,GAAGiH,OAAOrI,EAAQ8H,OAG3D8W,QAAQpD,EAAQtN,EAAO3K,EAAK+X,EAAStX,GAEnC,GAAIsX,IAAY/X,EACd,MAAMgK,EAAe,0CAA2CW,MAAAA,IAGlE,GAAe,OAAXsN,EACF,MAAMjO,EAAe,gCAAiCW,MAAAA,IAGxD,GAAmB,iBAAR3K,EACT,MAAMgK,EAAe,mCAAoCW,MAAAA,IAG3D,GAAI3K,EAAIoI,SAAS,MAGf,MAAM4B,EACJ,mEACCW,MAAAA,IAIL,QAAe5O,IAAXkc,EACF,OAGF,MAAMxb,EAASwb,EAAOtN,UAEfsN,EAAOtN,GAEd,MAAMqN,EAAWhY,EAAIsH,MAAM,KACrBgU,EAAUpD,EAAczX,EAAKuX,GAAWG,aAAa,IAE3D,GAAgB,OAAZmD,EACF,MAAMtR,EAAe,gCAAiCW,MAAAA,IAGxD2Q,EAAQtD,EAASM,OAAS7b,GAE5B8e,KAAKtD,EAAQtN,EAAO3K,GAGlB,MAAMgK,EAAe,yBAA0BW,MAAAA,KAEjD6Q,QAQInD,GACJ0C,MAAM,EACNE,OAAO,EACPG,UAAU,EACVC,SAAS,EACTrB,QAAQ,GAMJyB,GACJC,EAAG,iBACHC,IAAK,cACLC,KAAM,sBAIR,SAAS1K,EAAyBzQ,GAC5BA,GAAsB,iBAARA,GAChBuG,KAAKC,UAAUxG,EAAK,CAACpB,EAAK5D,KACxBogB,EAAuBxc,GAChB5D,IAKb,SAASogB,EAAuBxc,GAC9B,IAAIkE,EACJ,GAAmB,iBAARlE,IAAqBkE,EAAQlE,EAAIkE,MAAM,cAChD,MAAMyG,EAAc,OAAApM,OAAQyB,EAAR,cAAAzB,OAAwB6d,EAAelY,EAAM,MAqBrE,SAAS2U,EAAczX,EAAKuX,GAAwB,IAAdrU,EAAcC,UAAAvI,OAAA,QAAAU,IAAA6H,UAAA,GAAAA,UAAA,MAC9CkY,GAAiB,EAErB,IAAK,IAAIxd,EAAI,EAAGA,EAAI0Z,EAAS3c,OAAQiD,IAAK,CACxC,MAAMyd,EAAOzd,IAAM0Z,EAAS3c,OAAS,EACrC,IAAI2gB,EAAUhE,EAAS1Z,GAEvB,IAAK1E,EAAY6G,GAAM,CACrB,GAAIkD,EAAQyU,SACV,OAGF,MAAMxN,EAAQZ,EAAc,wBAAApM,OACFoe,EADE,kBAAApe,OACsB6C,IAGlD,MADAmK,EAAMkP,kBAAmB,EACnBlP,EAGR,GAAInK,aAAetF,MAAO,CACxB,GAAIwI,EAAQwU,YACV,OAAO,KAGT,GAAgB,MAAZ6D,EAAiB,CACnB,GAAIF,EACF,MAAM9R,EAAe,2CAGvB,IAAKrG,EAAQR,eAAiBQ,EAAQR,aAAa9H,OACjD,MAAM2O,EACJ,wEAKJgS,EAAUrY,EAAQR,aAAa,GAC/B2Y,GAAiB,MACZ,CAAA,IAAIjiB,EAAamiB,GAEjB,CACL,GAAIrY,EAAQyU,SACV,OAGF,MAAMpO,EAAc,kDAAApM,OACgCoe,EADhC,MANpBA,EAAUC,SAASD,GAerB,GAJID,IACF/D,EAAS1Z,GAAK0d,GAGZrY,EAAQyU,UAAY4D,GAAWvb,EAAIpF,OACrC,OAGF,KAAOoF,EAAIpF,OAAS2gB,GAClBvb,EAAI2E,KAAK,MAGX,IAAK2W,EACH,GAAItb,EAAIpF,SAAW2gB,EACjBvb,EAAI2E,cACC,GAA4B,iBAAjB3E,EAAIub,GACpB,MAAMhS,EACJ,uBAAApM,OAAuBoa,EAAS1Z,EAAI,GAApC,oBACA0I,KAAKC,UAAUxG,EAAIub,UAOzB,GAFAH,EAAuBG,KAEjBA,KAAWvb,GAAM,CACrB,GAAIkD,EAAQyU,SACV,OAGG2D,IACHtb,EAAIub,OAKV,GAAID,EACF,OAAOtb,EAGTA,EAAMA,EAAIub,mCC/8DuB,IAAI3iB,EAA2FI,EAAwBF,EAAOS,EAAnKb,EAAOG,QAAQe,QAAQ,IAAI+Q,IAA8BjS,EAAOC,KAAK,yBAAyBiB,QAAQC,GAAGjB,EAAgBiB,IAAI,GAAqDnB,EAAOC,KAAK,eAAeK,wBAAwBa,GAAGb,EAAwBa,GAAGf,OAAOe,GAAGf,EAAOe,GAAGN,eAAeM,GAAGN,EAAeM,IAAI,SA2BvS8Q,EACnBL,YAAY1F,EAAU6W,GAIpBjR,KAAKkR,UAELlR,KAAK3I,cAAe,EAEpB2I,KAAKlK,WAAY,EAIjBkK,KAAKlH,WAAY,EAGjBkH,KAAKmR,uBAAoBrgB,EAKzBkP,KAAKoR,UAAY,KACjBpR,KAAKqR,YAAcrR,KAAKsR,iBAAiBlX,GAIzC4F,KAAK/H,UAAYgZ,EAGnB/L,gBAAgB1P,GACd,GAAIA,IAAQlG,OAAOkG,GACjB,MAAMnF,MAAM,oCAGd,OAAO2P,KAAKqR,YAAY7b,GAG1B8K,cACE,OAAON,KAAK3I,aAGdka,WACE,OAAOvR,KAAKlK,UAGd0b,WACE,OAAOxR,KAAKlH,UAKdwY,iBAAiBlX,GAEf,GAAIA,aAAoBrE,SAKtB,OAJAiK,KAAKlH,WAAY,EACjBkH,KAAKoR,UAAYhX,EACjB4F,KAAKnK,gBAAgB,IAEdL,KAASP,SAAUmF,EAAS1H,KAAK8C,KAI1C,GAAIpH,EAAgBmQ,cAAcnE,GAIhC,OAHA4F,KAAKoR,WAAazS,IAAKvE,GACvB4F,KAAKnK,gBAAgB,OAEdL,KAASP,OAAQyF,EAAMoM,OAAOtR,EAAImJ,IAAKvE,KAMhD,IAAKA,GAAY9L,EAAOoE,KAAK0H,EAAU,SAAWA,EAASuE,IAEzD,OADAqB,KAAKlH,WAAY,EACV/J,EAIT,GAAImB,MAAMC,QAAQiK,IACdM,EAAMC,SAASP,IACK,kBAAbA,EACT,MAAM,IAAI/J,MAAJ,qBAAAsC,OAA+ByH,IAKvC,OAFA4F,KAAKoR,UAAY1W,EAAMkJ,MAAMxJ,GAEtB5L,EAAwB4L,EAAU4F,MAAO/I,QAAQ,IAK1Dwa,YACE,OAAOniB,OAAO4E,KAAK8L,KAAKkR,QAG1Brb,gBAAgB6H,GACdsC,KAAKkR,OAAOxT,IAAQ,GAKxBtP,EAAgBwE,IAEdC,MAAMxD,GACa,iBAANA,EACF,EAGQ,iBAANA,EACF,EAGQ,kBAANA,EACF,EAGLa,MAAMC,QAAQd,GACT,EAGC,OAANA,EACK,GAILA,aAAawB,OACR,GAGQ,mBAANxB,EACF,GAGLA,aAAaof,KACR,EAGL/T,EAAMC,SAAStL,GACV,EAGLA,aAAa8W,EAAQC,SAChB,EAIF,EAYTvM,OAAM,CAACtF,EAAGC,IACDkG,EAAMoM,OAAOvS,EAAGC,GAAIkd,mBAAmB,IAKhDC,WAAWC,KAMN,EACD,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,GACC,EACD,IACA,EACA,IACA,EACA,EACA,GACAA,GAOJzV,KAAK5H,EAAGC,GACN,QAAU1D,IAANyD,EACF,YAAazD,IAAN0D,EAAkB,GAAK,EAGhC,QAAU1D,IAAN0D,EACF,OAAO,EAGT,IAAIqd,EAAKzjB,EAAgBwE,GAAGC,MAAM0B,GAC9Bud,EAAK1jB,EAAgBwE,GAAGC,MAAM2B,GAElC,MAAMud,EAAK3jB,EAAgBwE,GAAG+e,WAAWE,GACnCG,EAAK5jB,EAAgBwE,GAAG+e,WAAWG,GAEzC,GAAIC,IAAOC,EACT,OAAOD,EAAKC,GAAM,EAAI,EAKxB,GAAIH,IAAOC,EACT,MAAMzhB,MAAM,uCAiBd,GAdW,IAAPwhB,IAEFA,EAAKC,EAAK,EACVvd,EAAIA,EAAE0d,cACNzd,EAAIA,EAAEyd,eAGG,IAAPJ,IAEFA,EAAKC,EAAK,EACVvd,EAAIA,EAAE2d,UACN1d,EAAIA,EAAE0d,WAGG,IAAPL,EACF,OAAOtd,EAAIC,EAEb,GAAW,IAAPsd,EACF,OAAOvd,EAAIC,GAAK,EAAID,IAAMC,EAAI,EAAI,EAEpC,GAAW,IAAPqd,EAAU,CAEZ,MAAMM,EAAU3gB,IACd,MAAMyD,KAMN,OAJA3F,OAAO4E,KAAK1C,GAAQyI,QAAQ7F,IAC1Ba,EAAOkF,KAAK/F,EAAK5C,EAAO4C,MAGnBa,GAGT,OAAO7G,EAAgBwE,GAAGuJ,KAAKgW,EAAQ5d,GAAI4d,EAAQ3d,IAGrD,GAAW,IAAPqd,EACF,IAAK,IAAIxe,EAAI,GAAKA,IAAK,CACrB,GAAIA,IAAMkB,EAAEnE,OACV,OAAOiD,IAAMmB,EAAEpE,OAAS,GAAK,EAG/B,GAAIiD,IAAMmB,EAAEpE,OACV,OAAO,EAGT,MAAMsL,EAAItN,EAAgBwE,GAAGuJ,KAAK5H,EAAElB,GAAImB,EAAEnB,IAC1C,GAAU,IAANqI,EACF,OAAOA,EAKb,GAAW,IAAPmW,EAAU,CAGZ,GAAItd,EAAEnE,SAAWoE,EAAEpE,OACjB,OAAOmE,EAAEnE,OAASoE,EAAEpE,OAGtB,IAAK,IAAIiD,EAAI,EAAGA,EAAIkB,EAAEnE,OAAQiD,IAAK,CACjC,GAAIkB,EAAElB,GAAKmB,EAAEnB,GACX,OAAQ,EAGV,GAAIkB,EAAElB,GAAKmB,EAAEnB,GACX,OAAO,EAIX,OAAO,EAGT,GAAW,IAAPwe,EACF,OAAItd,EACKC,EAAI,EAAI,EAGVA,GAAK,EAAI,EAGlB,GAAW,KAAPqd,EACF,OAAO,EAET,GAAW,KAAPA,EACF,MAAMxhB,MAAM,+CAUd,GAAW,KAAPwhB,EACF,MAAMxhB,MAAM,4CAEd,MAAMA,MAAM,iECzVhB,IAAI+hB,EAA6FjS,EAAkEI,EAA9IrS,EAAOC,KAAK,yBAAyBiB,QAAQC,GAAG+iB,EAAiB/iB,IAAI,GAAenB,EAAOC,KAAK,gBAAgBiB,QAAQC,GAAG8Q,EAAQ9Q,IAAI,GAAcnB,EAAOC,KAAK,eAAeiB,QAAQC,GAAGkR,EAAOlR,IAAI,GAI3NjB,EAAkBgkB,EAClBlS,GACI9R,gBAAiBgkB,EACjBjS,QAAAA,EACAI,OAAAA,wCCRJrS,EAAOG,QAAQe,QAAQ,IAAI0U,UACNA,iCCDe,IAAIvV,EAAkBE,EAAuBC,EAAuBJ,EAAOO,EAAiBC,EAAmBK,EAAnJjB,EAAOG,QAAQe,QAAQ,IAAImR,IAA6IrS,EAAOC,KAAK,eAAeI,kBAAkBc,GAAGd,EAAkBc,GAAGZ,uBAAuBY,GAAGZ,EAAuBY,GAAGX,uBAAuBW,GAAGX,EAAuBW,GAAGf,OAAOe,GAAGf,EAAOe,GAAGR,iBAAiBQ,GAAGR,EAAiBQ,GAAGP,mBAAmBO,GAAGP,EAAmBO,GAAGF,qBAAqBE,GAAGF,EAAqBE,IAAI,SAuBzdkR,EACnBT,YAAYuS,GACVrS,KAAKsS,kBACLtS,KAAKuS,cAAgB,KAErB,MAAMC,EAAc,CAAC9U,EAAM+U,KACzB,IAAK/U,EACH,MAAMrN,MAAM,+BAGd,GAAuB,MAAnBqN,EAAKgV,OAAO,GACd,MAAMriB,MAAK,yBAAAsC,OAA0B+K,IAGvCsC,KAAKsS,eAAenY,MAClBsY,UAAAA,EACAE,OAAQ7jB,EAAmB4O,GAAOZ,SAAS,IAC3CY,KAAAA,KAIJ,GAAI2U,aAAgBniB,MAClBmiB,EAAKpY,QAAQX,IACY,iBAAZA,EACTkZ,EAAYlZ,GAAS,GAErBkZ,EAAYlZ,EAAQ,GAAmB,SAAfA,EAAQ,WAG/B,GAAoB,iBAAT+Y,EAChB/iB,OAAO4E,KAAKme,GAAMpY,QAAQ7F,IACxBoe,EAAYpe,EAAKie,EAAKje,IAAQ,SAE3B,CAAA,GAAoB,mBAATie,EAGhB,MAAMhiB,MAAK,2BAAAsC,OAA4BoJ,KAAKC,UAAUqW,KAFtDrS,KAAKuS,cAAgBF,EAMvB,IAAIrS,KAAKuS,cAAT,CAQA,GAAIvS,KAAK4S,mBAAoB,CAC3B,MAAMxY,KAEN4F,KAAKsS,eAAerY,QAAQoY,IAC1BjY,EAASiY,EAAK3U,MAAQ,IAGxBsC,KAAK6S,+BAAiC,IAAI3S,EAAUC,QAAQ/F,GAG9D4F,KAAK8S,eAAiBC,EACpB/S,KAAKsS,eAAe3hB,IAAI,CAAC0hB,EAAMhf,IAAM2M,KAAKgT,oBAAoB3f,MAIlE8R,cAAczM,GAMZ,GAAIsH,KAAKsS,eAAeliB,SAAWsI,IAAYA,EAAQgK,UACrD,OAAO1C,KAAKiT,qBAGd,MAAMvQ,EAAYhK,EAAQgK,UAG1B,MAAO,CAACnO,EAAGC,KACT,IAAKkO,EAAU4D,IAAI/R,EAAEoK,KACnB,MAAMtO,MAAK,wBAAAsC,OAAyB4B,EAAEoK,MAGxC,IAAK+D,EAAU4D,IAAI9R,EAAEmK,KACnB,MAAMtO,MAAK,wBAAAsC,OAAyB6B,EAAEmK,MAGxC,OAAO+D,EAAUmC,IAAItQ,EAAEoK,KAAO+D,EAAUmC,IAAIrQ,EAAEmK,MAOlDuU,aAAaC,EAAMC,GACjB,GAAID,EAAK/iB,SAAW4P,KAAKsS,eAAeliB,QACpCgjB,EAAKhjB,SAAW4P,KAAKsS,eAAeliB,OACtC,MAAMC,MAAM,wBAGd,OAAO2P,KAAK8S,eAAeK,EAAMC,GAKnCC,qBAAqB7d,EAAK8d,GACxB,GAAmC,IAA/BtT,KAAKsS,eAAeliB,OACtB,MAAM,IAAIC,MAAM,sCAGlB,MAAMkjB,EAAkB7F,GAAO,GAAA/a,OAAO+a,EAAQjR,KAAK,KAApB,KAE/B,IAAI+W,EAAa,KAGjB,MAAMC,EAAuBzT,KAAKsS,eAAe3hB,IAAI0hB,IAGnD,IAAIjZ,EAAW1K,EAAuB2jB,EAAKM,OAAOnd,IAAM,GAInD4D,EAAShJ,SACZgJ,IAAc5I,WAAO,KAGvB,MAAM8I,EAAUhK,OAAOsW,OAAO,MAC9B,IAAI8N,GAAY,EAwChB,GAtCAta,EAASa,QAAQlC,IACf,IAAKA,EAAOG,aAAc,CAIxB,GAAIkB,EAAShJ,OAAS,EACpB,MAAMC,MAAM,wCAId,YADAiJ,EAAQ,IAAMvB,EAAOvH,OAIvBkjB,GAAY,EAEZ,MAAMhW,EAAO6V,EAAgBxb,EAAOG,cAEpC,GAAI5J,EAAOoE,KAAK4G,EAASoE,GACvB,MAAMrN,MAAK,mBAAAsC,OAAoB+K,IAejC,GAZApE,EAAQoE,GAAQ3F,EAAOvH,MAYnBgjB,IAAellB,EAAOoE,KAAK8gB,EAAY9V,GACzC,MAAMrN,MAAM,kCAIZmjB,GAGF,IAAKllB,EAAOoE,KAAK4G,EAAS,KACtBhK,OAAO4E,KAAKsf,GAAYpjB,SAAWd,OAAO4E,KAAKoF,GAASlJ,OAC1D,MAAMC,MAAM,sCAELqjB,IACTF,KAEAlkB,OAAO4E,KAAKoF,GAASW,QAAQyD,IAC3B8V,EAAW9V,IAAQ,KAIvB,OAAOpE,IAGT,GAAKka,EAeLlkB,OAAO4E,KAAKsf,GAAYvZ,QAAQyD,IAC9B,MAAMtJ,EAAMqf,EAAqB9iB,IAAIif,IACnC,GAAIthB,EAAOoE,KAAKkd,EAAQ,IACtB,OAAOA,EAAO,IAGhB,IAAKthB,EAAOoE,KAAKkd,EAAQlS,GACvB,MAAMrN,MAAM,iBAGd,OAAOuf,EAAOlS,KAGhB4V,EAAGlf,SA5BL,CAEE,MAAMuf,EAAUF,EAAqB9iB,IAAIif,IACvC,IAAKthB,EAAOoE,KAAKkd,EAAQ,IACvB,MAAMvf,MAAM,8BAGd,OAAOuf,EAAO,MAGhB0D,EAAGK,IAwBPV,qBACE,OAAIjT,KAAKuS,cACAvS,KAAKuS,cAKTvS,KAAKsS,eAAeliB,OAIlB,CAACwjB,EAAMC,KACZ,MAAMV,EAAOnT,KAAK8T,kBAAkBF,GAC9BR,EAAOpT,KAAK8T,kBAAkBD,GACpC,OAAO7T,KAAKkT,aAAaC,EAAMC,IANxB,CAACQ,EAAMC,IAAS,EAoB3BC,kBAAkBte,GAChB,IAAIhD,EAAS,KAab,OAXAwN,KAAKqT,qBAAqB7d,EAAKpB,IACd,OAAX5B,EAKAwN,KAAKkT,aAAa9e,EAAK5B,GAAU,IACnCA,EAAS4B,GALT5B,EAAS4B,IASN5B,EAGTif,YACE,OAAOzR,KAAKsS,eAAe3hB,IAAIojB,GAAQA,EAAKrW,MAK9CsV,oBAAoB3f,GAClB,MAAM2gB,GAAUhU,KAAKsS,eAAejf,GAAGof,UAEvC,MAAO,CAACU,EAAMC,KACZ,MAAMa,EAAU7lB,EAAgBwE,GAAGuJ,KAAKgX,EAAK9f,GAAI+f,EAAK/f,IACtD,OAAO2gB,GAAUC,EAAUA,IASjC,SAASlB,EAAmBmB,GAC1B,MAAO,CAAC3f,EAAGC,KACT,IAAK,IAAInB,EAAI,EAAGA,EAAI6gB,EAAgB9jB,SAAUiD,EAAG,CAC/C,MAAM4gB,EAAUC,EAAgB7gB,GAAGkB,EAAGC,GACtC,GAAgB,IAAZyf,EACF,OAAOA,EAIX,OAAO\",\"sourcesContent\":[\"import './minimongo_common.js';\\n\",\"import LocalCollection from './local_collection.js';\\n\\nexport const hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Each element selector contains:\\n//  - compileElementSelector, a function with args:\\n//    - operand - the \\\"right hand side\\\" of the operator\\n//    - valueSelector - the \\\"context\\\" for the operator (so that $regex can find\\n//      $options)\\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\\n//      more things)\\n//    returning a function mapping a single value to bool.\\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\\n//    being called\\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\\n//    expandArraysInBranches if it is called\\nexport const ELEMENT_OPERATORS = {\\n  $lt: makeInequality(cmpValue => cmpValue < 0),\\n  $gt: makeInequality(cmpValue => cmpValue > 0),\\n  $lte: makeInequality(cmpValue => cmpValue <= 0),\\n  $gte: makeInequality(cmpValue => cmpValue >= 0),\\n  $mod: {\\n    compileElementSelector(operand) {\\n      if (!(Array.isArray(operand) && operand.length === 2\\n            && typeof operand[0] === 'number'\\n            && typeof operand[1] === 'number')) {\\n        throw Error('argument to $mod must be an array of two numbers');\\n      }\\n\\n      // XXX could require to be ints or round or something\\n      const divisor = operand[0];\\n      const remainder = operand[1];\\n      return value => (\\n        typeof value === 'number' && value % divisor === remainder\\n      );\\n    },\\n  },\\n  $in: {\\n    compileElementSelector(operand) {\\n      if (!Array.isArray(operand)) {\\n        throw Error('$in needs an array');\\n      }\\n\\n      const elementMatchers = operand.map(option => {\\n        if (option instanceof RegExp) {\\n          return regexpElementMatcher(option);\\n        }\\n\\n        if (isOperatorObject(option)) {\\n          throw Error('cannot nest $ under $in');\\n        }\\n\\n        return equalityElementMatcher(option);\\n      });\\n\\n      return value => {\\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\\n        if (value === undefined) {\\n          value = null;\\n        }\\n\\n        return elementMatchers.some(matcher => matcher(value));\\n      };\\n    },\\n  },\\n  $size: {\\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\\n    // possible value.\\n    dontExpandLeafArrays: true,\\n    compileElementSelector(operand) {\\n      if (typeof operand === 'string') {\\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\\n        // does.\\n        operand = 0;\\n      } else if (typeof operand !== 'number') {\\n        throw Error('$size needs a number');\\n      }\\n\\n      return value => Array.isArray(value) && value.length === operand;\\n    },\\n  },\\n  $type: {\\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\\n    // should *not* include it itself.\\n    dontIncludeLeafArrays: true,\\n    compileElementSelector(operand) {\\n      if (typeof operand === 'string') {\\n        const operandAliasMap = {\\n          'double': 1,\\n          'string': 2,\\n          'object': 3,\\n          'array': 4,\\n          'binData': 5,\\n          'undefined': 6,\\n          'objectId': 7,\\n          'bool': 8,\\n          'date': 9,\\n          'null': 10,\\n          'regex': 11,\\n          'dbPointer': 12,\\n          'javascript': 13,\\n          'symbol': 14,\\n          'javascriptWithScope': 15,\\n          'int': 16,\\n          'timestamp': 17,\\n          'long': 18,\\n          'decimal': 19,\\n          'minKey': -1,\\n          'maxKey': 127,\\n        };\\n        if (!hasOwn.call(operandAliasMap, operand)) {\\n          throw Error(`unknown string alias for $type: ${operand}`);\\n        }\\n        operand = operandAliasMap[operand];\\n      } else if (typeof operand === 'number') {\\n        if (operand === 0 || operand < -1\\n          || (operand > 19 && operand !== 127)) {\\n          throw Error(`Invalid numerical $type code: ${operand}`);\\n        }\\n      } else {\\n        throw Error('argument to $type is not a number or a string');\\n      }\\n\\n      return value => (\\n        value !== undefined && LocalCollection._f._type(value) === operand\\n      );\\n    },\\n  },\\n  $bitsAllSet: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAllSet');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.every((byte, i) => (bitmask[i] & byte) === byte);\\n      };\\n    },\\n  },\\n  $bitsAnySet: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAnySet');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.some((byte, i) => (~bitmask[i] & byte) !== byte);\\n      };\\n    },\\n  },\\n  $bitsAllClear: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAllClear');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.every((byte, i) => !(bitmask[i] & byte));\\n      };\\n    },\\n  },\\n  $bitsAnyClear: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAnyClear');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.some((byte, i) => (bitmask[i] & byte) !== byte);\\n      };\\n    },\\n  },\\n  $regex: {\\n    compileElementSelector(operand, valueSelector) {\\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\\n        throw Error('$regex has to be a string or RegExp');\\n      }\\n\\n      let regexp;\\n      if (valueSelector.$options !== undefined) {\\n        // Options passed in $options (even the empty string) always overrides\\n        // options in the RegExp object itself.\\n\\n        // Be clear that we only support the JS-supported options, not extended\\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\\n        // by transforming the regexp, but not today...\\n        if (/[^gim]/.test(valueSelector.$options)) {\\n          throw new Error('Only the i, m, and g regexp options are supported');\\n        }\\n\\n        const source = operand instanceof RegExp ? operand.source : operand;\\n        regexp = new RegExp(source, valueSelector.$options);\\n      } else if (operand instanceof RegExp) {\\n        regexp = operand;\\n      } else {\\n        regexp = new RegExp(operand);\\n      }\\n\\n      return regexpElementMatcher(regexp);\\n    },\\n  },\\n  $elemMatch: {\\n    dontExpandLeafArrays: true,\\n    compileElementSelector(operand, valueSelector, matcher) {\\n      if (!LocalCollection._isPlainObject(operand)) {\\n        throw Error('$elemMatch need an object');\\n      }\\n\\n      const isDocMatcher = !isOperatorObject(\\n        Object.keys(operand)\\n          .filter(key => !hasOwn.call(LOGICAL_OPERATORS, key))\\n          .reduce((a, b) => Object.assign(a, {[b]: operand[b]}), {}),\\n        true);\\n\\n      let subMatcher;\\n      if (isDocMatcher) {\\n        // This is NOT the same as compileValueSelector(operand), and not just\\n        // because of the slightly different calling convention.\\n        // {$elemMatch: {x: 3}} means \\\"an element has a field x:3\\\", not\\n        // \\\"consists only of a field x:3\\\". Also, regexps and sub-$ are allowed.\\n        subMatcher =\\n          compileDocumentSelector(operand, matcher, {inElemMatch: true});\\n      } else {\\n        subMatcher = compileValueSelector(operand, matcher);\\n      }\\n\\n      return value => {\\n        if (!Array.isArray(value)) {\\n          return false;\\n        }\\n\\n        for (let i = 0; i < value.length; ++i) {\\n          const arrayElement = value[i];\\n          let arg;\\n          if (isDocMatcher) {\\n            // We can only match {$elemMatch: {b: 3}} against objects.\\n            // (We can also match against arrays, if there's numeric indices,\\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\\n            if (!isIndexable(arrayElement)) {\\n              return false;\\n            }\\n\\n            arg = arrayElement;\\n          } else {\\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\\n            // {a: [8]} but not {a: [[8]]}\\n            arg = [{value: arrayElement, dontIterate: true}];\\n          }\\n          // XXX support $near in $elemMatch by propagating $distance?\\n          if (subMatcher(arg).result) {\\n            return i; // specially understood to mean \\\"use as arrayIndices\\\"\\n          }\\n        }\\n\\n        return false;\\n      };\\n    },\\n  },\\n};\\n\\n// Operators that appear at the top level of a document selector.\\nconst LOGICAL_OPERATORS = {\\n  $and(subSelector, matcher, inElemMatch) {\\n    return andDocumentMatchers(\\n      compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch)\\n    );\\n  },\\n\\n  $or(subSelector, matcher, inElemMatch) {\\n    const matchers = compileArrayOfDocumentSelectors(\\n      subSelector,\\n      matcher,\\n      inElemMatch\\n    );\\n\\n    // Special case: if there is only one matcher, use it directly, *preserving*\\n    // any arrayIndices it returns.\\n    if (matchers.length === 1) {\\n      return matchers[0];\\n    }\\n\\n    return doc => {\\n      const result = matchers.some(fn => fn(doc).result);\\n      // $or does NOT set arrayIndices when it has multiple\\n      // sub-expressions. (Tested against MongoDB.)\\n      return {result};\\n    };\\n  },\\n\\n  $nor(subSelector, matcher, inElemMatch) {\\n    const matchers = compileArrayOfDocumentSelectors(\\n      subSelector,\\n      matcher,\\n      inElemMatch\\n    );\\n    return doc => {\\n      const result = matchers.every(fn => !fn(doc).result);\\n      // Never set arrayIndices, because we only match if nothing in particular\\n      // 'matched' (and because this is consistent with MongoDB).\\n      return {result};\\n    };\\n  },\\n\\n  $where(selectorValue, matcher) {\\n    // Record that *any* path may be used.\\n    matcher._recordPathUsed('');\\n    matcher._hasWhere = true;\\n\\n    if (!(selectorValue instanceof Function)) {\\n      // XXX MongoDB seems to have more complex logic to decide where or or not\\n      // to add 'return'; not sure exactly what it is.\\n      selectorValue = Function('obj', `return ${selectorValue}`);\\n    }\\n\\n    // We make the document available as both `this` and `obj`.\\n    // // XXX not sure what we should do if this throws\\n    return doc => ({result: selectorValue.call(doc, doc)});\\n  },\\n\\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\\n  // query logs); it has no effect on the actual selection.\\n  $comment() {\\n    return () => ({result: true});\\n  },\\n};\\n\\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\\n// \\\"match each branched value independently and combine with\\n// convertElementMatcherToBranchedMatcher\\\".\\nconst VALUE_OPERATORS = {\\n  $eq(operand) {\\n    return convertElementMatcherToBranchedMatcher(\\n      equalityElementMatcher(operand)\\n    );\\n  },\\n  $not(operand, valueSelector, matcher) {\\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\\n  },\\n  $ne(operand) {\\n    return invertBranchedMatcher(\\n      convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand))\\n    );\\n  },\\n  $nin(operand) {\\n    return invertBranchedMatcher(\\n      convertElementMatcherToBranchedMatcher(\\n        ELEMENT_OPERATORS.$in.compileElementSelector(operand)\\n      )\\n    );\\n  },\\n  $exists(operand) {\\n    const exists = convertElementMatcherToBranchedMatcher(\\n      value => value !== undefined\\n    );\\n    return operand ? exists : invertBranchedMatcher(exists);\\n  },\\n  // $options just provides options for $regex; its logic is inside $regex\\n  $options(operand, valueSelector) {\\n    if (!hasOwn.call(valueSelector, '$regex')) {\\n      throw Error('$options needs a $regex');\\n    }\\n\\n    return everythingMatcher;\\n  },\\n  // $maxDistance is basically an argument to $near\\n  $maxDistance(operand, valueSelector) {\\n    if (!valueSelector.$near) {\\n      throw Error('$maxDistance needs a $near');\\n    }\\n\\n    return everythingMatcher;\\n  },\\n  $all(operand, valueSelector, matcher) {\\n    if (!Array.isArray(operand)) {\\n      throw Error('$all requires array');\\n    }\\n\\n    // Not sure why, but this seems to be what MongoDB does.\\n    if (operand.length === 0) {\\n      return nothingMatcher;\\n    }\\n\\n    const branchedMatchers = operand.map(criterion => {\\n      // XXX handle $all/$elemMatch combination\\n      if (isOperatorObject(criterion)) {\\n        throw Error('no $ expressions in $all');\\n      }\\n\\n      // This is always a regexp or equality selector.\\n      return compileValueSelector(criterion, matcher);\\n    });\\n\\n    // andBranchedMatchers does NOT require all selectors to return true on the\\n    // SAME branch.\\n    return andBranchedMatchers(branchedMatchers);\\n  },\\n  $near(operand, valueSelector, matcher, isRoot) {\\n    if (!isRoot) {\\n      throw Error('$near can\\\\'t be inside another $ operator');\\n    }\\n\\n    matcher._hasGeoQuery = true;\\n\\n    // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\\n    // marked with a $geometry property, though legacy coordinates can be\\n    // matched using $geometry.\\n    let maxDistance, point, distance;\\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\\n      // GeoJSON \\\"2dsphere\\\" mode.\\n      maxDistance = operand.$maxDistance;\\n      point = operand.$geometry;\\n      distance = value => {\\n        // XXX: for now, we don't calculate the actual distance between, say,\\n        // polygon and circle. If people care about this use-case it will get\\n        // a priority.\\n        if (!value) {\\n          return null;\\n        }\\n\\n        if (!value.type) {\\n          return GeoJSON.pointDistance(\\n            point,\\n            {type: 'Point', coordinates: pointToArray(value)}\\n          );\\n        }\\n\\n        if (value.type === 'Point') {\\n          return GeoJSON.pointDistance(point, value);\\n        }\\n\\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance)\\n          ? 0\\n          : maxDistance + 1;\\n      };\\n    } else {\\n      maxDistance = valueSelector.$maxDistance;\\n\\n      if (!isIndexable(operand)) {\\n        throw Error('$near argument must be coordinate pair or GeoJSON');\\n      }\\n\\n      point = pointToArray(operand);\\n\\n      distance = value => {\\n        if (!isIndexable(value)) {\\n          return null;\\n        }\\n\\n        return distanceCoordinatePairs(point, value);\\n      };\\n    }\\n\\n    return branchedValues => {\\n      // There might be multiple points in the document that match the given\\n      // field. Only one of them needs to be within $maxDistance, but we need to\\n      // evaluate all of them and use the nearest one for the implicit sort\\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\\n      //\\n      // Note: This differs from MongoDB's implementation, where a document will\\n      // actually show up *multiple times* in the result set, with one entry for\\n      // each within-$maxDistance branching point.\\n      const result = {result: false};\\n      expandArraysInBranches(branchedValues).every(branch => {\\n        // if operation is an update, don't skip branches, just return the first\\n        // one (#3599)\\n        let curDistance;\\n        if (!matcher._isUpdate) {\\n          if (!(typeof branch.value === 'object')) {\\n            return true;\\n          }\\n\\n          curDistance = distance(branch.value);\\n\\n          // Skip branches that aren't real points or are too far away.\\n          if (curDistance === null || curDistance > maxDistance) {\\n            return true;\\n          }\\n\\n          // Skip anything that's a tie.\\n          if (result.distance !== undefined && result.distance <= curDistance) {\\n            return true;\\n          }\\n        }\\n\\n        result.result = true;\\n        result.distance = curDistance;\\n\\n        if (branch.arrayIndices) {\\n          result.arrayIndices = branch.arrayIndices;\\n        } else {\\n          delete result.arrayIndices;\\n        }\\n\\n        return !matcher._isUpdate;\\n      });\\n\\n      return result;\\n    };\\n  },\\n};\\n\\n// NB: We are cheating and using this function to implement 'AND' for both\\n// 'document matchers' and 'branched matchers'. They both return result objects\\n// but the argument is different: for the former it's a whole doc, whereas for\\n// the latter it's an array of 'branched values'.\\nfunction andSomeMatchers(subMatchers) {\\n  if (subMatchers.length === 0) {\\n    return everythingMatcher;\\n  }\\n\\n  if (subMatchers.length === 1) {\\n    return subMatchers[0];\\n  }\\n\\n  return docOrBranches => {\\n    const match = {};\\n    match.result = subMatchers.every(fn => {\\n      const subResult = fn(docOrBranches);\\n\\n      // Copy a 'distance' number out of the first sub-matcher that has\\n      // one. Yes, this means that if there are multiple $near fields in a\\n      // query, something arbitrary happens; this appears to be consistent with\\n      // Mongo.\\n      if (subResult.result &&\\n          subResult.distance !== undefined &&\\n          match.distance === undefined) {\\n        match.distance = subResult.distance;\\n      }\\n\\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\\n      // wins.\\n      if (subResult.result && subResult.arrayIndices) {\\n        match.arrayIndices = subResult.arrayIndices;\\n      }\\n\\n      return subResult.result;\\n    });\\n\\n    // If we didn't actually match, forget any extra metadata we came up with.\\n    if (!match.result) {\\n      delete match.distance;\\n      delete match.arrayIndices;\\n    }\\n\\n    return match;\\n  };\\n}\\n\\nconst andDocumentMatchers = andSomeMatchers;\\nconst andBranchedMatchers = andSomeMatchers;\\n\\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\\n  if (!Array.isArray(selectors) || selectors.length === 0) {\\n    throw Error('$and/$or/$nor must be nonempty array');\\n  }\\n\\n  return selectors.map(subSelector => {\\n    if (!LocalCollection._isPlainObject(subSelector)) {\\n      throw Error('$or/$and/$nor entries need to be full objects');\\n    }\\n\\n    return compileDocumentSelector(subSelector, matcher, {inElemMatch});\\n  });\\n}\\n\\n// Takes in a selector that could match a full document (eg, the original\\n// selector). Returns a function mapping document->result object.\\n//\\n// matcher is the Matcher object we are compiling.\\n//\\n// If this is the root document selector (ie, not wrapped in $and or the like),\\n// then isRoot is true. (This is used by $near.)\\nexport function compileDocumentSelector(docSelector, matcher, options = {}) {\\n  const docMatchers = Object.keys(docSelector).map(key => {\\n    const subSelector = docSelector[key];\\n\\n    if (key.substr(0, 1) === '$') {\\n      // Outer operators are either logical operators (they recurse back into\\n      // this function), or $where.\\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\\n        throw new Error(`Unrecognized logical operator: ${key}`);\\n      }\\n\\n      matcher._isSimple = false;\\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\\n    }\\n\\n    // Record this path, but only if we aren't in an elemMatcher, since in an\\n    // elemMatch this is a path inside an object in an array, not in the doc\\n    // root.\\n    if (!options.inElemMatch) {\\n      matcher._recordPathUsed(key);\\n    }\\n\\n    // Don't add a matcher if subSelector is a function -- this is to match\\n    // the behavior of Meteor on the server (inherited from the node mongodb\\n    // driver), which is to ignore any part of a selector which is a function.\\n    if (typeof subSelector === 'function') {\\n      return undefined;\\n    }\\n\\n    const lookUpByIndex = makeLookupFunction(key);\\n    const valueMatcher = compileValueSelector(\\n      subSelector,\\n      matcher,\\n      options.isRoot\\n    );\\n\\n    return doc => valueMatcher(lookUpByIndex(doc));\\n  }).filter(Boolean);\\n\\n  return andDocumentMatchers(docMatchers);\\n}\\n\\n// Takes in a selector that could match a key-indexed value in a document; eg,\\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\\n// indicate equality).  Returns a branched matcher: a function mapping\\n// [branched value]->result object.\\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\\n  if (valueSelector instanceof RegExp) {\\n    matcher._isSimple = false;\\n    return convertElementMatcherToBranchedMatcher(\\n      regexpElementMatcher(valueSelector)\\n    );\\n  }\\n\\n  if (isOperatorObject(valueSelector)) {\\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\\n  }\\n\\n  return convertElementMatcherToBranchedMatcher(\\n    equalityElementMatcher(valueSelector)\\n  );\\n}\\n\\n// Given an element matcher (which evaluates a single value), returns a branched\\n// value (which evaluates the element matcher on all the branches and returns a\\n// more structured return value possibly including arrayIndices).\\nfunction convertElementMatcherToBranchedMatcher(elementMatcher, options = {}) {\\n  return branches => {\\n    const expanded = options.dontExpandLeafArrays\\n      ? branches\\n      : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\\n\\n    const match = {};\\n    match.result = expanded.some(element => {\\n      let matched = elementMatcher(element.value);\\n\\n      // Special case for $elemMatch: it means \\\"true, and use this as an array\\n      // index if I didn't already have one\\\".\\n      if (typeof matched === 'number') {\\n        // XXX This code dates from when we only stored a single array index\\n        // (for the outermost array). Should we be also including deeper array\\n        // indices from the $elemMatch match?\\n        if (!element.arrayIndices) {\\n          element.arrayIndices = [matched];\\n        }\\n\\n        matched = true;\\n      }\\n\\n      // If some element matched, and it's tagged with array indices, include\\n      // those indices in our result object.\\n      if (matched && element.arrayIndices) {\\n        match.arrayIndices = element.arrayIndices;\\n      }\\n\\n      return matched;\\n    });\\n\\n    return match;\\n  };\\n}\\n\\n// Helpers for $near.\\nfunction distanceCoordinatePairs(a, b) {\\n  const pointA = pointToArray(a);\\n  const pointB = pointToArray(b);\\n\\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\\n}\\n\\n// Takes something that is not an operator object and returns an element matcher\\n// for equality with that thing.\\nexport function equalityElementMatcher(elementSelector) {\\n  if (isOperatorObject(elementSelector)) {\\n    throw Error('Can\\\\'t create equalityValueSelector for operator object');\\n  }\\n\\n  // Special-case: null and undefined are equal (if you got undefined in there\\n  // somewhere, or if you got it due to some branch being non-existent in the\\n  // weird special case), even though they aren't with EJSON.equals.\\n  // undefined or null\\n  if (elementSelector == null) {\\n    return value => value == null;\\n  }\\n\\n  return value => LocalCollection._f._equal(elementSelector, value);\\n}\\n\\nfunction everythingMatcher(docOrBranchedValues) {\\n  return {result: true};\\n}\\n\\nexport function expandArraysInBranches(branches, skipTheArrays) {\\n  const branchesOut = [];\\n\\n  branches.forEach(branch => {\\n    const thisIsArray = Array.isArray(branch.value);\\n\\n    // We include the branch itself, *UNLESS* we it's an array that we're going\\n    // to iterate and we're told to skip arrays.  (That's right, we include some\\n    // arrays even skipTheArrays is true: these are arrays that were found via\\n    // explicit numerical indices.)\\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\\n      branchesOut.push({arrayIndices: branch.arrayIndices, value: branch.value});\\n    }\\n\\n    if (thisIsArray && !branch.dontIterate) {\\n      branch.value.forEach((value, i) => {\\n        branchesOut.push({\\n          arrayIndices: (branch.arrayIndices || []).concat(i),\\n          value\\n        });\\n      });\\n    }\\n  });\\n\\n  return branchesOut;\\n}\\n\\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\\nfunction getOperandBitmask(operand, selector) {\\n  // numeric bitmask\\n  // You can provide a numeric bitmask to be matched against the operand field.\\n  // It must be representable as a non-negative 32-bit signed integer.\\n  // Otherwise, $bitsAllSet will return an error.\\n  if (Number.isInteger(operand) && operand >= 0) {\\n    return new Uint8Array(new Int32Array([operand]).buffer);\\n  }\\n\\n  // bindata bitmask\\n  // You can also use an arbitrarily large BinData instance as a bitmask.\\n  if (EJSON.isBinary(operand)) {\\n    return new Uint8Array(operand.buffer);\\n  }\\n\\n  // position list\\n  // If querying a list of bit positions, each <position> must be a non-negative\\n  // integer. Bit positions start at 0 from the least significant bit.\\n  if (Array.isArray(operand) &&\\n      operand.every(x => Number.isInteger(x) && x >= 0)) {\\n    const buffer = new ArrayBuffer((Math.max(...operand) >> 3) + 1);\\n    const view = new Uint8Array(buffer);\\n\\n    operand.forEach(x => {\\n      view[x >> 3] |= 1 << (x & 0x7);\\n    });\\n\\n    return view;\\n  }\\n\\n  // bad operand\\n  throw Error(\\n    `operand to ${selector} must be a numeric bitmask (representable as a ` +\\n    'non-negative 32-bit signed integer), a bindata bitmask or an array with ' +\\n    'bit positions (non-negative integers)'\\n  );\\n}\\n\\nfunction getValueBitmask(value, length) {\\n  // The field value must be either numerical or a BinData instance. Otherwise,\\n  // $bits... will not match the current document.\\n\\n  // numerical\\n  if (Number.isSafeInteger(value)) {\\n    // $bits... will not match numerical values that cannot be represented as a\\n    // signed 64-bit integer. This can be the case if a value is either too\\n    // large or small to fit in a signed 64-bit integer, or if it has a\\n    // fractional component.\\n    const buffer = new ArrayBuffer(\\n      Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT)\\n    );\\n\\n    let view = new Uint32Array(buffer, 0, 2);\\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0;\\n\\n    // sign extension\\n    if (value < 0) {\\n      view = new Uint8Array(buffer, 2);\\n      view.forEach((byte, i) => {\\n        view[i] = 0xff;\\n      });\\n    }\\n\\n    return new Uint8Array(buffer);\\n  }\\n\\n  // bindata\\n  if (EJSON.isBinary(value)) {\\n    return new Uint8Array(value.buffer);\\n  }\\n\\n  // no match\\n  return false;\\n}\\n\\n// Actually inserts a key value into the selector document\\n// However, this checks there is no ambiguity in setting\\n// the value for the given key, throws otherwise\\nfunction insertIntoDocument(document, key, value) {\\n  Object.keys(document).forEach(existingKey => {\\n    if (\\n      (existingKey.length > key.length && existingKey.indexOf(`${key}.`) === 0) ||\\n      (key.length > existingKey.length && key.indexOf(`${existingKey}.`) === 0)\\n    ) {\\n      throw new Error(\\n        `cannot infer query fields to set, both paths '${existingKey}' and ` +\\n        `'${key}' are matched`\\n      );\\n    } else if (existingKey === key) {\\n      throw new Error(\\n        `cannot infer query fields to set, path '${key}' is matched twice`\\n      );\\n    }\\n  });\\n\\n  document[key] = value;\\n}\\n\\n// Returns a branched matcher that matches iff the given matcher does not.\\n// Note that this implicitly \\\"deMorganizes\\\" the wrapped function.  ie, it\\n// means that ALL branch values need to fail to match innerBranchedMatcher.\\nfunction invertBranchedMatcher(branchedMatcher) {\\n  return branchValues => {\\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\\n    // say \\\"update the array element that does not match something\\\", at least\\n    // in mongo-land.\\n    return {result: !branchedMatcher(branchValues).result};\\n  };\\n}\\n\\nexport function isIndexable(obj) {\\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\\n}\\n\\nexport function isNumericKey(s) {\\n  return /^[0-9]+$/.test(s);\\n}\\n\\n// Returns true if this is an object with at least one key and all keys begin\\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\\n// others don't.\\nexport function isOperatorObject(valueSelector, inconsistentOK) {\\n  if (!LocalCollection._isPlainObject(valueSelector)) {\\n    return false;\\n  }\\n\\n  let theseAreOperators = undefined;\\n  Object.keys(valueSelector).forEach(selKey => {\\n    const thisIsOperator = selKey.substr(0, 1) === '$';\\n\\n    if (theseAreOperators === undefined) {\\n      theseAreOperators = thisIsOperator;\\n    } else if (theseAreOperators !== thisIsOperator) {\\n      if (!inconsistentOK) {\\n        throw new Error(\\n          `Inconsistent operator: ${JSON.stringify(valueSelector)}`\\n        );\\n      }\\n\\n      theseAreOperators = false;\\n    }\\n  });\\n\\n  return !!theseAreOperators; // {} has no operators\\n}\\n\\n// Helper for $lt/$gt/$lte/$gte.\\nfunction makeInequality(cmpValueComparator) {\\n  return {\\n    compileElementSelector(operand) {\\n      // Arrays never compare false with non-arrays for any inequality.\\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\\n      //     it seems to have been reverted.\\n      //     See https://jira.mongodb.org/browse/SERVER-11444\\n      if (Array.isArray(operand)) {\\n        return () => false;\\n      }\\n\\n      // Special case: consider undefined and null the same (so true with\\n      // $gte/$lte).\\n      if (operand === undefined) {\\n        operand = null;\\n      }\\n\\n      const operandType = LocalCollection._f._type(operand);\\n\\n      return value => {\\n        if (value === undefined) {\\n          value = null;\\n        }\\n\\n        // Comparisons are never true among things of different type (except\\n        // null vs undefined).\\n        if (LocalCollection._f._type(value) !== operandType) {\\n          return false;\\n        }\\n\\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\\n      };\\n    },\\n  };\\n}\\n\\n// makeLookupFunction(key) returns a lookup function.\\n//\\n// A lookup function takes in a document and returns an array of matching\\n// branches.  If no arrays are found while looking up the key, this array will\\n// have exactly one branches (possibly 'undefined', if some segment of the key\\n// was not found).\\n//\\n// If arrays are found in the middle, this can have more than one element, since\\n// we 'branch'. When we 'branch', if there are more key segments to look up,\\n// then we only pursue branches that are plain objects (not arrays or scalars).\\n// This means we can actually end up with no branches!\\n//\\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\\n// dotted member of the key). We just return that array; if you want to\\n// effectively 'branch' over the array's values, post-process the lookup\\n// function with expandArraysInBranches.\\n//\\n// Each branch is an object with keys:\\n//  - value: the value at the branch\\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\\n//    that expandArraysInBranches should NOT expand. This specifically happens\\n//    when there is a numeric index in the key, and ensures the\\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\\n//    match {a: [[5]]}.\\n//  - arrayIndices: if any array indexing was done during lookup (either due to\\n//    explicit numeric indices or implicit branching), this will be an array of\\n//    the array indices used, from outermost to innermost; it is falsey or\\n//    absent if no array index is used. If an explicit numeric index is used,\\n//    the index will be followed in arrayIndices by the string 'x'.\\n//\\n//    Note: arrayIndices is used for two purposes. First, it is used to\\n//    implement the '$' modifier feature, which only ever looks at its first\\n//    element.\\n//\\n//    Second, it is used for sort key generation, which needs to be able to tell\\n//    the difference between different paths. Moreover, it needs to\\n//    differentiate between explicit and implicit branching, which is why\\n//    there's the somewhat hacky 'x' entry: this means that explicit and\\n//    implicit array lookups will have different full arrayIndices paths. (That\\n//    code only requires that different paths have different arrayIndices; it\\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\\n//    could contain objects with flags like 'implicit', but I think that only\\n//    makes the code surrounding them more complex.)\\n//\\n//    (By the way, this field ends up getting passed around a lot without\\n//    cloning, so never mutate any arrayIndices field/var in this package!)\\n//\\n//\\n// At the top level, you may only pass in a plain object or array.\\n//\\n// See the test 'minimongo - lookup' for some examples of what lookup functions\\n// return.\\nexport function makeLookupFunction(key, options = {}) {\\n  const parts = key.split('.');\\n  const firstPart = parts.length ? parts[0] : '';\\n  const lookupRest = (\\n    parts.length > 1 &&\\n    makeLookupFunction(parts.slice(1).join('.'), options)\\n  );\\n\\n  const omitUnnecessaryFields = result => {\\n    if (!result.dontIterate) {\\n      delete result.dontIterate;\\n    }\\n\\n    if (result.arrayIndices && !result.arrayIndices.length) {\\n      delete result.arrayIndices;\\n    }\\n\\n    return result;\\n  };\\n\\n  // Doc will always be a plain object or an array.\\n  // apply an explicit numeric index, an array.\\n  return (doc, arrayIndices = []) => {\\n    if (Array.isArray(doc)) {\\n      // If we're being asked to do an invalid lookup into an array (non-integer\\n      // or out-of-bounds), return no results (which is different from returning\\n      // a single undefined result, in that `null` equality checks won't match).\\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\\n        return [];\\n      }\\n\\n      // Remember that we used this array index. Include an 'x' to indicate that\\n      // the previous index came from being considered as an explicit array\\n      // index (not branching).\\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\\n    }\\n\\n    // Do our first lookup.\\n    const firstLevel = doc[firstPart];\\n\\n    // If there is no deeper to dig, return what we found.\\n    //\\n    // If what we found is an array, most value selectors will choose to treat\\n    // the elements of the array as matchable values in their own right, but\\n    // that's done outside of the lookup function. (Exceptions to this are $size\\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\\n    // [[1, 2]]}.)\\n    //\\n    // That said, if we just did an *explicit* array lookup (on doc) to find\\n    // firstLevel, and firstLevel is an array too, we do NOT want value\\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\\n    // So in that case, we mark the return value as 'don't iterate'.\\n    if (!lookupRest) {\\n      return [omitUnnecessaryFields({\\n        arrayIndices,\\n        dontIterate: Array.isArray(doc) && Array.isArray(firstLevel),\\n        value: firstLevel\\n      })];\\n    }\\n\\n    // We need to dig deeper.  But if we can't, because what we've found is not\\n    // an array or plain object, we're done. If we just did a numeric index into\\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\\n    // return a single `undefined` (which can, for example, match via equality\\n    // with `null`).\\n    if (!isIndexable(firstLevel)) {\\n      if (Array.isArray(doc)) {\\n        return [];\\n      }\\n\\n      return [omitUnnecessaryFields({arrayIndices, value: undefined})];\\n    }\\n\\n    const result = [];\\n    const appendToResult = more => {\\n      result.push(...more);\\n    };\\n\\n    // Dig deeper: look up the rest of the parts on whatever we've found.\\n    // (lookupRest is smart enough to not try to do invalid lookups into\\n    // firstLevel if it's an array.)\\n    appendToResult(lookupRest(firstLevel, arrayIndices));\\n\\n    // If we found an array, then in *addition* to potentially treating the next\\n    // part as a literal integer lookup, we should also 'branch': try to look up\\n    // the rest of the parts on each array element in parallel.\\n    //\\n    // In this case, we *only* dig deeper into array elements that are plain\\n    // objects. (Recall that we only got this far if we have further to dig.)\\n    // This makes sense: we certainly don't dig deeper into non-indexable\\n    // objects. And it would be weird to dig into an array: it's simpler to have\\n    // a rule that explicit integer indexes only apply to an outer array, not to\\n    // an array you find after a branching search.\\n    //\\n    // In the special case of a numeric part in a *sort selector* (not a query\\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\\n    // 'look up this index' in that case, not 'also look up this index in all\\n    // the elements of the array'.\\n    if (Array.isArray(firstLevel) &&\\n        !(isNumericKey(parts[1]) && options.forSort)) {\\n      firstLevel.forEach((branch, arrayIndex) => {\\n        if (LocalCollection._isPlainObject(branch)) {\\n          appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\\n        }\\n      });\\n    }\\n\\n    return result;\\n  };\\n}\\n\\n// Object exported only for unit testing.\\n// Use it to export private functions to test in Tinytest.\\nMinimongoTest = {makeLookupFunction};\\nMinimongoError = (message, options = {}) => {\\n  if (typeof message === 'string' && options.field) {\\n    message += ` for field '${options.field}'`;\\n  }\\n\\n  const error = new Error(message);\\n  error.name = 'MinimongoError';\\n  return error;\\n};\\n\\nexport function nothingMatcher(docOrBranchedValues) {\\n  return {result: false};\\n}\\n\\n// Takes an operator object (an object with $ keys) and returns a branched\\n// matcher for it.\\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\\n  // Each valueSelector works separately on the various branches.  So one\\n  // operator can match one branch and another can match another branch.  This\\n  // is OK.\\n  const operatorMatchers = Object.keys(valueSelector).map(operator => {\\n    const operand = valueSelector[operator];\\n\\n    const simpleRange = (\\n      ['$lt', '$lte', '$gt', '$gte'].includes(operator) &&\\n      typeof operand === 'number'\\n    );\\n\\n    const simpleEquality = (\\n      ['$ne', '$eq'].includes(operator) &&\\n      operand !== Object(operand)\\n    );\\n\\n    const simpleInclusion = (\\n      ['$in', '$nin'].includes(operator)\\n      && Array.isArray(operand)\\n      && !operand.some(x => x === Object(x))\\n    );\\n\\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\\n      matcher._isSimple = false;\\n    }\\n\\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\\n    }\\n\\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\\n      const options = ELEMENT_OPERATORS[operator];\\n      return convertElementMatcherToBranchedMatcher(\\n        options.compileElementSelector(operand, valueSelector, matcher),\\n        options\\n      );\\n    }\\n\\n    throw new Error(`Unrecognized operator: ${operator}`);\\n  });\\n\\n  return andBranchedMatchers(operatorMatchers);\\n}\\n\\n// paths - Array: list of mongo style paths\\n// newLeafFn - Function: of form function(path) should return a scalar value to\\n//                       put into list created for that path\\n// conflictFn - Function: of form function(node, path, fullPath) is called\\n//                        when building a tree path for 'fullPath' node on\\n//                        'path' was already a leaf with a value. Must return a\\n//                        conflict resolution.\\n// initial tree - Optional Object: starting tree.\\n// @returns - Object: tree represented as a set of nested objects\\nexport function pathsToTree(paths, newLeafFn, conflictFn, root = {}) {\\n  paths.forEach(path => {\\n    const pathArray = path.split('.');\\n    let tree = root;\\n\\n    // use .every just for iteration with break\\n    const success = pathArray.slice(0, -1).every((key, i) => {\\n      if (!hasOwn.call(tree, key)) {\\n        tree[key] = {};\\n      } else if (tree[key] !== Object(tree[key])) {\\n        tree[key] = conflictFn(\\n          tree[key],\\n          pathArray.slice(0, i + 1).join('.'),\\n          path\\n        );\\n\\n        // break out of loop if we are failing for this path\\n        if (tree[key] !== Object(tree[key])) {\\n          return false;\\n        }\\n      }\\n\\n      tree = tree[key];\\n\\n      return true;\\n    });\\n\\n    if (success) {\\n      const lastKey = pathArray[pathArray.length - 1];\\n      if (hasOwn.call(tree, lastKey)) {\\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\\n      } else {\\n        tree[lastKey] = newLeafFn(path);\\n      }\\n    }\\n  });\\n\\n  return root;\\n}\\n\\n// Makes sure we get 2 elements array and assume the first one to be x and\\n// the second one to y no matter what user passes.\\n// In case user passes { lon: x, lat: y } returns [x, y]\\nfunction pointToArray(point) {\\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\\n}\\n\\n// Creating a document from an upsert is quite tricky.\\n// E.g. this selector: {\\\"$or\\\": [{\\\"b.foo\\\": {\\\"$all\\\": [\\\"bar\\\"]}}]}, should result\\n// in: {\\\"b.foo\\\": \\\"bar\\\"}\\n// But this selector: {\\\"$or\\\": [{\\\"b\\\": {\\\"foo\\\": {\\\"$all\\\": [\\\"bar\\\"]}}}]} should throw\\n// an error\\n\\n// Some rules (found mainly with trial & error, so there might be more):\\n// - handle all childs of $and (or implicit $and)\\n// - handle $or nodes with exactly 1 child\\n// - ignore $or nodes with more than 1 child\\n// - ignore $nor and $not nodes\\n// - throw when a value can not be set unambiguously\\n// - every value for $all should be dealt with as separate $eq-s\\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\\n//   otherwise throw error)\\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\\n// - you can only have dotted keys on a root-level\\n// - you can not have '$'-prefixed keys more than one-level deep in an object\\n\\n// Handles one key/value pair to put in the selector document\\nfunction populateDocumentWithKeyValue(document, key, value) {\\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\\n    populateDocumentWithObject(document, key, value);\\n  } else if (!(value instanceof RegExp)) {\\n    insertIntoDocument(document, key, value);\\n  }\\n}\\n\\n// Handles a key, value pair to put in the selector document\\n// if the value is an object\\nfunction populateDocumentWithObject(document, key, value) {\\n  const keys = Object.keys(value);\\n  const unprefixedKeys = keys.filter(op => op[0] !== '$');\\n\\n  if (unprefixedKeys.length > 0 || !keys.length) {\\n    // Literal (possibly empty) object ( or empty object )\\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\\n    if (keys.length !== unprefixedKeys.length) {\\n      throw new Error(`unknown operator: ${unprefixedKeys[0]}`);\\n    }\\n\\n    validateObject(value, key);\\n    insertIntoDocument(document, key, value);\\n  } else {\\n    Object.keys(value).forEach(op => {\\n      const object = value[op];\\n\\n      if (op === '$eq') {\\n        populateDocumentWithKeyValue(document, key, object);\\n      } else if (op === '$all') {\\n        // every value for $all should be dealt with as separate $eq-s\\n        object.forEach(element =>\\n          populateDocumentWithKeyValue(document, key, element)\\n        );\\n      }\\n    });\\n  }\\n}\\n\\n// Fills a document with certain fields from an upsert selector\\nexport function populateDocumentWithQueryFields(query, document = {}) {\\n  if (Object.getPrototypeOf(query) === Object.prototype) {\\n    // handle implicit $and\\n    Object.keys(query).forEach(key => {\\n      const value = query[key];\\n\\n      if (key === '$and') {\\n        // handle explicit $and\\n        value.forEach(element =>\\n          populateDocumentWithQueryFields(element, document)\\n        );\\n      } else if (key === '$or') {\\n        // handle $or nodes with exactly 1 child\\n        if (value.length === 1) {\\n          populateDocumentWithQueryFields(value[0], document);\\n        }\\n      } else if (key[0] !== '$') {\\n        // Ignore other '$'-prefixed logical selectors\\n        populateDocumentWithKeyValue(document, key, value);\\n      }\\n    });\\n  } else {\\n    // Handle meteor-specific shortcut for selecting _id\\n    if (LocalCollection._selectorIsId(query)) {\\n      insertIntoDocument(document, '_id', query);\\n    }\\n  }\\n\\n  return document;\\n}\\n\\n// Traverses the keys of passed projection and constructs a tree where all\\n// leaves are either all True or all False\\n// @returns Object:\\n//  - tree - Object - tree representation of keys involved in projection\\n//  (exception for '_id' as it is a special case handled separately)\\n//  - including - Boolean - \\\"take only certain fields\\\" type of projection\\nexport function projectionDetails(fields) {\\n  // Find the non-_id keys (_id is handled specially because it is included\\n  // unless explicitly excluded). Sort the keys, so that our code to detect\\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\\n  let fieldsKeys = Object.keys(fields).sort();\\n\\n  // If _id is the only field in the projection, do not remove it, since it is\\n  // required to determine if this is an exclusion or exclusion. Also keep an\\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\\n  // inclusive and exclusive fields. If _id is not the only field in the\\n  // projection and is exclusive, remove it so it can be handled later by a\\n  // special case, since exclusive _id is always allowed.\\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\\n      !(fieldsKeys.includes('_id') && fields._id)) {\\n    fieldsKeys = fieldsKeys.filter(key => key !== '_id');\\n  }\\n\\n  let including = null; // Unknown\\n\\n  fieldsKeys.forEach(keyPath => {\\n    const rule = !!fields[keyPath];\\n\\n    if (including === null) {\\n      including = rule;\\n    }\\n\\n    // This error message is copied from MongoDB shell\\n    if (including !== rule) {\\n      throw MinimongoError(\\n        'You cannot currently mix including and excluding fields.'\\n      );\\n    }\\n  });\\n\\n  const projectionRulesTree = pathsToTree(\\n    fieldsKeys,\\n    path => including,\\n    (node, path, fullPath) => {\\n      // Check passed projection fields' keys: If you have two rules such as\\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\\n      // that happens, there is a probability you are doing something wrong,\\n      // framework should notify you about such mistake earlier on cursor\\n      // compilation step than later during runtime.  Note, that real mongo\\n      // doesn't do anything about it and the later rule appears in projection\\n      // project, more priority it takes.\\n      //\\n      // Example, assume following in mongo shell:\\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\\n      // {\\\"_id\\\": ObjectId(\\\"520bfe456024608e8ef24af3\\\"), \\\"a\\\": {\\\"b\\\": 23}}\\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\\n      // {\\\"_id\\\": ObjectId(\\\"520bfe456024608e8ef24af3\\\"), \\\"a\\\": {\\\"b\\\": 23, \\\"c\\\": 44}}\\n      //\\n      // Note, how second time the return set of keys is different.\\n      const currentPath = fullPath;\\n      const anotherPath = path;\\n      throw MinimongoError(\\n        `both ${currentPath} and ${anotherPath} found in fields option, ` +\\n        'using both of them may trigger unexpected behavior. Did you mean to ' +\\n        'use only one of them?'\\n      );\\n    });\\n\\n  return {including, tree: projectionRulesTree};\\n}\\n\\n// Takes a RegExp object and returns an element matcher.\\nexport function regexpElementMatcher(regexp) {\\n  return value => {\\n    if (value instanceof RegExp) {\\n      return value.toString() === regexp.toString();\\n    }\\n\\n    // Regexps only work against strings.\\n    if (typeof value !== 'string') {\\n      return false;\\n    }\\n\\n    // Reset regexp's state to avoid inconsistent matching for objects with the\\n    // same value on consecutive calls of regexp.test. This happens only if the\\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\\n    // which we should *not* change the lastIndex but MongoDB doesn't support\\n    // either of these flags.\\n    regexp.lastIndex = 0;\\n\\n    return regexp.test(value);\\n  };\\n}\\n\\n// Validates the key in a path.\\n// Objects that are nested more then 1 level cannot have dotted fields\\n// or fields starting with '$'\\nfunction validateKeyInPath(key, path) {\\n  if (key.includes('.')) {\\n    throw new Error(\\n      `The dotted field '${key}' in '${path}.${key} is not valid for storage.`\\n    );\\n  }\\n\\n  if (key[0] === '$') {\\n    throw new Error(\\n      `The dollar ($) prefixed field  '${path}.${key} is not valid for storage.`\\n    );\\n  }\\n}\\n\\n// Recursively validates an object that is nested more than one level deep\\nfunction validateObject(object, path) {\\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\\n    Object.keys(object).forEach(key => {\\n      validateKeyInPath(key, path);\\n      validateObject(object[key], path + '.' + key);\\n    });\\n  }\\n}\\n\",\"import LocalCollection from './local_collection.js';\\nimport { hasOwn } from './common.js';\\n\\n// Cursor: a specification for a particular subset of documents, w/ a defined\\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\\nexport default class Cursor {\\n  // don't call this ctor directly.  use LocalCollection.find().\\n  constructor(collection, selector, options = {}) {\\n    this.collection = collection;\\n    this.sorter = null;\\n    this.matcher = new Minimongo.Matcher(selector);\\n\\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n      // stash for fast _id and { _id }\\n      this._selectorId = hasOwn.call(selector, '_id')\\n        ? selector._id\\n        : selector;\\n    } else {\\n      this._selectorId = undefined;\\n\\n      if (this.matcher.hasGeoQuery() || options.sort) {\\n        this.sorter = new Minimongo.Sorter(options.sort || []);\\n      }\\n    }\\n\\n    this.skip = options.skip || 0;\\n    this.limit = options.limit;\\n    this.fields = options.fields;\\n\\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\\n\\n    this._transform = LocalCollection.wrapTransform(options.transform);\\n\\n    // by default, queries register w/ Tracker when it is available.\\n    if (typeof Tracker !== 'undefined') {\\n      this.reactive = options.reactive === undefined ? true : options.reactive;\\n    }\\n  }\\n\\n  /**\\n   * @summary Returns the number of documents that match a query.\\n   * @memberOf Mongo.Cursor\\n   * @method  count\\n   * @param {boolean} [applySkipLimit=true] If set to `false`, the value\\n   *                                         returned will reflect the total\\n   *                                         number of matching documents,\\n   *                                         ignoring any value supplied for\\n   *                                         limit\\n   * @instance\\n   * @locus Anywhere\\n   * @returns {Number}\\n   */\\n  count(applySkipLimit = true) {\\n    if (this.reactive) {\\n      // allow the observe to be unordered\\n      this._depend({added: true, removed: true}, true);\\n    }\\n\\n    return this._getRawObjects({\\n      ordered: true,\\n      applySkipLimit\\n    }).length;\\n  }\\n\\n  /**\\n   * @summary Return all matching documents as an Array.\\n   * @memberOf Mongo.Cursor\\n   * @method  fetch\\n   * @instance\\n   * @locus Anywhere\\n   * @returns {Object[]}\\n   */\\n  fetch() {\\n    const result = [];\\n\\n    this.forEach(doc => {\\n      result.push(doc);\\n    });\\n\\n    return result;\\n  }\\n\\n  [Symbol.iterator]() {\\n    if (this.reactive) {\\n      this._depend({\\n        addedBefore: true,\\n        removed: true,\\n        changed: true,\\n        movedBefore: true});\\n    }\\n\\n    let index = 0;\\n    const objects = this._getRawObjects({ordered: true});\\n\\n    return {\\n      next: () => {\\n        if (index < objects.length) {\\n          // This doubles as a clone operation.\\n          let element = this._projectionFn(objects[index++]);\\n\\n          if (this._transform)\\n            element = this._transform(element);\\n\\n          return {value: element};\\n        }\\n\\n        return {done: true};\\n      }\\n    };\\n  }\\n\\n  /**\\n   * @callback IterationCallback\\n   * @param {Object} doc\\n   * @param {Number} index\\n   */\\n  /**\\n   * @summary Call `callback` once for each matching document, sequentially and\\n   *          synchronously.\\n   * @locus Anywhere\\n   * @method  forEach\\n   * @instance\\n   * @memberOf Mongo.Cursor\\n   * @param {IterationCallback} callback Function to call. It will be called\\n   *                                     with three arguments: the document, a\\n   *                                     0-based index, and <em>cursor</em>\\n   *                                     itself.\\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\\n   *                        `callback`.\\n   */\\n  forEach(callback, thisArg) {\\n    if (this.reactive) {\\n      this._depend({\\n        addedBefore: true,\\n        removed: true,\\n        changed: true,\\n        movedBefore: true});\\n    }\\n\\n    this._getRawObjects({ordered: true}).forEach((element, i) => {\\n      // This doubles as a clone operation.\\n      element = this._projectionFn(element);\\n\\n      if (this._transform) {\\n        element = this._transform(element);\\n      }\\n\\n      callback.call(thisArg, element, i, this);\\n    });\\n  }\\n\\n  getTransform() {\\n    return this._transform;\\n  }\\n\\n  /**\\n   * @summary Map callback over all matching documents.  Returns an Array.\\n   * @locus Anywhere\\n   * @method map\\n   * @instance\\n   * @memberOf Mongo.Cursor\\n   * @param {IterationCallback} callback Function to call. It will be called\\n   *                                     with three arguments: the document, a\\n   *                                     0-based index, and <em>cursor</em>\\n   *                                     itself.\\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\\n   *                        `callback`.\\n   */\\n  map(callback, thisArg) {\\n    const result = [];\\n\\n    this.forEach((doc, i) => {\\n      result.push(callback.call(thisArg, doc, i, this));\\n    });\\n\\n    return result;\\n  }\\n\\n  // options to contain:\\n  //  * callbacks for observe():\\n  //    - addedAt (document, atIndex)\\n  //    - added (document)\\n  //    - changedAt (newDocument, oldDocument, atIndex)\\n  //    - changed (newDocument, oldDocument)\\n  //    - removedAt (document, atIndex)\\n  //    - removed (document)\\n  //    - movedTo (document, oldIndex, newIndex)\\n  //\\n  // attributes available on returned query handle:\\n  //  * stop(): end updates\\n  //  * collection: the collection this query is querying\\n  //\\n  // iff x is a returned query handle, (x instanceof\\n  // LocalCollection.ObserveHandle) is true\\n  //\\n  // initial results delivered through added callback\\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\\n  // XXX maybe support field limiting (to limit what you're notified on)\\n\\n  /**\\n   * @summary Watch a query.  Receive callbacks as the result set changes.\\n   * @locus Anywhere\\n   * @memberOf Mongo.Cursor\\n   * @instance\\n   * @param {Object} callbacks Functions to call to deliver the result set as it\\n   *                           changes\\n   */\\n  observe(options) {\\n    return LocalCollection._observeFromObserveChanges(this, options);\\n  }\\n\\n  /**\\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\\n   *          the differences between the old and new documents are passed to\\n   *          the callbacks.\\n   * @locus Anywhere\\n   * @memberOf Mongo.Cursor\\n   * @instance\\n   * @param {Object} callbacks Functions to call to deliver the result set as it\\n   *                           changes\\n   */\\n  observeChanges(options) {\\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\\n\\n    // there are several places that assume you aren't combining skip/limit with\\n    // unordered observe.  eg, update's EJSON.clone, and the \\\"there are several\\\"\\n    // comment in _modifyAndNotify\\n    // XXX allow skip/limit with unordered observe\\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\\n      throw new Error(\\n        \\\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \\\" +\\n        \\\"for observeChanges or 'addedAt' for observe, instead of 'added').\\\"\\n      );\\n    }\\n\\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\\n    }\\n\\n    const distances = (\\n      this.matcher.hasGeoQuery() &&\\n      ordered &&\\n      new LocalCollection._IdMap\\n    );\\n\\n    const query = {\\n      cursor: this,\\n      dirty: false,\\n      distances,\\n      matcher: this.matcher, // not fast pathed\\n      ordered,\\n      projectionFn: this._projectionFn,\\n      resultsSnapshot: null,\\n      sorter: ordered && this.sorter\\n    };\\n\\n    let qid;\\n\\n    // Non-reactive queries call added[Before] and then never call anything\\n    // else.\\n    if (this.reactive) {\\n      qid = this.collection.next_qid++;\\n      this.collection.queries[qid] = query;\\n    }\\n\\n    query.results = this._getRawObjects({ordered, distances: query.distances});\\n\\n    if (this.collection.paused) {\\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap;\\n    }\\n\\n    // wrap callbacks we were passed. callbacks only fire when not paused and\\n    // are never undefined\\n    // Filters out blacklisted fields according to cursor's projection.\\n    // XXX wrong place for this?\\n\\n    // furthermore, callbacks enqueue until the operation we're working on is\\n    // done.\\n    const wrapCallback = fn => {\\n      if (!fn) {\\n        return () => {};\\n      }\\n\\n      const self = this;\\n      return function(/* args*/) {\\n        if (self.collection.paused) {\\n          return;\\n        }\\n\\n        const args = arguments;\\n\\n        self.collection._observeQueue.queueTask(() => {\\n          fn.apply(this, args);\\n        });\\n      };\\n    };\\n\\n    query.added = wrapCallback(options.added);\\n    query.changed = wrapCallback(options.changed);\\n    query.removed = wrapCallback(options.removed);\\n\\n    if (ordered) {\\n      query.addedBefore = wrapCallback(options.addedBefore);\\n      query.movedBefore = wrapCallback(options.movedBefore);\\n    }\\n\\n    if (!options._suppress_initial && !this.collection.paused) {\\n      query.results.forEach(doc => {\\n        const fields = EJSON.clone(doc);\\n\\n        delete fields._id;\\n\\n        if (ordered) {\\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\\n        }\\n\\n        query.added(doc._id, this._projectionFn(fields));\\n      });\\n    }\\n\\n    const handle = Object.assign(new LocalCollection.ObserveHandle, {\\n      collection: this.collection,\\n      stop: () => {\\n        if (this.reactive) {\\n          delete this.collection.queries[qid];\\n        }\\n      }\\n    });\\n\\n    if (this.reactive && Tracker.active) {\\n      // XXX in many cases, the same observe will be recreated when\\n      // the current autorun is rerun.  we could save work by\\n      // letting it linger across rerun and potentially get\\n      // repurposed if the same observe is performed, using logic\\n      // similar to that of Meteor.subscribe.\\n      Tracker.onInvalidate(() => {\\n        handle.stop();\\n      });\\n    }\\n\\n    // run the observe callbacks resulting from the initial contents\\n    // before we leave the observe.\\n    this.collection._observeQueue.drain();\\n\\n    return handle;\\n  }\\n\\n  // Since we don't actually have a \\\"nextObject\\\" interface, there's really no\\n  // reason to have a \\\"rewind\\\" interface.  All it did was make multiple calls\\n  // to fetch/map/forEach return nothing the second time.\\n  // XXX COMPAT WITH 0.8.1\\n  rewind() {}\\n\\n  // XXX Maybe we need a version of observe that just calls a callback if\\n  // anything changed.\\n  _depend(changers, _allow_unordered) {\\n    if (Tracker.active) {\\n      const dependency = new Tracker.Dependency;\\n      const notify = dependency.changed.bind(dependency);\\n\\n      dependency.depend();\\n\\n      const options = {_allow_unordered, _suppress_initial: true};\\n\\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed']\\n        .forEach(fn => {\\n          if (changers[fn]) {\\n            options[fn] = notify;\\n          }\\n        });\\n\\n      // observeChanges will stop() when this computation is invalidated\\n      this.observeChanges(options);\\n    }\\n  }\\n\\n  _getCollectionName() {\\n    return this.collection.name;\\n  }\\n\\n  // Returns a collection of matching objects, but doesn't deep copy them.\\n  //\\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\\n  // limit properties of the query provided that options.applySkipLimit is\\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\\n  // natural order.\\n  //\\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\\n  // skip and limit should not be set).\\n  //\\n  // If ordered is set and this cursor is a $near geoquery, then this function\\n  // will use an _IdMap to track each distance from the $near argument point in\\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\\n  // argument, this function will clear it and use it for this purpose\\n  // (otherwise it will just create its own _IdMap). The observeChanges\\n  // implementation uses this to remember the distances after this function\\n  // returns.\\n  _getRawObjects(options = {}) {\\n    // By default this method will respect skip and limit because .fetch(),\\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\\n    // skip and limit by setting applySkipLimit to false (.count() does this,\\n    // for example)\\n    const applySkipLimit = options.applySkipLimit !== false;\\n\\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\\n    // compatible\\n    const results = options.ordered ? [] : new LocalCollection._IdMap;\\n\\n    // fast path for single ID value\\n    if (this._selectorId !== undefined) {\\n      // If you have non-zero skip and ask for a single id, you get nothing.\\n      // This is so it matches the behavior of the '{_id: foo}' path.\\n      if (applySkipLimit && this.skip) {\\n        return results;\\n      }\\n\\n      const selectedDoc = this.collection._docs.get(this._selectorId);\\n\\n      if (selectedDoc) {\\n        if (options.ordered) {\\n          results.push(selectedDoc);\\n        } else {\\n          results.set(this._selectorId, selectedDoc);\\n        }\\n      }\\n\\n      return results;\\n    }\\n\\n    // slow path for arbitrary selector, sort, skip, limit\\n\\n    // in the observeChanges case, distances is actually part of the \\\"query\\\"\\n    // (ie, live results set) object.  in other cases, distances is only used\\n    // inside this function.\\n    let distances;\\n    if (this.matcher.hasGeoQuery() && options.ordered) {\\n      if (options.distances) {\\n        distances = options.distances;\\n        distances.clear();\\n      } else {\\n        distances = new LocalCollection._IdMap();\\n      }\\n    }\\n\\n    this.collection._docs.forEach((doc, id) => {\\n      const matchResult = this.matcher.documentMatches(doc);\\n\\n      if (matchResult.result) {\\n        if (options.ordered) {\\n          results.push(doc);\\n\\n          if (distances && matchResult.distance !== undefined) {\\n            distances.set(id, matchResult.distance);\\n          }\\n        } else {\\n          results.set(id, doc);\\n        }\\n      }\\n\\n      // Override to ensure all docs are matched if ignoring skip & limit\\n      if (!applySkipLimit) {\\n        return true;\\n      }\\n\\n      // Fast path for limited unsorted queries.\\n      // XXX 'length' check here seems wrong for ordered\\n      return (\\n        !this.limit ||\\n        this.skip ||\\n        this.sorter ||\\n        results.length !== this.limit\\n      );\\n    });\\n\\n    if (!options.ordered) {\\n      return results;\\n    }\\n\\n    if (this.sorter) {\\n      results.sort(this.sorter.getComparator({distances}));\\n    }\\n\\n    // Return the full set of results if there is no skip or limit or if we're\\n    // ignoring them\\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\\n      return results;\\n    }\\n\\n    return results.slice(\\n      this.skip,\\n      this.limit ? this.limit + this.skip : results.length\\n    );\\n  }\\n\\n  _publishCursor(subscription) {\\n    // XXX minimongo should not depend on mongo-livedata!\\n    if (!Package.mongo) {\\n      throw new Error(\\n        'Can\\\\'t publish from Minimongo without the `mongo` package.'\\n      );\\n    }\\n\\n    if (!this.collection.name) {\\n      throw new Error(\\n        'Can\\\\'t publish a cursor from a collection without a name.'\\n      );\\n    }\\n\\n    return Package.mongo.Mongo.Collection._publishCursor(\\n      this,\\n      subscription,\\n      this.collection.name\\n    );\\n  }\\n}\\n\",\"import Cursor from './cursor.js';\\nimport ObserveHandle from './observe_handle.js';\\nimport {\\n  hasOwn,\\n  isIndexable,\\n  isNumericKey,\\n  isOperatorObject,\\n  populateDocumentWithQueryFields,\\n  projectionDetails,\\n} from './common.js';\\n\\n// XXX type checking on selectors (graceful error if malformed)\\n\\n// LocalCollection: a set of documents that supports queries and modifiers.\\nexport default class LocalCollection {\\n  constructor(name) {\\n    this.name = name;\\n    // _id -> document (also containing id)\\n    this._docs = new LocalCollection._IdMap;\\n\\n    this._observeQueue = new Meteor._SynchronousQueue();\\n\\n    this.next_qid = 1; // live query id generator\\n\\n    // qid -> live query object. keys:\\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\\n    //  results: array (ordered) or object (unordered) of current results\\n    //    (aliased with this._docs!)\\n    //  resultsSnapshot: snapshot of results. null if not paused.\\n    //  cursor: Cursor object for the query.\\n    //  selector, sorter, (callbacks): functions\\n    this.queries = Object.create(null);\\n\\n    // null if not saving originals; an IdMap from id to original document value\\n    // if saving originals. See comments before saveOriginals().\\n    this._savedOriginals = null;\\n\\n    // True when observers are paused and we should not send callbacks.\\n    this.paused = false;\\n  }\\n\\n  // options may include sort, skip, limit, reactive\\n  // sort may be any of these forms:\\n  //     {a: 1, b: -1}\\n  //     [[\\\"a\\\", \\\"asc\\\"], [\\\"b\\\", \\\"desc\\\"]]\\n  //     [\\\"a\\\", [\\\"b\\\", \\\"desc\\\"]]\\n  //   (in the first form you're beholden to key enumeration order in\\n  //   your javascript VM)\\n  //\\n  // reactive: if given, and false, don't register with Tracker (default\\n  // is true)\\n  //\\n  // XXX possibly should support retrieving a subset of fields? and\\n  // have it be a hint (ignored on the client, when not copying the\\n  // doc?)\\n  //\\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\\n  // XXX add one more sort form: \\\"key\\\"\\n  // XXX tests\\n  find(selector, options) {\\n    // default syntax for everything is to omit the selector argument.\\n    // but if selector is explicitly passed in as false or undefined, we\\n    // want a selector that matches nothing.\\n    if (arguments.length === 0) {\\n      selector = {};\\n    }\\n\\n    return new LocalCollection.Cursor(this, selector, options);\\n  }\\n\\n  findOne(selector, options = {}) {\\n    if (arguments.length === 0) {\\n      selector = {};\\n    }\\n\\n    // NOTE: by setting limit 1 here, we end up using very inefficient\\n    // code that recomputes the whole query on each update. The upside is\\n    // that when you reactively depend on a findOne you only get\\n    // invalidated when the found object changes, not any object in the\\n    // collection. Most findOne will be by id, which has a fast path, so\\n    // this might not be a big deal. In most cases, invalidation causes\\n    // the called to re-query anyway, so this should be a net performance\\n    // improvement.\\n    options.limit = 1;\\n\\n    return this.find(selector, options).fetch()[0];\\n  }\\n\\n  // XXX possibly enforce that 'undefined' does not appear (we assume\\n  // this in our handling of null and $exists)\\n  insert(doc, callback) {\\n    doc = EJSON.clone(doc);\\n\\n    assertHasValidFieldNames(doc);\\n\\n    // if you really want to use ObjectIDs, set this global.\\n    // Mongo.Collection specifies its own ids and does not use this code.\\n    if (!hasOwn.call(doc, '_id')) {\\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\\n    }\\n\\n    const id = doc._id;\\n\\n    if (this._docs.has(id)) {\\n      throw MinimongoError(`Duplicate _id '${id}'`);\\n    }\\n\\n    this._saveOriginal(id, undefined);\\n    this._docs.set(id, doc);\\n\\n    const queriesToRecompute = [];\\n\\n    // trigger live queries that match\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      const matchResult = query.matcher.documentMatches(doc);\\n\\n      if (matchResult.result) {\\n        if (query.distances && matchResult.distance !== undefined) {\\n          query.distances.set(id, matchResult.distance);\\n        }\\n\\n        if (query.cursor.skip || query.cursor.limit) {\\n          queriesToRecompute.push(qid);\\n        } else {\\n          LocalCollection._insertInResults(query, doc);\\n        }\\n      }\\n    });\\n\\n    queriesToRecompute.forEach(qid => {\\n      if (this.queries[qid]) {\\n        this._recomputeResults(this.queries[qid]);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    // Defer because the caller likely doesn't expect the callback to be run\\n    // immediately.\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, id);\\n      });\\n    }\\n\\n    return id;\\n  }\\n\\n  // Pause the observers. No callbacks from observers will fire until\\n  // 'resumeObservers' is called.\\n  pauseObservers() {\\n    // No-op if already paused.\\n    if (this.paused) {\\n      return;\\n    }\\n\\n    // Set the 'paused' flag such that new observer messages don't fire.\\n    this.paused = true;\\n\\n    // Take a snapshot of the query results for each query.\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n      query.resultsSnapshot = EJSON.clone(query.results);\\n    });\\n  }\\n\\n  remove(selector, callback) {\\n    // Easy special case: if we're not calling observeChanges callbacks and\\n    // we're not saving originals and we got asked to remove everything, then\\n    // just empty everything directly.\\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\\n      const result = this._docs.size();\\n\\n      this._docs.clear();\\n\\n      Object.keys(this.queries).forEach(qid => {\\n        const query = this.queries[qid];\\n\\n        if (query.ordered) {\\n          query.results = [];\\n        } else {\\n          query.results.clear();\\n        }\\n      });\\n\\n      if (callback) {\\n        Meteor.defer(() => {\\n          callback(null, result);\\n        });\\n      }\\n\\n      return result;\\n    }\\n\\n    const matcher = new Minimongo.Matcher(selector);\\n    const remove = [];\\n\\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\\n      if (matcher.documentMatches(doc).result) {\\n        remove.push(id);\\n      }\\n    });\\n\\n    const queriesToRecompute = [];\\n    const queryRemove = [];\\n\\n    for (let i = 0; i < remove.length; i++) {\\n      const removeId = remove[i];\\n      const removeDoc = this._docs.get(removeId);\\n\\n      Object.keys(this.queries).forEach(qid => {\\n        const query = this.queries[qid];\\n\\n        if (query.dirty) {\\n          return;\\n        }\\n\\n        if (query.matcher.documentMatches(removeDoc).result) {\\n          if (query.cursor.skip || query.cursor.limit) {\\n            queriesToRecompute.push(qid);\\n          } else {\\n            queryRemove.push({qid, doc: removeDoc});\\n          }\\n        }\\n      });\\n\\n      this._saveOriginal(removeId, removeDoc);\\n      this._docs.remove(removeId);\\n    }\\n\\n    // run live query callbacks _after_ we've removed the documents.\\n    queryRemove.forEach(remove => {\\n      const query = this.queries[remove.qid];\\n\\n      if (query) {\\n        query.distances && query.distances.remove(remove.doc._id);\\n        LocalCollection._removeFromResults(query, remove.doc);\\n      }\\n    });\\n\\n    queriesToRecompute.forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query) {\\n        this._recomputeResults(query);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    const result = remove.length;\\n\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, result);\\n      });\\n    }\\n\\n    return result;\\n  }\\n\\n  // Resume the observers. Observers immediately receive change\\n  // notifications to bring them to the current state of the\\n  // database. Note that this is not just replaying all the changes that\\n  // happened during the pause, it is a smarter 'coalesced' diff.\\n  resumeObservers() {\\n    // No-op if not paused.\\n    if (!this.paused) {\\n      return;\\n    }\\n\\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\\n    // observer methods won't actually fire when we trigger them.\\n    this.paused = false;\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        query.dirty = false;\\n\\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\\n        // automatically.\\n        this._recomputeResults(query, query.resultsSnapshot);\\n      } else {\\n        // Diff the current results against the snapshot and send to observers.\\n        // pass the query object for its observer callbacks.\\n        LocalCollection._diffQueryChanges(\\n          query.ordered,\\n          query.resultsSnapshot,\\n          query.results,\\n          query,\\n          {projectionFn: query.projectionFn}\\n        );\\n      }\\n\\n      query.resultsSnapshot = null;\\n    });\\n\\n    this._observeQueue.drain();\\n  }\\n\\n  retrieveOriginals() {\\n    if (!this._savedOriginals) {\\n      throw new Error('Called retrieveOriginals without saveOriginals');\\n    }\\n\\n    const originals = this._savedOriginals;\\n\\n    this._savedOriginals = null;\\n\\n    return originals;\\n  }\\n\\n  // To track what documents are affected by a piece of code, call\\n  // saveOriginals() before it and retrieveOriginals() after it.\\n  // retrieveOriginals returns an object whose keys are the ids of the documents\\n  // that were affected since the call to saveOriginals(), and the values are\\n  // equal to the document's contents at the time of saveOriginals. (In the case\\n  // of an inserted document, undefined is the value.) You must alternate\\n  // between calls to saveOriginals() and retrieveOriginals().\\n  saveOriginals() {\\n    if (this._savedOriginals) {\\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\\n    }\\n\\n    this._savedOriginals = new LocalCollection._IdMap;\\n  }\\n\\n  // XXX atomicity: if multi is true, and one modification fails, do\\n  // we rollback the whole operation, or what?\\n  update(selector, mod, options, callback) {\\n    if (! callback && options instanceof Function) {\\n      callback = options;\\n      options = null;\\n    }\\n\\n    if (!options) {\\n      options = {};\\n    }\\n\\n    const matcher = new Minimongo.Matcher(selector, true);\\n\\n    // Save the original results of any query that we might need to\\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\\n    // it. (We don't need to save the original results of paused queries because\\n    // they already have a resultsSnapshot and we won't be diffing in\\n    // _recomputeResults.)\\n    const qidToOriginalResults = {};\\n\\n    // We should only clone each document once, even if it appears in multiple\\n    // queries\\n    const docMap = new LocalCollection._IdMap;\\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\\n        // Catch the case of a reactive `count()` on a cursor with skip\\n        // or limit, which registers an unordered observe. This is a\\n        // pretty rare case, so we just clone the entire result set with\\n        // no optimizations for documents that appear in these result\\n        // sets and other queries.\\n        if (query.results instanceof LocalCollection._IdMap) {\\n          qidToOriginalResults[qid] = query.results.clone();\\n          return;\\n        }\\n\\n        if (!(query.results instanceof Array)) {\\n          throw new Error('Assertion failed: query.results not an array');\\n        }\\n\\n        // Clones a document to be stored in `qidToOriginalResults`\\n        // because it may be modified before the new and old result sets\\n        // are diffed. But if we know exactly which document IDs we're\\n        // going to modify, then we only need to clone those.\\n        const memoizedCloneIfNeeded = doc => {\\n          if (docMap.has(doc._id)) {\\n            return docMap.get(doc._id);\\n          }\\n\\n          const docToMemoize = (\\n            idsMatched &&\\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\\n          ) ? doc : EJSON.clone(doc);\\n\\n          docMap.set(doc._id, docToMemoize);\\n\\n          return docToMemoize;\\n        };\\n\\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\\n      }\\n    });\\n\\n    const recomputeQids = {};\\n\\n    let updateCount = 0;\\n\\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\\n      const queryResult = matcher.documentMatches(doc);\\n\\n      if (queryResult.result) {\\n        // XXX Should we save the original even if mod ends up being a no-op?\\n        this._saveOriginal(id, doc);\\n        this._modifyAndNotify(\\n          doc,\\n          mod,\\n          recomputeQids,\\n          queryResult.arrayIndices\\n        );\\n\\n        ++updateCount;\\n\\n        if (!options.multi) {\\n          return false; // break\\n        }\\n      }\\n\\n      return true;\\n    });\\n\\n    Object.keys(recomputeQids).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query) {\\n        this._recomputeResults(query, qidToOriginalResults[qid]);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    // If we are doing an upsert, and we didn't modify any documents yet, then\\n    // it's time to do an insert. Figure out what document we are inserting, and\\n    // generate an id for it.\\n    let insertedId;\\n    if (updateCount === 0 && options.upsert) {\\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\\n      if (! doc._id && options.insertedId) {\\n        doc._id = options.insertedId;\\n      }\\n\\n      insertedId = this.insert(doc);\\n      updateCount = 1;\\n    }\\n\\n    // Return the number of affected documents, or in the upsert case, an object\\n    // containing the number of affected docs and the id of the doc that was\\n    // inserted, if any.\\n    let result;\\n    if (options._returnObject) {\\n      result = {numberAffected: updateCount};\\n\\n      if (insertedId !== undefined) {\\n        result.insertedId = insertedId;\\n      }\\n    } else {\\n      result = updateCount;\\n    }\\n\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, result);\\n      });\\n    }\\n\\n    return result;\\n  }\\n\\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\\n  // _returnObject: true}).\\n  upsert(selector, mod, options, callback) {\\n    if (!callback && typeof options === 'function') {\\n      callback = options;\\n      options = {};\\n    }\\n\\n    return this.update(\\n      selector,\\n      mod,\\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\\n      callback\\n    );\\n  }\\n\\n  // Iterates over a subset of documents that could match selector; calls\\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\\n  // same object that is in _docs.\\n  _eachPossiblyMatchingDoc(selector, fn) {\\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\\n\\n    if (specificIds) {\\n      specificIds.some(id => {\\n        const doc = this._docs.get(id);\\n\\n        if (doc) {\\n          return fn(doc, id) === false;\\n        }\\n      });\\n    } else {\\n      this._docs.forEach(fn);\\n    }\\n  }\\n\\n  _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\\n    const matched_before = {};\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      if (query.ordered) {\\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\\n      } else {\\n        // Because we don't support skip or limit (yet) in unordered queries, we\\n        // can just do a direct lookup.\\n        matched_before[qid] = query.results.has(doc._id);\\n      }\\n    });\\n\\n    const old_doc = EJSON.clone(doc);\\n\\n    LocalCollection._modify(doc, mod, {arrayIndices});\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      const afterMatch = query.matcher.documentMatches(doc);\\n      const after = afterMatch.result;\\n      const before = matched_before[qid];\\n\\n      if (after && query.distances && afterMatch.distance !== undefined) {\\n        query.distances.set(doc._id, afterMatch.distance);\\n      }\\n\\n      if (query.cursor.skip || query.cursor.limit) {\\n        // We need to recompute any query where the doc may have been in the\\n        // cursor's window either before or after the update. (Note that if skip\\n        // or limit is set, \\\"before\\\" and \\\"after\\\" being true do not necessarily\\n        // mean that the document is in the cursor's output after skip/limit is\\n        // applied... but if they are false, then the document definitely is NOT\\n        // in the output. So it's safe to skip recompute if neither before or\\n        // after are true.)\\n        if (before || after) {\\n          recomputeQids[qid] = true;\\n        }\\n      } else if (before && !after) {\\n        LocalCollection._removeFromResults(query, doc);\\n      } else if (!before && after) {\\n        LocalCollection._insertInResults(query, doc);\\n      } else if (before && after) {\\n        LocalCollection._updateInResults(query, doc, old_doc);\\n      }\\n    });\\n  }\\n\\n  // Recomputes the results of a query and runs observe callbacks for the\\n  // difference between the previous results and the current results (unless\\n  // paused). Used for skip/limit queries.\\n  //\\n  // When this is used by insert or remove, it can just use query.results for\\n  // the old results (and there's no need to pass in oldResults), because these\\n  // operations don't mutate the documents in the collection. Update needs to\\n  // pass in an oldResults which was deep-copied before the modifier was\\n  // applied.\\n  //\\n  // oldResults is guaranteed to be ignored if the query is not paused.\\n  _recomputeResults(query, oldResults) {\\n    if (this.paused) {\\n      // There's no reason to recompute the results now as we're still paused.\\n      // By flagging the query as \\\"dirty\\\", the recompute will be performed\\n      // when resumeObservers is called.\\n      query.dirty = true;\\n      return;\\n    }\\n\\n    if (!this.paused && !oldResults) {\\n      oldResults = query.results;\\n    }\\n\\n    if (query.distances) {\\n      query.distances.clear();\\n    }\\n\\n    query.results = query.cursor._getRawObjects({\\n      distances: query.distances,\\n      ordered: query.ordered\\n    });\\n\\n    if (!this.paused) {\\n      LocalCollection._diffQueryChanges(\\n        query.ordered,\\n        oldResults,\\n        query.results,\\n        query,\\n        {projectionFn: query.projectionFn}\\n      );\\n    }\\n  }\\n\\n  _saveOriginal(id, doc) {\\n    // Are we even trying to save originals?\\n    if (!this._savedOriginals) {\\n      return;\\n    }\\n\\n    // Have we previously mutated the original (and so 'doc' is not actually\\n    // original)?  (Note the 'has' check rather than truth: we store undefined\\n    // here for inserted docs!)\\n    if (this._savedOriginals.has(id)) {\\n      return;\\n    }\\n\\n    this._savedOriginals.set(id, EJSON.clone(doc));\\n  }\\n}\\n\\nLocalCollection.Cursor = Cursor;\\n\\nLocalCollection.ObserveHandle = ObserveHandle;\\n\\n// XXX maybe move these into another ObserveHelpers package or something\\n\\n// _CachingChangeObserver is an object which receives observeChanges callbacks\\n// and keeps a cache of the current cursor state up to date in this.docs. Users\\n// of this class should read the docs field but not modify it. You should pass\\n// the \\\"applyChange\\\" field as the callbacks to the underlying observeChanges\\n// call. Optionally, you can specify your own observeChanges callbacks which are\\n// invoked immediately before the docs field is updated; this object is made\\n// available as `this` to those callbacks.\\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\\n  constructor(options = {}) {\\n    const orderedFromCallbacks = (\\n      options.callbacks &&\\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\\n    );\\n\\n    if (hasOwn.call(options, 'ordered')) {\\n      this.ordered = options.ordered;\\n\\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\\n        throw Error('ordered option doesn\\\\'t match callbacks');\\n      }\\n    } else if (options.callbacks) {\\n      this.ordered = orderedFromCallbacks;\\n    } else {\\n      throw Error('must provide ordered or callbacks');\\n    }\\n\\n    const callbacks = options.callbacks || {};\\n\\n    if (this.ordered) {\\n      this.docs = new OrderedDict(MongoID.idStringify);\\n      this.applyChange = {\\n        addedBefore: (id, fields, before) => {\\n          const doc = EJSON.clone(fields);\\n\\n          doc._id = id;\\n\\n          if (callbacks.addedBefore) {\\n            callbacks.addedBefore.call(this, id, fields, before);\\n          }\\n\\n          // This line triggers if we provide added with movedBefore.\\n          if (callbacks.added) {\\n            callbacks.added.call(this, id, fields);\\n          }\\n\\n          // XXX could `before` be a falsy ID?  Technically\\n          // idStringify seems to allow for them -- though\\n          // OrderedDict won't call stringify on a falsy arg.\\n          this.docs.putBefore(id, doc, before || null);\\n        },\\n        movedBefore: (id, before) => {\\n          const doc = this.docs.get(id);\\n\\n          if (callbacks.movedBefore) {\\n            callbacks.movedBefore.call(this, id, before);\\n          }\\n\\n          this.docs.moveBefore(id, before || null);\\n        },\\n      };\\n    } else {\\n      this.docs = new LocalCollection._IdMap;\\n      this.applyChange = {\\n        added: (id, fields) => {\\n          const doc = EJSON.clone(fields);\\n\\n          if (callbacks.added) {\\n            callbacks.added.call(this, id, fields);\\n          }\\n\\n          doc._id = id;\\n\\n          this.docs.set(id,  doc);\\n        },\\n      };\\n    }\\n\\n    // The methods in _IdMap and OrderedDict used by these callbacks are\\n    // identical.\\n    this.applyChange.changed = (id, fields) => {\\n      const doc = this.docs.get(id);\\n\\n      if (!doc) {\\n        throw new Error(`Unknown id for changed: ${id}`);\\n      }\\n\\n      if (callbacks.changed) {\\n        callbacks.changed.call(this, id, EJSON.clone(fields));\\n      }\\n\\n      DiffSequence.applyChanges(doc, fields);\\n    };\\n\\n    this.applyChange.removed = id => {\\n      if (callbacks.removed) {\\n        callbacks.removed.call(this, id);\\n      }\\n\\n      this.docs.remove(id);\\n    };\\n  }\\n};\\n\\nLocalCollection._IdMap = class _IdMap extends IdMap {\\n  constructor() {\\n    super(MongoID.idStringify, MongoID.idParse);\\n  }\\n};\\n\\n// Wrap a transform function to return objects that have the _id field\\n// of the untransformed document. This ensures that subsystems such as\\n// the observe-sequence package that call `observe` can keep track of\\n// the documents identities.\\n//\\n// - Require that it returns objects\\n// - If the return value has an _id field, verify that it matches the\\n//   original _id field\\n// - If the return value doesn't have an _id field, add it back.\\nLocalCollection.wrapTransform = transform => {\\n  if (!transform) {\\n    return null;\\n  }\\n\\n  // No need to doubly-wrap transforms.\\n  if (transform.__wrappedTransform__) {\\n    return transform;\\n  }\\n\\n  const wrapped = doc => {\\n    if (!hasOwn.call(doc, '_id')) {\\n      // XXX do we ever have a transform on the oplog's collection? because that\\n      // collection has no _id.\\n      throw new Error('can only transform documents with _id');\\n    }\\n\\n    const id = doc._id;\\n\\n    // XXX consider making tracker a weak dependency and checking\\n    // Package.tracker here\\n    const transformed = Tracker.nonreactive(() => transform(doc));\\n\\n    if (!LocalCollection._isPlainObject(transformed)) {\\n      throw new Error('transform must return object');\\n    }\\n\\n    if (hasOwn.call(transformed, '_id')) {\\n      if (!EJSON.equals(transformed._id, id)) {\\n        throw new Error('transformed document can\\\\'t have different _id');\\n      }\\n    } else {\\n      transformed._id = id;\\n    }\\n\\n    return transformed;\\n  };\\n\\n  wrapped.__wrappedTransform__ = true;\\n\\n  return wrapped;\\n};\\n\\n// XXX the sorted-query logic below is laughably inefficient. we'll\\n// need to come up with a better datastructure for this.\\n//\\n// XXX the logic for observing with a skip or a limit is even more\\n// laughably inefficient. we recompute the whole results every time!\\n\\n// This binary search puts a value between any equal values, and the first\\n// lesser value.\\nLocalCollection._binarySearch = (cmp, array, value) => {\\n  let first = 0;\\n  let range = array.length;\\n\\n  while (range > 0) {\\n    const halfRange = Math.floor(range / 2);\\n\\n    if (cmp(value, array[first + halfRange]) >= 0) {\\n      first += halfRange + 1;\\n      range -= halfRange + 1;\\n    } else {\\n      range = halfRange;\\n    }\\n  }\\n\\n  return first;\\n};\\n\\nLocalCollection._checkSupportedProjection = fields => {\\n  if (fields !== Object(fields) || Array.isArray(fields)) {\\n    throw MinimongoError('fields option must be an object');\\n  }\\n\\n  Object.keys(fields).forEach(keyPath => {\\n    if (keyPath.split('.').includes('$')) {\\n      throw MinimongoError(\\n        'Minimongo doesn\\\\'t support $ operator in projections yet.'\\n      );\\n    }\\n\\n    const value = fields[keyPath];\\n\\n    if (typeof value === 'object' &&\\n        ['$elemMatch', '$meta', '$slice'].some(key =>\\n          hasOwn.call(value, key)\\n        )) {\\n      throw MinimongoError(\\n        'Minimongo doesn\\\\'t support operators in projections yet.'\\n      );\\n    }\\n\\n    if (![1, 0, true, false].includes(value)) {\\n      throw MinimongoError(\\n        'Projection values should be one of 1, 0, true, or false'\\n      );\\n    }\\n  });\\n};\\n\\n// Knows how to compile a fields projection to a predicate function.\\n// @returns - Function: a closure that filters out an object according to the\\n//            fields projection rules:\\n//            @param obj - Object: MongoDB-styled document\\n//            @returns - Object: a document with the fields filtered out\\n//                       according to projection rules. Doesn't retain subfields\\n//                       of passed argument.\\nLocalCollection._compileProjection = fields => {\\n  LocalCollection._checkSupportedProjection(fields);\\n\\n  const _idProjection = fields._id === undefined ? true : fields._id;\\n  const details = projectionDetails(fields);\\n\\n  // returns transformed doc according to ruleTree\\n  const transform = (doc, ruleTree) => {\\n    // Special case for \\\"sets\\\"\\n    if (Array.isArray(doc)) {\\n      return doc.map(subdoc => transform(subdoc, ruleTree));\\n    }\\n\\n    const result = details.including ? {} : EJSON.clone(doc);\\n\\n    Object.keys(ruleTree).forEach(key => {\\n      if (!hasOwn.call(doc, key)) {\\n        return;\\n      }\\n\\n      const rule = ruleTree[key];\\n\\n      if (rule === Object(rule)) {\\n        // For sub-objects/subsets we branch\\n        if (doc[key] === Object(doc[key])) {\\n          result[key] = transform(doc[key], rule);\\n        }\\n      } else if (details.including) {\\n        // Otherwise we don't even touch this subfield\\n        result[key] = EJSON.clone(doc[key]);\\n      } else {\\n        delete result[key];\\n      }\\n    });\\n\\n    return result;\\n  };\\n\\n  return doc => {\\n    const result = transform(doc, details.tree);\\n\\n    if (_idProjection && hasOwn.call(doc, '_id')) {\\n      result._id = doc._id;\\n    }\\n\\n    if (!_idProjection && hasOwn.call(result, '_id')) {\\n      delete result._id;\\n    }\\n\\n    return result;\\n  };\\n};\\n\\n// Calculates the document to insert in case we're doing an upsert and the\\n// selector does not match any elements\\nLocalCollection._createUpsertDocument = (selector, modifier) => {\\n  const selectorDocument = populateDocumentWithQueryFields(selector);\\n  const isModify = LocalCollection._isModificationMod(modifier);\\n\\n  const newDoc = {};\\n\\n  if (selectorDocument._id) {\\n    newDoc._id = selectorDocument._id;\\n    delete selectorDocument._id;\\n  }\\n\\n  // This double _modify call is made to help with nested properties (see issue\\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\\n  // ambiguous id's)\\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\\n\\n  if (isModify) {\\n    return newDoc;\\n  }\\n\\n  // Replacement can take _id from query document\\n  const replacement = Object.assign({}, modifier);\\n  if (newDoc._id) {\\n    replacement._id = newDoc._id;\\n  }\\n\\n  return replacement;\\n};\\n\\nLocalCollection._diffObjects = (left, right, callbacks) => {\\n  return DiffSequence.diffObjects(left, right, callbacks);\\n};\\n\\n// ordered: bool.\\n// old_results and new_results: collections of documents.\\n//    if ordered, they are arrays.\\n//    if unordered, they are IdMaps\\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._findInOrderedResults = (query, doc) => {\\n  if (!query.ordered) {\\n    throw new Error('Can\\\\'t call _findInOrderedResults on unordered query');\\n  }\\n\\n  for (let i = 0; i < query.results.length; i++) {\\n    if (query.results[i] === doc) {\\n      return i;\\n    }\\n  }\\n\\n  throw Error('object missing from query');\\n};\\n\\n// If this is a selector which explicitly constrains the match by ID to a finite\\n// number of documents, returns a list of their IDs.  Otherwise returns\\n// null. Note that the selector may have other restrictions so it may not even\\n// match those document!  We care about $in and $and since those are generated\\n// access-controlled update and remove.\\nLocalCollection._idsMatchedBySelector = selector => {\\n  // Is the selector just an ID?\\n  if (LocalCollection._selectorIsId(selector)) {\\n    return [selector];\\n  }\\n\\n  if (!selector) {\\n    return null;\\n  }\\n\\n  // Do we have an _id clause?\\n  if (hasOwn.call(selector, '_id')) {\\n    // Is the _id clause just an ID?\\n    if (LocalCollection._selectorIsId(selector._id)) {\\n      return [selector._id];\\n    }\\n\\n    // Is the _id clause {_id: {$in: [\\\"x\\\", \\\"y\\\", \\\"z\\\"]}}?\\n    if (selector._id\\n        && Array.isArray(selector._id.$in)\\n        && selector._id.$in.length\\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\\n      return selector._id.$in;\\n    }\\n\\n    return null;\\n  }\\n\\n  // If this is a top-level $and, and any of the clauses constrain their\\n  // documents, then the whole selector is constrained by any one clause's\\n  // constraint. (Well, by their intersection, but that seems unlikely.)\\n  if (Array.isArray(selector.$and)) {\\n    for (let i = 0; i < selector.$and.length; ++i) {\\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\\n\\n      if (subIds) {\\n        return subIds;\\n      }\\n    }\\n  }\\n\\n  return null;\\n};\\n\\nLocalCollection._insertInResults = (query, doc) => {\\n  const fields = EJSON.clone(doc);\\n\\n  delete fields._id;\\n\\n  if (query.ordered) {\\n    if (!query.sorter) {\\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\\n      query.results.push(doc);\\n    } else {\\n      const i = LocalCollection._insertInSortedList(\\n        query.sorter.getComparator({distances: query.distances}),\\n        query.results,\\n        doc\\n      );\\n\\n      let next = query.results[i + 1];\\n      if (next) {\\n        next = next._id;\\n      } else {\\n        next = null;\\n      }\\n\\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\\n    }\\n\\n    query.added(doc._id, query.projectionFn(fields));\\n  } else {\\n    query.added(doc._id, query.projectionFn(fields));\\n    query.results.set(doc._id, doc);\\n  }\\n};\\n\\nLocalCollection._insertInSortedList = (cmp, array, value) => {\\n  if (array.length === 0) {\\n    array.push(value);\\n    return 0;\\n  }\\n\\n  const i = LocalCollection._binarySearch(cmp, array, value);\\n\\n  array.splice(i, 0, value);\\n\\n  return i;\\n};\\n\\nLocalCollection._isModificationMod = mod => {\\n  let isModify = false;\\n  let isReplace = false;\\n\\n  Object.keys(mod).forEach(key => {\\n    if (key.substr(0, 1) === '$') {\\n      isModify = true;\\n    } else {\\n      isReplace = true;\\n    }\\n  });\\n\\n  if (isModify && isReplace) {\\n    throw new Error(\\n      'Update parameter cannot have both modifier and non-modifier fields.'\\n    );\\n  }\\n\\n  return isModify;\\n};\\n\\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\\n// RegExp\\n// XXX note that _type(undefined) === 3!!!!\\nLocalCollection._isPlainObject = x => {\\n  return x && LocalCollection._f._type(x) === 3;\\n};\\n\\n// XXX need a strategy for passing the binding of $ into this\\n// function, from the compiled selector\\n//\\n// maybe just {key.up.to.just.before.dollarsign: array_index}\\n//\\n// XXX atomicity: if one modification fails, do we roll back the whole\\n// change?\\n//\\n// options:\\n//   - isInsert is set when _modify is being called to compute the document to\\n//     insert as part of an upsert operation. We use this primarily to figure\\n//     out when to set the fields in $setOnInsert, if present.\\nLocalCollection._modify = (doc, modifier, options = {}) => {\\n  if (!LocalCollection._isPlainObject(modifier)) {\\n    throw MinimongoError('Modifier must be an object');\\n  }\\n\\n  // Make sure the caller can't mutate our data structures.\\n  modifier = EJSON.clone(modifier);\\n\\n  const isModifier = isOperatorObject(modifier);\\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\\n\\n  if (isModifier) {\\n    // apply modifiers to the doc.\\n    Object.keys(modifier).forEach(operator => {\\n      // Treat $setOnInsert as $set if this is an insert.\\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\\n      const operand = modifier[operator];\\n\\n      if (!modFunc) {\\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\\n      }\\n\\n      Object.keys(operand).forEach(keypath => {\\n        const arg = operand[keypath];\\n\\n        if (keypath === '') {\\n          throw MinimongoError('An empty update path is not valid.');\\n        }\\n\\n        const keyparts = keypath.split('.');\\n\\n        if (!keyparts.every(Boolean)) {\\n          throw MinimongoError(\\n            `The update path '${keypath}' contains an empty field name, ` +\\n            'which is not allowed.'\\n          );\\n        }\\n\\n        const target = findModTarget(newDoc, keyparts, {\\n          arrayIndices: options.arrayIndices,\\n          forbidArray: operator === '$rename',\\n          noCreate: NO_CREATE_MODIFIERS[operator]\\n        });\\n\\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\\n      });\\n    });\\n\\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\\n      throw MinimongoError(\\n        `After applying the update to the document {_id: \\\"${doc._id}\\\", ...},` +\\n        ' the (immutable) field \\\\'_id\\\\' was found to have been altered to ' +\\n        `_id: \\\"${newDoc._id}\\\"`\\n      );\\n    }\\n  } else {\\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\\n      throw MinimongoError(\\n        `The _id field cannot be changed from {_id: \\\"${doc._id}\\\"} to ` +\\n        `{_id: \\\"${modifier._id}\\\"}`\\n      );\\n    }\\n\\n    // replace the whole document\\n    assertHasValidFieldNames(modifier);\\n  }\\n\\n  // move new document into place.\\n  Object.keys(doc).forEach(key => {\\n    // Note: this used to be for (var key in doc) however, this does not\\n    // work right in Opera. Deleting from a doc while iterating over it\\n    // would sometimes cause opera to skip some keys.\\n    if (key !== '_id') {\\n      delete doc[key];\\n    }\\n  });\\n\\n  Object.keys(newDoc).forEach(key => {\\n    doc[key] = newDoc[key];\\n  });\\n};\\n\\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\\n  const transform = cursor.getTransform() || (doc => doc);\\n  let suppressed = !!observeCallbacks._suppress_initial;\\n\\n  let observeChangesCallbacks;\\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\\n    // The \\\"_no_indices\\\" option sets all index arguments to -1 and skips the\\n    // linear scans required to generate them.  This lets observers that don't\\n    // need absolute indices benefit from the other features of this API --\\n    // relative order, transforms, and applyChanges -- without the speed hit.\\n    const indices = !observeCallbacks._no_indices;\\n\\n    observeChangesCallbacks = {\\n      addedBefore(id, fields, before) {\\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\\n          return;\\n        }\\n\\n        const doc = transform(Object.assign(fields, {_id: id}));\\n\\n        if (observeCallbacks.addedAt) {\\n          observeCallbacks.addedAt(\\n            doc,\\n            indices\\n              ? before\\n                ? this.docs.indexOf(before)\\n                : this.docs.size()\\n              : -1,\\n            before\\n          );\\n        } else {\\n          observeCallbacks.added(doc);\\n        }\\n      },\\n      changed(id, fields) {\\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\\n          return;\\n        }\\n\\n        let doc = EJSON.clone(this.docs.get(id));\\n        if (!doc) {\\n          throw new Error(`Unknown id for changed: ${id}`);\\n        }\\n\\n        const oldDoc = transform(EJSON.clone(doc));\\n\\n        DiffSequence.applyChanges(doc, fields);\\n\\n        if (observeCallbacks.changedAt) {\\n          observeCallbacks.changedAt(\\n            transform(doc),\\n            oldDoc,\\n            indices ? this.docs.indexOf(id) : -1\\n          );\\n        } else {\\n          observeCallbacks.changed(transform(doc), oldDoc);\\n        }\\n      },\\n      movedBefore(id, before) {\\n        if (!observeCallbacks.movedTo) {\\n          return;\\n        }\\n\\n        const from = indices ? this.docs.indexOf(id) : -1;\\n        let to = indices\\n          ? before\\n            ? this.docs.indexOf(before)\\n            : this.docs.size()\\n          : -1;\\n\\n        // When not moving backwards, adjust for the fact that removing the\\n        // document slides everything back one slot.\\n        if (to > from) {\\n          --to;\\n        }\\n\\n        observeCallbacks.movedTo(\\n          transform(EJSON.clone(this.docs.get(id))),\\n          from,\\n          to,\\n          before || null\\n        );\\n      },\\n      removed(id) {\\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\\n          return;\\n        }\\n\\n        // technically maybe there should be an EJSON.clone here, but it's about\\n        // to be removed from this.docs!\\n        const doc = transform(this.docs.get(id));\\n\\n        if (observeCallbacks.removedAt) {\\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\\n        } else {\\n          observeCallbacks.removed(doc);\\n        }\\n      },\\n    };\\n  } else {\\n    observeChangesCallbacks = {\\n      added(id, fields) {\\n        if (!suppressed && observeCallbacks.added) {\\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\\n        }\\n      },\\n      changed(id, fields) {\\n        if (observeCallbacks.changed) {\\n          const oldDoc = this.docs.get(id);\\n          const doc = EJSON.clone(oldDoc);\\n\\n          DiffSequence.applyChanges(doc, fields);\\n\\n          observeCallbacks.changed(\\n            transform(doc),\\n            transform(EJSON.clone(oldDoc))\\n          );\\n        }\\n      },\\n      removed(id) {\\n        if (observeCallbacks.removed) {\\n          observeCallbacks.removed(transform(this.docs.get(id)));\\n        }\\n      },\\n    };\\n  }\\n\\n  const changeObserver = new LocalCollection._CachingChangeObserver({\\n    callbacks: observeChangesCallbacks\\n  });\\n\\n  const handle = cursor.observeChanges(changeObserver.applyChange);\\n\\n  suppressed = false;\\n\\n  return handle;\\n};\\n\\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\\n  if (callbacks.added && callbacks.addedAt) {\\n    throw new Error('Please specify only one of added() and addedAt()');\\n  }\\n\\n  if (callbacks.changed && callbacks.changedAt) {\\n    throw new Error('Please specify only one of changed() and changedAt()');\\n  }\\n\\n  if (callbacks.removed && callbacks.removedAt) {\\n    throw new Error('Please specify only one of removed() and removedAt()');\\n  }\\n\\n  return !!(\\n    callbacks.addedAt ||\\n    callbacks.changedAt ||\\n    callbacks.movedTo ||\\n    callbacks.removedAt\\n  );\\n};\\n\\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\\n  if (callbacks.added && callbacks.addedBefore) {\\n    throw new Error('Please specify only one of added() and addedBefore()');\\n  }\\n\\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\\n};\\n\\nLocalCollection._removeFromResults = (query, doc) => {\\n  if (query.ordered) {\\n    const i = LocalCollection._findInOrderedResults(query, doc);\\n\\n    query.removed(doc._id);\\n    query.results.splice(i, 1);\\n  } else {\\n    const id = doc._id;  // in case callback mutates doc\\n\\n    query.removed(doc._id);\\n    query.results.remove(id);\\n  }\\n};\\n\\n// Is this selector just shorthand for lookup by _id?\\nLocalCollection._selectorIsId = selector =>\\n  typeof selector === 'number' ||\\n  typeof selector === 'string' ||\\n  selector instanceof MongoID.ObjectID\\n;\\n\\n// Is the selector just lookup by _id (shorthand or not)?\\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\\n  LocalCollection._selectorIsId(selector) ||\\n  LocalCollection._selectorIsId(selector && selector._id) &&\\n  Object.keys(selector).length === 1\\n;\\n\\nLocalCollection._updateInResults = (query, doc, old_doc) => {\\n  if (!EJSON.equals(doc._id, old_doc._id)) {\\n    throw new Error('Can\\\\'t change a doc\\\\'s _id while updating');\\n  }\\n\\n  const projectionFn = query.projectionFn;\\n  const changedFields = DiffSequence.makeChangedFields(\\n    projectionFn(doc),\\n    projectionFn(old_doc)\\n  );\\n\\n  if (!query.ordered) {\\n    if (Object.keys(changedFields).length) {\\n      query.changed(doc._id, changedFields);\\n      query.results.set(doc._id, doc);\\n    }\\n\\n    return;\\n  }\\n\\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\\n\\n  if (Object.keys(changedFields).length) {\\n    query.changed(doc._id, changedFields);\\n  }\\n\\n  if (!query.sorter) {\\n    return;\\n  }\\n\\n  // just take it out and put it back in again, and see if the index changes\\n  query.results.splice(old_idx, 1);\\n\\n  const new_idx = LocalCollection._insertInSortedList(\\n    query.sorter.getComparator({distances: query.distances}),\\n    query.results,\\n    doc\\n  );\\n\\n  if (old_idx !== new_idx) {\\n    let next = query.results[new_idx + 1];\\n    if (next) {\\n      next = next._id;\\n    } else {\\n      next = null;\\n    }\\n\\n    query.movedBefore && query.movedBefore(doc._id, next);\\n  }\\n};\\n\\nconst MODIFIERS = {\\n  $currentDate(target, field, arg) {\\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\\n      if (arg.$type !== 'date') {\\n        throw MinimongoError(\\n          'Minimongo does currently only support the date type in ' +\\n          '$currentDate modifiers',\\n          {field}\\n        );\\n      }\\n    } else if (arg !== true) {\\n      throw MinimongoError('Invalid $currentDate modifier', {field});\\n    }\\n\\n    target[field] = new Date();\\n  },\\n  $min(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $min modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      if (target[field] > arg) {\\n        target[field] = arg;\\n      }\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $max(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $max modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      if (target[field] < arg) {\\n        target[field] = arg;\\n      }\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $inc(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $inc modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      target[field] += arg;\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $set(target, field, arg) {\\n    if (target !== Object(target)) { // not an array or an object\\n      const error = MinimongoError(\\n        'Cannot set property on non-object field',\\n        {field}\\n      );\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    if (target === null) {\\n      const error = MinimongoError('Cannot set property on null', {field});\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    assertHasValidFieldNames(arg);\\n\\n    target[field] = arg;\\n  },\\n  $setOnInsert(target, field, arg) {\\n    // converted to `$set` in `_modify`\\n  },\\n  $unset(target, field, arg) {\\n    if (target !== undefined) {\\n      if (target instanceof Array) {\\n        if (field in target) {\\n          target[field] = null;\\n        }\\n      } else {\\n        delete target[field];\\n      }\\n    }\\n  },\\n  $push(target, field, arg) {\\n    if (target[field] === undefined) {\\n      target[field] = [];\\n    }\\n\\n    if (!(target[field] instanceof Array)) {\\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\\n    }\\n\\n    if (!(arg && arg.$each)) {\\n      // Simple mode: not $each\\n      assertHasValidFieldNames(arg);\\n\\n      target[field].push(arg);\\n\\n      return;\\n    }\\n\\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\\n    const toPush = arg.$each;\\n    if (!(toPush instanceof Array)) {\\n      throw MinimongoError('$each must be an array', {field});\\n    }\\n\\n    assertHasValidFieldNames(toPush);\\n\\n    // Parse $position\\n    let position = undefined;\\n    if ('$position' in arg) {\\n      if (typeof arg.$position !== 'number') {\\n        throw MinimongoError('$position must be a numeric value', {field});\\n      }\\n\\n      // XXX should check to make sure integer\\n      if (arg.$position < 0) {\\n        throw MinimongoError(\\n          '$position in $push must be zero or positive',\\n          {field}\\n        );\\n      }\\n\\n      position = arg.$position;\\n    }\\n\\n    // Parse $slice.\\n    let slice = undefined;\\n    if ('$slice' in arg) {\\n      if (typeof arg.$slice !== 'number') {\\n        throw MinimongoError('$slice must be a numeric value', {field});\\n      }\\n\\n      // XXX should check to make sure integer\\n      slice = arg.$slice;\\n    }\\n\\n    // Parse $sort.\\n    let sortFunction = undefined;\\n    if (arg.$sort) {\\n      if (slice === undefined) {\\n        throw MinimongoError('$sort requires $slice to be present', {field});\\n      }\\n\\n      // XXX this allows us to use a $sort whose value is an array, but that's\\n      // actually an extension of the Node driver, so it won't work\\n      // server-side. Could be confusing!\\n      // XXX is it correct that we don't do geo-stuff here?\\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\\n\\n      toPush.forEach(element => {\\n        if (LocalCollection._f._type(element) !== 3) {\\n          throw MinimongoError(\\n            '$push like modifiers using $sort require all elements to be ' +\\n            'objects',\\n            {field}\\n          );\\n        }\\n      });\\n    }\\n\\n    // Actually push.\\n    if (position === undefined) {\\n      toPush.forEach(element => {\\n        target[field].push(element);\\n      });\\n    } else {\\n      const spliceArguments = [position, 0];\\n\\n      toPush.forEach(element => {\\n        spliceArguments.push(element);\\n      });\\n\\n      target[field].splice(...spliceArguments);\\n    }\\n\\n    // Actually sort.\\n    if (sortFunction) {\\n      target[field].sort(sortFunction);\\n    }\\n\\n    // Actually slice.\\n    if (slice !== undefined) {\\n      if (slice === 0) {\\n        target[field] = []; // differs from Array.slice!\\n      } else if (slice < 0) {\\n        target[field] = target[field].slice(slice);\\n      } else {\\n        target[field] = target[field].slice(0, slice);\\n      }\\n    }\\n  },\\n  $pushAll(target, field, arg) {\\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\\n    }\\n\\n    assertHasValidFieldNames(arg);\\n\\n    const toPush = target[field];\\n\\n    if (toPush === undefined) {\\n      target[field] = arg;\\n    } else if (!(toPush instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pushAll modifier to non-array',\\n        {field}\\n      );\\n    } else {\\n      toPush.push(...arg);\\n    }\\n  },\\n  $addToSet(target, field, arg) {\\n    let isEach = false;\\n\\n    if (typeof arg === 'object') {\\n      // check if first key is '$each'\\n      const keys = Object.keys(arg);\\n      if (keys[0] === '$each') {\\n        isEach = true;\\n      }\\n    }\\n\\n    const values = isEach ? arg.$each : [arg];\\n\\n    assertHasValidFieldNames(values);\\n\\n    const toAdd = target[field];\\n    if (toAdd === undefined) {\\n      target[field] = values;\\n    } else if (!(toAdd instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $addToSet modifier to non-array',\\n        {field}\\n      );\\n    } else {\\n      values.forEach(value => {\\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\\n          return;\\n        }\\n\\n        toAdd.push(value);\\n      });\\n    }\\n  },\\n  $pop(target, field, arg) {\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPop = target[field];\\n\\n    if (toPop === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPop instanceof Array)) {\\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\\n    }\\n\\n    if (typeof arg === 'number' && arg < 0) {\\n      toPop.splice(0, 1);\\n    } else {\\n      toPop.pop();\\n    }\\n  },\\n  $pull(target, field, arg) {\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPull = target[field];\\n    if (toPull === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPull instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pull/pullAll modifier to non-array',\\n        {field}\\n      );\\n    }\\n\\n    let out;\\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\\n      // XXX would be much nicer to compile this once, rather than\\n      // for each document we modify.. but usually we're not\\n      // modifying that many documents, so we'll let it slide for\\n      // now\\n\\n      // XXX Minimongo.Matcher isn't up for the job, because we need\\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\\n      // like {$gt: 4} is not normally a complete selector.\\n      // same issue as $elemMatch possibly?\\n      const matcher = new Minimongo.Matcher(arg);\\n\\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\\n    } else {\\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\\n    }\\n\\n    target[field] = out;\\n  },\\n  $pullAll(target, field, arg) {\\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\\n      throw MinimongoError(\\n        'Modifier $pushAll/pullAll allowed for arrays only',\\n        {field}\\n      );\\n    }\\n\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPull = target[field];\\n\\n    if (toPull === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPull instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pull/pullAll modifier to non-array',\\n        {field}\\n      );\\n    }\\n\\n    target[field] = toPull.filter(object =>\\n      !arg.some(element => LocalCollection._f._equal(object, element))\\n    );\\n  },\\n  $rename(target, field, arg, keypath, doc) {\\n    // no idea why mongo has this restriction..\\n    if (keypath === arg) {\\n      throw MinimongoError('$rename source must differ from target', {field});\\n    }\\n\\n    if (target === null) {\\n      throw MinimongoError('$rename source field invalid', {field});\\n    }\\n\\n    if (typeof arg !== 'string') {\\n      throw MinimongoError('$rename target must be a string', {field});\\n    }\\n\\n    if (arg.includes('\\\\0')) {\\n      // Null bytes are not allowed in Mongo field names\\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\\n      throw MinimongoError(\\n        'The \\\\'to\\\\' field for $rename cannot contain an embedded null byte',\\n        {field}\\n      );\\n    }\\n\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const object = target[field];\\n\\n    delete target[field];\\n\\n    const keyparts = arg.split('.');\\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\\n\\n    if (target2 === null) {\\n      throw MinimongoError('$rename target field invalid', {field});\\n    }\\n\\n    target2[keyparts.pop()] = object;\\n  },\\n  $bit(target, field, arg) {\\n    // XXX mongo only supports $bit on integers, and we only support\\n    // native javascript numbers (doubles) so far, so we can't support $bit\\n    throw MinimongoError('$bit is not supported', {field});\\n  },\\n  $v() {\\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\\n    // the `$v` operator is not needed by Meteor, but problems can occur if\\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\\n    // a no-op to work around these problems.\\n  }\\n};\\n\\nconst NO_CREATE_MODIFIERS = {\\n  $pop: true,\\n  $pull: true,\\n  $pullAll: true,\\n  $rename: true,\\n  $unset: true\\n};\\n\\n// Make sure field names do not contain Mongo restricted\\n// characters ('.', '$', '\\\\0').\\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\\nconst invalidCharMsg = {\\n  $: 'start with \\\\'$\\\\'',\\n  '.': 'contain \\\\'.\\\\'',\\n  '\\\\0': 'contain null bytes'\\n};\\n\\n// checks if all field names in an object are valid\\nfunction assertHasValidFieldNames(doc) {\\n  if (doc && typeof doc === 'object') {\\n    JSON.stringify(doc, (key, value) => {\\n      assertIsValidFieldName(key);\\n      return value;\\n    });\\n  }\\n}\\n\\nfunction assertIsValidFieldName(key) {\\n  let match;\\n  if (typeof key === 'string' && (match = key.match(/^\\\\$|\\\\.|\\\\0/))) {\\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\\n  }\\n}\\n\\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\\n// and then you would operate on the 'e' property of the returned\\n// object.\\n//\\n// if options.noCreate is falsey, creates intermediate levels of\\n// structure as necessary, like mkdir -p (and raises an exception if\\n// that would mean giving a non-numeric property to an array.) if\\n// options.noCreate is true, return undefined instead.\\n//\\n// may modify the last element of keyparts to signal to the caller that it needs\\n// to use a different value to index into the returned object (for example,\\n// ['a', '01'] -> ['a', 1]).\\n//\\n// if forbidArray is true, return null if the keypath goes through an array.\\n//\\n// if options.arrayIndices is set, use its first element for the (first) '$' in\\n// the path.\\nfunction findModTarget(doc, keyparts, options = {}) {\\n  let usedArrayIndex = false;\\n\\n  for (let i = 0; i < keyparts.length; i++) {\\n    const last = i === keyparts.length - 1;\\n    let keypart = keyparts[i];\\n\\n    if (!isIndexable(doc)) {\\n      if (options.noCreate) {\\n        return undefined;\\n      }\\n\\n      const error = MinimongoError(\\n        `cannot use the part '${keypart}' to traverse ${doc}`\\n      );\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    if (doc instanceof Array) {\\n      if (options.forbidArray) {\\n        return null;\\n      }\\n\\n      if (keypart === '$') {\\n        if (usedArrayIndex) {\\n          throw MinimongoError('Too many positional (i.e. \\\\'$\\\\') elements');\\n        }\\n\\n        if (!options.arrayIndices || !options.arrayIndices.length) {\\n          throw MinimongoError(\\n            'The positional operator did not find the match needed from the ' +\\n            'query'\\n          );\\n        }\\n\\n        keypart = options.arrayIndices[0];\\n        usedArrayIndex = true;\\n      } else if (isNumericKey(keypart)) {\\n        keypart = parseInt(keypart);\\n      } else {\\n        if (options.noCreate) {\\n          return undefined;\\n        }\\n\\n        throw MinimongoError(\\n          `can't append to array using string field name [${keypart}]`\\n        );\\n      }\\n\\n      if (last) {\\n        keyparts[i] = keypart; // handle 'a.01'\\n      }\\n\\n      if (options.noCreate && keypart >= doc.length) {\\n        return undefined;\\n      }\\n\\n      while (doc.length < keypart) {\\n        doc.push(null);\\n      }\\n\\n      if (!last) {\\n        if (doc.length === keypart) {\\n          doc.push({});\\n        } else if (typeof doc[keypart] !== 'object') {\\n          throw MinimongoError(\\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\\n            JSON.stringify(doc[keypart])\\n          );\\n        }\\n      }\\n    } else {\\n      assertIsValidFieldName(keypart);\\n\\n      if (!(keypart in doc)) {\\n        if (options.noCreate) {\\n          return undefined;\\n        }\\n\\n        if (!last) {\\n          doc[keypart] = {};\\n        }\\n      }\\n    }\\n\\n    if (last) {\\n      return doc;\\n    }\\n\\n    doc = doc[keypart];\\n  }\\n\\n  // notreached\\n}\\n\",\"import LocalCollection from './local_collection.js';\\nimport {\\n  compileDocumentSelector,\\n  hasOwn,\\n  nothingMatcher,\\n} from './common.js';\\n\\n// The minimongo selector compiler!\\n\\n// Terminology:\\n//  - a 'selector' is the EJSON object representing a selector\\n//  - a 'matcher' is its compiled form (whether a full Minimongo.Matcher\\n//    object or one of the component lambdas that matches parts of it)\\n//  - a 'result object' is an object with a 'result' field and maybe\\n//    distance and arrayIndices.\\n//  - a 'branched value' is an object with a 'value' field and maybe\\n//    'dontIterate' and 'arrayIndices'.\\n//  - a 'document' is a top-level object that can be stored in a collection.\\n//  - a 'lookup function' is a function that takes in a document and returns\\n//    an array of 'branched values'.\\n//  - a 'branched matcher' maps from an array of branched values to a result\\n//    object.\\n//  - an 'element matcher' maps from a single value to a bool.\\n\\n// Main entry point.\\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});\\n//   if (matcher.documentMatches({a: 7})) ...\\nexport default class Matcher {\\n  constructor(selector, isUpdate) {\\n    // A set (object mapping string -> *) of all of the document paths looked\\n    // at by the selector. Also includes the empty string if it may look at any\\n    // path (eg, $where).\\n    this._paths = {};\\n    // Set to true if compilation finds a $near.\\n    this._hasGeoQuery = false;\\n    // Set to true if compilation finds a $where.\\n    this._hasWhere = false;\\n    // Set to false if compilation finds anything other than a simple equality\\n    // or one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used\\n    // with scalars as operands.\\n    this._isSimple = true;\\n    // Set to a dummy document which always matches this Matcher. Or set to null\\n    // if such document is too hard to find.\\n    this._matchingDocument = undefined;\\n    // A clone of the original selector. It may just be a function if the user\\n    // passed in a function; otherwise is definitely an object (eg, IDs are\\n    // translated into {_id: ID} first. Used by canBecomeTrueByModifier and\\n    // Sorter._useWithMatcher.\\n    this._selector = null;\\n    this._docMatcher = this._compileSelector(selector);\\n    // Set to true if selection is done for an update operation\\n    // Default is false\\n    // Used for $near array update (issue #3599)\\n    this._isUpdate = isUpdate;\\n  }\\n\\n  documentMatches(doc) {\\n    if (doc !== Object(doc)) {\\n      throw Error('documentMatches needs a document');\\n    }\\n\\n    return this._docMatcher(doc);\\n  }\\n\\n  hasGeoQuery() {\\n    return this._hasGeoQuery;\\n  }\\n\\n  hasWhere() {\\n    return this._hasWhere;\\n  }\\n\\n  isSimple() {\\n    return this._isSimple;\\n  }\\n\\n  // Given a selector, return a function that takes one argument, a\\n  // document. It returns a result object.\\n  _compileSelector(selector) {\\n    // you can pass a literal function instead of a selector\\n    if (selector instanceof Function) {\\n      this._isSimple = false;\\n      this._selector = selector;\\n      this._recordPathUsed('');\\n\\n      return doc => ({result: !!selector.call(doc)});\\n    }\\n\\n    // shorthand -- scalar _id\\n    if (LocalCollection._selectorIsId(selector)) {\\n      this._selector = {_id: selector};\\n      this._recordPathUsed('_id');\\n\\n      return doc => ({result: EJSON.equals(doc._id, selector)});\\n    }\\n\\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both\\n    // likely programmer error, and not what you want, particularly for\\n    // destructive operations.\\n    if (!selector || hasOwn.call(selector, '_id') && !selector._id) {\\n      this._isSimple = false;\\n      return nothingMatcher;\\n    }\\n\\n    // Top level can't be an array or true or binary.\\n    if (Array.isArray(selector) ||\\n        EJSON.isBinary(selector) ||\\n        typeof selector === 'boolean') {\\n      throw new Error(`Invalid selector: ${selector}`);\\n    }\\n\\n    this._selector = EJSON.clone(selector);\\n\\n    return compileDocumentSelector(selector, this, {isRoot: true});\\n  }\\n\\n  // Returns a list of key paths the given selector is looking for. It includes\\n  // the empty string if there is a $where.\\n  _getPaths() {\\n    return Object.keys(this._paths);\\n  }\\n\\n  _recordPathUsed(path) {\\n    this._paths[path] = true;\\n  }\\n}\\n\\n// helpers used by compiled selector code\\nLocalCollection._f = {\\n  // XXX for _all and _in, consider building 'inquery' at compile time..\\n  _type(v) {\\n    if (typeof v === 'number') {\\n      return 1;\\n    }\\n\\n    if (typeof v === 'string') {\\n      return 2;\\n    }\\n\\n    if (typeof v === 'boolean') {\\n      return 8;\\n    }\\n\\n    if (Array.isArray(v)) {\\n      return 4;\\n    }\\n\\n    if (v === null) {\\n      return 10;\\n    }\\n\\n    // note that typeof(/x/) === \\\"object\\\"\\n    if (v instanceof RegExp) {\\n      return 11;\\n    }\\n\\n    if (typeof v === 'function') {\\n      return 13;\\n    }\\n\\n    if (v instanceof Date) {\\n      return 9;\\n    }\\n\\n    if (EJSON.isBinary(v)) {\\n      return 5;\\n    }\\n\\n    if (v instanceof MongoID.ObjectID) {\\n      return 7;\\n    }\\n\\n    // object\\n    return 3;\\n\\n    // XXX support some/all of these:\\n    // 14, symbol\\n    // 15, javascript code with scope\\n    // 16, 18: 32-bit/64-bit integer\\n    // 17, timestamp\\n    // 255, minkey\\n    // 127, maxkey\\n  },\\n\\n  // deep equality test: use for literal document and array matches\\n  _equal(a, b) {\\n    return EJSON.equals(a, b, {keyOrderSensitive: true});\\n  },\\n\\n  // maps a type code to a value that can be used to sort values of different\\n  // types\\n  _typeorder(t) {\\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\\n    // XXX what is the correct sort position for Javascript code?\\n    // ('100' in the matrix below)\\n    // XXX minkey/maxkey\\n    return [\\n      -1,  // (not a type)\\n      1,   // number\\n      2,   // string\\n      3,   // object\\n      4,   // array\\n      5,   // binary\\n      -1,  // deprecated\\n      6,   // ObjectID\\n      7,   // bool\\n      8,   // Date\\n      0,   // null\\n      9,   // RegExp\\n      -1,  // deprecated\\n      100, // JS code\\n      2,   // deprecated (symbol)\\n      100, // JS code\\n      1,   // 32-bit int\\n      8,   // Mongo timestamp\\n      1    // 64-bit int\\n    ][t];\\n  },\\n\\n  // compare two values of unknown type according to BSON ordering\\n  // semantics. (as an extension, consider 'undefined' to be less than\\n  // any other value.) return negative if a is less, positive if b is\\n  // less, or 0 if equal\\n  _cmp(a, b) {\\n    if (a === undefined) {\\n      return b === undefined ? 0 : -1;\\n    }\\n\\n    if (b === undefined) {\\n      return 1;\\n    }\\n\\n    let ta = LocalCollection._f._type(a);\\n    let tb = LocalCollection._f._type(b);\\n\\n    const oa = LocalCollection._f._typeorder(ta);\\n    const ob = LocalCollection._f._typeorder(tb);\\n\\n    if (oa !== ob) {\\n      return oa < ob ? -1 : 1;\\n    }\\n\\n    // XXX need to implement this if we implement Symbol or integers, or\\n    // Timestamp\\n    if (ta !== tb) {\\n      throw Error('Missing type coercion logic in _cmp');\\n    }\\n\\n    if (ta === 7) { // ObjectID\\n      // Convert to string.\\n      ta = tb = 2;\\n      a = a.toHexString();\\n      b = b.toHexString();\\n    }\\n\\n    if (ta === 9) { // Date\\n      // Convert to millis.\\n      ta = tb = 1;\\n      a = a.getTime();\\n      b = b.getTime();\\n    }\\n\\n    if (ta === 1) // double\\n      return a - b;\\n\\n    if (tb === 2) // string\\n      return a < b ? -1 : a === b ? 0 : 1;\\n\\n    if (ta === 3) { // Object\\n      // this could be much more efficient in the expected case ...\\n      const toArray = object => {\\n        const result = [];\\n\\n        Object.keys(object).forEach(key => {\\n          result.push(key, object[key]);\\n        });\\n\\n        return result;\\n      };\\n\\n      return LocalCollection._f._cmp(toArray(a), toArray(b));\\n    }\\n\\n    if (ta === 4) { // Array\\n      for (let i = 0; ; i++) {\\n        if (i === a.length) {\\n          return i === b.length ? 0 : -1;\\n        }\\n\\n        if (i === b.length) {\\n          return 1;\\n        }\\n\\n        const s = LocalCollection._f._cmp(a[i], b[i]);\\n        if (s !== 0) {\\n          return s;\\n        }\\n      }\\n    }\\n\\n    if (ta === 5) { // binary\\n      // Surprisingly, a small binary blob is always less than a large one in\\n      // Mongo.\\n      if (a.length !== b.length) {\\n        return a.length - b.length;\\n      }\\n\\n      for (let i = 0; i < a.length; i++) {\\n        if (a[i] < b[i]) {\\n          return -1;\\n        }\\n\\n        if (a[i] > b[i]) {\\n          return 1;\\n        }\\n      }\\n\\n      return 0;\\n    }\\n\\n    if (ta === 8) { // boolean\\n      if (a) {\\n        return b ? 0 : 1;\\n      }\\n\\n      return b ? -1 : 0;\\n    }\\n\\n    if (ta === 10) // null\\n      return 0;\\n\\n    if (ta === 11) // regexp\\n      throw Error('Sorting not supported on regular expression'); // XXX\\n\\n    // 13: javascript code\\n    // 14: symbol\\n    // 15: javascript code with scope\\n    // 16: 32-bit integer\\n    // 17: timestamp\\n    // 18: 64-bit integer\\n    // 255: minkey\\n    // 127: maxkey\\n    if (ta === 13) // javascript code\\n      throw Error('Sorting not supported on Javascript code'); // XXX\\n\\n    throw Error('Unknown type to sort');\\n  },\\n};\\n\",\"import LocalCollection_ from './local_collection.js';\\nimport Matcher from './matcher.js';\\nimport Sorter from './sorter.js';\\n\\nLocalCollection = LocalCollection_;\\nMinimongo = {\\n    LocalCollection: LocalCollection_,\\n    Matcher,\\n    Sorter\\n};\\n\",\"// ObserveHandle: the return value of a live query.\\nexport default class ObserveHandle {}\\n\",\"import {\\n  ELEMENT_OPERATORS,\\n  equalityElementMatcher,\\n  expandArraysInBranches,\\n  hasOwn,\\n  isOperatorObject,\\n  makeLookupFunction,\\n  regexpElementMatcher,\\n} from './common.js';\\n\\n// Give a sort spec, which can be in any of these forms:\\n//   {\\\"key1\\\": 1, \\\"key2\\\": -1}\\n//   [[\\\"key1\\\", \\\"asc\\\"], [\\\"key2\\\", \\\"desc\\\"]]\\n//   [\\\"key1\\\", [\\\"key2\\\", \\\"desc\\\"]]\\n//\\n// (.. with the first form being dependent on the key enumeration\\n// behavior of your javascript VM, which usually does what you mean in\\n// this case if the key names don't look like integers ..)\\n//\\n// return a function that takes two objects, and returns -1 if the\\n// first object comes first in order, 1 if the second object comes\\n// first, or 0 if neither object comes before the other.\\n\\nexport default class Sorter {\\n  constructor(spec) {\\n    this._sortSpecParts = [];\\n    this._sortFunction = null;\\n\\n    const addSpecPart = (path, ascending) => {\\n      if (!path) {\\n        throw Error('sort keys must be non-empty');\\n      }\\n\\n      if (path.charAt(0) === '$') {\\n        throw Error(`unsupported sort key: ${path}`);\\n      }\\n\\n      this._sortSpecParts.push({\\n        ascending,\\n        lookup: makeLookupFunction(path, {forSort: true}),\\n        path\\n      });\\n    };\\n\\n    if (spec instanceof Array) {\\n      spec.forEach(element => {\\n        if (typeof element === 'string') {\\n          addSpecPart(element, true);\\n        } else {\\n          addSpecPart(element[0], element[1] !== 'desc');\\n        }\\n      });\\n    } else if (typeof spec === 'object') {\\n      Object.keys(spec).forEach(key => {\\n        addSpecPart(key, spec[key] >= 0);\\n      });\\n    } else if (typeof spec === 'function') {\\n      this._sortFunction = spec;\\n    } else {\\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\\n    }\\n\\n    // If a function is specified for sorting, we skip the rest.\\n    if (this._sortFunction) {\\n      return;\\n    }\\n\\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\\n    // affectedByModifier code; we create a selector that is affected by the\\n    // same modifiers as this sort order. This is only implemented on the\\n    // server.\\n    if (this.affectedByModifier) {\\n      const selector = {};\\n\\n      this._sortSpecParts.forEach(spec => {\\n        selector[spec.path] = 1;\\n      });\\n\\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\\n    }\\n\\n    this._keyComparator = composeComparators(\\n      this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))\\n    );\\n  }\\n\\n  getComparator(options) {\\n    // If sort is specified or have no distances, just use the comparator from\\n    // the source specification (which defaults to \\\"everything is equal\\\".\\n    // issue #3599\\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\\n    // sort effectively overrides $near\\n    if (this._sortSpecParts.length || !options || !options.distances) {\\n      return this._getBaseComparator();\\n    }\\n\\n    const distances = options.distances;\\n\\n    // Return a comparator which compares using $near distances.\\n    return (a, b) => {\\n      if (!distances.has(a._id)) {\\n        throw Error(`Missing distance for ${a._id}`);\\n      }\\n\\n      if (!distances.has(b._id)) {\\n        throw Error(`Missing distance for ${b._id}`);\\n      }\\n\\n      return distances.get(a._id) - distances.get(b._id);\\n    };\\n  }\\n\\n  // Takes in two keys: arrays whose lengths match the number of spec\\n  // parts. Returns negative, 0, or positive based on using the sort spec to\\n  // compare fields.\\n  _compareKeys(key1, key2) {\\n    if (key1.length !== this._sortSpecParts.length ||\\n        key2.length !== this._sortSpecParts.length) {\\n      throw Error('Key has wrong length');\\n    }\\n\\n    return this._keyComparator(key1, key2);\\n  }\\n\\n  // Iterates over each possible \\\"key\\\" from doc (ie, over each branch), calling\\n  // 'cb' with the key.\\n  _generateKeysFromDoc(doc, cb) {\\n    if (this._sortSpecParts.length === 0) {\\n      throw new Error('can\\\\'t generate keys without a spec');\\n    }\\n\\n    const pathFromIndices = indices => `${indices.join(',')},`;\\n\\n    let knownPaths = null;\\n\\n    // maps index -> ({'' -> value} or {path -> value})\\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\\n      // Expand any leaf arrays that we find, and ignore those arrays\\n      // themselves.  (We never sort based on an array itself.)\\n      let branches = expandArraysInBranches(spec.lookup(doc), true);\\n\\n      // If there are no values for a key (eg, key goes to an empty array),\\n      // pretend we found one undefined value.\\n      if (!branches.length) {\\n        branches = [{ value: void 0 }];\\n      }\\n\\n      const element = Object.create(null);\\n      let usedPaths = false;\\n\\n      branches.forEach(branch => {\\n        if (!branch.arrayIndices) {\\n          // If there are no array indices for a branch, then it must be the\\n          // only branch, because the only thing that produces multiple branches\\n          // is the use of arrays.\\n          if (branches.length > 1) {\\n            throw Error('multiple branches but no array used?');\\n          }\\n\\n          element[''] = branch.value;\\n          return;\\n        }\\n\\n        usedPaths = true;\\n\\n        const path = pathFromIndices(branch.arrayIndices);\\n\\n        if (hasOwn.call(element, path)) {\\n          throw Error(`duplicate path: ${path}`);\\n        }\\n\\n        element[path] = branch.value;\\n\\n        // If two sort fields both go into arrays, they have to go into the\\n        // exact same arrays and we have to find the same paths.  This is\\n        // roughly the same condition that makes MongoDB throw this strange\\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\\n        // b:1} then a and b cannot both be arrays.\\n        //\\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\\n        // #NestedArraySort\\n        // XXX achieve full compatibility here\\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\\n          throw Error('cannot index parallel arrays');\\n        }\\n      });\\n\\n      if (knownPaths) {\\n        // Similarly to above, paths must match everywhere, unless this is a\\n        // non-array field.\\n        if (!hasOwn.call(element, '') &&\\n            Object.keys(knownPaths).length !== Object.keys(element).length) {\\n          throw Error('cannot index parallel arrays!');\\n        }\\n      } else if (usedPaths) {\\n        knownPaths = {};\\n\\n        Object.keys(element).forEach(path => {\\n          knownPaths[path] = true;\\n        });\\n      }\\n\\n      return element;\\n    });\\n\\n    if (!knownPaths) {\\n      // Easy case: no use of arrays.\\n      const soleKey = valuesByIndexAndPath.map(values => {\\n        if (!hasOwn.call(values, '')) {\\n          throw Error('no value in sole key case?');\\n        }\\n\\n        return values[''];\\n      });\\n\\n      cb(soleKey);\\n\\n      return;\\n    }\\n\\n    Object.keys(knownPaths).forEach(path => {\\n      const key = valuesByIndexAndPath.map(values => {\\n        if (hasOwn.call(values, '')) {\\n          return values[''];\\n        }\\n\\n        if (!hasOwn.call(values, path)) {\\n          throw Error('missing path?');\\n        }\\n\\n        return values[path];\\n      });\\n\\n      cb(key);\\n    });\\n  }\\n\\n  // Returns a comparator that represents the sort specification (but not\\n  // including a possible geoquery distance tie-breaker).\\n  _getBaseComparator() {\\n    if (this._sortFunction) {\\n      return this._sortFunction;\\n    }\\n\\n    // If we're only sorting on geoquery distance and no specs, just say\\n    // everything is equal.\\n    if (!this._sortSpecParts.length) {\\n      return (doc1, doc2) => 0;\\n    }\\n\\n    return (doc1, doc2) => {\\n      const key1 = this._getMinKeyFromDoc(doc1);\\n      const key2 = this._getMinKeyFromDoc(doc2);\\n      return this._compareKeys(key1, key2);\\n    };\\n  }\\n\\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\\n  // \\\"minimum\\\" here but this is with respect to the sort spec, so \\\"descending\\\"\\n  // sort fields mean we're finding the max for that field.)\\n  //\\n  // Note that this is NOT \\\"find the minimum value of the first field, the\\n  // minimum value of the second field, etc\\\"... it's \\\"choose the\\n  // lexicographically minimum value of the key vector, allowing only keys which\\n  // you can find along the same paths\\\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\\n  _getMinKeyFromDoc(doc) {\\n    let minKey = null;\\n\\n    this._generateKeysFromDoc(doc, key => {\\n      if (minKey === null) {\\n        minKey = key;\\n        return;\\n      }\\n\\n      if (this._compareKeys(key, minKey) < 0) {\\n        minKey = key;\\n      }\\n    });\\n\\n    return minKey;\\n  }\\n\\n  _getPaths() {\\n    return this._sortSpecParts.map(part => part.path);\\n  }\\n\\n  // Given an index 'i', returns a comparator that compares two key arrays based\\n  // on field 'i'.\\n  _keyFieldComparator(i) {\\n    const invert = !this._sortSpecParts[i].ascending;\\n\\n    return (key1, key2) => {\\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\\n      return invert ? -compare : compare;\\n    };\\n  }\\n}\\n\\n// Given an array of comparators\\n// (functions (a,b)->(negative or positive or zero)), returns a single\\n// comparator which uses each comparator in order and returns the first\\n// non-zero value.\\nfunction composeComparators(comparatorArray) {\\n  return (a, b) => {\\n    for (let i = 0; i < comparatorArray.length; ++i) {\\n      const compare = comparatorArray[i](a, b);\\n      if (compare !== 0) {\\n        return compare;\\n      }\\n    }\\n\\n    return 0;\\n  };\\n}\\n\"]}","minifier":"terser"}