{"code":"!function(){var e=Package.meteor.Meteor,a=Package.meteor.global,s=Package.meteor.meteorEnv,t=Package[\"reactive-dict\"].ReactiveDict,i=Package.ejson.EJSON,o=Package.modules.meteorInstall,n=Package[\"babel-runtime\"].meteorBabelHelpers,c=Package.promise.Promise,r=Package[\"ecmascript-runtime-client\"].Symbol,m=Package[\"ecmascript-runtime-client\"].Map,l=Package[\"ecmascript-runtime-client\"].Set,g,k,P=o({node_modules:{meteor:{session:{\"session.js\":function(e,a,s){var t;s.export({Session:function(){return i}}),s.link(\"meteor/reactive-dict\",{ReactiveDict:function(e){t=e}},0);var i=new t(\"session\")}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/session/session.js\");Package._define(\"session\",P,{Session:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/session/session.js\"],\"names\":[\"ReactiveDict\",\"module\",\"export\",\"Session\",\"link\",\"v\"],\"mappings\":\"0cAAqC,IAAIA,EAAzCC,EAAOC,QAAQC,QAAQ,WAAA,OAAIA,KAA2BF,EAAOG,KAAK,wBAAwBJ,aAAD,SAAcK,GAAGL,EAAaK,IAAI,GAEpH,IAAMF,EAAU,IAAIH,EAAa\",\"sourcesContent\":[\"import { ReactiveDict } from 'meteor/reactive-dict';\\n\\nexport const Session = new ReactiveDict('session');\\n\\n// Documentation here is really awkward because the methods are defined\\n// elsewhere\\n\\n/**\\n * @memberOf Session\\n * @method set\\n * @summary Set a variable in the session. Notify any listeners that the value\\n * has changed (eg: redraw templates, and rerun any\\n * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n * [`Session.get`](#session_get) on this `key`.)\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method setDefault\\n * @summary Set a variable in the session if it hasn't been set before.\\n * Otherwise works exactly the same as [`Session.set`](#session_set).\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method get\\n * @summary Get the value of a session variable. If inside a [reactive\\n * computation](#reactivity), invalidate the computation the next time the\\n * value of the variable is changed by [`Session.set`](#session_set). This\\n * returns a clone of the session value, so if it's an object or an array,\\n * mutating the returned value has no effect on the value stored in the\\n * session.\\n * @locus Client\\n * @param {String} key The name of the session variable to return\\n */\\n\\n/**\\n * @memberOf Session\\n * @method equals\\n * @summary Test if a session variable is equal to a value. If inside a\\n * [reactive computation](#reactivity), invalidate the computation the next\\n * time the variable changes to or from the value.\\n * @locus Client\\n * @param {String} key The name of the session variable to test\\n * @param {String | Number | Boolean | null | undefined} value The value to\\n * test against\\n */\\n\"]}","minifier":"terser"}