{"code":"!function(){var e=Package.meteor.Meteor,n=Package.meteor.global,d=Package.meteor.meteorEnv,o=Package.ejson.EJSON,r=Package.modules.meteorInstall,i=Package[\"babel-runtime\"].meteorBabelHelpers,a=Package.promise.Promise,f,t,c=r({node_modules:{meteor:{\"diff-sequence\":{\"diff.js\":function(n,d,r){r.export({DiffSequence:()=>i});const i={},a=Object.prototype.hasOwnProperty;function f(e){for(let n in Object(e))if(a.call(e,n))return!1;return!0}i.diffQueryChanges=function(e,n,d,o,r){e?i.diffQueryOrderedChanges(n,d,o,r):i.diffQueryUnorderedChanges(n,d,o,r)},i.diffQueryUnorderedChanges=function(e,n,d,r){var a=(r=r||{}).projectionFn||o.clone;if(d.movedBefore)throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");n.forEach(function(n,r){var t=e.get(r);if(t){if(d.changed&&!o.equals(t,n)){var c=a(n),l=a(t),s=i.makeChangedFields(c,l);f(s)||d.changed(r,s)}}else if(d.added){var u=a(n);delete u._id,d.added(n._id,u)}}),d.removed&&e.forEach(function(e,o){n.has(o)||d.removed(o)})},i.diffQueryOrderedChanges=function(n,d,r,t){var c=(t=t||{}).projectionFn||o.clone,l={};d.forEach(function(n){l[n._id]&&e._debug(\"Duplicate _id in new_results\"),l[n._id]=!0});var s={};n.forEach(function(n,d){n._id in s&&e._debug(\"Duplicate _id in old_results\"),s[n._id]=d});for(var u=[],h=0,g=d.length,_=new Array(g),v=new Array(g),m=function(e){return s[d[e]._id]},y=0;y<g;y++)if(void 0!==s[d[y]._id]){for(var O=h;O>0&&!(m(_[O-1])<m(y));)O--;v[y]=0===O?-1:_[O-1],_[O]=y,O+1>h&&(h=O+1)}for(var b=0===h?-1:_[h-1];b>=0;)u.push(b),b=v[b];u.reverse(),u.push(d.length),n.forEach(function(e){l[e._id]||r.removed&&r.removed(e._id)});var k=0;u.forEach(function(e){for(var o=d[e]?d[e]._id:null,t,l,u,h,g,_=k;_<e;_++)l=d[_],a.call(s,l._id)?(t=n[s[l._id]],h=c(l),g=c(t),f(u=i.makeChangedFields(h,g))||r.changed&&r.changed(l._id,u),r.movedBefore&&r.movedBefore(l._id,o)):(delete(u=c(l))._id,r.addedBefore&&r.addedBefore(l._id,u,o),r.added&&r.added(l._id,u));o&&(l=d[e],t=n[s[l._id]],h=c(l),g=c(t),f(u=i.makeChangedFields(h,g))||r.changed&&r.changed(l._id,u)),k=e+1})},i.diffObjects=function(e,n,d){Object.keys(e).forEach(o=>{const r=e[o];a.call(n,o)?d.both&&d.both(o,r,n[o]):d.leftOnly&&d.leftOnly(o,r)}),d.rightOnly&&Object.keys(n).forEach(o=>{const r=n[o];a.call(e,o)||d.rightOnly(o,r)})},i.diffMaps=function(e,n,d){e.forEach(function(e,o){n.has(o)?d.both&&d.both(o,e,n.get(o)):d.leftOnly&&d.leftOnly(o,e)}),d.rightOnly&&n.forEach(function(n,o){e.has(o)||d.rightOnly(o,n)})},i.makeChangedFields=function(e,n){var d={};return i.diffObjects(n,e,{leftOnly:function(e,n){d[e]=void 0},rightOnly:function(e,n){d[e]=n},both:function(e,n,r){o.equals(n,r)||(d[e]=r)}}),d},i.applyChanges=function(e,n){Object.keys(n).forEach(d=>{const o=n[d];void 0===o?delete e[d]:e[d]=o})}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/diff-sequence/diff.js\");Package._define(\"diff-sequence\",c,{DiffSequence:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/diff-sequence/diff.js\"],\"names\":[\"module\",\"export\",\"DiffSequence\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"isObjEmpty\",\"obj\",\"key\",\"call\",\"diffQueryChanges\",\"ordered\",\"oldResults\",\"newResults\",\"observer\",\"options\",\"diffQueryOrderedChanges\",\"diffQueryUnorderedChanges\",\"projectionFn\",\"EJSON\",\"clone\",\"movedBefore\",\"Error\",\"forEach\",\"newDoc\",\"id\",\"oldDoc\",\"get\",\"changed\",\"equals\",\"projectedNew\",\"projectedOld\",\"changedFields\",\"makeChangedFields\",\"added\",\"fields\",\"_id\",\"removed\",\"has\",\"old_results\",\"new_results\",\"new_presence_of_id\",\"doc\",\"Meteor\",\"_debug\",\"old_index_of_id\",\"i\",\"unmoved\",\"max_seq_len\",\"N\",\"length\",\"seq_ends\",\"Array\",\"ptrs\",\"old_idx_seq\",\"i_new\",\"undefined\",\"j\",\"idx\",\"push\",\"reverse\",\"startOfGroup\",\"endOfGroup\",\"groupId\",\"addedBefore\",\"diffObjects\",\"left\",\"right\",\"callbacks\",\"keys\",\"leftValue\",\"both\",\"leftOnly\",\"rightOnly\",\"rightValue\",\"diffMaps\",\"value\",\"applyChanges\",\"changeFields\"],\"mappings\":\"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\",\"sourcesContent\":[\"export const DiffSequence = {};\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nfunction isObjEmpty(obj) {\\n  for (let key in Object(obj)) {\\n    if (hasOwn.call(obj, key)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n// ordered: bool.\\n// old_results and new_results: collections of documents.\\n//    if ordered, they are arrays.\\n//    if unordered, they are IdMaps\\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,\\n                                              observer, options) {\\n  if (ordered)\\n    DiffSequence.diffQueryOrderedChanges(\\n      oldResults, newResults, observer, options);\\n  else\\n    DiffSequence.diffQueryUnorderedChanges(\\n      oldResults, newResults, observer, options);\\n};\\n\\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,\\n                                                       observer, options) {\\n  options = options || {};\\n  var projectionFn = options.projectionFn || EJSON.clone;\\n\\n  if (observer.movedBefore) {\\n    throw new Error(\\\"_diffQueryUnordered called with a movedBefore observer!\\\");\\n  }\\n\\n  newResults.forEach(function (newDoc, id) {\\n    var oldDoc = oldResults.get(id);\\n    if (oldDoc) {\\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\\n        var projectedNew = projectionFn(newDoc);\\n        var projectedOld = projectionFn(oldDoc);\\n        var changedFields =\\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n        if (! isObjEmpty(changedFields)) {\\n          observer.changed(id, changedFields);\\n        }\\n      }\\n    } else if (observer.added) {\\n      var fields = projectionFn(newDoc);\\n      delete fields._id;\\n      observer.added(newDoc._id, fields);\\n    }\\n  });\\n\\n  if (observer.removed) {\\n    oldResults.forEach(function (oldDoc, id) {\\n      if (!newResults.has(id))\\n        observer.removed(id);\\n    });\\n  }\\n};\\n\\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,\\n                                                     observer, options) {\\n  options = options || {};\\n  var projectionFn = options.projectionFn || EJSON.clone;\\n\\n  var new_presence_of_id = {};\\n  new_results.forEach(function (doc) {\\n    if (new_presence_of_id[doc._id])\\n      Meteor._debug(\\\"Duplicate _id in new_results\\\");\\n    new_presence_of_id[doc._id] = true;\\n  });\\n\\n  var old_index_of_id = {};\\n  old_results.forEach(function (doc, i) {\\n    if (doc._id in old_index_of_id)\\n      Meteor._debug(\\\"Duplicate _id in old_results\\\");\\n    old_index_of_id[doc._id] = i;\\n  });\\n\\n  // ALGORITHM:\\n  //\\n  // To determine which docs should be considered \\\"moved\\\" (and which\\n  // merely change position because of other docs moving) we run\\n  // a \\\"longest common subsequence\\\" (LCS) algorithm.  The LCS of the\\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\\n  // considered moved.\\n\\n  // To actually call the appropriate callbacks to get from the old state to the\\n  // new state:\\n\\n  // First, we call removed() on all the items that only appear in the old\\n  // state.\\n\\n  // Then, once we have the items that should not move, we walk through the new\\n  // results array group-by-group, where a \\\"group\\\" is a set of items that have\\n  // moved, anchored on the end by an item that should not move.  One by one, we\\n  // move each of those elements into place \\\"before\\\" the anchoring end-of-group\\n  // item, and fire changed events on them if necessary.  Then we fire a changed\\n  // event on the anchor, and move on to the next group.  There is always at\\n  // least one group; the last group is anchored by a virtual \\\"null\\\" id at the\\n  // end.\\n\\n  // Asymptotically: O(N k) where k is number of ops, or potentially\\n  // O(N log N) if inner loop of LCS were made to be binary search.\\n\\n\\n  //////// LCS (longest common sequence, with respect to _id)\\n  // (see Wikipedia article on Longest Increasing Subsequence,\\n  // where the LIS is taken of the sequence of old indices of the\\n  // docs in new_results)\\n  //\\n  // unmoved: the output of the algorithm; members of the LCS,\\n  // in the form of indices into new_results\\n  var unmoved = [];\\n  // max_seq_len: length of LCS found so far\\n  var max_seq_len = 0;\\n  // seq_ends[i]: the index into new_results of the last doc in a\\n  // common subsequence of length of i+1 <= max_seq_len\\n  var N = new_results.length;\\n  var seq_ends = new Array(N);\\n  // ptrs:  the common subsequence ending with new_results[n] extends\\n  // a common subsequence ending with new_results[ptr[n]], unless\\n  // ptr[n] is -1.\\n  var ptrs = new Array(N);\\n  // virtual sequence of old indices of new results\\n  var old_idx_seq = function(i_new) {\\n    return old_index_of_id[new_results[i_new]._id];\\n  };\\n  // for each item in new_results, use it to extend a common subsequence\\n  // of length j <= max_seq_len\\n  for(var i=0; i<N; i++) {\\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\\n      var j = max_seq_len;\\n      // this inner loop would traditionally be a binary search,\\n      // but scanning backwards we will likely find a subseq to extend\\n      // pretty soon, bounded for example by the total number of ops.\\n      // If this were to be changed to a binary search, we'd still want\\n      // to scan backwards a bit as an optimization.\\n      while (j > 0) {\\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))\\n          break;\\n        j--;\\n      }\\n\\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);\\n      seq_ends[j] = i;\\n      if (j+1 > max_seq_len)\\n        max_seq_len = j+1;\\n    }\\n  }\\n\\n  // pull out the LCS/LIS into unmoved\\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);\\n  while (idx >= 0) {\\n    unmoved.push(idx);\\n    idx = ptrs[idx];\\n  }\\n  // the unmoved item list is built backwards, so fix that\\n  unmoved.reverse();\\n\\n  // the last group is always anchored by the end of the result list, which is\\n  // an id of \\\"null\\\"\\n  unmoved.push(new_results.length);\\n\\n  old_results.forEach(function (doc) {\\n    if (!new_presence_of_id[doc._id])\\n      observer.removed && observer.removed(doc._id);\\n  });\\n\\n  // for each group of things in the new_results that is anchored by an unmoved\\n  // element, iterate through the things before it.\\n  var startOfGroup = 0;\\n  unmoved.forEach(function (endOfGroup) {\\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\\n    for (var i = startOfGroup; i < endOfGroup; i++) {\\n      newDoc = new_results[i];\\n      if (!hasOwn.call(old_index_of_id, newDoc._id)) {\\n        fields = projectionFn(newDoc);\\n        delete fields._id;\\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\\n        observer.added && observer.added(newDoc._id, fields);\\n      } else {\\n        // moved\\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\\n        projectedNew = projectionFn(newDoc);\\n        projectedOld = projectionFn(oldDoc);\\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n        if (!isObjEmpty(fields)) {\\n          observer.changed && observer.changed(newDoc._id, fields);\\n        }\\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\\n      }\\n    }\\n    if (groupId) {\\n      newDoc = new_results[endOfGroup];\\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\\n      projectedNew = projectionFn(newDoc);\\n      projectedOld = projectionFn(oldDoc);\\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\\n      if (!isObjEmpty(fields)) {\\n        observer.changed && observer.changed(newDoc._id, fields);\\n      }\\n    }\\n    startOfGroup = endOfGroup+1;\\n  });\\n\\n\\n};\\n\\n\\n// General helper for diff-ing two objects.\\n// callbacks is an object like so:\\n// { leftOnly: function (key, leftValue) {...},\\n//   rightOnly: function (key, rightValue) {...},\\n//   both: function (key, leftValue, rightValue) {...},\\n// }\\nDiffSequence.diffObjects = function (left, right, callbacks) {\\n  Object.keys(left).forEach(key => {\\n    const leftValue = left[key];\\n    if (hasOwn.call(right, key)) {\\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\\n    } else {\\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\\n    }\\n  });\\n\\n  if (callbacks.rightOnly) {\\n    Object.keys(right).forEach(key => {\\n      const rightValue = right[key];\\n      if (! hasOwn.call(left, key)) {\\n        callbacks.rightOnly(key, rightValue);\\n      }\\n    });\\n  }\\n};\\n\\nDiffSequence.diffMaps = function (left, right, callbacks) {\\n  left.forEach(function (leftValue, key) {\\n    if (right.has(key)){\\n      callbacks.both && callbacks.both(key, leftValue, right.get(key));\\n    } else {\\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\\n    }\\n  });\\n\\n  if (callbacks.rightOnly) {\\n    right.forEach(function (rightValue, key) {\\n      if (!left.has(key)){\\n        callbacks.rightOnly(key, rightValue);\\n      }\\n    });\\n  }\\n};\\n\\n\\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\\n  var fields = {};\\n  DiffSequence.diffObjects(oldDoc, newDoc, {\\n    leftOnly: function (key, value) {\\n      fields[key] = undefined;\\n    },\\n    rightOnly: function (key, value) {\\n      fields[key] = value;\\n    },\\n    both: function (key, leftValue, rightValue) {\\n      if (!EJSON.equals(leftValue, rightValue))\\n        fields[key] = rightValue;\\n    }\\n  });\\n  return fields;\\n};\\n\\nDiffSequence.applyChanges = function (doc, changeFields) {\\n  Object.keys(changeFields).forEach(key => {\\n    const value = changeFields[key];\\n    if (typeof value === \\\"undefined\\\") {\\n      delete doc[key];\\n    } else {\\n      doc[key] = value;\\n    }\\n  });\\n};\\n\\n\"]}","minifier":"terser"}