{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,n=Package.meteor.meteorEnv,r=Package.ejson.EJSON,c=Package.modules.meteorInstall,a=Package[\"babel-runtime\"].meteorBabelHelpers,o=Package.promise.Promise,s,i,l,u=c({node_modules:{meteor:{check:{\"match.js\":function(t,n,c){let a;c.export({check:()=>i,Match:()=>l}),c.link(\"./isPlainObject\",{isPlainObject(e){a=e}},0);const o=new e.EnvironmentVariable,s=Object.prototype.hasOwnProperty;function i(e,t){const n=o.getOrNullIfOutsideFiber();n&&n.checking(e);const r=b(e,t);if(r){const e=new l.Error(r.message);throw r.path&&(e.message+=\" in field \".concat(r.path),e.path=r.path),e}}const l={Optional:function(e){return new u(e)},Maybe:function(e){return new h(e)},OneOf:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return new f(t)},Any:[\"__any__\"],Where:function(e){return new p(e)},ObjectIncluding:function(e){return new g(e)},ObjectWithValues:function(e){return new m(e)},Integer:[\"__integer__\"],Error:e.makeErrorType(\"Match.Error\",function(t){this.message=\"Match error: \".concat(t),this.path=\"\",this.sanitizedError=new e.Error(400,\"Match failed\")}),test:(e,t)=>!b(e,t),_failIfArgumentsAreNotAllChecked(e,t,n,r){const c=new O(n,r),a=o.withValue(c,()=>e.apply(t,n));return c.throwUnlessAllArgumentsHaveBeenChecked(),a}};class u{constructor(e){this.pattern=e}}class h{constructor(e){this.pattern=e}}class f{constructor(e){if(!e||0===e.length)throw new Error(\"Must provide at least one choice to Match.OneOf\");this.choices=e}}class p{constructor(e){this.condition=e}}class g{constructor(e){this.pattern=e}}class m{constructor(e){this.pattern=e}}const y=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null===e)return\"null\";if(t.onlyShowType)return typeof e;if(\"object\"!=typeof e)return r.stringify(e);try{JSON.stringify(e)}catch(t){if(\"TypeError\"===t.name)return typeof e}return r.stringify(e)},d=[[String,\"string\"],[Number,\"number\"],[Boolean,\"boolean\"],[Function,\"function\"],[void 0,\"undefined\"]],b=(e,t)=>{if(t===l.Any)return!1;for(let a=0;a<d.length;++a)if(t===d[a][0])return typeof e!==d[a][1]&&{message:\"Expected \".concat(d[a][1],\", got \").concat(y(e,{onlyShowType:!0})),path:\"\"};if(null===t)return null!==e&&{message:\"Expected null, got \".concat(y(e)),path:\"\"};if(\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t)return e!==t&&{message:\"Expected \".concat(t,\", got \").concat(y(e)),path:\"\"};if(t===l.Integer)return(\"number\"!=typeof e||(0|e)!==e)&&{message:\"Expected Integer, got \".concat(y(e)),path:\"\"};if(t===Object&&(t=l.ObjectIncluding({})),t instanceof Array){if(1!==t.length)return{message:\"Bad pattern: arrays must have one type element \".concat(y(t)),path:\"\"};if(!Array.isArray(e)&&!v(e))return{message:\"Expected array, got \".concat(y(e)),path:\"\"};for(let n=0,r=e.length;n<r;n++){const r=b(e[n],t[0]);if(r)return r.path=k(n,r.path),r}return!1}if(t instanceof p){let n;try{n=t.condition(e)}catch(e){if(!(e instanceof l.Error))throw e;return{message:e.message,path:e.path}}return!n&&{message:\"Failed Match.Where validation\",path:\"\"}}if(t instanceof h?t=l.OneOf(void 0,null,t.pattern):t instanceof u&&(t=l.OneOf(void 0,t.pattern)),t instanceof f){for(let n=0;n<t.choices.length;++n){const r=b(e,t.choices[n]);if(!r)return!1}return{message:\"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",path:\"\"}}if(t instanceof Function)return!(e instanceof t)&&{message:\"Expected \".concat(t.name||\"particular constructor\"),path:\"\"};let n=!1,r;if(t instanceof g&&(n=!0,t=t.pattern),t instanceof m&&(n=!0,r=[t.pattern],t={}),\"object\"!=typeof t)return{message:\"Bad pattern: unknown pattern type\",path:\"\"};if(\"object\"!=typeof e)return{message:\"Expected object, got \".concat(typeof e),path:\"\"};if(null===e)return{message:\"Expected object, got null\",path:\"\"};if(!a(e))return{message:\"Expected plain object\",path:\"\"};const c=Object.create(null),o=Object.create(null);Object.keys(t).forEach(e=>{const n=t[e];n instanceof u||n instanceof h?o[e]=n.pattern:c[e]=n});for(let a in Object(e)){const t=e[a];if(s.call(c,a)){const e=b(t,c[a]);if(e)return e.path=k(a,e.path),e;delete c[a]}else if(s.call(o,a)){const e=b(t,o[a]);if(e)return e.path=k(a,e.path),e}else{if(!n)return{message:\"Unknown key\",path:a};if(r){const e=b(t,r[0]);if(e)return e.path=k(a,e.path),e}}}const i=Object.keys(c);return i.length?{message:\"Missing key '\".concat(i[0],\"'\"),path:\"\"}:void 0};class O{constructor(e,t){this.args=[...e],this.args.reverse(),this.description=t}checking(e){this._checkingOneValue(e)||(Array.isArray(e)||v(e))&&Array.prototype.forEach.call(e,this._checkingOneValue.bind(this))}_checkingOneValue(e){for(let t=0;t<this.args.length;++t)if(e===this.args[t]||Number.isNaN(e)&&Number.isNaN(this.args[t]))return this.args.splice(t,1),!0;return!1}throwUnlessAllArgumentsHaveBeenChecked(){if(this.args.length>0)throw new Error(\"Did not check() all arguments during \".concat(this.description))}}const j=[\"do\",\"if\",\"in\",\"for\",\"let\",\"new\",\"try\",\"var\",\"case\",\"else\",\"enum\",\"eval\",\"false\",\"null\",\"this\",\"true\",\"void\",\"with\",\"break\",\"catch\",\"class\",\"const\",\"super\",\"throw\",\"while\",\"yield\",\"delete\",\"export\",\"import\",\"public\",\"return\",\"static\",\"switch\",\"typeof\",\"default\",\"extends\",\"finally\",\"package\",\"private\",\"continue\",\"debugger\",\"function\",\"arguments\",\"interface\",\"protected\",\"implements\",\"instanceof\"],k=(e,t)=>(\"number\"==typeof e||e.match(/^[0-9]+$/)?e=\"[\".concat(e,\"]\"):(!e.match(/^[a-z_$][0-9a-z_$]*$/i)||j.indexOf(e)>=0)&&(e=JSON.stringify([e])),t&&\"[\"!==t[0]?\"\".concat(e,\".\").concat(t):e+t),w=e=>\"object\"==typeof e&&null!==e,E=e=>w(e)&&\"[object Arguments]\"===Object.prototype.toString.call(e),v=E(function(){return arguments}())?E:e=>w(e)&&\"function\"==typeof e.callee},\"isPlainObject.js\":function(e,t,n){n.export({isPlainObject:()=>l});const r={},c=r.toString,a=Object.prototype.hasOwnProperty,o=a.toString,s=o.call(Object),i=Object.getPrototypeOf,l=e=>{let t,n;return!(!e||\"[object Object]\"!==c.call(e))&&(!(t=i(e))||\"function\"==typeof(n=a.call(t,\"constructor\")&&t.constructor)&&o.call(n)===s)}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/check/match.js\");Package._define(\"check\",u,{check:s,Match:i})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/check/match.js\",\"packages/check/isPlainObject.js\"],\"names\":[\"isPlainObject\",\"module\",\"export\",\"check\",\"Match\",\"link\",\"v\",\"currentArgumentChecker\",\"Meteor\",\"EnvironmentVariable\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"value\",\"pattern\",\"argChecker\",\"getOrNullIfOutsideFiber\",\"checking\",\"result\",\"testSubtree\",\"err\",\"Error\",\"message\",\"path\",\"concat\",\"Optional\",\"Maybe\",\"OneOf\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"Any\",\"Where\",\"condition\",\"ObjectIncluding\",\"ObjectWithValues\",\"Integer\",\"makeErrorType\",\"msg\",\"this\",\"sanitizedError\",\"test\",\"_failIfArgumentsAreNotAllChecked\",\"f\",\"context\",\"description\",\"ArgumentChecker\",\"withValue\",\"apply\",\"throwUnlessAllArgumentsHaveBeenChecked\",\"constructor\",\"choices\",\"stringForErrorMessage\",\"options\",\"undefined\",\"onlyShowType\",\"EJSON\",\"stringify\",\"JSON\",\"stringifyError\",\"name\",\"typeofChecks\",\"String\",\"Number\",\"Boolean\",\"Function\",\"i\",\"isArray\",\"isArguments\",\"_prependPath\",\"unknownKeysAllowed\",\"unknownKeyPattern\",\"requiredPatterns\",\"create\",\"optionalPatterns\",\"keys\",\"forEach\",\"key\",\"subPattern\",\"subValue\",\"call\",\"reverse\",\"_checkingOneValue\",\"bind\",\"isNaN\",\"splice\",\"_jsKeywords\",\"base\",\"match\",\"indexOf\",\"isObject\",\"baseIsArguments\",\"item\",\"toString\",\"callee\",\"class2type\",\"fnToString\",\"ObjectFunctionString\",\"getProto\",\"getPrototypeOf\",\"obj\",\"proto\",\"Ctor\"],\"mappings\":\"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\",\"sourcesContent\":[\"// XXX docs\\nimport { isPlainObject } from './isPlainObject';\\n\\n// Things we explicitly do NOT support:\\n//    - heterogenous arrays\\n\\nconst currentArgumentChecker = new Meteor.EnvironmentVariable;\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n/**\\n * @summary Check that a value matches a [pattern](#matchpatterns).\\n * If the value does not match the pattern, throw a `Match.Error`.\\n *\\n * Particularly useful to assert that arguments to a function have the right\\n * types and structure.\\n * @locus Anywhere\\n * @param {Any} value The value to check\\n * @param {MatchPattern} pattern The pattern to match `value` against\\n */\\nexport function check(value, pattern) {\\n  // Record that check got called, if somebody cared.\\n  //\\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\\n  // from non-Fiber server contexts; the downside is that if you forget to\\n  // bindEnvironment on some random callback in your method/publisher,\\n  // it might not find the argumentChecker and you'll get an error about\\n  // not checking an argument that it looks like you're checking (instead\\n  // of just getting a \\\"Node code must run in a Fiber\\\" error).\\n  const argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\\n  if (argChecker) {\\n    argChecker.checking(value);\\n  }\\n\\n  const result = testSubtree(value, pattern);\\n  if (result) {\\n    const err = new Match.Error(result.message);\\n    if (result.path) {\\n      err.message += ` in field ${result.path}`;\\n      err.path = result.path;\\n    }\\n\\n    throw err;\\n  }\\n};\\n\\n/**\\n * @namespace Match\\n * @summary The namespace for all Match types and methods.\\n */\\nexport const Match = {\\n  Optional: function(pattern) {\\n    return new Optional(pattern);\\n  },\\n\\n  Maybe: function(pattern) {\\n    return new Maybe(pattern);\\n  },\\n\\n  OneOf: function(...args) {\\n    return new OneOf(args);\\n  },\\n\\n  Any: ['__any__'],\\n  Where: function(condition) {\\n    return new Where(condition);\\n  },\\n\\n  ObjectIncluding: function(pattern) {\\n    return new ObjectIncluding(pattern)\\n  },\\n\\n  ObjectWithValues: function(pattern) {\\n    return new ObjectWithValues(pattern);\\n  },\\n\\n  // Matches only signed 32-bit integers\\n  Integer: ['__integer__'],\\n\\n  // XXX matchers should know how to describe themselves for errors\\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\\n    this.message = `Match error: ${msg}`;\\n\\n    // The path of the value that failed to match. Initially empty, this gets\\n    // populated by catching and rethrowing the exception as it goes back up the\\n    // stack.\\n    // E.g.: \\\"vals[3].entity.created\\\"\\n    this.path = '';\\n\\n    // If this gets sent over DDP, don't give full internal details but at least\\n    // provide something better than 500 Internal server error.\\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\\n  }),\\n\\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\\n  // or false (unless an error other than Match.Error was thrown). It does not\\n  // interact with _failIfArgumentsAreNotAllChecked.\\n  // XXX maybe also implement a Match.match which returns more information about\\n  //     failures but without using exception handling or doing what check()\\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\\n\\n  /**\\n   * @summary Returns true if the value matches the pattern.\\n   * @locus Anywhere\\n   * @param {Any} value The value to check\\n   * @param {MatchPattern} pattern The pattern to match `value` against\\n   */\\n  test(value, pattern) {\\n    return !testSubtree(value, pattern);\\n  },\\n\\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\\n  // `args` (either directly or in the first level of an array), throws an error\\n  // (using `description` in the message).\\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\\n    const argChecker = new ArgumentChecker(args, description);\\n    const result = currentArgumentChecker.withValue(\\n      argChecker, \\n      () => f.apply(context, args)\\n    );\\n\\n    // If f didn't itself throw, make sure it checked all of its arguments.\\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\\n    return result;\\n  }\\n};\\n\\nclass Optional {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass Maybe {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass OneOf {\\n  constructor(choices) {\\n    if (!choices || choices.length === 0) {\\n      throw new Error('Must provide at least one choice to Match.OneOf');\\n    }\\n\\n    this.choices = choices;\\n  }\\n}\\n\\nclass Where {\\n  constructor(condition) {\\n    this.condition = condition;\\n  }\\n}\\n\\nclass ObjectIncluding {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass ObjectWithValues {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nconst stringForErrorMessage = (value, options = {}) => {\\n  if ( value === null ) {\\n    return 'null';\\n  }\\n\\n  if ( options.onlyShowType ) {\\n    return typeof value;\\n  }\\n\\n  // Your average non-object things.  Saves from doing the try/catch below for.\\n  if ( typeof value !== 'object' ) {\\n    return EJSON.stringify(value)\\n  }\\n\\n  try {\\n\\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\\n    JSON.stringify(value);\\n  } catch (stringifyError) {\\n    if ( stringifyError.name === 'TypeError' ) {\\n      return typeof value;\\n    }\\n  }\\n\\n  return EJSON.stringify(value);\\n};\\n\\nconst typeofChecks = [\\n  [String, 'string'],\\n  [Number, 'number'],\\n  [Boolean, 'boolean'],\\n\\n  // While we don't allow undefined/function in EJSON, this is good for optional\\n  // arguments with OneOf.\\n  [Function, 'function'],\\n  [undefined, 'undefined'],\\n];\\n\\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\\nconst testSubtree = (value, pattern) => {\\n\\n  // Match anything!\\n  if (pattern === Match.Any) {\\n    return false;\\n  }\\n\\n  // Basic atomic types.\\n  // Do not match boxed objects (e.g. String, Boolean)\\n  for (let i = 0; i < typeofChecks.length; ++i) {\\n    if (pattern === typeofChecks[i][0]) {\\n      if (typeof value === typeofChecks[i][1]) {\\n        return false;\\n      }\\n\\n      return {\\n        message: `Expected ${typeofChecks[i][1]}, got ${stringForErrorMessage(value, { onlyShowType: true })}`,\\n        path: '',\\n      };\\n    }\\n  }\\n\\n  if (pattern === null) {\\n    if (value === null) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected null, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\\n    if (value === pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern}, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Match.Integer is special type encoded with array\\n  if (pattern === Match.Integer) {\\n\\n    // There is no consistent and reliable way to check if variable is a 64-bit\\n    // integer. One of the popular solutions is to get reminder of division by 1\\n    // but this method fails on really large floats with big precision.\\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\\n    // Bitwise operators work consistantly but always cast variable to 32-bit\\n    // signed integer according to JavaScript specs.\\n    if (typeof value === 'number' && (value | 0) === value) {\\n      return false;\\n    }\\n    \\n    return {\\n      message: `Expected Integer, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // 'Object' is shorthand for Match.ObjectIncluding({});\\n  if (pattern === Object) {\\n    pattern = Match.ObjectIncluding({});\\n  }\\n\\n  // Array (checked AFTER Any, which is implemented as an Array).\\n  if (pattern instanceof Array) {\\n    if (pattern.length !== 1) {\\n      return {\\n        message: `Bad pattern: arrays must have one type element ${stringForErrorMessage(pattern)}`,\\n        path: '',\\n      };\\n    }\\n\\n    if (!Array.isArray(value) && !isArguments(value)) {\\n      return {\\n        message: `Expected array, got ${stringForErrorMessage(value)}`,\\n        path: '',\\n      };\\n    }\\n\\n    for (let i = 0, length = value.length; i < length; i++) {\\n      const result = testSubtree(value[i], pattern[0]);\\n      if (result) {\\n        result.path = _prependPath(i, result.path);\\n        return result;\\n      }\\n    }\\n    \\n    return false;\\n  }\\n\\n  // Arbitrary validation checks. The condition can return false or throw a\\n  // Match.Error (ie, it can internally use check()) to fail.\\n  if (pattern instanceof Where) {\\n    let result;\\n    try {\\n      result = pattern.condition(value);\\n    } catch (err) {\\n      if (!(err instanceof Match.Error)) {\\n        throw err;\\n      }\\n      \\n      return {\\n        message: err.message,\\n        path: err.path\\n      };\\n    }\\n\\n    if (result) {\\n      return false;\\n    }\\n\\n    // XXX this error is terrible\\n    return {\\n      message: 'Failed Match.Where validation',\\n      path: '',\\n    };\\n  }\\n\\n  if (pattern instanceof Maybe) {\\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\\n  } else if (pattern instanceof Optional) {\\n    pattern = Match.OneOf(undefined, pattern.pattern);\\n  }\\n\\n  if (pattern instanceof OneOf) {\\n    for (let i = 0; i < pattern.choices.length; ++i) {\\n      const result = testSubtree(value, pattern.choices[i]);\\n      if (!result) {\\n\\n        // No error? Yay, return.\\n        return false;\\n      }\\n\\n      // Match errors just mean try another choice.\\n    }\\n\\n    // XXX this error is terrible\\n    return {\\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\\n      path: '',\\n    };\\n  }\\n\\n  // A function that isn't something we special-case is assumed to be a\\n  // constructor.\\n  if (pattern instanceof Function) {\\n    if (value instanceof pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern.name || 'particular constructor'}`,\\n      path: '',\\n    };\\n  }\\n\\n  let unknownKeysAllowed = false;\\n  let unknownKeyPattern;\\n  if (pattern instanceof ObjectIncluding) {\\n    unknownKeysAllowed = true;\\n    pattern = pattern.pattern;\\n  }\\n\\n  if (pattern instanceof ObjectWithValues) {\\n    unknownKeysAllowed = true;\\n    unknownKeyPattern = [pattern.pattern];\\n    pattern = {};  // no required keys\\n  }\\n\\n  if (typeof pattern !== 'object') {\\n    return {\\n      message: 'Bad pattern: unknown pattern type',\\n      path: '',\\n    };\\n  }\\n\\n  // An object, with required and optional keys. Note that this does NOT do\\n  // structural matches against objects of special types that happen to match\\n  // the pattern: this really needs to be a plain old {Object}!\\n  if (typeof value !== 'object') {\\n    return {\\n      message: `Expected object, got ${typeof value}`,\\n      path: '',\\n    };\\n  }\\n\\n  if (value === null) {\\n    return {\\n      message: `Expected object, got null`,\\n      path: '',\\n    };\\n  }\\n\\n  if (! isPlainObject(value)) {\\n    return {\\n      message: `Expected plain object`,\\n      path: '',\\n    };\\n  }\\n\\n  const requiredPatterns = Object.create(null);\\n  const optionalPatterns = Object.create(null);\\n\\n  Object.keys(pattern).forEach(key => {\\n    const subPattern = pattern[key];\\n    if (subPattern instanceof Optional ||\\n        subPattern instanceof Maybe) {\\n      optionalPatterns[key] = subPattern.pattern;\\n    } else {\\n      requiredPatterns[key] = subPattern;\\n    }\\n  });\\n\\n  for (let key in Object(value)) {\\n    const subValue = value[key];\\n    if (hasOwn.call(requiredPatterns, key)) {\\n      const result = testSubtree(subValue, requiredPatterns[key]);\\n      if (result) {\\n        result.path = _prependPath(key, result.path);\\n        return result;\\n      }\\n\\n      delete requiredPatterns[key];\\n    } else if (hasOwn.call(optionalPatterns, key)) {\\n      const result = testSubtree(subValue, optionalPatterns[key]);\\n      if (result) {\\n        result.path = _prependPath(key, result.path);\\n        return result;\\n      }\\n\\n    } else {\\n      if (!unknownKeysAllowed) {\\n        return {\\n          message: 'Unknown key',\\n          path: key,\\n        };\\n      }\\n\\n      if (unknownKeyPattern) {\\n        const result = testSubtree(subValue, unknownKeyPattern[0]);\\n        if (result) {\\n          result.path = _prependPath(key, result.path);\\n          return result;\\n        }\\n      }\\n    }\\n  }\\n\\n  const keys = Object.keys(requiredPatterns);\\n  if (keys.length) {\\n    return {\\n      message: `Missing key '${keys[0]}'`,\\n      path: '',\\n    };\\n  }\\n};\\n\\nclass ArgumentChecker {\\n  constructor (args, description) {\\n\\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\\n    // against its contents.)\\n    this.args = [...args];\\n\\n    // Since the common case will be to check arguments in order, and we splice\\n    // out arguments when we check them, make it so we splice out from the end\\n    // rather than the beginning.\\n    this.args.reverse();\\n    this.description = description;\\n  }\\n\\n  checking(value) {\\n    if (this._checkingOneValue(value)) {\\n      return;\\n    }\\n\\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\\n    // or check([foo, bar], [String]) to count... but only if value wasn't\\n    // itself an argument.\\n    if (Array.isArray(value) || isArguments(value)) {\\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\\n    }\\n  }\\n\\n  _checkingOneValue(value) {\\n    for (let i = 0; i < this.args.length; ++i) {\\n\\n      // Is this value one of the arguments? (This can have a false positive if\\n      // the argument is an interned primitive, but it's still a good enough\\n      // check.)\\n      // (NaN is not === to itself, so we have to check specially.)\\n      if (value === this.args[i] ||\\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\\n        this.args.splice(i, 1);\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  throwUnlessAllArgumentsHaveBeenChecked() {\\n    if (this.args.length > 0)\\n      throw new Error(`Did not check() all arguments during ${this.description}`);\\n  }\\n}\\n\\nconst _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case',\\n  'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with',\\n  'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield',\\n  'delete', 'export', 'import', 'public', 'return', 'static', 'switch',\\n  'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue',\\n  'debugger', 'function', 'arguments', 'interface', 'protected', 'implements',\\n  'instanceof'];\\n\\n// Assumes the base of path is already escaped properly\\n// returns key + base\\nconst _prependPath = (key, base) => {\\n  if ((typeof key) === 'number' || key.match(/^[0-9]+$/)) {\\n    key = `[${key}]`;\\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) ||\\n             _jsKeywords.indexOf(key) >= 0) {\\n    key = JSON.stringify([key]);\\n  }\\n\\n  if (base && base[0] !== '[') {\\n    return `${key}.${base}`;\\n  }\\n\\n  return key + base;\\n}\\n\\nconst isObject = value => typeof value === 'object' && value !== null;\\n\\nconst baseIsArguments = item =>\\n  isObject(item) &&\\n  Object.prototype.toString.call(item) === '[object Arguments]';\\n\\nconst isArguments = baseIsArguments(function() { return arguments; }()) ?\\n  baseIsArguments :\\n  value => isObject(value) && typeof value.callee === 'function';\\n\",\"// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\\n\\nconst class2type = {};\\n\\nconst toString = class2type.toString;\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nconst fnToString = hasOwn.toString;\\n\\nconst ObjectFunctionString = fnToString.call(Object);\\n\\nconst getProto = Object.getPrototypeOf;\\n\\nexport const isPlainObject = obj => {\\n  let proto;\\n  let Ctor;\\n\\n  // Detect obvious negatives\\n  // Use toString instead of jQuery.type to catch host objects\\n  if (!obj || toString.call(obj) !== '[object Object]') {\\n    return false;\\n  }\\n\\n  proto = getProto(obj);\\n\\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\\n  if (!proto) {\\n    return true;\\n  }\\n\\n  // Objects with prototype are plain iff they were constructed by a global Object function\\n  Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\\n  return typeof Ctor === 'function' && \\n    fnToString.call(Ctor) === ObjectFunctionString;\\n};\\n\"]}","minifier":"terser"}