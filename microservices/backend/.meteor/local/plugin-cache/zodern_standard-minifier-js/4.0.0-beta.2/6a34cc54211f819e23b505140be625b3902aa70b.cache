{"code":"!function(){var e=Package.meteor.Meteor,s=Package.meteor.global,o=Package.meteor.meteorEnv,a=Package[\"reactive-dict\"].ReactiveDict,t=Package.ejson.EJSON,i=Package.modules.meteorInstall,n=Package[\"babel-runtime\"].meteorBabelHelpers,c=Package.promise.Promise,r,m,l=i({node_modules:{meteor:{session:{\"session.js\":function(e,s,o){let a;o.export({Session:()=>t}),o.link(\"meteor/reactive-dict\",{ReactiveDict(e){a=e}},0);const t=new a(\"session\")}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/session/session.js\");Package._define(\"session\",l,{Session:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/session/session.js\"],\"names\":[\"ReactiveDict\",\"module\",\"export\",\"Session\",\"link\",\"v\"],\"mappings\":\"sUAAqC,IAAIA,EAAzCC,EAAOC,QAAQC,QAAQ,IAAIA,IAA2BF,EAAOG,KAAK,wBAAwBJ,aAAaK,GAAGL,EAAaK,IAAI,GAEpH,MAAMF,EAAU,IAAIH,EAAa\",\"sourcesContent\":[\"import { ReactiveDict } from 'meteor/reactive-dict';\\n\\nexport const Session = new ReactiveDict('session');\\n\\n// Documentation here is really awkward because the methods are defined\\n// elsewhere\\n\\n/**\\n * @memberOf Session\\n * @method set\\n * @summary Set a variable in the session. Notify any listeners that the value\\n * has changed (eg: redraw templates, and rerun any\\n * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n * [`Session.get`](#session_get) on this `key`.)\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method setDefault\\n * @summary Set a variable in the session if it hasn't been set before.\\n * Otherwise works exactly the same as [`Session.set`](#session_set).\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method get\\n * @summary Get the value of a session variable. If inside a [reactive\\n * computation](#reactivity), invalidate the computation the next time the\\n * value of the variable is changed by [`Session.set`](#session_set). This\\n * returns a clone of the session value, so if it's an object or an array,\\n * mutating the returned value has no effect on the value stored in the\\n * session.\\n * @locus Client\\n * @param {String} key The name of the session variable to return\\n */\\n\\n/**\\n * @memberOf Session\\n * @method equals\\n * @summary Test if a session variable is equal to a value. If inside a\\n * [reactive computation](#reactivity), invalidate the computation the next\\n * time the variable changes to or from the value.\\n * @locus Client\\n * @param {String} key The name of the session variable to test\\n * @param {String | Number | Boolean | null | undefined} value The value to\\n * test against\\n */\\n\"]}","minifier":"terser"}