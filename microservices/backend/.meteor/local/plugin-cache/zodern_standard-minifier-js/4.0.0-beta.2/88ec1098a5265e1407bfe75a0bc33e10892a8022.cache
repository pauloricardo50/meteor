{"code":"!function(){var e=Package.meteor.Meteor,o=Package.meteor.global,t=Package.meteor.meteorEnv,a=Package.modules.meteorInstall,n=Package[\"babel-runtime\"].meteorBabelHelpers,r=Package.promise.Promise,i,l,d=a({node_modules:{meteor:{reload:{\"reload.js\":function(o,t,a){a.export({Reload:()=>n});const n={};var r=\"Meteor_Reload\",i={},l,d=null;try{(d=window.sessionStorage)?(d.setItem(\"__dummy__\",\"1\"),d.removeItem(\"__dummy__\")):d=null}catch(e){d=null}n._getData=function(){return d&&d.getItem(r)},d&&(l=n._getData(),d.removeItem(r)),l||(l=\"{}\");var s={};try{\"object\"!=typeof(s=JSON.parse(l))&&(e._debug(\"Got bad data on reload. Ignoring.\"),s={})}catch(o){e._debug(\"Got invalid JSON on reload. Ignoring.\")}s.reload&&\"object\"==typeof s.data&&(i=s.data);var c=[];n._onMigrate=function(e,o){o||(o=e,e=void 0),c.push({name:e,callback:o})},n._migrationData=function(e){return i[e]};var u=function(e,o){e=e||function(){},o=o||{};for(var t={},a=c.slice(0),n=!0;a.length;){var r=a.shift(),i=r.callback(e,o);i[0]||(n=!1),i.length>1&&r.name&&(t[r.name]=i[1])}return n||o.immediateMigration?t:null};n._migrate=function(o,t){var a=u(o,t);if(null===a)return!1;try{var n=JSON.stringify({data:a,reload:!0})}catch(o){throw e._debug(\"Couldn't serialize data for migration\",a),o}if(d)try{d.setItem(r,n)}catch(o){e._debug(\"Couldn't save data for migration to sessionStorage\",o)}else e._debug(\"Browser does not support sessionStorage. Not saving migration state.\");return!0},n._withFreshProvidersForTest=function(e){var o=c.slice(0);c=[];try{e()}finally{c=o}};var m=!1;n._reload=function(o){function t(){setTimeout(r,1)}function a(){window.location.hash||window.location.href.endsWith(\"#\")?window.location.reload():window.location.replace(window.location.href)}function r(){n._migrate(t,o)&&(e.isCordova?WebAppLocalServer.switchToPendingVersion(()=>{a()}):a())}o=o||{},m||(m=!0,t())}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/reload/reload.js\");Package._define(\"reload\",d,{Reload:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/reload/reload.js\"],\"names\":[\"module\",\"export\",\"Reload\",\"KEY_NAME\",\"old_data\",\"old_json\",\"safeSessionStorage\",\"window\",\"sessionStorage\",\"setItem\",\"removeItem\",\"e\",\"_getData\",\"getItem\",\"old_parsed\",\"JSON\",\"parse\",\"Meteor\",\"_debug\",\"err\",\"reload\",\"data\",\"providers\",\"_onMigrate\",\"name\",\"callback\",\"undefined\",\"push\",\"_migrationData\",\"pollProviders\",\"tryReload\",\"options\",\"migrationData\",\"remaining\",\"slice\",\"allReady\",\"length\",\"p\",\"shift\",\"status\",\"immediateMigration\",\"_migrate\",\"json\",\"stringify\",\"_withFreshProvidersForTest\",\"f\",\"originalProviders\",\"reloading\",\"_reload\",\"setTimeout\",\"forceBrowserReload\",\"location\",\"hash\",\"href\",\"endsWith\",\"replace\",\"isCordova\",\"WebAppLocalServer\",\"switchToPendingVersion\"],\"mappings\":\"sQAAAA,EAAOC,QAAQC,OAAO,IAAIA,IAiCnB,MAAMA,KAEb,IAAIC,EAAW,gBAEXC,KAEAC,EAGAC,EAAqB,KACzB,KASEA,EAAqBC,OAAOC,iBAI1BF,EAAmBG,QAAQ,YAAa,KACxCH,EAAmBI,WAAW,cAG9BJ,EAAqB,KAEvB,MAAOK,GAEPL,EAAqB,KAIvBJ,EAAOU,SAAW,WAChB,OAAON,GAAsBA,EAAmBO,QAAQV,IAGtDG,IACFD,EAAWH,EAAOU,WAClBN,EAAmBI,WAAWP,IAO3BE,IAAUA,EAAW,MAC1B,IAAIS,KACJ,IAE4B,iBAD1BA,EAAaC,KAAKC,MAAMX,MAEtBY,EAAOC,OAAO,qCACdJ,MAEF,MAAOK,GACPF,EAAOC,OAAO,yCAGZJ,EAAWM,QAAqC,iBAApBN,EAAWO,OAEzCjB,EAAWU,EAAWO,MAIxB,IAAIC,KAsBJpB,EAAOqB,WAAa,SAAUC,EAAMC,GAC7BA,IAEHA,EAAWD,EACXA,OAAOE,GAETJ,EAAUK,MAAOH,KAAMA,EAAMC,SAAUA,KAMzCvB,EAAO0B,eAAiB,SAAUJ,GAChC,OAAOpB,EAASoB,IAIlB,IAAIK,EAAgB,SAAUC,EAAWC,GACvCD,EAAYA,GAAa,aACzBC,EAAUA,MAKV,IAHA,IAAIC,KACAC,EAAYX,EAAUY,MAAM,GAC5BC,GAAW,EACRF,EAAUG,QAAQ,CACvB,IAAIC,EAAIJ,EAAUK,QACdC,EAASF,EAAEZ,SAASK,EAAWC,GAC9BQ,EAAO,KACVJ,GAAW,GACTI,EAAOH,OAAS,GAAKC,EAAEb,OACzBQ,EAAcK,EAAEb,MAAQe,EAAO,IAEnC,OAAIJ,GAAYJ,EAAQS,mBACfR,EAEA,MAMX9B,EAAOuC,SAAW,SAAUX,EAAWC,GAGrC,IAAIC,EAAgBH,EAAcC,EAAWC,GAC7C,GAAsB,OAAlBC,EACF,OAAO,EAET,IAEE,IAAIU,EAAO3B,KAAK4B,WACdtB,KAAMW,EAAeZ,QAAQ,IAE/B,MAAOD,GAEP,MADAF,EAAOC,OAAO,wCAAyCc,GACjDb,EAGR,GAAIb,EACF,IACEA,EAAmBG,QAAQN,EAAUuC,GACrC,MAAOvB,GAEPF,EAAOC,OAAO,qDAAsDC,QAGtEF,EAAOC,OAAO,wEAGhB,OAAO,GAIThB,EAAO0C,2BAA6B,SAAUC,GAC5C,IAAIC,EAAoBxB,EAAUY,MAAM,GACxCZ,KACA,IACEuB,IADF,QAGEvB,EAAYwB,IAUhB,IAAIC,GAAY,EAChB7C,EAAO8C,QAAU,SAAUjB,GAOzB,SAASD,IACPmB,WAAW7B,EAAQ,GAGrB,SAAS8B,IAMH3C,OAAO4C,SAASC,MAAQ7C,OAAO4C,SAASE,KAAKC,SAAS,KACxD/C,OAAO4C,SAAS/B,SAEhBb,OAAO4C,SAASI,QAAQhD,OAAO4C,SAASE,MAI5C,SAASjC,IACHlB,EAAOuC,SAASX,EAAWC,KACzBd,EAAOuC,UACTC,kBAAkBC,uBAAuB,KACvCR,MAGFA,KA9BNnB,EAAUA,MAENgB,IAEJA,GAAY,EA+BZjB\",\"sourcesContent\":[\"/**\\n * This code does _NOT_ support hot (session-restoring) reloads on\\n * IE6,7. It only works on browsers with sessionStorage support.\\n *\\n * There are a couple approaches to add IE6,7 support:\\n *\\n * - use IE's \\\"userData\\\" mechanism in combination with window.name.\\n * This mostly works, however the problem is that it can not get to the\\n * data until after DOMReady. This is a problem for us since this API\\n * relies on the data being ready before API users run. We could\\n * refactor using Meteor.startup in all API users, but that might slow\\n * page loads as we couldn't start the stream until after DOMReady.\\n * Here are some resources on this approach:\\n * https://github.com/hugeinc/USTORE.js\\n * http://thudjs.tumblr.com/post/419577524/localstorage-userdata\\n * http://www.javascriptkit.com/javatutors/domstorage2.shtml\\n *\\n * - POST the data to the server, and have the server send it back on\\n * page load. This is nice because it sidesteps all the local storage\\n * compatibility issues, however it is kinda tricky. We can use a unique\\n * token in the URL, then get rid of it with HTML5 pushstate, but that\\n * only works on pushstate browsers.\\n *\\n * This will all need to be reworked entirely when we add server-side\\n * HTML rendering. In that case, the server will need to have access to\\n * the client's session to render properly.\\n */\\n\\n// XXX when making this API public, also expose a flag for the app\\n// developer to know whether a hot code push is happening. This is\\n// useful for apps using `window.onbeforeunload`. See\\n// https://github.com/meteor/meteor/pull/657\\n\\nexport const Reload = {};\\n\\nvar KEY_NAME = 'Meteor_Reload';\\n\\nvar old_data = {};\\n// read in old data at startup.\\nvar old_json;\\n\\n// This logic for sessionStorage detection is based on browserstate/history.js\\nvar safeSessionStorage = null;\\ntry {\\n  // This throws a SecurityError on Chrome if cookies & localStorage are\\n  // explicitly disabled\\n  //\\n  // On Firefox with dom.storage.enabled set to false, sessionStorage is null\\n  //\\n  // We can't even do (typeof sessionStorage) on Chrome, it throws.  So we rely\\n  // on the throw if sessionStorage == null; the alternative is browser\\n  // detection, but this seems better.\\n  safeSessionStorage = window.sessionStorage;\\n\\n  // Check we can actually use it\\n  if (safeSessionStorage) {\\n    safeSessionStorage.setItem('__dummy__', '1');\\n    safeSessionStorage.removeItem('__dummy__');\\n  } else {\\n    // Be consistently null, for safety\\n    safeSessionStorage = null;\\n  }\\n} catch (e) {\\n  // Expected on chrome with strict security, or if sessionStorage not supported\\n  safeSessionStorage = null;\\n}\\n\\n// Exported for test.\\nReload._getData = function () {\\n  return safeSessionStorage && safeSessionStorage.getItem(KEY_NAME);\\n};\\n\\nif (safeSessionStorage) {\\n  old_json = Reload._getData();\\n  safeSessionStorage.removeItem(KEY_NAME);\\n} else {\\n  // Unsupported browser (IE 6,7) or locked down security settings.\\n  // No session resumption.\\n  // Meteor._debug(\\\"XXX UNSUPPORTED BROWSER/SETTINGS\\\");\\n}\\n\\nif (!old_json) old_json = '{}';\\nvar old_parsed = {};\\ntry {\\n  old_parsed = JSON.parse(old_json);\\n  if (typeof old_parsed !== \\\"object\\\") {\\n    Meteor._debug(\\\"Got bad data on reload. Ignoring.\\\");\\n    old_parsed = {};\\n  }\\n} catch (err) {\\n  Meteor._debug(\\\"Got invalid JSON on reload. Ignoring.\\\");\\n}\\n\\nif (old_parsed.reload && typeof old_parsed.data === \\\"object\\\") {\\n  // Meteor._debug(\\\"Restoring reload data.\\\");\\n  old_data = old_parsed.data;\\n}\\n\\n\\nvar providers = [];\\n\\n////////// External API //////////\\n\\n// Packages that support migration should register themselves by calling\\n// this function. When it's time to migrate, callback will be called\\n// with one argument, the \\\"retry function,\\\" and an optional 'option'\\n// argument (containing a key 'immediateMigration'). If the package\\n// is ready to migrate, it should return [true, data], where data is\\n// its migration data, an arbitrary JSON value (or [true] if it has\\n// no migration data this time). If the package needs more time\\n// before it is ready to migrate, it should return false. Then, once\\n// it is ready to migrating again, it should call the retry\\n// function. The retry function will return immediately, but will\\n// schedule the migration to be retried, meaning that every package\\n// will be polled once again for its migration data. If they are all\\n// ready this time, then the migration will happen. name must be set if there\\n// is migration data. If 'immediateMigration' is set in the options\\n// argument, then it doesn't matter whether the package is ready to\\n// migrate or not; the reload will happen immediately without waiting\\n// (used for OAuth redirect login).\\n//\\nReload._onMigrate = function (name, callback) {\\n  if (!callback) {\\n    // name not provided, so first arg is callback.\\n    callback = name;\\n    name = undefined;\\n  }\\n  providers.push({ name: name, callback: callback });\\n};\\n\\n// Called by packages when they start up.\\n// Returns the object that was saved, or undefined if none saved.\\n//\\nReload._migrationData = function (name) {\\n  return old_data[name];\\n};\\n\\n// Options are the same as for `Reload._migrate`.\\nvar pollProviders = function (tryReload, options) {\\n  tryReload = tryReload || function () {};\\n  options = options || {};\\n\\n  var migrationData = {};\\n  var remaining = providers.slice(0);\\n  var allReady = true;\\n  while (remaining.length) {\\n    var p = remaining.shift();\\n    var status = p.callback(tryReload, options);\\n    if (!status[0])\\n      allReady = false;\\n    if (status.length > 1 && p.name)\\n      migrationData[p.name] = status[1];\\n  };\\n  if (allReady || options.immediateMigration)\\n    return migrationData;\\n  else\\n    return null;\\n};\\n\\n// Options are:\\n//  - immediateMigration: true if the page will be reloaded immediately\\n//    regardless of whether packages report that they are ready or not.\\nReload._migrate = function (tryReload, options) {\\n  // Make sure each package is ready to go, and collect their\\n  // migration data\\n  var migrationData = pollProviders(tryReload, options);\\n  if (migrationData === null)\\n    return false; // not ready yet..\\n\\n  try {\\n    // Persist the migration data\\n    var json = JSON.stringify({\\n      data: migrationData, reload: true\\n    });\\n  } catch (err) {\\n    Meteor._debug(\\\"Couldn't serialize data for migration\\\", migrationData);\\n    throw err;\\n  }\\n\\n  if (safeSessionStorage) {\\n    try {\\n      safeSessionStorage.setItem(KEY_NAME, json);\\n    } catch (err) {\\n      // We should have already checked this, but just log - don't throw\\n      Meteor._debug(\\\"Couldn't save data for migration to sessionStorage\\\", err);\\n    }\\n  } else {\\n    Meteor._debug(\\\"Browser does not support sessionStorage. Not saving migration state.\\\");\\n  }\\n\\n  return true;\\n};\\n\\n// Allows tests to isolate the list of providers.\\nReload._withFreshProvidersForTest = function (f) {\\n  var originalProviders = providers.slice(0);\\n  providers = [];\\n  try {\\n    f();\\n  } finally {\\n    providers = originalProviders;\\n  }\\n};\\n\\n// Migrating reload: reload this page (presumably to pick up a new\\n// version of the code or assets), but save the program state and\\n// migrate it over. This function returns immediately. The reload\\n// will happen at some point in the future once all of the packages\\n// are ready to migrate.\\n//\\nvar reloading = false;\\nReload._reload = function (options) {\\n  options = options || {};\\n\\n  if (reloading)\\n    return;\\n  reloading = true;\\n\\n  function tryReload() {\\n    setTimeout(reload, 1);\\n  }\\n\\n  function forceBrowserReload() {\\n    // We'd like to make the browser reload the page using location.replace()\\n    // instead of location.reload(), because this avoids validating assets\\n    // with the server if we still have a valid cached copy. This doesn't work\\n    // when the location contains a hash however, because that wouldn't reload\\n    // the page and just scroll to the hash location instead.\\n    if (window.location.hash || window.location.href.endsWith(\\\"#\\\")) {\\n      window.location.reload();\\n    } else {\\n      window.location.replace(window.location.href);\\n    }\\n  }\\n\\n  function reload() {\\n    if (Reload._migrate(tryReload, options)) {\\n      if (Meteor.isCordova) {\\n        WebAppLocalServer.switchToPendingVersion(() => {\\n          forceBrowserReload();\\n        });\\n      } else {\\n        forceBrowserReload();\\n      }\\n    }\\n  }\\n\\n  tryReload();\\n};\\n\"]}","minifier":"terser"}