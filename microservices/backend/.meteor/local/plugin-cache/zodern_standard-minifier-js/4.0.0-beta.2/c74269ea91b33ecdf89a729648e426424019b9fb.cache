{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,r=Package.meteor.meteorEnv,n=Package.tracker.Tracker,s=Package.tracker.Deps,o=Package.retry.Retry,a=Package[\"ddp-client\"].DDP,i=Package.modules.meteorInstall,l=Package[\"babel-runtime\"].meteorBabelHelpers,c=Package.promise.Promise,u,d,h=i({node_modules:{meteor:{autoupdate:{\"autoupdate_client.js\":function(t,r,n){let s;n.export({Autoupdate:()=>u}),n.link(\"./client_versions.js\",{ClientVersions(e){s=e}},0);const i=e.isCordova?\"web.cordova\":e.isModern?\"web.browser\":\"web.browser.legacy\",l=((__meteor_runtime_config__.autoupdate||{}).versions||{})[i]||{version:\"unknown\",versionRefreshable:\"unknown\",versionNonRefreshable:\"unknown\",assets:[]},u={},d=a.connect(__meteor_runtime_config__.ROOT_URL),h=u._clientVersions=new s;d.registerStore(\"meteor_autoupdate_clientVersions\",h.createStore()),u.newClientAvailable=function(){return h.newClientAvailable(i,[\"versionRefreshable\",\"versionNonRefreshable\"],l)};let _=!1;const b=new o({minCount:0,baseTimeout:3e4});let f=0;u._retrySubscription=(()=>{d.subscribe(\"meteor_autoupdate_clientVersions\",{onError(t){e._debug(\"autoupdate subscription failed\",t),f++,b.retryLater(f,()=>{u._retrySubscription()})},onReady(){const t=c.resolve();function r(e){t.then(()=>s(e))}const n=h.watch(r);function s(t){if(t._id===i){if(t.versionNonRefreshable!==l.versionNonRefreshable)return n&&n(),void(Package.reload&&Package.reload.Reload._reload());if(t.versionRefreshable!==l.versionRefreshable){l.versionRefreshable=t.versionRefreshable;const n=t.assets||[],o=[];function r(t,r){let n;if(t.onload=function(){_=!0,n||(n=!0,r())},!_)var s=e.setInterval(()=>{t.sheet&&(n||(n=!0,r()),e.clearInterval(s))},50)}Array.prototype.forEach.call(document.getElementsByTagName(\"link\"),e=>{\"__meteor-css__\"===e.className&&o.push(e)});let a=n.length;function s(){o.length>0&&--a<1&&o.splice(0).forEach(e=>{e.parentNode.removeChild(e)})}n.length>0?n.forEach(t=>{const n=document.createElement(\"link\");n.setAttribute(\"rel\",\"stylesheet\"),n.setAttribute(\"type\",\"text/css\"),n.setAttribute(\"class\",\"__meteor-css__\"),n.setAttribute(\"href\",t.url),r(n,()=>{e.setTimeout(s,200)});const o=document.getElementsByTagName(\"head\").item(0);o.appendChild(n)}):s()}}}}})}),u._retrySubscription()},\"client_versions.js\":function(e,t,r){var n,s=e(\"@babel/runtime/helpers/interopRequireDefault\")(e(\"@babel/runtime/helpers/objectSpread\"));let o;r.export({ClientVersions:()=>a}),r.link(\"meteor/tracker\",{Tracker(e){o=e}},0);class a{constructor(){this._versions=new Map,this._watchCallbacks=new Set}createStore(){return{update:e=>{let{id:t,msg:r,fields:n}=e;\"added\"!==r&&\"changed\"!==r||this.set(t,n)}}}hasVersions(){return this._versions.size>0}get(e){return this._versions.get(e)}set(e,t){let r=this._versions.get(e),n=!1;r?Object.assign(r,t):(r=(0,s.default)({_id:e},t),n=!0,this._versions.set(e,r)),this._watchCallbacks.forEach(e=>{let{fn:t,filter:s}=e;s&&s!==r._id||t(r,n)})}watch(e){let{skipInitial:t,filter:r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t){const t=c.resolve();this._versions.forEach(n=>{r&&r!==n._id||t.then(()=>e(n,!0))})}const n={fn:e,filter:r};return this._watchCallbacks.add(n),()=>this._watchCallbacks.delete(n)}newClientAvailable(e,t,r){function n(n){return n._id===e&&t.some(e=>n[e]!==r[e])}const s=new o.Dependency,a=this.get(e);s.depend();const i=this.watch(e=>{n(e)&&(s.changed(),i())},{skipInitial:!0});return!!a&&n(a)}}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/autoupdate/autoupdate_client.js\");Package._define(\"autoupdate\",h,{Autoupdate:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/autoupdate/autoupdate_client.js\",\"packages/autoupdate/client_versions.js\"],\"names\":[\"ClientVersions\",\"module\",\"export\",\"Autoupdate\",\"link\",\"v\",\"clientArch\",\"Meteor\",\"isCordova\",\"isModern\",\"autoupdateVersions\",\"__meteor_runtime_config__\",\"autoupdate\",\"versions\",\"version\",\"versionRefreshable\",\"versionNonRefreshable\",\"assets\",\"connection\",\"DDP\",\"connect\",\"ROOT_URL\",\"clientVersions\",\"_clientVersions\",\"registerStore\",\"createStore\",\"newClientAvailable\",\"knownToSupportCssOnLoad\",\"retry\",\"Retry\",\"minCount\",\"baseTimeout\",\"failures\",\"_retrySubscription\",\"subscribe\",\"onError\",\"error\",\"_debug\",\"retryLater\",\"onReady\",\"resolved\",\"Promise\",\"resolve\",\"check\",\"doc\",\"then\",\"checkNewVersionDocument\",\"stop\",\"watch\",\"_id\",\"Package\",\"reload\",\"Reload\",\"_reload\",\"newCss\",\"oldLinks\",\"waitUntilCssLoads\",\"callback\",\"called\",\"onload\",\"id\",\"setInterval\",\"sheet\",\"clearInterval\",\"Array\",\"prototype\",\"forEach\",\"call\",\"document\",\"getElementsByTagName\",\"className\",\"push\",\"newLinksLeftToLoad\",\"length\",\"removeOldLinks\",\"splice\",\"parentNode\",\"removeChild\",\"css\",\"newLink\",\"createElement\",\"setAttribute\",\"url\",\"setTimeout\",\"head\",\"item\",\"appendChild\",\"Tracker\",\"constructor\",\"this\",\"_versions\",\"Map\",\"_watchCallbacks\",\"Set\",\"update\",\"_ref\",\"msg\",\"fields\",\"set\",\"hasVersions\",\"size\",\"get\",\"isNew\",\"Object\",\"assign\",\"_objectSpread2\",\"default\",\"_ref2\",\"fn\",\"filter\",\"skipInitial\",\"arguments\",\"undefined\",\"add\",\"delete\",\"currentVersion\",\"isNewVersion\",\"some\",\"field\",\"dependency\",\"Dependency\",\"depend\",\"changed\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Subscribe to the `meteor_autoupdate_clientVersions` collection,\\n// which contains the set of acceptable client versions.\\n//\\n// A \\\"hard code push\\\" occurs when the running client version is not in\\n// the set of acceptable client versions (or the server updates the\\n// collection, there is a published client version marked `current` and\\n// the running client version is no longer in the set).\\n//\\n// When the `reload` package is loaded, a hard code push causes\\n// the browser to reload, so that it will load the latest client\\n// version from the server.\\n//\\n// A \\\"soft code push\\\" represents the situation when the running client\\n// version is in the set of acceptable versions, but there is a newer\\n// version available on the server.\\n//\\n// `Autoupdate.newClientAvailable` is a reactive data source which\\n// becomes `true` if there is a new version of the client is available on\\n// the server.\\n//\\n// This package doesn't implement a soft code reload process itself,\\n// but `newClientAvailable` could be used for example to display a\\n// \\\"click to reload\\\" link to the user.\\n\\n// The client version of the client code currently running in the\\n// browser.\\n\\nimport { ClientVersions } from './client_versions.js';\\n\\nconst clientArch = Meteor.isCordova\\n  ? 'web.cordova'\\n  : Meteor.isModern\\n    ? 'web.browser'\\n    : 'web.browser.legacy';\\n\\nconst autoupdateVersions = ((__meteor_runtime_config__.autoupdate || {})\\n  .versions || {})[clientArch] || {\\n  version: 'unknown',\\n  versionRefreshable: 'unknown',\\n  versionNonRefreshable: 'unknown',\\n  assets: [],\\n};\\n\\nexport const Autoupdate = {};\\nconst connection = DDP.connect(__meteor_runtime_config__.ROOT_URL);\\n\\n// Stores acceptable client versions.\\nconst clientVersions = (Autoupdate._clientVersions = new ClientVersions()); // Used by a self-test.\\n\\nconnection.registerStore(\\n  'meteor_autoupdate_clientVersions',\\n  clientVersions.createStore(),\\n);\\n\\nAutoupdate.newClientAvailable = function () {\\n  return clientVersions.newClientAvailable(\\n    clientArch,\\n    ['versionRefreshable', 'versionNonRefreshable'],\\n    autoupdateVersions,\\n  );\\n};\\n\\n// Set to true if the link.onload callback ever fires for any <link> node.\\nlet knownToSupportCssOnLoad = false;\\n\\nconst retry = new Retry({\\n  // Unlike the stream reconnect use of Retry, which we want to be instant\\n  // in normal operation, this is a wacky failure. We don't want to retry\\n  // right away, we can start slowly.\\n  //\\n  // A better way than timeconstants here might be to use the knowledge\\n  // of when we reconnect to help trigger these retries. Typically, the\\n  // server fixing code will result in a restart and reconnect, but\\n  // potentially the subscription could have a transient error.\\n  minCount: 0, // don't do any immediate retries\\n  baseTimeout: 30 * 1000, // start with 30s\\n});\\n\\nlet failures = 0;\\n\\nAutoupdate._retrySubscription = () => {\\n  connection.subscribe('meteor_autoupdate_clientVersions', {\\n    onError(error) {\\n      Meteor._debug('autoupdate subscription failed', error);\\n      failures++;\\n      retry.retryLater(failures, () => {\\n        // Just retry making the subscription, don't reload the whole\\n        // page. While reloading would catch more cases (for example,\\n        // the server went back a version and is now doing old-style hot\\n        // code push), it would also be more prone to reload loops,\\n        // which look really bad to the user. Just retrying the\\n        // subscription over DDP means it is at least possible to fix by\\n        // updating the server.\\n        Autoupdate._retrySubscription();\\n      });\\n    },\\n\\n    onReady() {\\n      // Call checkNewVersionDocument with a slight delay, so that the\\n      // const handle declaration is guaranteed to be initialized, even if\\n      // the added or changed callbacks are called synchronously.\\n      const resolved = Promise.resolve();\\n      function check(doc) {\\n        resolved.then(() => checkNewVersionDocument(doc));\\n      }\\n\\n      const stop = clientVersions.watch(check);\\n\\n      function checkNewVersionDocument(doc) {\\n        if (doc._id !== clientArch) {\\n          return;\\n        }\\n\\n        if (\\n          doc.versionNonRefreshable !== autoupdateVersions.versionNonRefreshable\\n        ) {\\n          // Non-refreshable assets have changed, so we have to reload the\\n          // whole page rather than just replacing <link> tags.\\n          if (stop) stop();\\n          if (Package.reload) {\\n            // The reload package should be provided by ddp-client, which\\n            // is provided by the ddp package that autoupdate depends on.\\n            Package.reload.Reload._reload();\\n          }\\n          return;\\n        }\\n\\n        if (doc.versionRefreshable !== autoupdateVersions.versionRefreshable) {\\n          autoupdateVersions.versionRefreshable = doc.versionRefreshable;\\n\\n          // Switch out old css links for the new css links. Inspired by:\\n          // https://github.com/guard/guard-livereload/blob/master/js/livereload.js#L710\\n          const newCss = doc.assets || [];\\n          const oldLinks = [];\\n\\n          Array.prototype.forEach.call(\\n            document.getElementsByTagName('link'),\\n            (link) => {\\n              if (link.className === '__meteor-css__') {\\n                oldLinks.push(link);\\n              }\\n            },\\n          );\\n\\n          function waitUntilCssLoads(link, callback) {\\n            let called;\\n\\n            link.onload = function () {\\n              knownToSupportCssOnLoad = true;\\n              if (!called) {\\n                called = true;\\n                callback();\\n              }\\n            };\\n\\n            if (!knownToSupportCssOnLoad) {\\n              var id = Meteor.setInterval(() => {\\n                if (link.sheet) {\\n                  if (!called) {\\n                    called = true;\\n                    callback();\\n                  }\\n                  Meteor.clearInterval(id);\\n                }\\n              }, 50);\\n            }\\n          }\\n\\n          let newLinksLeftToLoad = newCss.length;\\n          function removeOldLinks() {\\n            if (oldLinks.length > 0 && --newLinksLeftToLoad < 1) {\\n              oldLinks.splice(0).forEach((link) => {\\n                link.parentNode.removeChild(link);\\n              });\\n            }\\n          }\\n\\n          if (newCss.length > 0) {\\n            newCss.forEach((css) => {\\n              const newLink = document.createElement('link');\\n              newLink.setAttribute('rel', 'stylesheet');\\n              newLink.setAttribute('type', 'text/css');\\n              newLink.setAttribute('class', '__meteor-css__');\\n              newLink.setAttribute('href', css.url);\\n\\n              waitUntilCssLoads(newLink, () => {\\n                Meteor.setTimeout(removeOldLinks, 200);\\n              });\\n\\n              const head = document.getElementsByTagName('head').item(0);\\n              head.appendChild(newLink);\\n            });\\n          } else {\\n            removeOldLinks();\\n          }\\n        }\\n      }\\n    },\\n  });\\n};\\n\\nAutoupdate._retrySubscription();\\n\",\"import { Tracker } from \\\"meteor/tracker\\\";\\n\\nexport class ClientVersions {\\n  constructor() {\\n    this._versions = new Map();\\n    this._watchCallbacks = new Set();\\n  }\\n\\n  // Creates a Livedata store for use with `Meteor.connection.registerStore`.\\n  // After the store is registered, document updates reported by Livedata are\\n  // merged with the documents in this `ClientVersions` instance.\\n  createStore() {\\n    return {\\n      update: ({ id, msg, fields }) => {\\n        if (msg === \\\"added\\\" || msg === \\\"changed\\\") {\\n          this.set(id, fields);\\n        }\\n      }\\n    };\\n  }\\n\\n  hasVersions() {\\n    return this._versions.size > 0;\\n  }\\n\\n  get(id) {\\n    return this._versions.get(id);\\n  }\\n\\n  // Adds or updates a version document and invokes registered callbacks for the\\n  // added/updated document. If a document with the given ID already exists, its\\n  // fields are merged with `fields`.\\n  set(id, fields) {\\n    let version = this._versions.get(id);\\n    let isNew = false;\\n\\n    if (version) {\\n      Object.assign(version, fields);\\n    } else {\\n      version = {\\n        _id: id,\\n        ...fields\\n      };\\n\\n      isNew = true;\\n      this._versions.set(id, version);\\n    }\\n\\n    this._watchCallbacks.forEach(({ fn, filter }) => {\\n      if (! filter || filter === version._id) {\\n        fn(version, isNew);\\n      }\\n    });\\n  }\\n\\n  // Registers a callback that will be invoked when a version document is added\\n  // or changed. Calling the function returned by `watch` removes the callback.\\n  // If `skipInitial` is true, the callback isn't be invoked for existing\\n  // documents. If `filter` is set, the callback is only invoked for documents\\n  // with ID `filter`.\\n  watch(fn, { skipInitial, filter } = {}) {\\n    if (! skipInitial) {\\n      const resolved = Promise.resolve();\\n\\n      this._versions.forEach((version) => {\\n        if (! filter || filter === version._id) {\\n          resolved.then(() => fn(version, true));\\n        }\\n      });\\n    }\\n\\n    const callback = { fn, filter };\\n    this._watchCallbacks.add(callback);\\n\\n    return () => this._watchCallbacks.delete(callback);\\n  }\\n\\n  // A reactive data source for `Autoupdate.newClientAvailable`.\\n  newClientAvailable(id, fields, currentVersion) {\\n    function isNewVersion(version) {\\n      return (\\n        version._id === id &&\\n        fields.some((field) => version[field] !== currentVersion[field])\\n      );\\n    }\\n\\n    const dependency = new Tracker.Dependency();\\n    const version = this.get(id);\\n\\n    dependency.depend();\\n\\n    const stop = this.watch(\\n      (version) => {\\n        if (isNewVersion(version)) {\\n          dependency.changed();\\n          stop();\\n        }\\n      },\\n      { skipInitial: true }\\n    );\\n\\n    return !! version && isNewVersion(version);\\n  }\\n}\\n\"]}","minifier":"terser"}