{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,n=Package.meteor.meteorEnv,r=Package.ejson.EJSON,a=Package.modules.meteorInstall,i=Package[\"babel-runtime\"].meteorBabelHelpers,c=Package.promise.Promise,o=Package[\"ecmascript-runtime-client\"].Symbol,u=Package[\"ecmascript-runtime-client\"].Map,s=Package[\"ecmascript-runtime-client\"].Set,f,l,h,p=a({node_modules:{meteor:{check:{\"match.js\":function(t,n,a){var c=t(\"@babel/runtime/helpers/interopRequireDefault\"),o=c(t(\"@babel/runtime/helpers/toConsumableArray\")),u=c(t(\"@babel/runtime/helpers/typeof\")),s;a.export({check:function(){return h},Match:function(){return p}}),a.link(\"./isPlainObject\",{isPlainObject:function(e){s=e}},0);var f=new e.EnvironmentVariable,l=Object.prototype.hasOwnProperty;function h(e,t){var n=f.getOrNullIfOutsideFiber();n&&n.checking(e);var r=k(e,t);if(r){var a=new p.Error(r.message);throw r.path&&(a.message+=\" in field \"+r.path,a.path=r.path),a}}var p={Optional:function(e){return new g(e)},Maybe:function(e){return new m(e)},OneOf:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return new d(t)},Any:[\"__any__\"],Where:function(e){return new b(e)},ObjectIncluding:function(e){return new y(e)},ObjectWithValues:function(e){return new v(e)},Integer:[\"__integer__\"],Error:e.makeErrorType(\"Match.Error\",function(t){this.message=\"Match error: \"+t,this.path=\"\",this.sanitizedError=new e.Error(400,\"Match failed\")}),test:function(e,t){return!k(e,t)},_failIfArgumentsAreNotAllChecked:function(e,t,n,r){var a=new w(n,r),i=f.withValue(a,function(){return e.apply(t,n)});return a.throwUnlessAllArgumentsHaveBeenChecked(),i}},g=function(){function e(e){this.pattern=e}return e}(),m=function(){function e(e){this.pattern=e}return e}(),d=function(){function e(e){if(!e||0===e.length)throw new Error(\"Must provide at least one choice to Match.OneOf\");this.choices=e}return e}(),b=function(){function e(e){this.condition=e}return e}(),y=function(){function e(e){this.pattern=e}return e}(),v=function(){function e(e){this.pattern=e}return e}(),O=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null===e)return\"null\";if(t.onlyShowType)return(0,u.default)(e);if(\"object\"!==(0,u.default)(e))return r.stringify(e);try{JSON.stringify(e)}catch(t){if(\"TypeError\"===t.name)return(0,u.default)(e)}return r.stringify(e)},j=[[String,\"string\"],[Number,\"number\"],[Boolean,\"boolean\"],[Function,\"function\"],[void 0,\"undefined\"]],k=function(e,t){if(t===p.Any)return!1;for(var n=0;n<j.length;++n)if(t===j[n][0])return(0,u.default)(e)!==j[n][1]&&{message:\"Expected \"+j[n][1]+\", got \"+O(e,{onlyShowType:!0}),path:\"\"};if(null===t)return null!==e&&{message:\"Expected null, got \"+O(e),path:\"\"};if(\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t)return e!==t&&{message:\"Expected \"+t+\", got \"+O(e),path:\"\"};if(t===p.Integer)return(\"number\"!=typeof e||(0|e)!==e)&&{message:\"Expected Integer, got \"+O(e),path:\"\"};if(t===Object&&(t=p.ObjectIncluding({})),t instanceof Array){if(1!==t.length)return{message:\"Bad pattern: arrays must have one type element \"+O(t),path:\"\"};if(!Array.isArray(e)&&!M(e))return{message:\"Expected array, got \"+O(e),path:\"\"};for(var r=0,a=e.length;r<a;r++){var c=k(e[r],t[0]);if(c)return c.path=P(r,c.path),c}return!1}if(t instanceof b){var o;try{o=t.condition(e)}catch(e){if(!(e instanceof p.Error))throw e;return{message:e.message,path:e.path}}return!o&&{message:\"Failed Match.Where validation\",path:\"\"}}if(t instanceof m?t=p.OneOf(void 0,null,t.pattern):t instanceof g&&(t=p.OneOf(void 0,t.pattern)),t instanceof d){for(var f=0;f<t.choices.length;++f){var h;if(!k(e,t.choices[f]))return!1}return{message:\"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",path:\"\"}}if(t instanceof Function)return!(e instanceof t)&&{message:\"Expected \"+(t.name||\"particular constructor\"),path:\"\"};var w=!1,E;if(t instanceof y&&(w=!0,t=t.pattern),t instanceof v&&(w=!0,E=[t.pattern],t={}),\"object\"!==(0,u.default)(t))return{message:\"Bad pattern: unknown pattern type\",path:\"\"};if(\"object\"!==(0,u.default)(e))return{message:\"Expected object, got \"+(0,u.default)(e),path:\"\"};if(null===e)return{message:\"Expected object, got null\",path:\"\"};if(!s(e))return{message:\"Expected plain object\",path:\"\"};var A=Object.create(null),_=Object.create(null);for(var x in Object.keys(t).forEach(function(e){var n=t[e];n instanceof g||n instanceof m?_[e]=n.pattern:A[e]=n}),i.sanitizeForInObject(Object(e))){var N=e[x];if(l.call(A,x)){var S=k(N,A[x]);if(S)return S.path=P(x,S.path),S;delete A[x]}else if(l.call(_,x)){var I=k(N,_[x]);if(I)return I.path=P(x,I.path),I}else{if(!w)return{message:\"Unknown key\",path:x};if(E){var B=k(N,E[0]);if(B)return B.path=P(x,B.path),B}}}var F=Object.keys(A);return F.length?{message:\"Missing key '\"+F[0]+\"'\",path:\"\"}:void 0},w=function(){function e(e,t){this.args=(0,o.default)(e),this.args.reverse(),this.description=t}var t=e.prototype;return t.checking=function(){function e(e){this._checkingOneValue(e)||(Array.isArray(e)||M(e))&&Array.prototype.forEach.call(e,this._checkingOneValue.bind(this))}return e}(),t._checkingOneValue=function(){function e(e){for(var t=0;t<this.args.length;++t)if(e===this.args[t]||Number.isNaN(e)&&Number.isNaN(this.args[t]))return this.args.splice(t,1),!0;return!1}return e}(),t.throwUnlessAllArgumentsHaveBeenChecked=function(){function e(){if(this.args.length>0)throw new Error(\"Did not check() all arguments during \"+this.description)}return e}(),e}(),E=[\"do\",\"if\",\"in\",\"for\",\"let\",\"new\",\"try\",\"var\",\"case\",\"else\",\"enum\",\"eval\",\"false\",\"null\",\"this\",\"true\",\"void\",\"with\",\"break\",\"catch\",\"class\",\"const\",\"super\",\"throw\",\"while\",\"yield\",\"delete\",\"export\",\"import\",\"public\",\"return\",\"static\",\"switch\",\"typeof\",\"default\",\"extends\",\"finally\",\"package\",\"private\",\"continue\",\"debugger\",\"function\",\"arguments\",\"interface\",\"protected\",\"implements\",\"instanceof\"],P=function(e,t){return\"number\"==typeof e||e.match(/^[0-9]+$/)?e=\"[\"+e+\"]\":(!e.match(/^[a-z_$][0-9a-z_$]*$/i)||E.indexOf(e)>=0)&&(e=JSON.stringify([e])),t&&\"[\"!==t[0]?e+\".\"+t:e+t},A=function(e){return\"object\"===(0,u.default)(e)&&null!==e},_=function(e){return A(e)&&\"[object Arguments]\"===Object.prototype.toString.call(e)},M=_(function(){return arguments}())?_:function(e){return A(e)&&\"function\"==typeof e.callee}},\"isPlainObject.js\":function(e,t,n){n.export({isPlainObject:function(){return s}});var r,a={}.toString,i=Object.prototype.hasOwnProperty,c=i.toString,o=c.call(Object),u=Object.getPrototypeOf,s=function(e){var t,n;return!(!e||\"[object Object]\"!==a.call(e))&&(!(t=u(e))||\"function\"==typeof(n=i.call(t,\"constructor\")&&t.constructor)&&c.call(n)===o)}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/check/match.js\");Package._define(\"check\",p,{check:f,Match:l})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/check/match.js\",\"packages/check/isPlainObject.js\"],\"names\":[\"isPlainObject\",\"module\",\"export\",\"check\",\"Match\",\"link\",\"v\",\"currentArgumentChecker\",\"Meteor\",\"EnvironmentVariable\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"value\",\"pattern\",\"argChecker\",\"getOrNullIfOutsideFiber\",\"checking\",\"result\",\"testSubtree\",\"err\",\"Error\",\"message\",\"path\",\"Optional\",\"Maybe\",\"OneOf\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"Any\",\"Where\",\"condition\",\"ObjectIncluding\",\"ObjectWithValues\",\"Integer\",\"makeErrorType\",\"msg\",\"this\",\"sanitizedError\",\"test\",\"_failIfArgumentsAreNotAllChecked\",\"f\",\"context\",\"description\",\"ArgumentChecker\",\"withValue\",\"apply\",\"throwUnlessAllArgumentsHaveBeenChecked\",\"choices\",\"stringForErrorMessage\",\"options\",\"undefined\",\"onlyShowType\",\"_typeof2\",\"default\",\"EJSON\",\"stringify\",\"JSON\",\"stringifyError\",\"name\",\"typeofChecks\",\"String\",\"Number\",\"Boolean\",\"Function\",\"i\",\"isArray\",\"isArguments\",\"_prependPath\",\"unknownKeysAllowed\",\"unknownKeyPattern\",\"requiredPatterns\",\"create\",\"optionalPatterns\",\"key\",\"keys\",\"forEach\",\"subPattern\",\"meteorBabelHelpers\",\"sanitizeForInObject\",\"subValue\",\"call\",\"_toConsumableArray2\",\"reverse\",\"_checkingOneValue\",\"bind\",\"isNaN\",\"splice\",\"_jsKeywords\",\"base\",\"match\",\"indexOf\",\"isObject\",\"baseIsArguments\",\"item\",\"toString\",\"callee\",\"class2type\",\"fnToString\",\"ObjectFunctionString\",\"getProto\",\"getPrototypeOf\",\"obj\",\"proto\",\"Ctor\",\"constructor\"],\"mappings\":\"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\",\"sourcesContent\":[\"// XXX docs\\nimport { isPlainObject } from './isPlainObject';\\n\\n// Things we explicitly do NOT support:\\n//    - heterogenous arrays\\n\\nconst currentArgumentChecker = new Meteor.EnvironmentVariable;\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n/**\\n * @summary Check that a value matches a [pattern](#matchpatterns).\\n * If the value does not match the pattern, throw a `Match.Error`.\\n *\\n * Particularly useful to assert that arguments to a function have the right\\n * types and structure.\\n * @locus Anywhere\\n * @param {Any} value The value to check\\n * @param {MatchPattern} pattern The pattern to match `value` against\\n */\\nexport function check(value, pattern) {\\n  // Record that check got called, if somebody cared.\\n  //\\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\\n  // from non-Fiber server contexts; the downside is that if you forget to\\n  // bindEnvironment on some random callback in your method/publisher,\\n  // it might not find the argumentChecker and you'll get an error about\\n  // not checking an argument that it looks like you're checking (instead\\n  // of just getting a \\\"Node code must run in a Fiber\\\" error).\\n  const argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\\n  if (argChecker) {\\n    argChecker.checking(value);\\n  }\\n\\n  const result = testSubtree(value, pattern);\\n  if (result) {\\n    const err = new Match.Error(result.message);\\n    if (result.path) {\\n      err.message += ` in field ${result.path}`;\\n      err.path = result.path;\\n    }\\n\\n    throw err;\\n  }\\n};\\n\\n/**\\n * @namespace Match\\n * @summary The namespace for all Match types and methods.\\n */\\nexport const Match = {\\n  Optional: function(pattern) {\\n    return new Optional(pattern);\\n  },\\n\\n  Maybe: function(pattern) {\\n    return new Maybe(pattern);\\n  },\\n\\n  OneOf: function(...args) {\\n    return new OneOf(args);\\n  },\\n\\n  Any: ['__any__'],\\n  Where: function(condition) {\\n    return new Where(condition);\\n  },\\n\\n  ObjectIncluding: function(pattern) {\\n    return new ObjectIncluding(pattern)\\n  },\\n\\n  ObjectWithValues: function(pattern) {\\n    return new ObjectWithValues(pattern);\\n  },\\n\\n  // Matches only signed 32-bit integers\\n  Integer: ['__integer__'],\\n\\n  // XXX matchers should know how to describe themselves for errors\\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\\n    this.message = `Match error: ${msg}`;\\n\\n    // The path of the value that failed to match. Initially empty, this gets\\n    // populated by catching and rethrowing the exception as it goes back up the\\n    // stack.\\n    // E.g.: \\\"vals[3].entity.created\\\"\\n    this.path = '';\\n\\n    // If this gets sent over DDP, don't give full internal details but at least\\n    // provide something better than 500 Internal server error.\\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\\n  }),\\n\\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\\n  // or false (unless an error other than Match.Error was thrown). It does not\\n  // interact with _failIfArgumentsAreNotAllChecked.\\n  // XXX maybe also implement a Match.match which returns more information about\\n  //     failures but without using exception handling or doing what check()\\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\\n\\n  /**\\n   * @summary Returns true if the value matches the pattern.\\n   * @locus Anywhere\\n   * @param {Any} value The value to check\\n   * @param {MatchPattern} pattern The pattern to match `value` against\\n   */\\n  test(value, pattern) {\\n    return !testSubtree(value, pattern);\\n  },\\n\\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\\n  // `args` (either directly or in the first level of an array), throws an error\\n  // (using `description` in the message).\\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\\n    const argChecker = new ArgumentChecker(args, description);\\n    const result = currentArgumentChecker.withValue(\\n      argChecker, \\n      () => f.apply(context, args)\\n    );\\n\\n    // If f didn't itself throw, make sure it checked all of its arguments.\\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\\n    return result;\\n  }\\n};\\n\\nclass Optional {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass Maybe {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass OneOf {\\n  constructor(choices) {\\n    if (!choices || choices.length === 0) {\\n      throw new Error('Must provide at least one choice to Match.OneOf');\\n    }\\n\\n    this.choices = choices;\\n  }\\n}\\n\\nclass Where {\\n  constructor(condition) {\\n    this.condition = condition;\\n  }\\n}\\n\\nclass ObjectIncluding {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass ObjectWithValues {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nconst stringForErrorMessage = (value, options = {}) => {\\n  if ( value === null ) {\\n    return 'null';\\n  }\\n\\n  if ( options.onlyShowType ) {\\n    return typeof value;\\n  }\\n\\n  // Your average non-object things.  Saves from doing the try/catch below for.\\n  if ( typeof value !== 'object' ) {\\n    return EJSON.stringify(value)\\n  }\\n\\n  try {\\n\\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\\n    JSON.stringify(value);\\n  } catch (stringifyError) {\\n    if ( stringifyError.name === 'TypeError' ) {\\n      return typeof value;\\n    }\\n  }\\n\\n  return EJSON.stringify(value);\\n};\\n\\nconst typeofChecks = [\\n  [String, 'string'],\\n  [Number, 'number'],\\n  [Boolean, 'boolean'],\\n\\n  // While we don't allow undefined/function in EJSON, this is good for optional\\n  // arguments with OneOf.\\n  [Function, 'function'],\\n  [undefined, 'undefined'],\\n];\\n\\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\\nconst testSubtree = (value, pattern) => {\\n\\n  // Match anything!\\n  if (pattern === Match.Any) {\\n    return false;\\n  }\\n\\n  // Basic atomic types.\\n  // Do not match boxed objects (e.g. String, Boolean)\\n  for (let i = 0; i < typeofChecks.length; ++i) {\\n    if (pattern === typeofChecks[i][0]) {\\n      if (typeof value === typeofChecks[i][1]) {\\n        return false;\\n      }\\n\\n      return {\\n        message: `Expected ${typeofChecks[i][1]}, got ${stringForErrorMessage(value, { onlyShowType: true })}`,\\n        path: '',\\n      };\\n    }\\n  }\\n\\n  if (pattern === null) {\\n    if (value === null) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected null, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\\n    if (value === pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern}, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Match.Integer is special type encoded with array\\n  if (pattern === Match.Integer) {\\n\\n    // There is no consistent and reliable way to check if variable is a 64-bit\\n    // integer. One of the popular solutions is to get reminder of division by 1\\n    // but this method fails on really large floats with big precision.\\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\\n    // Bitwise operators work consistantly but always cast variable to 32-bit\\n    // signed integer according to JavaScript specs.\\n    if (typeof value === 'number' && (value | 0) === value) {\\n      return false;\\n    }\\n    \\n    return {\\n      message: `Expected Integer, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // 'Object' is shorthand for Match.ObjectIncluding({});\\n  if (pattern === Object) {\\n    pattern = Match.ObjectIncluding({});\\n  }\\n\\n  // Array (checked AFTER Any, which is implemented as an Array).\\n  if (pattern instanceof Array) {\\n    if (pattern.length !== 1) {\\n      return {\\n        message: `Bad pattern: arrays must have one type element ${stringForErrorMessage(pattern)}`,\\n        path: '',\\n      };\\n    }\\n\\n    if (!Array.isArray(value) && !isArguments(value)) {\\n      return {\\n        message: `Expected array, got ${stringForErrorMessage(value)}`,\\n        path: '',\\n      };\\n    }\\n\\n    for (let i = 0, length = value.length; i < length; i++) {\\n      const result = testSubtree(value[i], pattern[0]);\\n      if (result) {\\n        result.path = _prependPath(i, result.path);\\n        return result;\\n      }\\n    }\\n    \\n    return false;\\n  }\\n\\n  // Arbitrary validation checks. The condition can return false or throw a\\n  // Match.Error (ie, it can internally use check()) to fail.\\n  if (pattern instanceof Where) {\\n    let result;\\n    try {\\n      result = pattern.condition(value);\\n    } catch (err) {\\n      if (!(err instanceof Match.Error)) {\\n        throw err;\\n      }\\n      \\n      return {\\n        message: err.message,\\n        path: err.path\\n      };\\n    }\\n\\n    if (result) {\\n      return false;\\n    }\\n\\n    // XXX this error is terrible\\n    return {\\n      message: 'Failed Match.Where validation',\\n      path: '',\\n    };\\n  }\\n\\n  if (pattern instanceof Maybe) {\\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\\n  } else if (pattern instanceof Optional) {\\n    pattern = Match.OneOf(undefined, pattern.pattern);\\n  }\\n\\n  if (pattern instanceof OneOf) {\\n    for (let i = 0; i < pattern.choices.length; ++i) {\\n      const result = testSubtree(value, pattern.choices[i]);\\n      if (!result) {\\n\\n        // No error? Yay, return.\\n        return false;\\n      }\\n\\n      // Match errors just mean try another choice.\\n    }\\n\\n    // XXX this error is terrible\\n    return {\\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\\n      path: '',\\n    };\\n  }\\n\\n  // A function that isn't something we special-case is assumed to be a\\n  // constructor.\\n  if (pattern instanceof Function) {\\n    if (value instanceof pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern.name || 'particular constructor'}`,\\n      path: '',\\n    };\\n  }\\n\\n  let unknownKeysAllowed = false;\\n  let unknownKeyPattern;\\n  if (pattern instanceof ObjectIncluding) {\\n    unknownKeysAllowed = true;\\n    pattern = pattern.pattern;\\n  }\\n\\n  if (pattern instanceof ObjectWithValues) {\\n    unknownKeysAllowed = true;\\n    unknownKeyPattern = [pattern.pattern];\\n    pattern = {};  // no required keys\\n  }\\n\\n  if (typeof pattern !== 'object') {\\n    return {\\n      message: 'Bad pattern: unknown pattern type',\\n      path: '',\\n    };\\n  }\\n\\n  // An object, with required and optional keys. Note that this does NOT do\\n  // structural matches against objects of special types that happen to match\\n  // the pattern: this really needs to be a plain old {Object}!\\n  if (typeof value !== 'object') {\\n    return {\\n      message: `Expected object, got ${typeof value}`,\\n      path: '',\\n    };\\n  }\\n\\n  if (value === null) {\\n    return {\\n      message: `Expected object, got null`,\\n      path: '',\\n    };\\n  }\\n\\n  if (! isPlainObject(value)) {\\n    return {\\n      message: `Expected plain object`,\\n      path: '',\\n    };\\n  }\\n\\n  const requiredPatterns = Object.create(null);\\n  const optionalPatterns = Object.create(null);\\n\\n  Object.keys(pattern).forEach(key => {\\n    const subPattern = pattern[key];\\n    if (subPattern instanceof Optional ||\\n        subPattern instanceof Maybe) {\\n      optionalPatterns[key] = subPattern.pattern;\\n    } else {\\n      requiredPatterns[key] = subPattern;\\n    }\\n  });\\n\\n  for (let key in Object(value)) {\\n    const subValue = value[key];\\n    if (hasOwn.call(requiredPatterns, key)) {\\n      const result = testSubtree(subValue, requiredPatterns[key]);\\n      if (result) {\\n        result.path = _prependPath(key, result.path);\\n        return result;\\n      }\\n\\n      delete requiredPatterns[key];\\n    } else if (hasOwn.call(optionalPatterns, key)) {\\n      const result = testSubtree(subValue, optionalPatterns[key]);\\n      if (result) {\\n        result.path = _prependPath(key, result.path);\\n        return result;\\n      }\\n\\n    } else {\\n      if (!unknownKeysAllowed) {\\n        return {\\n          message: 'Unknown key',\\n          path: key,\\n        };\\n      }\\n\\n      if (unknownKeyPattern) {\\n        const result = testSubtree(subValue, unknownKeyPattern[0]);\\n        if (result) {\\n          result.path = _prependPath(key, result.path);\\n          return result;\\n        }\\n      }\\n    }\\n  }\\n\\n  const keys = Object.keys(requiredPatterns);\\n  if (keys.length) {\\n    return {\\n      message: `Missing key '${keys[0]}'`,\\n      path: '',\\n    };\\n  }\\n};\\n\\nclass ArgumentChecker {\\n  constructor (args, description) {\\n\\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\\n    // against its contents.)\\n    this.args = [...args];\\n\\n    // Since the common case will be to check arguments in order, and we splice\\n    // out arguments when we check them, make it so we splice out from the end\\n    // rather than the beginning.\\n    this.args.reverse();\\n    this.description = description;\\n  }\\n\\n  checking(value) {\\n    if (this._checkingOneValue(value)) {\\n      return;\\n    }\\n\\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\\n    // or check([foo, bar], [String]) to count... but only if value wasn't\\n    // itself an argument.\\n    if (Array.isArray(value) || isArguments(value)) {\\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\\n    }\\n  }\\n\\n  _checkingOneValue(value) {\\n    for (let i = 0; i < this.args.length; ++i) {\\n\\n      // Is this value one of the arguments? (This can have a false positive if\\n      // the argument is an interned primitive, but it's still a good enough\\n      // check.)\\n      // (NaN is not === to itself, so we have to check specially.)\\n      if (value === this.args[i] ||\\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\\n        this.args.splice(i, 1);\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  throwUnlessAllArgumentsHaveBeenChecked() {\\n    if (this.args.length > 0)\\n      throw new Error(`Did not check() all arguments during ${this.description}`);\\n  }\\n}\\n\\nconst _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case',\\n  'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with',\\n  'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield',\\n  'delete', 'export', 'import', 'public', 'return', 'static', 'switch',\\n  'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue',\\n  'debugger', 'function', 'arguments', 'interface', 'protected', 'implements',\\n  'instanceof'];\\n\\n// Assumes the base of path is already escaped properly\\n// returns key + base\\nconst _prependPath = (key, base) => {\\n  if ((typeof key) === 'number' || key.match(/^[0-9]+$/)) {\\n    key = `[${key}]`;\\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) ||\\n             _jsKeywords.indexOf(key) >= 0) {\\n    key = JSON.stringify([key]);\\n  }\\n\\n  if (base && base[0] !== '[') {\\n    return `${key}.${base}`;\\n  }\\n\\n  return key + base;\\n}\\n\\nconst isObject = value => typeof value === 'object' && value !== null;\\n\\nconst baseIsArguments = item =>\\n  isObject(item) &&\\n  Object.prototype.toString.call(item) === '[object Arguments]';\\n\\nconst isArguments = baseIsArguments(function() { return arguments; }()) ?\\n  baseIsArguments :\\n  value => isObject(value) && typeof value.callee === 'function';\\n\",\"// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\\n\\nconst class2type = {};\\n\\nconst toString = class2type.toString;\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nconst fnToString = hasOwn.toString;\\n\\nconst ObjectFunctionString = fnToString.call(Object);\\n\\nconst getProto = Object.getPrototypeOf;\\n\\nexport const isPlainObject = obj => {\\n  let proto;\\n  let Ctor;\\n\\n  // Detect obvious negatives\\n  // Use toString instead of jQuery.type to catch host objects\\n  if (!obj || toString.call(obj) !== '[object Object]') {\\n    return false;\\n  }\\n\\n  proto = getProto(obj);\\n\\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\\n  if (!proto) {\\n    return true;\\n  }\\n\\n  // Objects with prototype are plain iff they were constructed by a global Object function\\n  Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\\n  return typeof Ctor === 'function' && \\n    fnToString.call(Ctor) === ObjectFunctionString;\\n};\\n\"]}","minifier":"terser"}