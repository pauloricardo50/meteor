{"code":"!function(){var e=Package.meteor.Meteor,r=Package.meteor.global,t=Package.meteor.meteorEnv,n=Package[\"diff-sequence\"].DiffSequence,i=Package.ejson.EJSON,o=Package[\"geojson-utils\"].GeoJSON,a=Package[\"id-map\"].IdMap,s=Package[\"mongo-id\"].MongoID,c=Package[\"ordered-dict\"].OrderedDict,u=Package.random.Random,f=Package.tracker.Tracker,l=Package.tracker.Deps,d=Package.modules.meteorInstall,h=Package[\"babel-runtime\"].meteorBabelHelpers,p=Package.promise.Promise,m=Package[\"ecmascript-runtime-client\"].Symbol,v=Package[\"ecmascript-runtime-client\"].Map,y=Package[\"ecmascript-runtime-client\"].Set,_,g,b,w,E,$=d({node_modules:{meteor:{minimongo:{\"minimongo_client.js\":function(e,r,t){t.link(\"./minimongo_common.js\")},\"common.js\":function(e,r,t){var n=e(\"@babel/runtime/helpers/interopRequireDefault\"),a=n(e(\"@babel/runtime/helpers/toConsumableArray\")),s=n(e(\"@babel/runtime/helpers/typeof\")),c;t.export({hasOwn:function(){return u},ELEMENT_OPERATORS:function(){return f},compileDocumentSelector:function(){return y},equalityElementMatcher:function(){return $},expandArraysInBranches:function(){return O},isIndexable:function(){return M},isNumericKey:function(){return C},isOperatorObject:function(){return P},makeLookupFunction:function(){return q},nothingMatcher:function(){return B},pathsToTree:function(){return F},populateDocumentWithQueryFields:function(){return Q},projectionDetails:function(){return L},regexpElementMatcher:function(){return N}}),t.link(\"./local_collection.js\",{default:function(e){c=e}},0);var u=Object.prototype.hasOwnProperty,f={$lt:x(function(e){return e<0}),$gt:x(function(e){return e>0}),$lte:x(function(e){return e<=0}),$gte:x(function(e){return e>=0}),$mod:{compileElementSelector:function(e){if(!Array.isArray(e)||2!==e.length||\"number\"!=typeof e[0]||\"number\"!=typeof e[1])throw Error(\"argument to $mod must be an array of two numbers\");var r=e[0],t=e[1];return function(e){return\"number\"==typeof e&&e%r===t}}},$in:{compileElementSelector:function(e){if(!Array.isArray(e))throw Error(\"$in needs an array\");var r=e.map(function(e){if(e instanceof RegExp)return N(e);if(P(e))throw Error(\"cannot nest $ under $in\");return $(e)});return function(e){return void 0===e&&(e=null),r.some(function(r){return r(e)})}}},$size:{dontExpandLeafArrays:!0,compileElementSelector:function(e){if(\"string\"==typeof e)e=0;else if(\"number\"!=typeof e)throw Error(\"$size needs a number\");return function(r){return Array.isArray(r)&&r.length===e}}},$type:{dontIncludeLeafArrays:!0,compileElementSelector:function(e){if(\"string\"==typeof e){var r={double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127};if(!u.call(r,e))throw Error(\"unknown string alias for $type: \"+e);e=r[e]}else{if(\"number\"!=typeof e)throw Error(\"argument to $type is not a number or a string\");if(0===e||e<-1||e>19&&127!==e)throw Error(\"Invalid numerical $type code: \"+e)}return function(r){return void 0!==r&&c._f._type(r)===e}}},$bitsAllSet:{compileElementSelector:function(e){var r=A(e,\"$bitsAllSet\");return function(e){var t=k(e,r.length);return t&&r.every(function(e,r){return(t[r]&e)===e})}}},$bitsAnySet:{compileElementSelector:function(e){var r=A(e,\"$bitsAnySet\");return function(e){var t=k(e,r.length);return t&&r.some(function(e,r){return(~t[r]&e)!==e})}}},$bitsAllClear:{compileElementSelector:function(e){var r=A(e,\"$bitsAllClear\");return function(e){var t=k(e,r.length);return t&&r.every(function(e,r){return!(t[r]&e)})}}},$bitsAnyClear:{compileElementSelector:function(e){var r=A(e,\"$bitsAnyClear\");return function(e){var t=k(e,r.length);return t&&r.some(function(e,r){return(t[r]&e)!==e})}}},$regex:{compileElementSelector:function(e,r){if(!(\"string\"==typeof e||e instanceof RegExp))throw Error(\"$regex has to be a string or RegExp\");var t;if(void 0!==r.$options){if(/[^gim]/.test(r.$options))throw new Error(\"Only the i, m, and g regexp options are supported\");var n=e instanceof RegExp?e.source:e;t=new RegExp(n,r.$options)}else t=e instanceof RegExp?e:new RegExp(e);return N(t)}},$elemMatch:{dontExpandLeafArrays:!0,compileElementSelector:function(e,r,t){if(!c._isPlainObject(e))throw Error(\"$elemMatch need an object\");var n=!P(Object.keys(e).filter(function(e){return!u.call(l,e)}).reduce(function(r,t){var n;return Object.assign(r,((n={})[t]=e[t],n))},{}),!0),i;return i=n?y(e,t,{inElemMatch:!0}):b(e,t),function(e){if(!Array.isArray(e))return!1;for(var r=0;r<e.length;++r){var t=e[r],o=void 0;if(n){if(!M(t))return!1;o=t}else o=[{value:t,dontIterate:!0}];if(i(o).result)return r}return!1}}}},l={$and:function(e,r,t){return p(v(e,r,t))},$or:function(e,r,t){var n=v(e,r,t);return 1===n.length?n[0]:function(e){var r;return{result:n.some(function(r){return r(e).result})}}},$nor:function(e,r,t){var n=v(e,r,t);return function(e){var r;return{result:n.every(function(r){return!r(e).result})}}},$where:function(e,r){return r._recordPathUsed(\"\"),r._hasWhere=!0,e instanceof Function||(e=Function(\"obj\",\"return \"+e)),function(r){return{result:e.call(r,r)}}},$comment:function(){return function(){return{result:!0}}}},d={$eq:function(e){return w($(e))},$not:function(e,r,t){return S(b(e,t))},$ne:function(e){return S(w($(e)))},$nin:function(e){return S(w(f.$in.compileElementSelector(e)))},$exists:function(e){var r=w(function(e){return void 0!==e});return e?r:S(r)},$options:function(e,r){if(!u.call(r,\"$regex\"))throw Error(\"$options needs a $regex\");return j},$maxDistance:function(e,r){if(!r.$near)throw Error(\"$maxDistance needs a $near\");return j},$all:function(e,r,t){if(!Array.isArray(e))throw Error(\"$all requires array\");if(0===e.length)return B;var n=e.map(function(e){if(P(e))throw Error(\"no $ expressions in $all\");return b(e,t)});return m(n)},$near:function(e,r,t,n){if(!n)throw Error(\"$near can't be inside another $ operator\");var i,a,f;if(t._hasGeoQuery=!0,c._isPlainObject(e)&&u.call(e,\"$geometry\"))i=e.$maxDistance,a=e.$geometry,f=function(e){return e?e.type?\"Point\"===e.type?o.pointDistance(a,e):o.geometryWithinRadius(e,a,i)?0:i+1:o.pointDistance(a,{type:\"Point\",coordinates:D(e)}):null};else{if(i=r.$maxDistance,!M(e))throw Error(\"$near argument must be coordinate pair or GeoJSON\");a=D(e),f=function(e){return M(e)?E(a,e):null}}return function(e){var r={result:!1};return O(e).every(function(e){var n;if(!t._isUpdate){if(\"object\"!==(0,s.default)(e.value))return!0;if(null===(n=f(e.value))||n>i)return!0;if(void 0!==r.distance&&r.distance<=n)return!0}return r.result=!0,r.distance=n,e.arrayIndices?r.arrayIndices=e.arrayIndices:delete r.arrayIndices,!t._isUpdate}),r}}};function h(e){return 0===e.length?j:1===e.length?e[0]:function(r){var t={};return t.result=e.every(function(e){var n=e(r);return n.result&&void 0!==n.distance&&void 0===t.distance&&(t.distance=n.distance),n.result&&n.arrayIndices&&(t.arrayIndices=n.arrayIndices),n.result}),t.result||(delete t.distance,delete t.arrayIndices),t}}var p=h,m=h;function v(e,r,t){if(!Array.isArray(e)||0===e.length)throw Error(\"$and/$or/$nor must be nonempty array\");return e.map(function(e){if(!c._isPlainObject(e))throw Error(\"$or/$and/$nor entries need to be full objects\");return y(e,r,{inElemMatch:t})})}function y(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=Object.keys(e).map(function(n){var i=e[n];if(\"$\"===n.substr(0,1)){if(!u.call(l,n))throw new Error(\"Unrecognized logical operator: \"+n);return r._isSimple=!1,l[n](i,r,t.inElemMatch)}if(t.inElemMatch||r._recordPathUsed(n),\"function\"!=typeof i){var o=q(n),a=b(i,r,t.isRoot);return function(e){return a(o(e))}}}).filter(Boolean);return p(n)}function b(e,r,t){return e instanceof RegExp?(r._isSimple=!1,w(N(e))):P(e)?R(e,r,t):w($(e))}function w(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return function(t){var n=r.dontExpandLeafArrays?t:O(t,r.dontIncludeLeafArrays),i={};return i.result=n.some(function(r){var t=e(r.value);return\"number\"==typeof t&&(r.arrayIndices||(r.arrayIndices=[t]),t=!0),t&&r.arrayIndices&&(i.arrayIndices=r.arrayIndices),t}),i}}function E(e,r){var t=D(e),n=D(r);return Math.hypot(t[0]-n[0],t[1]-n[1])}function $(e){if(P(e))throw Error(\"Can't create equalityValueSelector for operator object\");return null==e?function(e){return null==e}:function(r){return c._f._equal(e,r)}}function j(e){return{result:!0}}function O(e,r){var t=[];return e.forEach(function(e){var n=Array.isArray(e.value);r&&n&&!e.dontIterate||t.push({arrayIndices:e.arrayIndices,value:e.value}),n&&!e.dontIterate&&e.value.forEach(function(r,n){t.push({arrayIndices:(e.arrayIndices||[]).concat(n),value:r})})}),t}function A(e,r){if(Number.isInteger(e)&&e>=0)return new Uint8Array(new Int32Array([e]).buffer);if(i.isBinary(e))return new Uint8Array(e.buffer);if(Array.isArray(e)&&e.every(function(e){return Number.isInteger(e)&&e>=0})){var t=new ArrayBuffer(1+(Math.max.apply(Math,(0,a.default)(e))>>3)),n=new Uint8Array(t);return e.forEach(function(e){n[e>>3]|=1<<(7&e)}),n}throw Error(\"operand to \"+r+\" must be a numeric bitmask (representable as a non-negative 32-bit signed integer), a bindata bitmask or an array with bit positions (non-negative integers)\")}function k(e,r){if(Number.isSafeInteger(e)){var t=new ArrayBuffer(Math.max(r,2*Uint32Array.BYTES_PER_ELEMENT)),n=new Uint32Array(t,0,2);return n[0]=e%4294967296|0,n[1]=e/4294967296|0,e<0&&(n=new Uint8Array(t,2)).forEach(function(e,r){n[r]=255}),new Uint8Array(t)}return!!i.isBinary(e)&&new Uint8Array(e.buffer)}function I(e,r,t){Object.keys(e).forEach(function(e){if(e.length>r.length&&0===e.indexOf(r+\".\")||r.length>e.length&&0===r.indexOf(e+\".\"))throw new Error(\"cannot infer query fields to set, both paths '\"+e+\"' and '\"+r+\"' are matched\");if(e===r)throw new Error(\"cannot infer query fields to set, path '\"+r+\"' is matched twice\")}),e[r]=t}function S(e){return function(r){return{result:!e(r).result}}}function M(e){return Array.isArray(e)||c._isPlainObject(e)}function C(e){return/^[0-9]+$/.test(e)}function P(e,r){if(!c._isPlainObject(e))return!1;var t=void 0;return Object.keys(e).forEach(function(n){var i=\"$\"===n.substr(0,1);if(void 0===t)t=i;else if(t!==i){if(!r)throw new Error(\"Inconsistent operator: \"+JSON.stringify(e));t=!1}}),!!t}function x(e){return{compileElementSelector:function(r){if(Array.isArray(r))return function(){return!1};void 0===r&&(r=null);var t=c._f._type(r);return function(n){return void 0===n&&(n=null),c._f._type(n)===t&&e(c._f._cmp(n,r))}}}}function q(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.split(\".\"),n=t.length?t[0]:\"\",i=t.length>1&&q(t.slice(1).join(\".\"),r),o=function(e){return e.dontIterate||delete e.dontIterate,e.arrayIndices&&!e.arrayIndices.length&&delete e.arrayIndices,e};return function(e){var s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(Array.isArray(e)){if(!(C(n)&&n<e.length))return[];s=s.concat(+n,\"x\")}var u=e[n];if(!i)return[o({arrayIndices:s,dontIterate:Array.isArray(e)&&Array.isArray(u),value:u})];if(!M(u))return Array.isArray(e)?[]:[o({arrayIndices:s,value:void 0})];var f=[],l=function(e){f.push.apply(f,(0,a.default)(e))};return l(i(u,s)),!Array.isArray(u)||C(t[1])&&r.forSort||u.forEach(function(e,r){c._isPlainObject(e)&&l(i(e,s.concat(r)))}),f}}function B(e){return{result:!1}}function R(e,r,t){var n=Object.keys(e).map(function(n){var i=e[n],o=[\"$lt\",\"$lte\",\"$gt\",\"$gte\"].includes(n)&&\"number\"==typeof i,a=[\"$ne\",\"$eq\"].includes(n)&&i!==Object(i),s=[\"$in\",\"$nin\"].includes(n)&&Array.isArray(i)&&!i.some(function(e){return e===Object(e)});if(o||s||a||(r._isSimple=!1),u.call(d,n))return d[n](i,e,r,t);if(u.call(f,n)){var c=f[n];return w(c.compileElementSelector(i,e,r),c)}throw new Error(\"Unrecognized operator: \"+n)});return m(n)}function F(e,r,t){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return e.forEach(function(e){var i=e.split(\".\"),o=n,a;if(i.slice(0,-1).every(function(r,n){if(u.call(o,r)){if(o[r]!==Object(o[r])&&(o[r]=t(o[r],i.slice(0,n+1).join(\".\"),e),o[r]!==Object(o[r])))return!1}else o[r]={};return o=o[r],!0})){var s=i[i.length-1];u.call(o,s)?o[s]=t(o[s],e,e):o[s]=r(e)}}),n}function D(e){return Array.isArray(e)?e.slice():[e.x,e.y]}function T(e,r,t){t&&Object.getPrototypeOf(t)===Object.prototype?U(e,r,t):t instanceof RegExp||I(e,r,t)}function U(e,r,t){var n=Object.keys(t),i=n.filter(function(e){return\"$\"!==e[0]});if(i.length>0||!n.length){if(n.length!==i.length)throw new Error(\"unknown operator: \"+i[0]);G(t,r),I(e,r,t)}else Object.keys(t).forEach(function(n){var i=t[n];\"$eq\"===n?T(e,r,i):\"$all\"===n&&i.forEach(function(t){return T(e,r,t)})})}function Q(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Object.getPrototypeOf(e)===Object.prototype?Object.keys(e).forEach(function(t){var n=e[t];\"$and\"===t?n.forEach(function(e){return Q(e,r)}):\"$or\"===t?1===n.length&&Q(n[0],r):\"$\"!==t[0]&&T(r,t,n)}):c._selectorIsId(e)&&I(r,\"_id\",e),r}function L(e){var r=Object.keys(e).sort();1===r.length&&\"_id\"===r[0]||r.includes(\"_id\")&&e._id||(r=r.filter(function(e){return\"_id\"!==e}));var t=null;r.forEach(function(r){var n=!!e[r];if(null===t&&(t=n),t!==n)throw g(\"You cannot currently mix including and excluding fields.\")});var n=F(r,function(e){return t},function(e,r,t){var n,i;throw g(\"both \"+t+\" and \"+r+\" found in fields option, using both of them may trigger unexpected behavior. Did you mean to use only one of them?\")});return{including:t,tree:n}}function N(e){return function(r){return r instanceof RegExp?r.toString()===e.toString():\"string\"==typeof r&&(e.lastIndex=0,e.test(r))}}function K(e,r){if(e.includes(\".\"))throw new Error(\"The dotted field '\"+e+\"' in '\"+r+\".\"+e+\" is not valid for storage.\");if(\"$\"===e[0])throw new Error(\"The dollar ($) prefixed field  '\"+r+\".\"+e+\" is not valid for storage.\")}function G(e,r){e&&Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).forEach(function(t){K(t,r),G(e[t],r+\".\"+t)})}_={makeLookupFunction:q},g=function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};\"string\"==typeof e&&r.field&&(e+=\" for field '\"+r.field+\"'\");var t=new Error(e);return t.name=\"MinimongoError\",t}},\"cursor.js\":function(e,r,t){var n,o;t.export({default:function(){return a}}),t.link(\"./local_collection.js\",{default:function(e){n=e}},0),t.link(\"./common.js\",{hasOwn:function(e){o=e}},1);var a=function(){function e(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.collection=e,this.sorter=null,this.matcher=new w.Matcher(r),n._selectorIsIdPerhapsAsObject(r)?this._selectorId=o.call(r,\"_id\")?r._id:r:(this._selectorId=void 0,(this.matcher.hasGeoQuery()||t.sort)&&(this.sorter=new w.Sorter(t.sort||[]))),this.skip=t.skip||0,this.limit=t.limit,this.fields=t.fields,this._projectionFn=n._compileProjection(this.fields||{}),this._transform=n.wrapTransform(t.transform),void 0!==f&&(this.reactive=void 0===t.reactive||t.reactive)}var r=e.prototype;return r.count=function(){function e(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.reactive&&this._depend({added:!0,removed:!0},!0),this._getRawObjects({ordered:!0,applySkipLimit:e}).length}return e}(),r.fetch=function(){function e(){var e=[];return this.forEach(function(r){e.push(r)}),e}return e}(),r[m.iterator]=function(){var e=this;this.reactive&&this._depend({addedBefore:!0,removed:!0,changed:!0,movedBefore:!0});var r=0,t=this._getRawObjects({ordered:!0});return{next:function(){if(r<t.length){var n=e._projectionFn(t[r++]);return e._transform&&(n=e._transform(n)),{value:n}}return{done:!0}}}},r.forEach=function(){function e(e,r){var t=this;this.reactive&&this._depend({addedBefore:!0,removed:!0,changed:!0,movedBefore:!0}),this._getRawObjects({ordered:!0}).forEach(function(n,i){n=t._projectionFn(n),t._transform&&(n=t._transform(n)),e.call(r,n,i,t)})}return e}(),r.getTransform=function(){function e(){return this._transform}return e}(),r.map=function(){function e(e,r){var t=this,n=[];return this.forEach(function(i,o){n.push(e.call(r,i,o,t))}),n}return e}(),r.observe=function(){function e(e){return n._observeFromObserveChanges(this,e)}return e}(),r.observeChanges=function(){function e(e){var r=this,t=n._observeChangesCallbacksAreOrdered(e);if(!e._allow_unordered&&!t&&(this.skip||this.limit))throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' for observeChanges or 'addedAt' for observe, instead of 'added').\");if(this.fields&&(0===this.fields._id||!1===this.fields._id))throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");var o,a={cursor:this,dirty:!1,distances:this.matcher.hasGeoQuery()&&t&&new n._IdMap,matcher:this.matcher,ordered:t,projectionFn:this._projectionFn,resultsSnapshot:null,sorter:t&&this.sorter},s;this.reactive&&(s=this.collection.next_qid++,this.collection.queries[s]=a),a.results=this._getRawObjects({ordered:t,distances:a.distances}),this.collection.paused&&(a.resultsSnapshot=t?[]:new n._IdMap);var c=function(e){if(!e)return function(){};var t=r;return function(){var r=this;if(!t.collection.paused){var n=arguments;t.collection._observeQueue.queueTask(function(){e.apply(r,n)})}}};a.added=c(e.added),a.changed=c(e.changed),a.removed=c(e.removed),t&&(a.addedBefore=c(e.addedBefore),a.movedBefore=c(e.movedBefore)),e._suppress_initial||this.collection.paused||a.results.forEach(function(e){var n=i.clone(e);delete n._id,t&&a.addedBefore(e._id,r._projectionFn(n),null),a.added(e._id,r._projectionFn(n))});var u=Object.assign(new n.ObserveHandle,{collection:this.collection,stop:function(){r.reactive&&delete r.collection.queries[s]}});return this.reactive&&f.active&&f.onInvalidate(function(){u.stop()}),this.collection._observeQueue.drain(),u}return e}(),r.rewind=function(){function e(){}return e}(),r._depend=function(){function e(e,r){if(f.active){var t=new f.Dependency,n=t.changed.bind(t);t.depend();var i={_allow_unordered:r,_suppress_initial:!0};[\"added\",\"addedBefore\",\"changed\",\"movedBefore\",\"removed\"].forEach(function(r){e[r]&&(i[r]=n)}),this.observeChanges(i)}}return e}(),r._getCollectionName=function(){function e(){return this.collection.name}return e}(),r._getRawObjects=function(){function e(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=!1!==r.applySkipLimit,i=r.ordered?[]:new n._IdMap,o;if(void 0!==this._selectorId){if(t&&this.skip)return i;var a=this.collection._docs.get(this._selectorId);return a&&(r.ordered?i.push(a):i.set(this._selectorId,a)),i}return this.matcher.hasGeoQuery()&&r.ordered&&(r.distances?(o=r.distances).clear():o=new n._IdMap),this.collection._docs.forEach(function(n,a){var s=e.matcher.documentMatches(n);return s.result&&(r.ordered?(i.push(n),o&&void 0!==s.distance&&o.set(a,s.distance)):i.set(a,n)),!t||(!e.limit||e.skip||e.sorter||i.length!==e.limit)}),r.ordered?(this.sorter&&i.sort(this.sorter.getComparator({distances:o})),t&&(this.limit||this.skip)?i.slice(this.skip,this.limit?this.limit+this.skip:i.length):i):i}return e}(),r._publishCursor=function(){function e(e){if(!Package.mongo)throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");if(!this.collection.name)throw new Error(\"Can't publish a cursor from a collection without a name.\");return Package.mongo.Mongo.Collection._publishCursor(this,e,this.collection.name)}return e}(),e}()},\"local_collection.js\":function(r,t,o){var l=r(\"@babel/runtime/helpers/interopRequireDefault\"),d=l(r(\"@babel/runtime/helpers/toConsumableArray\")),h=l(r(\"@babel/runtime/helpers/typeof\")),p=l(r(\"@babel/runtime/helpers/inheritsLoose\")),m,v,y,_,b,E,$,j;o.export({default:function(){return O}}),o.link(\"./cursor.js\",{default:function(e){m=e}},0),o.link(\"./observe_handle.js\",{default:function(e){v=e}},1),o.link(\"./common.js\",{hasOwn:function(e){y=e},isIndexable:function(e){_=e},isNumericKey:function(e){b=e},isOperatorObject:function(e){E=e},populateDocumentWithQueryFields:function(e){$=e},projectionDetails:function(e){j=e}},2);var O=function(){function r(t){this.name=t,this._docs=new r._IdMap,this._observeQueue=new e._SynchronousQueue,this.next_qid=1,this.queries=Object.create(null),this._savedOriginals=null,this.paused=!1}var t=r.prototype;return t.find=function(){function e(e,t){return 0===arguments.length&&(e={}),new r.Cursor(this,e,t)}return e}(),t.findOne=function(){function e(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return 0===arguments.length&&(e={}),r.limit=1,this.find(e,r).fetch()[0]}return e}(),t.insert=function(){function t(t,n){var o=this;S(t=i.clone(t)),y.call(t,\"_id\")||(t._id=r._useOID?new s.ObjectID:u.id());var a=t._id;if(this._docs.has(a))throw g(\"Duplicate _id '\"+a+\"'\");this._saveOriginal(a,void 0),this._docs.set(a,t);var c=[];return Object.keys(this.queries).forEach(function(e){var n=o.queries[e];if(!n.dirty){var i=n.matcher.documentMatches(t);i.result&&(n.distances&&void 0!==i.distance&&n.distances.set(a,i.distance),n.cursor.skip||n.cursor.limit?c.push(e):r._insertInResults(n,t))}}),c.forEach(function(e){o.queries[e]&&o._recomputeResults(o.queries[e])}),this._observeQueue.drain(),n&&e.defer(function(){n(null,a)}),a}return t}(),t.pauseObservers=function(){function e(){var e=this;this.paused||(this.paused=!0,Object.keys(this.queries).forEach(function(r){var t=e.queries[r];t.resultsSnapshot=i.clone(t.results)}))}return e}(),t.remove=function(){function t(t,n){var o=this;if(this.paused&&!this._savedOriginals&&i.equals(t,{})){var a=this._docs.size();return this._docs.clear(),Object.keys(this.queries).forEach(function(e){var r=o.queries[e];r.ordered?r.results=[]:r.results.clear()}),n&&e.defer(function(){n(null,a)}),a}var s=new w.Matcher(t),c=[];this._eachPossiblyMatchingDoc(t,function(e,r){s.documentMatches(e).result&&c.push(r)});for(var u=[],f=[],l=function(e){var r=c[e],t=o._docs.get(r);Object.keys(o.queries).forEach(function(e){var r=o.queries[e];r.dirty||r.matcher.documentMatches(t).result&&(r.cursor.skip||r.cursor.limit?u.push(e):f.push({qid:e,doc:t}))}),o._saveOriginal(r,t),o._docs.remove(r)},d=0;d<c.length;d++)l(d);f.forEach(function(e){var t=o.queries[e.qid];t&&(t.distances&&t.distances.remove(e.doc._id),r._removeFromResults(t,e.doc))}),u.forEach(function(e){var r=o.queries[e];r&&o._recomputeResults(r)}),this._observeQueue.drain();var h=c.length;return n&&e.defer(function(){n(null,h)}),h}return t}(),t.resumeObservers=function(){function e(){var e=this;this.paused&&(this.paused=!1,Object.keys(this.queries).forEach(function(t){var n=e.queries[t];n.dirty?(n.dirty=!1,e._recomputeResults(n,n.resultsSnapshot)):r._diffQueryChanges(n.ordered,n.resultsSnapshot,n.results,n,{projectionFn:n.projectionFn}),n.resultsSnapshot=null}),this._observeQueue.drain())}return e}(),t.retrieveOriginals=function(){function e(){if(!this._savedOriginals)throw new Error(\"Called retrieveOriginals without saveOriginals\");var e=this._savedOriginals;return this._savedOriginals=null,e}return e}(),t.saveOriginals=function(){function e(){if(this._savedOriginals)throw new Error(\"Called saveOriginals twice without retrieveOriginals\");this._savedOriginals=new r._IdMap}return e}(),t.update=function(){function t(t,n,o,a){var s=this;!a&&o instanceof Function&&(a=o,o=null),o||(o={});var c=new w.Matcher(t,!0),u={},f=new r._IdMap,l=r._idsMatchedBySelector(t);Object.keys(this.queries).forEach(function(e){var t=s.queries[e];if((t.cursor.skip||t.cursor.limit)&&!s.paused){if(t.results instanceof r._IdMap)return void(u[e]=t.results.clone());if(!(t.results instanceof Array))throw new Error(\"Assertion failed: query.results not an array\");var n=function(e){if(f.has(e._id))return f.get(e._id);var r=l&&!l.some(function(r){return i.equals(r,e._id)})?e:i.clone(e);return f.set(e._id,r),r};u[e]=t.results.map(n)}});var d={},h=0,p,m;if(this._eachPossiblyMatchingDoc(t,function(e,r){var t=c.documentMatches(e);return!(t.result&&(s._saveOriginal(r,e),s._modifyAndNotify(e,n,d,t.arrayIndices),++h,!o.multi))}),Object.keys(d).forEach(function(e){var r=s.queries[e];r&&s._recomputeResults(r,u[e])}),this._observeQueue.drain(),0===h&&o.upsert){var v=r._createUpsertDocument(t,n);!v._id&&o.insertedId&&(v._id=o.insertedId),p=this.insert(v),h=1}return o._returnObject?(m={numberAffected:h},void 0!==p&&(m.insertedId=p)):m=h,a&&e.defer(function(){a(null,m)}),m}return t}(),t.upsert=function(){function e(e,r,t,n){return n||\"function\"!=typeof t||(n=t,t={}),this.update(e,r,Object.assign({},t,{upsert:!0,_returnObject:!0}),n)}return e}(),t._eachPossiblyMatchingDoc=function(){function e(e,t){var n=this,i=r._idsMatchedBySelector(e);i?i.some(function(e){var r=n._docs.get(e);if(r)return!1===t(r,e)}):this._docs.forEach(t)}return e}(),t._modifyAndNotify=function(){function e(e,t,n,o){var a=this,s={};Object.keys(this.queries).forEach(function(r){var t=a.queries[r];t.dirty||(t.ordered?s[r]=t.matcher.documentMatches(e).result:s[r]=t.results.has(e._id))});var c=i.clone(e);r._modify(e,t,{arrayIndices:o}),Object.keys(this.queries).forEach(function(t){var i=a.queries[t];if(!i.dirty){var o=i.matcher.documentMatches(e),u=o.result,f=s[t];u&&i.distances&&void 0!==o.distance&&i.distances.set(e._id,o.distance),i.cursor.skip||i.cursor.limit?(f||u)&&(n[t]=!0):f&&!u?r._removeFromResults(i,e):!f&&u?r._insertInResults(i,e):f&&u&&r._updateInResults(i,e,c)}})}return e}(),t._recomputeResults=function(){function e(e,t){this.paused?e.dirty=!0:(this.paused||t||(t=e.results),e.distances&&e.distances.clear(),e.results=e.cursor._getRawObjects({distances:e.distances,ordered:e.ordered}),this.paused||r._diffQueryChanges(e.ordered,t,e.results,e,{projectionFn:e.projectionFn}))}return e}(),t._saveOriginal=function(){function e(e,r){this._savedOriginals&&(this._savedOriginals.has(e)||this._savedOriginals.set(e,i.clone(r)))}return e}(),r}();O.Cursor=m,O.ObserveHandle=v,O._CachingChangeObserver=function(){function e(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=r.callbacks&&O._observeChangesCallbacksAreOrdered(r.callbacks);if(y.call(r,\"ordered\")){if(this.ordered=r.ordered,r.callbacks&&r.ordered!==t)throw Error(\"ordered option doesn't match callbacks\")}else{if(!r.callbacks)throw Error(\"must provide ordered or callbacks\");this.ordered=t}var o=r.callbacks||{};this.ordered?(this.docs=new c(s.idStringify),this.applyChange={addedBefore:function(r,t,n){var a=i.clone(t);a._id=r,o.addedBefore&&o.addedBefore.call(e,r,t,n),o.added&&o.added.call(e,r,t),e.docs.putBefore(r,a,n||null)},movedBefore:function(r,t){var n=e.docs.get(r);o.movedBefore&&o.movedBefore.call(e,r,t),e.docs.moveBefore(r,t||null)}}):(this.docs=new O._IdMap,this.applyChange={added:function(r,t){var n=i.clone(t);o.added&&o.added.call(e,r,t),n._id=r,e.docs.set(r,n)}}),this.applyChange.changed=function(r,t){var a=e.docs.get(r);if(!a)throw new Error(\"Unknown id for changed: \"+r);o.changed&&o.changed.call(e,r,i.clone(t)),n.applyChanges(a,t)},this.applyChange.removed=function(r){o.removed&&o.removed.call(e,r),e.docs.remove(r)}}return e}(),O._IdMap=function(e){function r(){return e.call(this,s.idStringify,s.idParse)||this}return(0,p.default)(r,e),r}(a),O.wrapTransform=function(e){if(!e)return null;if(e.__wrappedTransform__)return e;var r=function(r){if(!y.call(r,\"_id\"))throw new Error(\"can only transform documents with _id\");var t=r._id,n=f.nonreactive(function(){return e(r)});if(!O._isPlainObject(n))throw new Error(\"transform must return object\");if(y.call(n,\"_id\")){if(!i.equals(n._id,t))throw new Error(\"transformed document can't have different _id\")}else n._id=t;return n};return r.__wrappedTransform__=!0,r},O._binarySearch=function(e,r,t){for(var n=0,i=r.length;i>0;){var o=Math.floor(i/2);e(t,r[n+o])>=0?(n+=o+1,i-=o+1):i=o}return n},O._checkSupportedProjection=function(e){if(e!==Object(e)||Array.isArray(e))throw g(\"fields option must be an object\");Object.keys(e).forEach(function(r){if(r.split(\".\").includes(\"$\"))throw g(\"Minimongo doesn't support $ operator in projections yet.\");var t=e[r];if(\"object\"===(0,h.default)(t)&&[\"$elemMatch\",\"$meta\",\"$slice\"].some(function(e){return y.call(t,e)}))throw g(\"Minimongo doesn't support operators in projections yet.\");if(![1,0,!0,!1].includes(t))throw g(\"Projection values should be one of 1, 0, true, or false\")})},O._compileProjection=function(e){O._checkSupportedProjection(e);var r=void 0===e._id||e._id,t=j(e),n=function(e,r){if(Array.isArray(e))return e.map(function(e){return n(e,r)});var o=t.including?{}:i.clone(e);return Object.keys(r).forEach(function(a){if(y.call(e,a)){var s=r[a];s===Object(s)?e[a]===Object(e[a])&&(o[a]=n(e[a],s)):t.including?o[a]=i.clone(e[a]):delete o[a]}}),o};return function(e){var i=n(e,t.tree);return r&&y.call(e,\"_id\")&&(i._id=e._id),!r&&y.call(i,\"_id\")&&delete i._id,i}},O._createUpsertDocument=function(e,r){var t=$(e),n=O._isModificationMod(r),i={};if(t._id&&(i._id=t._id,delete t._id),O._modify(i,{$set:t}),O._modify(i,r,{isInsert:!0}),n)return i;var o=Object.assign({},r);return i._id&&(o._id=i._id),o},O._diffObjects=function(e,r,t){return n.diffObjects(e,r,t)},O._diffQueryChanges=function(e,r,t,i,o){return n.diffQueryChanges(e,r,t,i,o)},O._diffQueryOrderedChanges=function(e,r,t,i){return n.diffQueryOrderedChanges(e,r,t,i)},O._diffQueryUnorderedChanges=function(e,r,t,i){return n.diffQueryUnorderedChanges(e,r,t,i)},O._findInOrderedResults=function(e,r){if(!e.ordered)throw new Error(\"Can't call _findInOrderedResults on unordered query\");for(var t=0;t<e.results.length;t++)if(e.results[t]===r)return t;throw Error(\"object missing from query\")},O._idsMatchedBySelector=function(e){if(O._selectorIsId(e))return[e];if(!e)return null;if(y.call(e,\"_id\"))return O._selectorIsId(e._id)?[e._id]:e._id&&Array.isArray(e._id.$in)&&e._id.$in.length&&e._id.$in.every(O._selectorIsId)?e._id.$in:null;if(Array.isArray(e.$and))for(var r=0;r<e.$and.length;++r){var t=O._idsMatchedBySelector(e.$and[r]);if(t)return t}return null},O._insertInResults=function(e,r){var t=i.clone(r);if(delete t._id,e.ordered){if(e.sorter){var n=O._insertInSortedList(e.sorter.getComparator({distances:e.distances}),e.results,r),o=e.results[n+1];o=o?o._id:null,e.addedBefore(r._id,e.projectionFn(t),o)}else e.addedBefore(r._id,e.projectionFn(t),null),e.results.push(r);e.added(r._id,e.projectionFn(t))}else e.added(r._id,e.projectionFn(t)),e.results.set(r._id,r)},O._insertInSortedList=function(e,r,t){if(0===r.length)return r.push(t),0;var n=O._binarySearch(e,r,t);return r.splice(n,0,t),n},O._isModificationMod=function(e){var r=!1,t=!1;if(Object.keys(e).forEach(function(e){\"$\"===e.substr(0,1)?r=!0:t=!0}),r&&t)throw new Error(\"Update parameter cannot have both modifier and non-modifier fields.\");return r},O._isPlainObject=function(e){return e&&3===O._f._type(e)},O._modify=function(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!O._isPlainObject(r))throw g(\"Modifier must be an object\");r=i.clone(r);var n=E(r),o=n?i.clone(e):r;if(n){if(Object.keys(r).forEach(function(e){var n=t.isInsert&&\"$setOnInsert\"===e,i=A[n?\"$set\":e],a=r[e];if(!i)throw g(\"Invalid modifier specified \"+e);Object.keys(a).forEach(function(r){var n=a[r];if(\"\"===r)throw g(\"An empty update path is not valid.\");var s=r.split(\".\");if(!s.every(Boolean))throw g(\"The update path '\"+r+\"' contains an empty field name, which is not allowed.\");var c=C(o,s,{arrayIndices:t.arrayIndices,forbidArray:\"$rename\"===e,noCreate:k[e]});i(c,s.pop(),n,r,o)})}),e._id&&!i.equals(e._id,o._id))throw g('After applying the update to the document {_id: \"'+e._id+\"\\\", ...}, the (immutable) field '_id' was found to have been altered to _id: \\\"\"+o._id+'\"')}else{if(e._id&&r._id&&!i.equals(e._id,r._id))throw g('The _id field cannot be changed from {_id: \"'+e._id+'\"} to {_id: \"'+r._id+'\"}');S(r)}Object.keys(e).forEach(function(r){\"_id\"!==r&&delete e[r]}),Object.keys(o).forEach(function(r){e[r]=o[r]})},O._observeFromObserveChanges=function(e,r){var t=e.getTransform()||function(e){return e},o=!!r._suppress_initial,a;if(O._observeCallbacksAreOrdered(r)){var s=!r._no_indices;a={addedBefore:function(e,n,i){if(!o&&(r.addedAt||r.added)){var a=t(Object.assign(n,{_id:e}));r.addedAt?r.addedAt(a,s?i?this.docs.indexOf(i):this.docs.size():-1,i):r.added(a)}},changed:function(e,o){if(r.changedAt||r.changed){var a=i.clone(this.docs.get(e));if(!a)throw new Error(\"Unknown id for changed: \"+e);var c=t(i.clone(a));n.applyChanges(a,o),r.changedAt?r.changedAt(t(a),c,s?this.docs.indexOf(e):-1):r.changed(t(a),c)}},movedBefore:function(e,n){if(r.movedTo){var o=s?this.docs.indexOf(e):-1,a=s?n?this.docs.indexOf(n):this.docs.size():-1;a>o&&--a,r.movedTo(t(i.clone(this.docs.get(e))),o,a,n||null)}},removed:function(e){if(r.removedAt||r.removed){var n=t(this.docs.get(e));r.removedAt?r.removedAt(n,s?this.docs.indexOf(e):-1):r.removed(n)}}}}else a={added:function(e,n){!o&&r.added&&r.added(t(Object.assign(n,{_id:e})))},changed:function(e,o){if(r.changed){var a=this.docs.get(e),s=i.clone(a);n.applyChanges(s,o),r.changed(t(s),t(i.clone(a)))}},removed:function(e){r.removed&&r.removed(t(this.docs.get(e)))}};var c=new O._CachingChangeObserver({callbacks:a}),u=e.observeChanges(c.applyChange);return o=!1,u},O._observeCallbacksAreOrdered=function(e){if(e.added&&e.addedAt)throw new Error(\"Please specify only one of added() and addedAt()\");if(e.changed&&e.changedAt)throw new Error(\"Please specify only one of changed() and changedAt()\");if(e.removed&&e.removedAt)throw new Error(\"Please specify only one of removed() and removedAt()\");return!!(e.addedAt||e.changedAt||e.movedTo||e.removedAt)},O._observeChangesCallbacksAreOrdered=function(e){if(e.added&&e.addedBefore)throw new Error(\"Please specify only one of added() and addedBefore()\");return!(!e.addedBefore&&!e.movedBefore)},O._removeFromResults=function(e,r){if(e.ordered){var t=O._findInOrderedResults(e,r);e.removed(r._id),e.results.splice(t,1)}else{var n=r._id;e.removed(r._id),e.results.remove(n)}},O._selectorIsId=function(e){return\"number\"==typeof e||\"string\"==typeof e||e instanceof s.ObjectID},O._selectorIsIdPerhapsAsObject=function(e){return O._selectorIsId(e)||O._selectorIsId(e&&e._id)&&1===Object.keys(e).length},O._updateInResults=function(e,r,t){if(!i.equals(r._id,t._id))throw new Error(\"Can't change a doc's _id while updating\");var o=e.projectionFn,a=n.makeChangedFields(o(r),o(t));if(e.ordered){var s=O._findInOrderedResults(e,r);if(Object.keys(a).length&&e.changed(r._id,a),e.sorter){e.results.splice(s,1);var c=O._insertInSortedList(e.sorter.getComparator({distances:e.distances}),e.results,r);if(s!==c){var u=e.results[c+1];u=u?u._id:null,e.movedBefore&&e.movedBefore(r._id,u)}}}else Object.keys(a).length&&(e.changed(r._id,a),e.results.set(r._id,r))};var A={$currentDate:function(e,r,t){if(\"object\"===(0,h.default)(t)&&y.call(t,\"$type\")){if(\"date\"!==t.$type)throw g(\"Minimongo does currently only support the date type in $currentDate modifiers\",{field:r})}else if(!0!==t)throw g(\"Invalid $currentDate modifier\",{field:r});e[r]=new Date},$min:function(e,r,t){if(\"number\"!=typeof t)throw g(\"Modifier $min allowed for numbers only\",{field:r});if(r in e){if(\"number\"!=typeof e[r])throw g(\"Cannot apply $min modifier to non-number\",{field:r});e[r]>t&&(e[r]=t)}else e[r]=t},$max:function(e,r,t){if(\"number\"!=typeof t)throw g(\"Modifier $max allowed for numbers only\",{field:r});if(r in e){if(\"number\"!=typeof e[r])throw g(\"Cannot apply $max modifier to non-number\",{field:r});e[r]<t&&(e[r]=t)}else e[r]=t},$inc:function(e,r,t){if(\"number\"!=typeof t)throw g(\"Modifier $inc allowed for numbers only\",{field:r});if(r in e){if(\"number\"!=typeof e[r])throw g(\"Cannot apply $inc modifier to non-number\",{field:r});e[r]+=t}else e[r]=t},$set:function(e,r,t){if(e!==Object(e)){var n=g(\"Cannot set property on non-object field\",{field:r});throw n.setPropertyError=!0,n}if(null===e){var i=g(\"Cannot set property on null\",{field:r});throw i.setPropertyError=!0,i}S(t),e[r]=t},$setOnInsert:function(e,r,t){},$unset:function(e,r,t){void 0!==e&&(e instanceof Array?r in e&&(e[r]=null):delete e[r])},$push:function(e,r,t){if(void 0===e[r]&&(e[r]=[]),!(e[r]instanceof Array))throw g(\"Cannot apply $push modifier to non-array\",{field:r});if(!t||!t.$each)return S(t),void e[r].push(t);var n=t.$each;if(!(n instanceof Array))throw g(\"$each must be an array\",{field:r});S(n);var i=void 0;if(\"$position\"in t){if(\"number\"!=typeof t.$position)throw g(\"$position must be a numeric value\",{field:r});if(t.$position<0)throw g(\"$position in $push must be zero or positive\",{field:r});i=t.$position}var o=void 0;if(\"$slice\"in t){if(\"number\"!=typeof t.$slice)throw g(\"$slice must be a numeric value\",{field:r});o=t.$slice}var a=void 0;if(t.$sort){if(void 0===o)throw g(\"$sort requires $slice to be present\",{field:r});a=new w.Sorter(t.$sort).getComparator(),n.forEach(function(e){if(3!==O._f._type(e))throw g(\"$push like modifiers using $sort require all elements to be objects\",{field:r})})}if(void 0===i)n.forEach(function(t){e[r].push(t)});else{var s,c=[i,0];n.forEach(function(e){c.push(e)}),(s=e[r]).splice.apply(s,c)}a&&e[r].sort(a),void 0!==o&&(e[r]=0===o?[]:o<0?e[r].slice(o):e[r].slice(0,o))},$pushAll:function(e,r,t){if(!(\"object\"===(0,h.default)(t)&&t instanceof Array))throw g(\"Modifier $pushAll/pullAll allowed for arrays only\");S(t);var n=e[r];if(void 0===n)e[r]=t;else{if(!(n instanceof Array))throw g(\"Cannot apply $pushAll modifier to non-array\",{field:r});n.push.apply(n,(0,d.default)(t))}},$addToSet:function(e,r,t){var n=!1,i;\"object\"===(0,h.default)(t)&&(\"$each\"===Object.keys(t)[0]&&(n=!0));var o=n?t.$each:[t];S(o);var a=e[r];if(void 0===a)e[r]=o;else{if(!(a instanceof Array))throw g(\"Cannot apply $addToSet modifier to non-array\",{field:r});o.forEach(function(e){a.some(function(r){return O._f._equal(e,r)})||a.push(e)})}},$pop:function(e,r,t){if(void 0!==e){var n=e[r];if(void 0!==n){if(!(n instanceof Array))throw g(\"Cannot apply $pop modifier to non-array\",{field:r});\"number\"==typeof t&&t<0?n.splice(0,1):n.pop()}}},$pull:function(e,r,t){if(void 0!==e){var n=e[r];if(void 0!==n){if(!(n instanceof Array))throw g(\"Cannot apply $pull/pullAll modifier to non-array\",{field:r});var i;if(null==t||\"object\"!==(0,h.default)(t)||t instanceof Array)i=n.filter(function(e){return!O._f._equal(e,t)});else{var o=new w.Matcher(t);i=n.filter(function(e){return!o.documentMatches(e).result})}e[r]=i}}},$pullAll:function(e,r,t){if(!(\"object\"===(0,h.default)(t)&&t instanceof Array))throw g(\"Modifier $pushAll/pullAll allowed for arrays only\",{field:r});if(void 0!==e){var n=e[r];if(void 0!==n){if(!(n instanceof Array))throw g(\"Cannot apply $pull/pullAll modifier to non-array\",{field:r});e[r]=n.filter(function(e){return!t.some(function(r){return O._f._equal(e,r)})})}}},$rename:function(e,r,t,n,i){if(n===t)throw g(\"$rename source must differ from target\",{field:r});if(null===e)throw g(\"$rename source field invalid\",{field:r});if(\"string\"!=typeof t)throw g(\"$rename target must be a string\",{field:r});if(t.includes(\"\\0\"))throw g(\"The 'to' field for $rename cannot contain an embedded null byte\",{field:r});if(void 0!==e){var o=e[r];delete e[r];var a=t.split(\".\"),s=C(i,a,{forbidArray:!0});if(null===s)throw g(\"$rename target field invalid\",{field:r});s[a.pop()]=o}},$bit:function(e,r,t){throw g(\"$bit is not supported\",{field:r})},$v:function(){}},k={$pop:!0,$pull:!0,$pullAll:!0,$rename:!0,$unset:!0},I={$:\"start with '$'\",\".\":\"contain '.'\",\"\\0\":\"contain null bytes\"};function S(e){e&&\"object\"===(0,h.default)(e)&&JSON.stringify(e,function(e,r){return M(e),r})}function M(e){var r;if(\"string\"==typeof e&&(r=e.match(/^\\$|\\.|\\0/)))throw g(\"Key \"+e+\" must not \"+I[r[0]])}function C(e,r){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=!1,i=0;i<r.length;i++){var o=i===r.length-1,a=r[i];if(!_(e)){if(t.noCreate)return;var s=g(\"cannot use the part '\"+a+\"' to traverse \"+e);throw s.setPropertyError=!0,s}if(e instanceof Array){if(t.forbidArray)return null;if(\"$\"===a){if(n)throw g(\"Too many positional (i.e. '$') elements\");if(!t.arrayIndices||!t.arrayIndices.length)throw g(\"The positional operator did not find the match needed from the query\");a=t.arrayIndices[0],n=!0}else{if(!b(a)){if(t.noCreate)return;throw g(\"can't append to array using string field name [\"+a+\"]\")}a=parseInt(a)}if(o&&(r[i]=a),t.noCreate&&a>=e.length)return;for(;e.length<a;)e.push(null);if(!o)if(e.length===a)e.push({});else if(\"object\"!==(0,h.default)(e[a]))throw g(\"can't modify field '\"+r[i+1]+\"' of list value \"+JSON.stringify(e[a]))}else if(M(a),!(a in e)){if(t.noCreate)return;o||(e[a]={})}if(o)return e;e=e[a]}}},\"matcher.js\":function(e,r,t){var n,o,a,c;t.export({default:function(){return u}}),t.link(\"./local_collection.js\",{default:function(e){n=e}},0),t.link(\"./common.js\",{compileDocumentSelector:function(e){o=e},hasOwn:function(e){a=e},nothingMatcher:function(e){c=e}},1);var u=function(){function e(e,r){this._paths={},this._hasGeoQuery=!1,this._hasWhere=!1,this._isSimple=!0,this._matchingDocument=void 0,this._selector=null,this._docMatcher=this._compileSelector(e),this._isUpdate=r}var r=e.prototype;return r.documentMatches=function(){function e(e){if(e!==Object(e))throw Error(\"documentMatches needs a document\");return this._docMatcher(e)}return e}(),r.hasGeoQuery=function(){function e(){return this._hasGeoQuery}return e}(),r.hasWhere=function(){function e(){return this._hasWhere}return e}(),r.isSimple=function(){function e(){return this._isSimple}return e}(),r._compileSelector=function(){function e(e){if(e instanceof Function)return this._isSimple=!1,this._selector=e,this._recordPathUsed(\"\"),function(r){return{result:!!e.call(r)}};if(n._selectorIsId(e))return this._selector={_id:e},this._recordPathUsed(\"_id\"),function(r){return{result:i.equals(r._id,e)}};if(!e||a.call(e,\"_id\")&&!e._id)return this._isSimple=!1,c;if(Array.isArray(e)||i.isBinary(e)||\"boolean\"==typeof e)throw new Error(\"Invalid selector: \"+e);return this._selector=i.clone(e),o(e,this,{isRoot:!0})}return e}(),r._getPaths=function(){function e(){return Object.keys(this._paths)}return e}(),r._recordPathUsed=function(){function e(e){this._paths[e]=!0}return e}(),e}();n._f={_type:function(e){return\"number\"==typeof e?1:\"string\"==typeof e?2:\"boolean\"==typeof e?8:Array.isArray(e)?4:null===e?10:e instanceof RegExp?11:\"function\"==typeof e?13:e instanceof Date?9:i.isBinary(e)?5:e instanceof s.ObjectID?7:3},_equal:function(e,r){return i.equals(e,r,{keyOrderSensitive:!0})},_typeorder:function(e){return[-1,1,2,3,4,5,-1,6,7,8,0,9,-1,100,2,100,1,8,1][e]},_cmp:function(e,r){if(void 0===e)return void 0===r?0:-1;if(void 0===r)return 1;var t=n._f._type(e),i=n._f._type(r),o=n._f._typeorder(t),a=n._f._typeorder(i);if(o!==a)return o<a?-1:1;if(t!==i)throw Error(\"Missing type coercion logic in _cmp\");if(7===t&&(t=i=2,e=e.toHexString(),r=r.toHexString()),9===t&&(t=i=1,e=e.getTime(),r=r.getTime()),1===t)return e-r;if(2===i)return e<r?-1:e===r?0:1;if(3===t){var s=function(e){var r=[];return Object.keys(e).forEach(function(t){r.push(t,e[t])}),r};return n._f._cmp(s(e),s(r))}if(4===t)for(var c=0;;c++){if(c===e.length)return c===r.length?0:-1;if(c===r.length)return 1;var u=n._f._cmp(e[c],r[c]);if(0!==u)return u}if(5===t){if(e.length!==r.length)return e.length-r.length;for(var f=0;f<e.length;f++){if(e[f]<r[f])return-1;if(e[f]>r[f])return 1}return 0}if(8===t)return e?r?0:1:r?-1:0;if(10===t)return 0;if(11===t)throw Error(\"Sorting not supported on regular expression\");if(13===t)throw Error(\"Sorting not supported on Javascript code\");throw Error(\"Unknown type to sort\")}}},\"minimongo_common.js\":function(e,r,t){var n,i,o;t.link(\"./local_collection.js\",{default:function(e){n=e}},0),t.link(\"./matcher.js\",{default:function(e){i=e}},1),t.link(\"./sorter.js\",{default:function(e){o=e}},2),b=n,w={LocalCollection:n,Matcher:i,Sorter:o}},\"observe_handle.js\":function(e,r,t){t.export({default:function(){return n}});var n=function(){function e(){}return e}()},\"sorter.js\":function(e,r,t){var n,i=e(\"@babel/runtime/helpers/interopRequireDefault\")(e(\"@babel/runtime/helpers/typeof\")),o,a,s,c,u,f,l;t.export({default:function(){return d}}),t.link(\"./common.js\",{ELEMENT_OPERATORS:function(e){o=e},equalityElementMatcher:function(e){a=e},expandArraysInBranches:function(e){s=e},hasOwn:function(e){c=e},isOperatorObject:function(e){u=e},makeLookupFunction:function(e){f=e},regexpElementMatcher:function(e){l=e}},0);var d=function(){function e(e){var r=this;this._sortSpecParts=[],this._sortFunction=null;var t=function(e,t){if(!e)throw Error(\"sort keys must be non-empty\");if(\"$\"===e.charAt(0))throw Error(\"unsupported sort key: \"+e);r._sortSpecParts.push({ascending:t,lookup:f(e,{forSort:!0}),path:e})};if(e instanceof Array)e.forEach(function(e){\"string\"==typeof e?t(e,!0):t(e[0],\"desc\"!==e[1])});else if(\"object\"===(0,i.default)(e))Object.keys(e).forEach(function(r){t(r,e[r]>=0)});else{if(\"function\"!=typeof e)throw Error(\"Bad sort specification: \"+JSON.stringify(e));this._sortFunction=e}if(!this._sortFunction){if(this.affectedByModifier){var n={};this._sortSpecParts.forEach(function(e){n[e.path]=1}),this._selectorForAffectedByModifier=new w.Matcher(n)}this._keyComparator=h(this._sortSpecParts.map(function(e,t){return r._keyFieldComparator(t)}))}}var r=e.prototype;return r.getComparator=function(){function e(e){if(this._sortSpecParts.length||!e||!e.distances)return this._getBaseComparator();var r=e.distances;return function(e,t){if(!r.has(e._id))throw Error(\"Missing distance for \"+e._id);if(!r.has(t._id))throw Error(\"Missing distance for \"+t._id);return r.get(e._id)-r.get(t._id)}}return e}(),r._compareKeys=function(){function e(e,r){if(e.length!==this._sortSpecParts.length||r.length!==this._sortSpecParts.length)throw Error(\"Key has wrong length\");return this._keyComparator(e,r)}return e}(),r._generateKeysFromDoc=function(){function e(e,r){if(0===this._sortSpecParts.length)throw new Error(\"can't generate keys without a spec\");var t=function(e){return e.join(\",\")+\",\"},n=null,i=this._sortSpecParts.map(function(r){var i=s(r.lookup(e),!0);i.length||(i=[{value:void 0}]);var o=Object.create(null),a=!1;if(i.forEach(function(e){if(e.arrayIndices){a=!0;var r=t(e.arrayIndices);if(c.call(o,r))throw Error(\"duplicate path: \"+r);if(o[r]=e.value,n&&!c.call(n,r))throw Error(\"cannot index parallel arrays\")}else{if(i.length>1)throw Error(\"multiple branches but no array used?\");o[\"\"]=e.value}}),n){if(!c.call(o,\"\")&&Object.keys(n).length!==Object.keys(o).length)throw Error(\"cannot index parallel arrays!\")}else a&&(n={},Object.keys(o).forEach(function(e){n[e]=!0}));return o});if(n)Object.keys(n).forEach(function(e){var t=i.map(function(r){if(c.call(r,\"\"))return r[\"\"];if(!c.call(r,e))throw Error(\"missing path?\");return r[e]});r(t)});else{var o=i.map(function(e){if(!c.call(e,\"\"))throw Error(\"no value in sole key case?\");return e[\"\"]});r(o)}}return e}(),r._getBaseComparator=function(){function e(){var e=this;return this._sortFunction?this._sortFunction:this._sortSpecParts.length?function(r,t){var n=e._getMinKeyFromDoc(r),i=e._getMinKeyFromDoc(t);return e._compareKeys(n,i)}:function(e,r){return 0}}return e}(),r._getMinKeyFromDoc=function(){function e(e){var r=this,t=null;return this._generateKeysFromDoc(e,function(e){null!==t?r._compareKeys(e,t)<0&&(t=e):t=e}),t}return e}(),r._getPaths=function(){function e(){return this._sortSpecParts.map(function(e){return e.path})}return e}(),r._keyFieldComparator=function(){function e(e){var r=!this._sortSpecParts[e].ascending;return function(t,n){var i=b._f._cmp(t[e],n[e]);return r?-i:i}}return e}(),e}();function h(e){return function(r,t){for(var n=0;n<e.length;++n){var i=e[n](r,t);if(0!==i)return i}return 0}}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/minimongo/minimongo_client.js\");Package._define(\"minimongo\",$,{LocalCollection:b,Minimongo:w,MinimongoTest:_,MinimongoError:g})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/minimongo/minimongo_client.js\",\"packages/minimongo/common.js\",\"packages/minimongo/cursor.js\",\"packages/minimongo/local_collection.js\",\"packages/minimongo/matcher.js\",\"packages/minimongo/minimongo_common.js\",\"packages/minimongo/observe_handle.js\",\"packages/minimongo/sorter.js\"],\"names\":[\"module\",\"link\",\"LocalCollection\",\"export\",\"hasOwn\",\"ELEMENT_OPERATORS\",\"compileDocumentSelector\",\"equalityElementMatcher\",\"expandArraysInBranches\",\"isIndexable\",\"isNumericKey\",\"isOperatorObject\",\"makeLookupFunction\",\"nothingMatcher\",\"pathsToTree\",\"populateDocumentWithQueryFields\",\"projectionDetails\",\"regexpElementMatcher\",\"default\",\"v\",\"Object\",\"prototype\",\"hasOwnProperty\",\"$lt\",\"makeInequality\",\"cmpValue\",\"$gt\",\"$lte\",\"$gte\",\"$mod\",\"compileElementSelector\",\"operand\",\"Array\",\"isArray\",\"length\",\"Error\",\"divisor\",\"remainder\",\"value\",\"$in\",\"elementMatchers\",\"map\",\"option\",\"RegExp\",\"undefined\",\"some\",\"matcher\",\"$size\",\"dontExpandLeafArrays\",\"$type\",\"dontIncludeLeafArrays\",\"operandAliasMap\",\"double\",\"string\",\"object\",\"array\",\"binData\",\"objectId\",\"bool\",\"date\",\"null\",\"regex\",\"dbPointer\",\"javascript\",\"symbol\",\"javascriptWithScope\",\"int\",\"timestamp\",\"long\",\"decimal\",\"minKey\",\"maxKey\",\"call\",\"_f\",\"_type\",\"$bitsAllSet\",\"mask\",\"getOperandBitmask\",\"bitmask\",\"getValueBitmask\",\"every\",\"byte\",\"i\",\"$bitsAnySet\",\"$bitsAllClear\",\"$bitsAnyClear\",\"$regex\",\"valueSelector\",\"regexp\",\"$options\",\"test\",\"source\",\"$elemMatch\",\"_isPlainObject\",\"isDocMatcher\",\"keys\",\"filter\",\"key\",\"LOGICAL_OPERATORS\",\"reduce\",\"a\",\"b\",\"_Object$assign\",\"assign\",\"subMatcher\",\"inElemMatch\",\"compileValueSelector\",\"arrayElement\",\"arg\",\"dontIterate\",\"result\",\"$and\",\"subSelector\",\"andDocumentMatchers\",\"compileArrayOfDocumentSelectors\",\"$or\",\"matchers\",\"doc\",\"fn\",\"$nor\",\"$where\",\"selectorValue\",\"_recordPathUsed\",\"_hasWhere\",\"Function\",\"$comment\",\"VALUE_OPERATORS\",\"$eq\",\"convertElementMatcherToBranchedMatcher\",\"$not\",\"invertBranchedMatcher\",\"$ne\",\"$nin\",\"$exists\",\"exists\",\"everythingMatcher\",\"$maxDistance\",\"$near\",\"$all\",\"branchedMatchers\",\"criterion\",\"andBranchedMatchers\",\"isRoot\",\"maxDistance\",\"point\",\"distance\",\"_hasGeoQuery\",\"$geometry\",\"type\",\"GeoJSON\",\"pointDistance\",\"geometryWithinRadius\",\"coordinates\",\"pointToArray\",\"distanceCoordinatePairs\",\"branchedValues\",\"branch\",\"curDistance\",\"_isUpdate\",\"_typeof2\",\"arrayIndices\",\"andSomeMatchers\",\"subMatchers\",\"docOrBranches\",\"match\",\"subResult\",\"selectors\",\"docSelector\",\"options\",\"arguments\",\"docMatchers\",\"substr\",\"_isSimple\",\"lookUpByIndex\",\"valueMatcher\",\"Boolean\",\"operatorBranchedMatcher\",\"elementMatcher\",\"branches\",\"expanded\",\"element\",\"matched\",\"pointA\",\"pointB\",\"Math\",\"hypot\",\"elementSelector\",\"_equal\",\"docOrBranchedValues\",\"skipTheArrays\",\"branchesOut\",\"forEach\",\"thisIsArray\",\"push\",\"concat\",\"selector\",\"Number\",\"isInteger\",\"Uint8Array\",\"Int32Array\",\"buffer\",\"EJSON\",\"isBinary\",\"x\",\"ArrayBuffer\",\"max\",\"apply\",\"_toConsumableArray2\",\"view\",\"isSafeInteger\",\"Uint32Array\",\"BYTES_PER_ELEMENT\",\"insertIntoDocument\",\"document\",\"existingKey\",\"indexOf\",\"branchedMatcher\",\"branchValues\",\"obj\",\"s\",\"inconsistentOK\",\"theseAreOperators\",\"selKey\",\"thisIsOperator\",\"JSON\",\"stringify\",\"cmpValueComparator\",\"operandType\",\"_cmp\",\"parts\",\"split\",\"firstPart\",\"lookupRest\",\"slice\",\"join\",\"omitUnnecessaryFields\",\"firstLevel\",\"appendToResult\",\"more\",\"forSort\",\"arrayIndex\",\"operatorMatchers\",\"operator\",\"simpleRange\",\"includes\",\"simpleEquality\",\"simpleInclusion\",\"paths\",\"newLeafFn\",\"conflictFn\",\"root\",\"path\",\"pathArray\",\"tree\",\"success\",\"lastKey\",\"y\",\"populateDocumentWithKeyValue\",\"getPrototypeOf\",\"populateDocumentWithObject\",\"unprefixedKeys\",\"op\",\"validateObject\",\"query\",\"_selectorIsId\",\"fields\",\"fieldsKeys\",\"sort\",\"_id\",\"including\",\"keyPath\",\"rule\",\"MinimongoError\",\"projectionRulesTree\",\"node\",\"fullPath\",\"currentPath\",\"anotherPath\",\"toString\",\"lastIndex\",\"validateKeyInPath\",\"MinimongoTest\",\"message\",\"field\",\"error\",\"name\",\"Cursor\",\"collection\",\"this\",\"sorter\",\"Minimongo\",\"Matcher\",\"_selectorIsIdPerhapsAsObject\",\"_selectorId\",\"hasGeoQuery\",\"Sorter\",\"skip\",\"limit\",\"_projectionFn\",\"_compileProjection\",\"_transform\",\"wrapTransform\",\"transform\",\"Tracker\",\"reactive\",\"count\",\"applySkipLimit\",\"_depend\",\"added\",\"removed\",\"_getRawObjects\",\"ordered\",\"fetch\",\"Symbol\",\"iterator\",\"_this\",\"addedBefore\",\"changed\",\"movedBefore\",\"index\",\"objects\",\"next\",\"done\",\"callback\",\"thisArg\",\"_this2\",\"getTransform\",\"_this3\",\"observe\",\"_observeFromObserveChanges\",\"observeChanges\",\"_this4\",\"_observeChangesCallbacksAreOrdered\",\"_allow_unordered\",\"distances\",\"cursor\",\"dirty\",\"_IdMap\",\"projectionFn\",\"resultsSnapshot\",\"qid\",\"next_qid\",\"queries\",\"results\",\"paused\",\"wrapCallback\",\"self\",\"_this5\",\"args\",\"_observeQueue\",\"queueTask\",\"_suppress_initial\",\"clone\",\"handle\",\"ObserveHandle\",\"stop\",\"active\",\"onInvalidate\",\"drain\",\"rewind\",\"changers\",\"dependency\",\"Dependency\",\"notify\",\"bind\",\"depend\",\"_getCollectionName\",\"_this6\",\"selectedDoc\",\"_docs\",\"get\",\"set\",\"clear\",\"id\",\"matchResult\",\"documentMatches\",\"getComparator\",\"_publishCursor\",\"subscription\",\"Package\",\"mongo\",\"Mongo\",\"Collection\",\"Meteor\",\"_SynchronousQueue\",\"create\",\"_savedOriginals\",\"find\",\"findOne\",\"insert\",\"assertHasValidFieldNames\",\"_useOID\",\"MongoID\",\"ObjectID\",\"Random\",\"has\",\"_saveOriginal\",\"queriesToRecompute\",\"_insertInResults\",\"_recomputeResults\",\"defer\",\"pauseObservers\",\"remove\",\"equals\",\"size\",\"_eachPossiblyMatchingDoc\",\"queryRemove\",\"_loop\",\"removeId\",\"removeDoc\",\"_removeFromResults\",\"resumeObservers\",\"_diffQueryChanges\",\"retrieveOriginals\",\"originals\",\"saveOriginals\",\"update\",\"mod\",\"qidToOriginalResults\",\"docMap\",\"idsMatched\",\"_idsMatchedBySelector\",\"memoizedCloneIfNeeded\",\"docToMemoize\",\"recomputeQids\",\"updateCount\",\"insertedId\",\"queryResult\",\"_modifyAndNotify\",\"multi\",\"upsert\",\"_createUpsertDocument\",\"_returnObject\",\"numberAffected\",\"specificIds\",\"_this7\",\"matched_before\",\"old_doc\",\"_modify\",\"afterMatch\",\"after\",\"before\",\"_updateInResults\",\"oldResults\",\"_CachingChangeObserver\",\"_this8\",\"orderedFromCallbacks\",\"callbacks\",\"docs\",\"OrderedDict\",\"idStringify\",\"applyChange\",\"putBefore\",\"moveBefore\",\"DiffSequence\",\"applyChanges\",\"_IdMap2\",\"idParse\",\"_inheritsLoose2\",\"IdMap\",\"__wrappedTransform__\",\"wrapped\",\"transformed\",\"nonreactive\",\"_binarySearch\",\"cmp\",\"first\",\"range\",\"halfRange\",\"floor\",\"_checkSupportedProjection\",\"_idProjection\",\"details\",\"ruleTree\",\"subdoc\",\"modifier\",\"selectorDocument\",\"isModify\",\"_isModificationMod\",\"newDoc\",\"$set\",\"isInsert\",\"replacement\",\"_diffObjects\",\"left\",\"right\",\"diffObjects\",\"newResults\",\"observer\",\"diffQueryChanges\",\"_diffQueryOrderedChanges\",\"diffQueryOrderedChanges\",\"_diffQueryUnorderedChanges\",\"diffQueryUnorderedChanges\",\"_findInOrderedResults\",\"subIds\",\"_insertInSortedList\",\"splice\",\"isReplace\",\"isModifier\",\"setOnInsert\",\"modFunc\",\"MODIFIERS\",\"keypath\",\"keyparts\",\"target\",\"findModTarget\",\"forbidArray\",\"noCreate\",\"NO_CREATE_MODIFIERS\",\"pop\",\"observeCallbacks\",\"suppressed\",\"observeChangesCallbacks\",\"_observeCallbacksAreOrdered\",\"indices\",\"_no_indices\",\"addedAt\",\"changedAt\",\"oldDoc\",\"movedTo\",\"from\",\"to\",\"removedAt\",\"changeObserver\",\"changedFields\",\"makeChangedFields\",\"old_idx\",\"new_idx\",\"$currentDate\",\"Date\",\"$min\",\"$max\",\"$inc\",\"setPropertyError\",\"$setOnInsert\",\"$unset\",\"$push\",\"$each\",\"toPush\",\"position\",\"$position\",\"$slice\",\"sortFunction\",\"$sort\",\"_target$field\",\"spliceArguments\",\"$pushAll\",\"$addToSet\",\"isEach\",\"values\",\"toAdd\",\"$pop\",\"toPop\",\"$pull\",\"toPull\",\"out\",\"$pullAll\",\"$rename\",\"target2\",\"$bit\",\"$v\",\"invalidCharMsg\",\"$\",\".\",\"\\u0000\",\"assertIsValidFieldName\",\"usedArrayIndex\",\"last\",\"keypart\",\"parseInt\",\"isUpdate\",\"_paths\",\"_matchingDocument\",\"_selector\",\"_docMatcher\",\"_compileSelector\",\"hasWhere\",\"isSimple\",\"_getPaths\",\"keyOrderSensitive\",\"_typeorder\",\"t\",\"ta\",\"tb\",\"oa\",\"ob\",\"toHexString\",\"getTime\",\"toArray\",\"LocalCollection_\",\"spec\",\"_sortSpecParts\",\"_sortFunction\",\"addSpecPart\",\"ascending\",\"charAt\",\"lookup\",\"affectedByModifier\",\"_selectorForAffectedByModifier\",\"_keyComparator\",\"composeComparators\",\"_keyFieldComparator\",\"_getBaseComparator\",\"_compareKeys\",\"key1\",\"key2\",\"_generateKeysFromDoc\",\"cb\",\"pathFromIndices\",\"knownPaths\",\"valuesByIndexAndPath\",\"usedPaths\",\"soleKey\",\"doc1\",\"doc2\",\"_getMinKeyFromDoc\",\"part\",\"invert\",\"compare\",\"comparatorArray\"],\"mappings\":\"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\",\"sourcesContent\":[\"import './minimongo_common.js';\\n\",\"import LocalCollection from './local_collection.js';\\n\\nexport const hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Each element selector contains:\\n//  - compileElementSelector, a function with args:\\n//    - operand - the \\\"right hand side\\\" of the operator\\n//    - valueSelector - the \\\"context\\\" for the operator (so that $regex can find\\n//      $options)\\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\\n//      more things)\\n//    returning a function mapping a single value to bool.\\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\\n//    being called\\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\\n//    expandArraysInBranches if it is called\\nexport const ELEMENT_OPERATORS = {\\n  $lt: makeInequality(cmpValue => cmpValue < 0),\\n  $gt: makeInequality(cmpValue => cmpValue > 0),\\n  $lte: makeInequality(cmpValue => cmpValue <= 0),\\n  $gte: makeInequality(cmpValue => cmpValue >= 0),\\n  $mod: {\\n    compileElementSelector(operand) {\\n      if (!(Array.isArray(operand) && operand.length === 2\\n            && typeof operand[0] === 'number'\\n            && typeof operand[1] === 'number')) {\\n        throw Error('argument to $mod must be an array of two numbers');\\n      }\\n\\n      // XXX could require to be ints or round or something\\n      const divisor = operand[0];\\n      const remainder = operand[1];\\n      return value => (\\n        typeof value === 'number' && value % divisor === remainder\\n      );\\n    },\\n  },\\n  $in: {\\n    compileElementSelector(operand) {\\n      if (!Array.isArray(operand)) {\\n        throw Error('$in needs an array');\\n      }\\n\\n      const elementMatchers = operand.map(option => {\\n        if (option instanceof RegExp) {\\n          return regexpElementMatcher(option);\\n        }\\n\\n        if (isOperatorObject(option)) {\\n          throw Error('cannot nest $ under $in');\\n        }\\n\\n        return equalityElementMatcher(option);\\n      });\\n\\n      return value => {\\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\\n        if (value === undefined) {\\n          value = null;\\n        }\\n\\n        return elementMatchers.some(matcher => matcher(value));\\n      };\\n    },\\n  },\\n  $size: {\\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\\n    // possible value.\\n    dontExpandLeafArrays: true,\\n    compileElementSelector(operand) {\\n      if (typeof operand === 'string') {\\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\\n        // does.\\n        operand = 0;\\n      } else if (typeof operand !== 'number') {\\n        throw Error('$size needs a number');\\n      }\\n\\n      return value => Array.isArray(value) && value.length === operand;\\n    },\\n  },\\n  $type: {\\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\\n    // should *not* include it itself.\\n    dontIncludeLeafArrays: true,\\n    compileElementSelector(operand) {\\n      if (typeof operand === 'string') {\\n        const operandAliasMap = {\\n          'double': 1,\\n          'string': 2,\\n          'object': 3,\\n          'array': 4,\\n          'binData': 5,\\n          'undefined': 6,\\n          'objectId': 7,\\n          'bool': 8,\\n          'date': 9,\\n          'null': 10,\\n          'regex': 11,\\n          'dbPointer': 12,\\n          'javascript': 13,\\n          'symbol': 14,\\n          'javascriptWithScope': 15,\\n          'int': 16,\\n          'timestamp': 17,\\n          'long': 18,\\n          'decimal': 19,\\n          'minKey': -1,\\n          'maxKey': 127,\\n        };\\n        if (!hasOwn.call(operandAliasMap, operand)) {\\n          throw Error(`unknown string alias for $type: ${operand}`);\\n        }\\n        operand = operandAliasMap[operand];\\n      } else if (typeof operand === 'number') {\\n        if (operand === 0 || operand < -1\\n          || (operand > 19 && operand !== 127)) {\\n          throw Error(`Invalid numerical $type code: ${operand}`);\\n        }\\n      } else {\\n        throw Error('argument to $type is not a number or a string');\\n      }\\n\\n      return value => (\\n        value !== undefined && LocalCollection._f._type(value) === operand\\n      );\\n    },\\n  },\\n  $bitsAllSet: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAllSet');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.every((byte, i) => (bitmask[i] & byte) === byte);\\n      };\\n    },\\n  },\\n  $bitsAnySet: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAnySet');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.some((byte, i) => (~bitmask[i] & byte) !== byte);\\n      };\\n    },\\n  },\\n  $bitsAllClear: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAllClear');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.every((byte, i) => !(bitmask[i] & byte));\\n      };\\n    },\\n  },\\n  $bitsAnyClear: {\\n    compileElementSelector(operand) {\\n      const mask = getOperandBitmask(operand, '$bitsAnyClear');\\n      return value => {\\n        const bitmask = getValueBitmask(value, mask.length);\\n        return bitmask && mask.some((byte, i) => (bitmask[i] & byte) !== byte);\\n      };\\n    },\\n  },\\n  $regex: {\\n    compileElementSelector(operand, valueSelector) {\\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\\n        throw Error('$regex has to be a string or RegExp');\\n      }\\n\\n      let regexp;\\n      if (valueSelector.$options !== undefined) {\\n        // Options passed in $options (even the empty string) always overrides\\n        // options in the RegExp object itself.\\n\\n        // Be clear that we only support the JS-supported options, not extended\\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\\n        // by transforming the regexp, but not today...\\n        if (/[^gim]/.test(valueSelector.$options)) {\\n          throw new Error('Only the i, m, and g regexp options are supported');\\n        }\\n\\n        const source = operand instanceof RegExp ? operand.source : operand;\\n        regexp = new RegExp(source, valueSelector.$options);\\n      } else if (operand instanceof RegExp) {\\n        regexp = operand;\\n      } else {\\n        regexp = new RegExp(operand);\\n      }\\n\\n      return regexpElementMatcher(regexp);\\n    },\\n  },\\n  $elemMatch: {\\n    dontExpandLeafArrays: true,\\n    compileElementSelector(operand, valueSelector, matcher) {\\n      if (!LocalCollection._isPlainObject(operand)) {\\n        throw Error('$elemMatch need an object');\\n      }\\n\\n      const isDocMatcher = !isOperatorObject(\\n        Object.keys(operand)\\n          .filter(key => !hasOwn.call(LOGICAL_OPERATORS, key))\\n          .reduce((a, b) => Object.assign(a, {[b]: operand[b]}), {}),\\n        true);\\n\\n      let subMatcher;\\n      if (isDocMatcher) {\\n        // This is NOT the same as compileValueSelector(operand), and not just\\n        // because of the slightly different calling convention.\\n        // {$elemMatch: {x: 3}} means \\\"an element has a field x:3\\\", not\\n        // \\\"consists only of a field x:3\\\". Also, regexps and sub-$ are allowed.\\n        subMatcher =\\n          compileDocumentSelector(operand, matcher, {inElemMatch: true});\\n      } else {\\n        subMatcher = compileValueSelector(operand, matcher);\\n      }\\n\\n      return value => {\\n        if (!Array.isArray(value)) {\\n          return false;\\n        }\\n\\n        for (let i = 0; i < value.length; ++i) {\\n          const arrayElement = value[i];\\n          let arg;\\n          if (isDocMatcher) {\\n            // We can only match {$elemMatch: {b: 3}} against objects.\\n            // (We can also match against arrays, if there's numeric indices,\\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\\n            if (!isIndexable(arrayElement)) {\\n              return false;\\n            }\\n\\n            arg = arrayElement;\\n          } else {\\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\\n            // {a: [8]} but not {a: [[8]]}\\n            arg = [{value: arrayElement, dontIterate: true}];\\n          }\\n          // XXX support $near in $elemMatch by propagating $distance?\\n          if (subMatcher(arg).result) {\\n            return i; // specially understood to mean \\\"use as arrayIndices\\\"\\n          }\\n        }\\n\\n        return false;\\n      };\\n    },\\n  },\\n};\\n\\n// Operators that appear at the top level of a document selector.\\nconst LOGICAL_OPERATORS = {\\n  $and(subSelector, matcher, inElemMatch) {\\n    return andDocumentMatchers(\\n      compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch)\\n    );\\n  },\\n\\n  $or(subSelector, matcher, inElemMatch) {\\n    const matchers = compileArrayOfDocumentSelectors(\\n      subSelector,\\n      matcher,\\n      inElemMatch\\n    );\\n\\n    // Special case: if there is only one matcher, use it directly, *preserving*\\n    // any arrayIndices it returns.\\n    if (matchers.length === 1) {\\n      return matchers[0];\\n    }\\n\\n    return doc => {\\n      const result = matchers.some(fn => fn(doc).result);\\n      // $or does NOT set arrayIndices when it has multiple\\n      // sub-expressions. (Tested against MongoDB.)\\n      return {result};\\n    };\\n  },\\n\\n  $nor(subSelector, matcher, inElemMatch) {\\n    const matchers = compileArrayOfDocumentSelectors(\\n      subSelector,\\n      matcher,\\n      inElemMatch\\n    );\\n    return doc => {\\n      const result = matchers.every(fn => !fn(doc).result);\\n      // Never set arrayIndices, because we only match if nothing in particular\\n      // 'matched' (and because this is consistent with MongoDB).\\n      return {result};\\n    };\\n  },\\n\\n  $where(selectorValue, matcher) {\\n    // Record that *any* path may be used.\\n    matcher._recordPathUsed('');\\n    matcher._hasWhere = true;\\n\\n    if (!(selectorValue instanceof Function)) {\\n      // XXX MongoDB seems to have more complex logic to decide where or or not\\n      // to add 'return'; not sure exactly what it is.\\n      selectorValue = Function('obj', `return ${selectorValue}`);\\n    }\\n\\n    // We make the document available as both `this` and `obj`.\\n    // // XXX not sure what we should do if this throws\\n    return doc => ({result: selectorValue.call(doc, doc)});\\n  },\\n\\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\\n  // query logs); it has no effect on the actual selection.\\n  $comment() {\\n    return () => ({result: true});\\n  },\\n};\\n\\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\\n// \\\"match each branched value independently and combine with\\n// convertElementMatcherToBranchedMatcher\\\".\\nconst VALUE_OPERATORS = {\\n  $eq(operand) {\\n    return convertElementMatcherToBranchedMatcher(\\n      equalityElementMatcher(operand)\\n    );\\n  },\\n  $not(operand, valueSelector, matcher) {\\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\\n  },\\n  $ne(operand) {\\n    return invertBranchedMatcher(\\n      convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand))\\n    );\\n  },\\n  $nin(operand) {\\n    return invertBranchedMatcher(\\n      convertElementMatcherToBranchedMatcher(\\n        ELEMENT_OPERATORS.$in.compileElementSelector(operand)\\n      )\\n    );\\n  },\\n  $exists(operand) {\\n    const exists = convertElementMatcherToBranchedMatcher(\\n      value => value !== undefined\\n    );\\n    return operand ? exists : invertBranchedMatcher(exists);\\n  },\\n  // $options just provides options for $regex; its logic is inside $regex\\n  $options(operand, valueSelector) {\\n    if (!hasOwn.call(valueSelector, '$regex')) {\\n      throw Error('$options needs a $regex');\\n    }\\n\\n    return everythingMatcher;\\n  },\\n  // $maxDistance is basically an argument to $near\\n  $maxDistance(operand, valueSelector) {\\n    if (!valueSelector.$near) {\\n      throw Error('$maxDistance needs a $near');\\n    }\\n\\n    return everythingMatcher;\\n  },\\n  $all(operand, valueSelector, matcher) {\\n    if (!Array.isArray(operand)) {\\n      throw Error('$all requires array');\\n    }\\n\\n    // Not sure why, but this seems to be what MongoDB does.\\n    if (operand.length === 0) {\\n      return nothingMatcher;\\n    }\\n\\n    const branchedMatchers = operand.map(criterion => {\\n      // XXX handle $all/$elemMatch combination\\n      if (isOperatorObject(criterion)) {\\n        throw Error('no $ expressions in $all');\\n      }\\n\\n      // This is always a regexp or equality selector.\\n      return compileValueSelector(criterion, matcher);\\n    });\\n\\n    // andBranchedMatchers does NOT require all selectors to return true on the\\n    // SAME branch.\\n    return andBranchedMatchers(branchedMatchers);\\n  },\\n  $near(operand, valueSelector, matcher, isRoot) {\\n    if (!isRoot) {\\n      throw Error('$near can\\\\'t be inside another $ operator');\\n    }\\n\\n    matcher._hasGeoQuery = true;\\n\\n    // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\\n    // marked with a $geometry property, though legacy coordinates can be\\n    // matched using $geometry.\\n    let maxDistance, point, distance;\\n    if (LocalCollection._isPlainObject(operand) && hasOwn.call(operand, '$geometry')) {\\n      // GeoJSON \\\"2dsphere\\\" mode.\\n      maxDistance = operand.$maxDistance;\\n      point = operand.$geometry;\\n      distance = value => {\\n        // XXX: for now, we don't calculate the actual distance between, say,\\n        // polygon and circle. If people care about this use-case it will get\\n        // a priority.\\n        if (!value) {\\n          return null;\\n        }\\n\\n        if (!value.type) {\\n          return GeoJSON.pointDistance(\\n            point,\\n            {type: 'Point', coordinates: pointToArray(value)}\\n          );\\n        }\\n\\n        if (value.type === 'Point') {\\n          return GeoJSON.pointDistance(point, value);\\n        }\\n\\n        return GeoJSON.geometryWithinRadius(value, point, maxDistance)\\n          ? 0\\n          : maxDistance + 1;\\n      };\\n    } else {\\n      maxDistance = valueSelector.$maxDistance;\\n\\n      if (!isIndexable(operand)) {\\n        throw Error('$near argument must be coordinate pair or GeoJSON');\\n      }\\n\\n      point = pointToArray(operand);\\n\\n      distance = value => {\\n        if (!isIndexable(value)) {\\n          return null;\\n        }\\n\\n        return distanceCoordinatePairs(point, value);\\n      };\\n    }\\n\\n    return branchedValues => {\\n      // There might be multiple points in the document that match the given\\n      // field. Only one of them needs to be within $maxDistance, but we need to\\n      // evaluate all of them and use the nearest one for the implicit sort\\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\\n      //\\n      // Note: This differs from MongoDB's implementation, where a document will\\n      // actually show up *multiple times* in the result set, with one entry for\\n      // each within-$maxDistance branching point.\\n      const result = {result: false};\\n      expandArraysInBranches(branchedValues).every(branch => {\\n        // if operation is an update, don't skip branches, just return the first\\n        // one (#3599)\\n        let curDistance;\\n        if (!matcher._isUpdate) {\\n          if (!(typeof branch.value === 'object')) {\\n            return true;\\n          }\\n\\n          curDistance = distance(branch.value);\\n\\n          // Skip branches that aren't real points or are too far away.\\n          if (curDistance === null || curDistance > maxDistance) {\\n            return true;\\n          }\\n\\n          // Skip anything that's a tie.\\n          if (result.distance !== undefined && result.distance <= curDistance) {\\n            return true;\\n          }\\n        }\\n\\n        result.result = true;\\n        result.distance = curDistance;\\n\\n        if (branch.arrayIndices) {\\n          result.arrayIndices = branch.arrayIndices;\\n        } else {\\n          delete result.arrayIndices;\\n        }\\n\\n        return !matcher._isUpdate;\\n      });\\n\\n      return result;\\n    };\\n  },\\n};\\n\\n// NB: We are cheating and using this function to implement 'AND' for both\\n// 'document matchers' and 'branched matchers'. They both return result objects\\n// but the argument is different: for the former it's a whole doc, whereas for\\n// the latter it's an array of 'branched values'.\\nfunction andSomeMatchers(subMatchers) {\\n  if (subMatchers.length === 0) {\\n    return everythingMatcher;\\n  }\\n\\n  if (subMatchers.length === 1) {\\n    return subMatchers[0];\\n  }\\n\\n  return docOrBranches => {\\n    const match = {};\\n    match.result = subMatchers.every(fn => {\\n      const subResult = fn(docOrBranches);\\n\\n      // Copy a 'distance' number out of the first sub-matcher that has\\n      // one. Yes, this means that if there are multiple $near fields in a\\n      // query, something arbitrary happens; this appears to be consistent with\\n      // Mongo.\\n      if (subResult.result &&\\n          subResult.distance !== undefined &&\\n          match.distance === undefined) {\\n        match.distance = subResult.distance;\\n      }\\n\\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\\n      // wins.\\n      if (subResult.result && subResult.arrayIndices) {\\n        match.arrayIndices = subResult.arrayIndices;\\n      }\\n\\n      return subResult.result;\\n    });\\n\\n    // If we didn't actually match, forget any extra metadata we came up with.\\n    if (!match.result) {\\n      delete match.distance;\\n      delete match.arrayIndices;\\n    }\\n\\n    return match;\\n  };\\n}\\n\\nconst andDocumentMatchers = andSomeMatchers;\\nconst andBranchedMatchers = andSomeMatchers;\\n\\nfunction compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\\n  if (!Array.isArray(selectors) || selectors.length === 0) {\\n    throw Error('$and/$or/$nor must be nonempty array');\\n  }\\n\\n  return selectors.map(subSelector => {\\n    if (!LocalCollection._isPlainObject(subSelector)) {\\n      throw Error('$or/$and/$nor entries need to be full objects');\\n    }\\n\\n    return compileDocumentSelector(subSelector, matcher, {inElemMatch});\\n  });\\n}\\n\\n// Takes in a selector that could match a full document (eg, the original\\n// selector). Returns a function mapping document->result object.\\n//\\n// matcher is the Matcher object we are compiling.\\n//\\n// If this is the root document selector (ie, not wrapped in $and or the like),\\n// then isRoot is true. (This is used by $near.)\\nexport function compileDocumentSelector(docSelector, matcher, options = {}) {\\n  const docMatchers = Object.keys(docSelector).map(key => {\\n    const subSelector = docSelector[key];\\n\\n    if (key.substr(0, 1) === '$') {\\n      // Outer operators are either logical operators (they recurse back into\\n      // this function), or $where.\\n      if (!hasOwn.call(LOGICAL_OPERATORS, key)) {\\n        throw new Error(`Unrecognized logical operator: ${key}`);\\n      }\\n\\n      matcher._isSimple = false;\\n      return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\\n    }\\n\\n    // Record this path, but only if we aren't in an elemMatcher, since in an\\n    // elemMatch this is a path inside an object in an array, not in the doc\\n    // root.\\n    if (!options.inElemMatch) {\\n      matcher._recordPathUsed(key);\\n    }\\n\\n    // Don't add a matcher if subSelector is a function -- this is to match\\n    // the behavior of Meteor on the server (inherited from the node mongodb\\n    // driver), which is to ignore any part of a selector which is a function.\\n    if (typeof subSelector === 'function') {\\n      return undefined;\\n    }\\n\\n    const lookUpByIndex = makeLookupFunction(key);\\n    const valueMatcher = compileValueSelector(\\n      subSelector,\\n      matcher,\\n      options.isRoot\\n    );\\n\\n    return doc => valueMatcher(lookUpByIndex(doc));\\n  }).filter(Boolean);\\n\\n  return andDocumentMatchers(docMatchers);\\n}\\n\\n// Takes in a selector that could match a key-indexed value in a document; eg,\\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\\n// indicate equality).  Returns a branched matcher: a function mapping\\n// [branched value]->result object.\\nfunction compileValueSelector(valueSelector, matcher, isRoot) {\\n  if (valueSelector instanceof RegExp) {\\n    matcher._isSimple = false;\\n    return convertElementMatcherToBranchedMatcher(\\n      regexpElementMatcher(valueSelector)\\n    );\\n  }\\n\\n  if (isOperatorObject(valueSelector)) {\\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\\n  }\\n\\n  return convertElementMatcherToBranchedMatcher(\\n    equalityElementMatcher(valueSelector)\\n  );\\n}\\n\\n// Given an element matcher (which evaluates a single value), returns a branched\\n// value (which evaluates the element matcher on all the branches and returns a\\n// more structured return value possibly including arrayIndices).\\nfunction convertElementMatcherToBranchedMatcher(elementMatcher, options = {}) {\\n  return branches => {\\n    const expanded = options.dontExpandLeafArrays\\n      ? branches\\n      : expandArraysInBranches(branches, options.dontIncludeLeafArrays);\\n\\n    const match = {};\\n    match.result = expanded.some(element => {\\n      let matched = elementMatcher(element.value);\\n\\n      // Special case for $elemMatch: it means \\\"true, and use this as an array\\n      // index if I didn't already have one\\\".\\n      if (typeof matched === 'number') {\\n        // XXX This code dates from when we only stored a single array index\\n        // (for the outermost array). Should we be also including deeper array\\n        // indices from the $elemMatch match?\\n        if (!element.arrayIndices) {\\n          element.arrayIndices = [matched];\\n        }\\n\\n        matched = true;\\n      }\\n\\n      // If some element matched, and it's tagged with array indices, include\\n      // those indices in our result object.\\n      if (matched && element.arrayIndices) {\\n        match.arrayIndices = element.arrayIndices;\\n      }\\n\\n      return matched;\\n    });\\n\\n    return match;\\n  };\\n}\\n\\n// Helpers for $near.\\nfunction distanceCoordinatePairs(a, b) {\\n  const pointA = pointToArray(a);\\n  const pointB = pointToArray(b);\\n\\n  return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\\n}\\n\\n// Takes something that is not an operator object and returns an element matcher\\n// for equality with that thing.\\nexport function equalityElementMatcher(elementSelector) {\\n  if (isOperatorObject(elementSelector)) {\\n    throw Error('Can\\\\'t create equalityValueSelector for operator object');\\n  }\\n\\n  // Special-case: null and undefined are equal (if you got undefined in there\\n  // somewhere, or if you got it due to some branch being non-existent in the\\n  // weird special case), even though they aren't with EJSON.equals.\\n  // undefined or null\\n  if (elementSelector == null) {\\n    return value => value == null;\\n  }\\n\\n  return value => LocalCollection._f._equal(elementSelector, value);\\n}\\n\\nfunction everythingMatcher(docOrBranchedValues) {\\n  return {result: true};\\n}\\n\\nexport function expandArraysInBranches(branches, skipTheArrays) {\\n  const branchesOut = [];\\n\\n  branches.forEach(branch => {\\n    const thisIsArray = Array.isArray(branch.value);\\n\\n    // We include the branch itself, *UNLESS* we it's an array that we're going\\n    // to iterate and we're told to skip arrays.  (That's right, we include some\\n    // arrays even skipTheArrays is true: these are arrays that were found via\\n    // explicit numerical indices.)\\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\\n      branchesOut.push({arrayIndices: branch.arrayIndices, value: branch.value});\\n    }\\n\\n    if (thisIsArray && !branch.dontIterate) {\\n      branch.value.forEach((value, i) => {\\n        branchesOut.push({\\n          arrayIndices: (branch.arrayIndices || []).concat(i),\\n          value\\n        });\\n      });\\n    }\\n  });\\n\\n  return branchesOut;\\n}\\n\\n// Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\\nfunction getOperandBitmask(operand, selector) {\\n  // numeric bitmask\\n  // You can provide a numeric bitmask to be matched against the operand field.\\n  // It must be representable as a non-negative 32-bit signed integer.\\n  // Otherwise, $bitsAllSet will return an error.\\n  if (Number.isInteger(operand) && operand >= 0) {\\n    return new Uint8Array(new Int32Array([operand]).buffer);\\n  }\\n\\n  // bindata bitmask\\n  // You can also use an arbitrarily large BinData instance as a bitmask.\\n  if (EJSON.isBinary(operand)) {\\n    return new Uint8Array(operand.buffer);\\n  }\\n\\n  // position list\\n  // If querying a list of bit positions, each <position> must be a non-negative\\n  // integer. Bit positions start at 0 from the least significant bit.\\n  if (Array.isArray(operand) &&\\n      operand.every(x => Number.isInteger(x) && x >= 0)) {\\n    const buffer = new ArrayBuffer((Math.max(...operand) >> 3) + 1);\\n    const view = new Uint8Array(buffer);\\n\\n    operand.forEach(x => {\\n      view[x >> 3] |= 1 << (x & 0x7);\\n    });\\n\\n    return view;\\n  }\\n\\n  // bad operand\\n  throw Error(\\n    `operand to ${selector} must be a numeric bitmask (representable as a ` +\\n    'non-negative 32-bit signed integer), a bindata bitmask or an array with ' +\\n    'bit positions (non-negative integers)'\\n  );\\n}\\n\\nfunction getValueBitmask(value, length) {\\n  // The field value must be either numerical or a BinData instance. Otherwise,\\n  // $bits... will not match the current document.\\n\\n  // numerical\\n  if (Number.isSafeInteger(value)) {\\n    // $bits... will not match numerical values that cannot be represented as a\\n    // signed 64-bit integer. This can be the case if a value is either too\\n    // large or small to fit in a signed 64-bit integer, or if it has a\\n    // fractional component.\\n    const buffer = new ArrayBuffer(\\n      Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT)\\n    );\\n\\n    let view = new Uint32Array(buffer, 0, 2);\\n    view[0] = value % ((1 << 16) * (1 << 16)) | 0;\\n    view[1] = value / ((1 << 16) * (1 << 16)) | 0;\\n\\n    // sign extension\\n    if (value < 0) {\\n      view = new Uint8Array(buffer, 2);\\n      view.forEach((byte, i) => {\\n        view[i] = 0xff;\\n      });\\n    }\\n\\n    return new Uint8Array(buffer);\\n  }\\n\\n  // bindata\\n  if (EJSON.isBinary(value)) {\\n    return new Uint8Array(value.buffer);\\n  }\\n\\n  // no match\\n  return false;\\n}\\n\\n// Actually inserts a key value into the selector document\\n// However, this checks there is no ambiguity in setting\\n// the value for the given key, throws otherwise\\nfunction insertIntoDocument(document, key, value) {\\n  Object.keys(document).forEach(existingKey => {\\n    if (\\n      (existingKey.length > key.length && existingKey.indexOf(`${key}.`) === 0) ||\\n      (key.length > existingKey.length && key.indexOf(`${existingKey}.`) === 0)\\n    ) {\\n      throw new Error(\\n        `cannot infer query fields to set, both paths '${existingKey}' and ` +\\n        `'${key}' are matched`\\n      );\\n    } else if (existingKey === key) {\\n      throw new Error(\\n        `cannot infer query fields to set, path '${key}' is matched twice`\\n      );\\n    }\\n  });\\n\\n  document[key] = value;\\n}\\n\\n// Returns a branched matcher that matches iff the given matcher does not.\\n// Note that this implicitly \\\"deMorganizes\\\" the wrapped function.  ie, it\\n// means that ALL branch values need to fail to match innerBranchedMatcher.\\nfunction invertBranchedMatcher(branchedMatcher) {\\n  return branchValues => {\\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\\n    // say \\\"update the array element that does not match something\\\", at least\\n    // in mongo-land.\\n    return {result: !branchedMatcher(branchValues).result};\\n  };\\n}\\n\\nexport function isIndexable(obj) {\\n  return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\\n}\\n\\nexport function isNumericKey(s) {\\n  return /^[0-9]+$/.test(s);\\n}\\n\\n// Returns true if this is an object with at least one key and all keys begin\\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\\n// others don't.\\nexport function isOperatorObject(valueSelector, inconsistentOK) {\\n  if (!LocalCollection._isPlainObject(valueSelector)) {\\n    return false;\\n  }\\n\\n  let theseAreOperators = undefined;\\n  Object.keys(valueSelector).forEach(selKey => {\\n    const thisIsOperator = selKey.substr(0, 1) === '$';\\n\\n    if (theseAreOperators === undefined) {\\n      theseAreOperators = thisIsOperator;\\n    } else if (theseAreOperators !== thisIsOperator) {\\n      if (!inconsistentOK) {\\n        throw new Error(\\n          `Inconsistent operator: ${JSON.stringify(valueSelector)}`\\n        );\\n      }\\n\\n      theseAreOperators = false;\\n    }\\n  });\\n\\n  return !!theseAreOperators; // {} has no operators\\n}\\n\\n// Helper for $lt/$gt/$lte/$gte.\\nfunction makeInequality(cmpValueComparator) {\\n  return {\\n    compileElementSelector(operand) {\\n      // Arrays never compare false with non-arrays for any inequality.\\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\\n      //     it seems to have been reverted.\\n      //     See https://jira.mongodb.org/browse/SERVER-11444\\n      if (Array.isArray(operand)) {\\n        return () => false;\\n      }\\n\\n      // Special case: consider undefined and null the same (so true with\\n      // $gte/$lte).\\n      if (operand === undefined) {\\n        operand = null;\\n      }\\n\\n      const operandType = LocalCollection._f._type(operand);\\n\\n      return value => {\\n        if (value === undefined) {\\n          value = null;\\n        }\\n\\n        // Comparisons are never true among things of different type (except\\n        // null vs undefined).\\n        if (LocalCollection._f._type(value) !== operandType) {\\n          return false;\\n        }\\n\\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));\\n      };\\n    },\\n  };\\n}\\n\\n// makeLookupFunction(key) returns a lookup function.\\n//\\n// A lookup function takes in a document and returns an array of matching\\n// branches.  If no arrays are found while looking up the key, this array will\\n// have exactly one branches (possibly 'undefined', if some segment of the key\\n// was not found).\\n//\\n// If arrays are found in the middle, this can have more than one element, since\\n// we 'branch'. When we 'branch', if there are more key segments to look up,\\n// then we only pursue branches that are plain objects (not arrays or scalars).\\n// This means we can actually end up with no branches!\\n//\\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\\n// dotted member of the key). We just return that array; if you want to\\n// effectively 'branch' over the array's values, post-process the lookup\\n// function with expandArraysInBranches.\\n//\\n// Each branch is an object with keys:\\n//  - value: the value at the branch\\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\\n//    that expandArraysInBranches should NOT expand. This specifically happens\\n//    when there is a numeric index in the key, and ensures the\\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\\n//    match {a: [[5]]}.\\n//  - arrayIndices: if any array indexing was done during lookup (either due to\\n//    explicit numeric indices or implicit branching), this will be an array of\\n//    the array indices used, from outermost to innermost; it is falsey or\\n//    absent if no array index is used. If an explicit numeric index is used,\\n//    the index will be followed in arrayIndices by the string 'x'.\\n//\\n//    Note: arrayIndices is used for two purposes. First, it is used to\\n//    implement the '$' modifier feature, which only ever looks at its first\\n//    element.\\n//\\n//    Second, it is used for sort key generation, which needs to be able to tell\\n//    the difference between different paths. Moreover, it needs to\\n//    differentiate between explicit and implicit branching, which is why\\n//    there's the somewhat hacky 'x' entry: this means that explicit and\\n//    implicit array lookups will have different full arrayIndices paths. (That\\n//    code only requires that different paths have different arrayIndices; it\\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\\n//    could contain objects with flags like 'implicit', but I think that only\\n//    makes the code surrounding them more complex.)\\n//\\n//    (By the way, this field ends up getting passed around a lot without\\n//    cloning, so never mutate any arrayIndices field/var in this package!)\\n//\\n//\\n// At the top level, you may only pass in a plain object or array.\\n//\\n// See the test 'minimongo - lookup' for some examples of what lookup functions\\n// return.\\nexport function makeLookupFunction(key, options = {}) {\\n  const parts = key.split('.');\\n  const firstPart = parts.length ? parts[0] : '';\\n  const lookupRest = (\\n    parts.length > 1 &&\\n    makeLookupFunction(parts.slice(1).join('.'), options)\\n  );\\n\\n  const omitUnnecessaryFields = result => {\\n    if (!result.dontIterate) {\\n      delete result.dontIterate;\\n    }\\n\\n    if (result.arrayIndices && !result.arrayIndices.length) {\\n      delete result.arrayIndices;\\n    }\\n\\n    return result;\\n  };\\n\\n  // Doc will always be a plain object or an array.\\n  // apply an explicit numeric index, an array.\\n  return (doc, arrayIndices = []) => {\\n    if (Array.isArray(doc)) {\\n      // If we're being asked to do an invalid lookup into an array (non-integer\\n      // or out-of-bounds), return no results (which is different from returning\\n      // a single undefined result, in that `null` equality checks won't match).\\n      if (!(isNumericKey(firstPart) && firstPart < doc.length)) {\\n        return [];\\n      }\\n\\n      // Remember that we used this array index. Include an 'x' to indicate that\\n      // the previous index came from being considered as an explicit array\\n      // index (not branching).\\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\\n    }\\n\\n    // Do our first lookup.\\n    const firstLevel = doc[firstPart];\\n\\n    // If there is no deeper to dig, return what we found.\\n    //\\n    // If what we found is an array, most value selectors will choose to treat\\n    // the elements of the array as matchable values in their own right, but\\n    // that's done outside of the lookup function. (Exceptions to this are $size\\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\\n    // [[1, 2]]}.)\\n    //\\n    // That said, if we just did an *explicit* array lookup (on doc) to find\\n    // firstLevel, and firstLevel is an array too, we do NOT want value\\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\\n    // So in that case, we mark the return value as 'don't iterate'.\\n    if (!lookupRest) {\\n      return [omitUnnecessaryFields({\\n        arrayIndices,\\n        dontIterate: Array.isArray(doc) && Array.isArray(firstLevel),\\n        value: firstLevel\\n      })];\\n    }\\n\\n    // We need to dig deeper.  But if we can't, because what we've found is not\\n    // an array or plain object, we're done. If we just did a numeric index into\\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\\n    // return a single `undefined` (which can, for example, match via equality\\n    // with `null`).\\n    if (!isIndexable(firstLevel)) {\\n      if (Array.isArray(doc)) {\\n        return [];\\n      }\\n\\n      return [omitUnnecessaryFields({arrayIndices, value: undefined})];\\n    }\\n\\n    const result = [];\\n    const appendToResult = more => {\\n      result.push(...more);\\n    };\\n\\n    // Dig deeper: look up the rest of the parts on whatever we've found.\\n    // (lookupRest is smart enough to not try to do invalid lookups into\\n    // firstLevel if it's an array.)\\n    appendToResult(lookupRest(firstLevel, arrayIndices));\\n\\n    // If we found an array, then in *addition* to potentially treating the next\\n    // part as a literal integer lookup, we should also 'branch': try to look up\\n    // the rest of the parts on each array element in parallel.\\n    //\\n    // In this case, we *only* dig deeper into array elements that are plain\\n    // objects. (Recall that we only got this far if we have further to dig.)\\n    // This makes sense: we certainly don't dig deeper into non-indexable\\n    // objects. And it would be weird to dig into an array: it's simpler to have\\n    // a rule that explicit integer indexes only apply to an outer array, not to\\n    // an array you find after a branching search.\\n    //\\n    // In the special case of a numeric part in a *sort selector* (not a query\\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\\n    // 'look up this index' in that case, not 'also look up this index in all\\n    // the elements of the array'.\\n    if (Array.isArray(firstLevel) &&\\n        !(isNumericKey(parts[1]) && options.forSort)) {\\n      firstLevel.forEach((branch, arrayIndex) => {\\n        if (LocalCollection._isPlainObject(branch)) {\\n          appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\\n        }\\n      });\\n    }\\n\\n    return result;\\n  };\\n}\\n\\n// Object exported only for unit testing.\\n// Use it to export private functions to test in Tinytest.\\nMinimongoTest = {makeLookupFunction};\\nMinimongoError = (message, options = {}) => {\\n  if (typeof message === 'string' && options.field) {\\n    message += ` for field '${options.field}'`;\\n  }\\n\\n  const error = new Error(message);\\n  error.name = 'MinimongoError';\\n  return error;\\n};\\n\\nexport function nothingMatcher(docOrBranchedValues) {\\n  return {result: false};\\n}\\n\\n// Takes an operator object (an object with $ keys) and returns a branched\\n// matcher for it.\\nfunction operatorBranchedMatcher(valueSelector, matcher, isRoot) {\\n  // Each valueSelector works separately on the various branches.  So one\\n  // operator can match one branch and another can match another branch.  This\\n  // is OK.\\n  const operatorMatchers = Object.keys(valueSelector).map(operator => {\\n    const operand = valueSelector[operator];\\n\\n    const simpleRange = (\\n      ['$lt', '$lte', '$gt', '$gte'].includes(operator) &&\\n      typeof operand === 'number'\\n    );\\n\\n    const simpleEquality = (\\n      ['$ne', '$eq'].includes(operator) &&\\n      operand !== Object(operand)\\n    );\\n\\n    const simpleInclusion = (\\n      ['$in', '$nin'].includes(operator)\\n      && Array.isArray(operand)\\n      && !operand.some(x => x === Object(x))\\n    );\\n\\n    if (!(simpleRange || simpleInclusion || simpleEquality)) {\\n      matcher._isSimple = false;\\n    }\\n\\n    if (hasOwn.call(VALUE_OPERATORS, operator)) {\\n      return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\\n    }\\n\\n    if (hasOwn.call(ELEMENT_OPERATORS, operator)) {\\n      const options = ELEMENT_OPERATORS[operator];\\n      return convertElementMatcherToBranchedMatcher(\\n        options.compileElementSelector(operand, valueSelector, matcher),\\n        options\\n      );\\n    }\\n\\n    throw new Error(`Unrecognized operator: ${operator}`);\\n  });\\n\\n  return andBranchedMatchers(operatorMatchers);\\n}\\n\\n// paths - Array: list of mongo style paths\\n// newLeafFn - Function: of form function(path) should return a scalar value to\\n//                       put into list created for that path\\n// conflictFn - Function: of form function(node, path, fullPath) is called\\n//                        when building a tree path for 'fullPath' node on\\n//                        'path' was already a leaf with a value. Must return a\\n//                        conflict resolution.\\n// initial tree - Optional Object: starting tree.\\n// @returns - Object: tree represented as a set of nested objects\\nexport function pathsToTree(paths, newLeafFn, conflictFn, root = {}) {\\n  paths.forEach(path => {\\n    const pathArray = path.split('.');\\n    let tree = root;\\n\\n    // use .every just for iteration with break\\n    const success = pathArray.slice(0, -1).every((key, i) => {\\n      if (!hasOwn.call(tree, key)) {\\n        tree[key] = {};\\n      } else if (tree[key] !== Object(tree[key])) {\\n        tree[key] = conflictFn(\\n          tree[key],\\n          pathArray.slice(0, i + 1).join('.'),\\n          path\\n        );\\n\\n        // break out of loop if we are failing for this path\\n        if (tree[key] !== Object(tree[key])) {\\n          return false;\\n        }\\n      }\\n\\n      tree = tree[key];\\n\\n      return true;\\n    });\\n\\n    if (success) {\\n      const lastKey = pathArray[pathArray.length - 1];\\n      if (hasOwn.call(tree, lastKey)) {\\n        tree[lastKey] = conflictFn(tree[lastKey], path, path);\\n      } else {\\n        tree[lastKey] = newLeafFn(path);\\n      }\\n    }\\n  });\\n\\n  return root;\\n}\\n\\n// Makes sure we get 2 elements array and assume the first one to be x and\\n// the second one to y no matter what user passes.\\n// In case user passes { lon: x, lat: y } returns [x, y]\\nfunction pointToArray(point) {\\n  return Array.isArray(point) ? point.slice() : [point.x, point.y];\\n}\\n\\n// Creating a document from an upsert is quite tricky.\\n// E.g. this selector: {\\\"$or\\\": [{\\\"b.foo\\\": {\\\"$all\\\": [\\\"bar\\\"]}}]}, should result\\n// in: {\\\"b.foo\\\": \\\"bar\\\"}\\n// But this selector: {\\\"$or\\\": [{\\\"b\\\": {\\\"foo\\\": {\\\"$all\\\": [\\\"bar\\\"]}}}]} should throw\\n// an error\\n\\n// Some rules (found mainly with trial & error, so there might be more):\\n// - handle all childs of $and (or implicit $and)\\n// - handle $or nodes with exactly 1 child\\n// - ignore $or nodes with more than 1 child\\n// - ignore $nor and $not nodes\\n// - throw when a value can not be set unambiguously\\n// - every value for $all should be dealt with as separate $eq-s\\n// - threat all children of $all as $eq setters (=> set if $all.length === 1,\\n//   otherwise throw error)\\n// - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\\n// - you can only have dotted keys on a root-level\\n// - you can not have '$'-prefixed keys more than one-level deep in an object\\n\\n// Handles one key/value pair to put in the selector document\\nfunction populateDocumentWithKeyValue(document, key, value) {\\n  if (value && Object.getPrototypeOf(value) === Object.prototype) {\\n    populateDocumentWithObject(document, key, value);\\n  } else if (!(value instanceof RegExp)) {\\n    insertIntoDocument(document, key, value);\\n  }\\n}\\n\\n// Handles a key, value pair to put in the selector document\\n// if the value is an object\\nfunction populateDocumentWithObject(document, key, value) {\\n  const keys = Object.keys(value);\\n  const unprefixedKeys = keys.filter(op => op[0] !== '$');\\n\\n  if (unprefixedKeys.length > 0 || !keys.length) {\\n    // Literal (possibly empty) object ( or empty object )\\n    // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\\n    if (keys.length !== unprefixedKeys.length) {\\n      throw new Error(`unknown operator: ${unprefixedKeys[0]}`);\\n    }\\n\\n    validateObject(value, key);\\n    insertIntoDocument(document, key, value);\\n  } else {\\n    Object.keys(value).forEach(op => {\\n      const object = value[op];\\n\\n      if (op === '$eq') {\\n        populateDocumentWithKeyValue(document, key, object);\\n      } else if (op === '$all') {\\n        // every value for $all should be dealt with as separate $eq-s\\n        object.forEach(element =>\\n          populateDocumentWithKeyValue(document, key, element)\\n        );\\n      }\\n    });\\n  }\\n}\\n\\n// Fills a document with certain fields from an upsert selector\\nexport function populateDocumentWithQueryFields(query, document = {}) {\\n  if (Object.getPrototypeOf(query) === Object.prototype) {\\n    // handle implicit $and\\n    Object.keys(query).forEach(key => {\\n      const value = query[key];\\n\\n      if (key === '$and') {\\n        // handle explicit $and\\n        value.forEach(element =>\\n          populateDocumentWithQueryFields(element, document)\\n        );\\n      } else if (key === '$or') {\\n        // handle $or nodes with exactly 1 child\\n        if (value.length === 1) {\\n          populateDocumentWithQueryFields(value[0], document);\\n        }\\n      } else if (key[0] !== '$') {\\n        // Ignore other '$'-prefixed logical selectors\\n        populateDocumentWithKeyValue(document, key, value);\\n      }\\n    });\\n  } else {\\n    // Handle meteor-specific shortcut for selecting _id\\n    if (LocalCollection._selectorIsId(query)) {\\n      insertIntoDocument(document, '_id', query);\\n    }\\n  }\\n\\n  return document;\\n}\\n\\n// Traverses the keys of passed projection and constructs a tree where all\\n// leaves are either all True or all False\\n// @returns Object:\\n//  - tree - Object - tree representation of keys involved in projection\\n//  (exception for '_id' as it is a special case handled separately)\\n//  - including - Boolean - \\\"take only certain fields\\\" type of projection\\nexport function projectionDetails(fields) {\\n  // Find the non-_id keys (_id is handled specially because it is included\\n  // unless explicitly excluded). Sort the keys, so that our code to detect\\n  // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\\n  let fieldsKeys = Object.keys(fields).sort();\\n\\n  // If _id is the only field in the projection, do not remove it, since it is\\n  // required to determine if this is an exclusion or exclusion. Also keep an\\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\\n  // inclusive and exclusive fields. If _id is not the only field in the\\n  // projection and is exclusive, remove it so it can be handled later by a\\n  // special case, since exclusive _id is always allowed.\\n  if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\\n      !(fieldsKeys.includes('_id') && fields._id)) {\\n    fieldsKeys = fieldsKeys.filter(key => key !== '_id');\\n  }\\n\\n  let including = null; // Unknown\\n\\n  fieldsKeys.forEach(keyPath => {\\n    const rule = !!fields[keyPath];\\n\\n    if (including === null) {\\n      including = rule;\\n    }\\n\\n    // This error message is copied from MongoDB shell\\n    if (including !== rule) {\\n      throw MinimongoError(\\n        'You cannot currently mix including and excluding fields.'\\n      );\\n    }\\n  });\\n\\n  const projectionRulesTree = pathsToTree(\\n    fieldsKeys,\\n    path => including,\\n    (node, path, fullPath) => {\\n      // Check passed projection fields' keys: If you have two rules such as\\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\\n      // that happens, there is a probability you are doing something wrong,\\n      // framework should notify you about such mistake earlier on cursor\\n      // compilation step than later during runtime.  Note, that real mongo\\n      // doesn't do anything about it and the later rule appears in projection\\n      // project, more priority it takes.\\n      //\\n      // Example, assume following in mongo shell:\\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\\n      // {\\\"_id\\\": ObjectId(\\\"520bfe456024608e8ef24af3\\\"), \\\"a\\\": {\\\"b\\\": 23}}\\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\\n      // {\\\"_id\\\": ObjectId(\\\"520bfe456024608e8ef24af3\\\"), \\\"a\\\": {\\\"b\\\": 23, \\\"c\\\": 44}}\\n      //\\n      // Note, how second time the return set of keys is different.\\n      const currentPath = fullPath;\\n      const anotherPath = path;\\n      throw MinimongoError(\\n        `both ${currentPath} and ${anotherPath} found in fields option, ` +\\n        'using both of them may trigger unexpected behavior. Did you mean to ' +\\n        'use only one of them?'\\n      );\\n    });\\n\\n  return {including, tree: projectionRulesTree};\\n}\\n\\n// Takes a RegExp object and returns an element matcher.\\nexport function regexpElementMatcher(regexp) {\\n  return value => {\\n    if (value instanceof RegExp) {\\n      return value.toString() === regexp.toString();\\n    }\\n\\n    // Regexps only work against strings.\\n    if (typeof value !== 'string') {\\n      return false;\\n    }\\n\\n    // Reset regexp's state to avoid inconsistent matching for objects with the\\n    // same value on consecutive calls of regexp.test. This happens only if the\\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\\n    // which we should *not* change the lastIndex but MongoDB doesn't support\\n    // either of these flags.\\n    regexp.lastIndex = 0;\\n\\n    return regexp.test(value);\\n  };\\n}\\n\\n// Validates the key in a path.\\n// Objects that are nested more then 1 level cannot have dotted fields\\n// or fields starting with '$'\\nfunction validateKeyInPath(key, path) {\\n  if (key.includes('.')) {\\n    throw new Error(\\n      `The dotted field '${key}' in '${path}.${key} is not valid for storage.`\\n    );\\n  }\\n\\n  if (key[0] === '$') {\\n    throw new Error(\\n      `The dollar ($) prefixed field  '${path}.${key} is not valid for storage.`\\n    );\\n  }\\n}\\n\\n// Recursively validates an object that is nested more than one level deep\\nfunction validateObject(object, path) {\\n  if (object && Object.getPrototypeOf(object) === Object.prototype) {\\n    Object.keys(object).forEach(key => {\\n      validateKeyInPath(key, path);\\n      validateObject(object[key], path + '.' + key);\\n    });\\n  }\\n}\\n\",\"import LocalCollection from './local_collection.js';\\nimport { hasOwn } from './common.js';\\n\\n// Cursor: a specification for a particular subset of documents, w/ a defined\\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\\nexport default class Cursor {\\n  // don't call this ctor directly.  use LocalCollection.find().\\n  constructor(collection, selector, options = {}) {\\n    this.collection = collection;\\n    this.sorter = null;\\n    this.matcher = new Minimongo.Matcher(selector);\\n\\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n      // stash for fast _id and { _id }\\n      this._selectorId = hasOwn.call(selector, '_id')\\n        ? selector._id\\n        : selector;\\n    } else {\\n      this._selectorId = undefined;\\n\\n      if (this.matcher.hasGeoQuery() || options.sort) {\\n        this.sorter = new Minimongo.Sorter(options.sort || []);\\n      }\\n    }\\n\\n    this.skip = options.skip || 0;\\n    this.limit = options.limit;\\n    this.fields = options.fields;\\n\\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\\n\\n    this._transform = LocalCollection.wrapTransform(options.transform);\\n\\n    // by default, queries register w/ Tracker when it is available.\\n    if (typeof Tracker !== 'undefined') {\\n      this.reactive = options.reactive === undefined ? true : options.reactive;\\n    }\\n  }\\n\\n  /**\\n   * @summary Returns the number of documents that match a query.\\n   * @memberOf Mongo.Cursor\\n   * @method  count\\n   * @param {boolean} [applySkipLimit=true] If set to `false`, the value\\n   *                                         returned will reflect the total\\n   *                                         number of matching documents,\\n   *                                         ignoring any value supplied for\\n   *                                         limit\\n   * @instance\\n   * @locus Anywhere\\n   * @returns {Number}\\n   */\\n  count(applySkipLimit = true) {\\n    if (this.reactive) {\\n      // allow the observe to be unordered\\n      this._depend({added: true, removed: true}, true);\\n    }\\n\\n    return this._getRawObjects({\\n      ordered: true,\\n      applySkipLimit\\n    }).length;\\n  }\\n\\n  /**\\n   * @summary Return all matching documents as an Array.\\n   * @memberOf Mongo.Cursor\\n   * @method  fetch\\n   * @instance\\n   * @locus Anywhere\\n   * @returns {Object[]}\\n   */\\n  fetch() {\\n    const result = [];\\n\\n    this.forEach(doc => {\\n      result.push(doc);\\n    });\\n\\n    return result;\\n  }\\n\\n  [Symbol.iterator]() {\\n    if (this.reactive) {\\n      this._depend({\\n        addedBefore: true,\\n        removed: true,\\n        changed: true,\\n        movedBefore: true});\\n    }\\n\\n    let index = 0;\\n    const objects = this._getRawObjects({ordered: true});\\n\\n    return {\\n      next: () => {\\n        if (index < objects.length) {\\n          // This doubles as a clone operation.\\n          let element = this._projectionFn(objects[index++]);\\n\\n          if (this._transform)\\n            element = this._transform(element);\\n\\n          return {value: element};\\n        }\\n\\n        return {done: true};\\n      }\\n    };\\n  }\\n\\n  /**\\n   * @callback IterationCallback\\n   * @param {Object} doc\\n   * @param {Number} index\\n   */\\n  /**\\n   * @summary Call `callback` once for each matching document, sequentially and\\n   *          synchronously.\\n   * @locus Anywhere\\n   * @method  forEach\\n   * @instance\\n   * @memberOf Mongo.Cursor\\n   * @param {IterationCallback} callback Function to call. It will be called\\n   *                                     with three arguments: the document, a\\n   *                                     0-based index, and <em>cursor</em>\\n   *                                     itself.\\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\\n   *                        `callback`.\\n   */\\n  forEach(callback, thisArg) {\\n    if (this.reactive) {\\n      this._depend({\\n        addedBefore: true,\\n        removed: true,\\n        changed: true,\\n        movedBefore: true});\\n    }\\n\\n    this._getRawObjects({ordered: true}).forEach((element, i) => {\\n      // This doubles as a clone operation.\\n      element = this._projectionFn(element);\\n\\n      if (this._transform) {\\n        element = this._transform(element);\\n      }\\n\\n      callback.call(thisArg, element, i, this);\\n    });\\n  }\\n\\n  getTransform() {\\n    return this._transform;\\n  }\\n\\n  /**\\n   * @summary Map callback over all matching documents.  Returns an Array.\\n   * @locus Anywhere\\n   * @method map\\n   * @instance\\n   * @memberOf Mongo.Cursor\\n   * @param {IterationCallback} callback Function to call. It will be called\\n   *                                     with three arguments: the document, a\\n   *                                     0-based index, and <em>cursor</em>\\n   *                                     itself.\\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\\n   *                        `callback`.\\n   */\\n  map(callback, thisArg) {\\n    const result = [];\\n\\n    this.forEach((doc, i) => {\\n      result.push(callback.call(thisArg, doc, i, this));\\n    });\\n\\n    return result;\\n  }\\n\\n  // options to contain:\\n  //  * callbacks for observe():\\n  //    - addedAt (document, atIndex)\\n  //    - added (document)\\n  //    - changedAt (newDocument, oldDocument, atIndex)\\n  //    - changed (newDocument, oldDocument)\\n  //    - removedAt (document, atIndex)\\n  //    - removed (document)\\n  //    - movedTo (document, oldIndex, newIndex)\\n  //\\n  // attributes available on returned query handle:\\n  //  * stop(): end updates\\n  //  * collection: the collection this query is querying\\n  //\\n  // iff x is a returned query handle, (x instanceof\\n  // LocalCollection.ObserveHandle) is true\\n  //\\n  // initial results delivered through added callback\\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\\n  // XXX maybe support field limiting (to limit what you're notified on)\\n\\n  /**\\n   * @summary Watch a query.  Receive callbacks as the result set changes.\\n   * @locus Anywhere\\n   * @memberOf Mongo.Cursor\\n   * @instance\\n   * @param {Object} callbacks Functions to call to deliver the result set as it\\n   *                           changes\\n   */\\n  observe(options) {\\n    return LocalCollection._observeFromObserveChanges(this, options);\\n  }\\n\\n  /**\\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\\n   *          the differences between the old and new documents are passed to\\n   *          the callbacks.\\n   * @locus Anywhere\\n   * @memberOf Mongo.Cursor\\n   * @instance\\n   * @param {Object} callbacks Functions to call to deliver the result set as it\\n   *                           changes\\n   */\\n  observeChanges(options) {\\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\\n\\n    // there are several places that assume you aren't combining skip/limit with\\n    // unordered observe.  eg, update's EJSON.clone, and the \\\"there are several\\\"\\n    // comment in _modifyAndNotify\\n    // XXX allow skip/limit with unordered observe\\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\\n      throw new Error(\\n        \\\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \\\" +\\n        \\\"for observeChanges or 'addedAt' for observe, instead of 'added').\\\"\\n      );\\n    }\\n\\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\\n    }\\n\\n    const distances = (\\n      this.matcher.hasGeoQuery() &&\\n      ordered &&\\n      new LocalCollection._IdMap\\n    );\\n\\n    const query = {\\n      cursor: this,\\n      dirty: false,\\n      distances,\\n      matcher: this.matcher, // not fast pathed\\n      ordered,\\n      projectionFn: this._projectionFn,\\n      resultsSnapshot: null,\\n      sorter: ordered && this.sorter\\n    };\\n\\n    let qid;\\n\\n    // Non-reactive queries call added[Before] and then never call anything\\n    // else.\\n    if (this.reactive) {\\n      qid = this.collection.next_qid++;\\n      this.collection.queries[qid] = query;\\n    }\\n\\n    query.results = this._getRawObjects({ordered, distances: query.distances});\\n\\n    if (this.collection.paused) {\\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap;\\n    }\\n\\n    // wrap callbacks we were passed. callbacks only fire when not paused and\\n    // are never undefined\\n    // Filters out blacklisted fields according to cursor's projection.\\n    // XXX wrong place for this?\\n\\n    // furthermore, callbacks enqueue until the operation we're working on is\\n    // done.\\n    const wrapCallback = fn => {\\n      if (!fn) {\\n        return () => {};\\n      }\\n\\n      const self = this;\\n      return function(/* args*/) {\\n        if (self.collection.paused) {\\n          return;\\n        }\\n\\n        const args = arguments;\\n\\n        self.collection._observeQueue.queueTask(() => {\\n          fn.apply(this, args);\\n        });\\n      };\\n    };\\n\\n    query.added = wrapCallback(options.added);\\n    query.changed = wrapCallback(options.changed);\\n    query.removed = wrapCallback(options.removed);\\n\\n    if (ordered) {\\n      query.addedBefore = wrapCallback(options.addedBefore);\\n      query.movedBefore = wrapCallback(options.movedBefore);\\n    }\\n\\n    if (!options._suppress_initial && !this.collection.paused) {\\n      query.results.forEach(doc => {\\n        const fields = EJSON.clone(doc);\\n\\n        delete fields._id;\\n\\n        if (ordered) {\\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\\n        }\\n\\n        query.added(doc._id, this._projectionFn(fields));\\n      });\\n    }\\n\\n    const handle = Object.assign(new LocalCollection.ObserveHandle, {\\n      collection: this.collection,\\n      stop: () => {\\n        if (this.reactive) {\\n          delete this.collection.queries[qid];\\n        }\\n      }\\n    });\\n\\n    if (this.reactive && Tracker.active) {\\n      // XXX in many cases, the same observe will be recreated when\\n      // the current autorun is rerun.  we could save work by\\n      // letting it linger across rerun and potentially get\\n      // repurposed if the same observe is performed, using logic\\n      // similar to that of Meteor.subscribe.\\n      Tracker.onInvalidate(() => {\\n        handle.stop();\\n      });\\n    }\\n\\n    // run the observe callbacks resulting from the initial contents\\n    // before we leave the observe.\\n    this.collection._observeQueue.drain();\\n\\n    return handle;\\n  }\\n\\n  // Since we don't actually have a \\\"nextObject\\\" interface, there's really no\\n  // reason to have a \\\"rewind\\\" interface.  All it did was make multiple calls\\n  // to fetch/map/forEach return nothing the second time.\\n  // XXX COMPAT WITH 0.8.1\\n  rewind() {}\\n\\n  // XXX Maybe we need a version of observe that just calls a callback if\\n  // anything changed.\\n  _depend(changers, _allow_unordered) {\\n    if (Tracker.active) {\\n      const dependency = new Tracker.Dependency;\\n      const notify = dependency.changed.bind(dependency);\\n\\n      dependency.depend();\\n\\n      const options = {_allow_unordered, _suppress_initial: true};\\n\\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed']\\n        .forEach(fn => {\\n          if (changers[fn]) {\\n            options[fn] = notify;\\n          }\\n        });\\n\\n      // observeChanges will stop() when this computation is invalidated\\n      this.observeChanges(options);\\n    }\\n  }\\n\\n  _getCollectionName() {\\n    return this.collection.name;\\n  }\\n\\n  // Returns a collection of matching objects, but doesn't deep copy them.\\n  //\\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\\n  // limit properties of the query provided that options.applySkipLimit is\\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\\n  // natural order.\\n  //\\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\\n  // skip and limit should not be set).\\n  //\\n  // If ordered is set and this cursor is a $near geoquery, then this function\\n  // will use an _IdMap to track each distance from the $near argument point in\\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\\n  // argument, this function will clear it and use it for this purpose\\n  // (otherwise it will just create its own _IdMap). The observeChanges\\n  // implementation uses this to remember the distances after this function\\n  // returns.\\n  _getRawObjects(options = {}) {\\n    // By default this method will respect skip and limit because .fetch(),\\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\\n    // skip and limit by setting applySkipLimit to false (.count() does this,\\n    // for example)\\n    const applySkipLimit = options.applySkipLimit !== false;\\n\\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\\n    // compatible\\n    const results = options.ordered ? [] : new LocalCollection._IdMap;\\n\\n    // fast path for single ID value\\n    if (this._selectorId !== undefined) {\\n      // If you have non-zero skip and ask for a single id, you get nothing.\\n      // This is so it matches the behavior of the '{_id: foo}' path.\\n      if (applySkipLimit && this.skip) {\\n        return results;\\n      }\\n\\n      const selectedDoc = this.collection._docs.get(this._selectorId);\\n\\n      if (selectedDoc) {\\n        if (options.ordered) {\\n          results.push(selectedDoc);\\n        } else {\\n          results.set(this._selectorId, selectedDoc);\\n        }\\n      }\\n\\n      return results;\\n    }\\n\\n    // slow path for arbitrary selector, sort, skip, limit\\n\\n    // in the observeChanges case, distances is actually part of the \\\"query\\\"\\n    // (ie, live results set) object.  in other cases, distances is only used\\n    // inside this function.\\n    let distances;\\n    if (this.matcher.hasGeoQuery() && options.ordered) {\\n      if (options.distances) {\\n        distances = options.distances;\\n        distances.clear();\\n      } else {\\n        distances = new LocalCollection._IdMap();\\n      }\\n    }\\n\\n    this.collection._docs.forEach((doc, id) => {\\n      const matchResult = this.matcher.documentMatches(doc);\\n\\n      if (matchResult.result) {\\n        if (options.ordered) {\\n          results.push(doc);\\n\\n          if (distances && matchResult.distance !== undefined) {\\n            distances.set(id, matchResult.distance);\\n          }\\n        } else {\\n          results.set(id, doc);\\n        }\\n      }\\n\\n      // Override to ensure all docs are matched if ignoring skip & limit\\n      if (!applySkipLimit) {\\n        return true;\\n      }\\n\\n      // Fast path for limited unsorted queries.\\n      // XXX 'length' check here seems wrong for ordered\\n      return (\\n        !this.limit ||\\n        this.skip ||\\n        this.sorter ||\\n        results.length !== this.limit\\n      );\\n    });\\n\\n    if (!options.ordered) {\\n      return results;\\n    }\\n\\n    if (this.sorter) {\\n      results.sort(this.sorter.getComparator({distances}));\\n    }\\n\\n    // Return the full set of results if there is no skip or limit or if we're\\n    // ignoring them\\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\\n      return results;\\n    }\\n\\n    return results.slice(\\n      this.skip,\\n      this.limit ? this.limit + this.skip : results.length\\n    );\\n  }\\n\\n  _publishCursor(subscription) {\\n    // XXX minimongo should not depend on mongo-livedata!\\n    if (!Package.mongo) {\\n      throw new Error(\\n        'Can\\\\'t publish from Minimongo without the `mongo` package.'\\n      );\\n    }\\n\\n    if (!this.collection.name) {\\n      throw new Error(\\n        'Can\\\\'t publish a cursor from a collection without a name.'\\n      );\\n    }\\n\\n    return Package.mongo.Mongo.Collection._publishCursor(\\n      this,\\n      subscription,\\n      this.collection.name\\n    );\\n  }\\n}\\n\",\"import Cursor from './cursor.js';\\nimport ObserveHandle from './observe_handle.js';\\nimport {\\n  hasOwn,\\n  isIndexable,\\n  isNumericKey,\\n  isOperatorObject,\\n  populateDocumentWithQueryFields,\\n  projectionDetails,\\n} from './common.js';\\n\\n// XXX type checking on selectors (graceful error if malformed)\\n\\n// LocalCollection: a set of documents that supports queries and modifiers.\\nexport default class LocalCollection {\\n  constructor(name) {\\n    this.name = name;\\n    // _id -> document (also containing id)\\n    this._docs = new LocalCollection._IdMap;\\n\\n    this._observeQueue = new Meteor._SynchronousQueue();\\n\\n    this.next_qid = 1; // live query id generator\\n\\n    // qid -> live query object. keys:\\n    //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\\n    //  results: array (ordered) or object (unordered) of current results\\n    //    (aliased with this._docs!)\\n    //  resultsSnapshot: snapshot of results. null if not paused.\\n    //  cursor: Cursor object for the query.\\n    //  selector, sorter, (callbacks): functions\\n    this.queries = Object.create(null);\\n\\n    // null if not saving originals; an IdMap from id to original document value\\n    // if saving originals. See comments before saveOriginals().\\n    this._savedOriginals = null;\\n\\n    // True when observers are paused and we should not send callbacks.\\n    this.paused = false;\\n  }\\n\\n  // options may include sort, skip, limit, reactive\\n  // sort may be any of these forms:\\n  //     {a: 1, b: -1}\\n  //     [[\\\"a\\\", \\\"asc\\\"], [\\\"b\\\", \\\"desc\\\"]]\\n  //     [\\\"a\\\", [\\\"b\\\", \\\"desc\\\"]]\\n  //   (in the first form you're beholden to key enumeration order in\\n  //   your javascript VM)\\n  //\\n  // reactive: if given, and false, don't register with Tracker (default\\n  // is true)\\n  //\\n  // XXX possibly should support retrieving a subset of fields? and\\n  // have it be a hint (ignored on the client, when not copying the\\n  // doc?)\\n  //\\n  // XXX sort does not yet support subkeys ('a.b') .. fix that!\\n  // XXX add one more sort form: \\\"key\\\"\\n  // XXX tests\\n  find(selector, options) {\\n    // default syntax for everything is to omit the selector argument.\\n    // but if selector is explicitly passed in as false or undefined, we\\n    // want a selector that matches nothing.\\n    if (arguments.length === 0) {\\n      selector = {};\\n    }\\n\\n    return new LocalCollection.Cursor(this, selector, options);\\n  }\\n\\n  findOne(selector, options = {}) {\\n    if (arguments.length === 0) {\\n      selector = {};\\n    }\\n\\n    // NOTE: by setting limit 1 here, we end up using very inefficient\\n    // code that recomputes the whole query on each update. The upside is\\n    // that when you reactively depend on a findOne you only get\\n    // invalidated when the found object changes, not any object in the\\n    // collection. Most findOne will be by id, which has a fast path, so\\n    // this might not be a big deal. In most cases, invalidation causes\\n    // the called to re-query anyway, so this should be a net performance\\n    // improvement.\\n    options.limit = 1;\\n\\n    return this.find(selector, options).fetch()[0];\\n  }\\n\\n  // XXX possibly enforce that 'undefined' does not appear (we assume\\n  // this in our handling of null and $exists)\\n  insert(doc, callback) {\\n    doc = EJSON.clone(doc);\\n\\n    assertHasValidFieldNames(doc);\\n\\n    // if you really want to use ObjectIDs, set this global.\\n    // Mongo.Collection specifies its own ids and does not use this code.\\n    if (!hasOwn.call(doc, '_id')) {\\n      doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\\n    }\\n\\n    const id = doc._id;\\n\\n    if (this._docs.has(id)) {\\n      throw MinimongoError(`Duplicate _id '${id}'`);\\n    }\\n\\n    this._saveOriginal(id, undefined);\\n    this._docs.set(id, doc);\\n\\n    const queriesToRecompute = [];\\n\\n    // trigger live queries that match\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      const matchResult = query.matcher.documentMatches(doc);\\n\\n      if (matchResult.result) {\\n        if (query.distances && matchResult.distance !== undefined) {\\n          query.distances.set(id, matchResult.distance);\\n        }\\n\\n        if (query.cursor.skip || query.cursor.limit) {\\n          queriesToRecompute.push(qid);\\n        } else {\\n          LocalCollection._insertInResults(query, doc);\\n        }\\n      }\\n    });\\n\\n    queriesToRecompute.forEach(qid => {\\n      if (this.queries[qid]) {\\n        this._recomputeResults(this.queries[qid]);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    // Defer because the caller likely doesn't expect the callback to be run\\n    // immediately.\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, id);\\n      });\\n    }\\n\\n    return id;\\n  }\\n\\n  // Pause the observers. No callbacks from observers will fire until\\n  // 'resumeObservers' is called.\\n  pauseObservers() {\\n    // No-op if already paused.\\n    if (this.paused) {\\n      return;\\n    }\\n\\n    // Set the 'paused' flag such that new observer messages don't fire.\\n    this.paused = true;\\n\\n    // Take a snapshot of the query results for each query.\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n      query.resultsSnapshot = EJSON.clone(query.results);\\n    });\\n  }\\n\\n  remove(selector, callback) {\\n    // Easy special case: if we're not calling observeChanges callbacks and\\n    // we're not saving originals and we got asked to remove everything, then\\n    // just empty everything directly.\\n    if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\\n      const result = this._docs.size();\\n\\n      this._docs.clear();\\n\\n      Object.keys(this.queries).forEach(qid => {\\n        const query = this.queries[qid];\\n\\n        if (query.ordered) {\\n          query.results = [];\\n        } else {\\n          query.results.clear();\\n        }\\n      });\\n\\n      if (callback) {\\n        Meteor.defer(() => {\\n          callback(null, result);\\n        });\\n      }\\n\\n      return result;\\n    }\\n\\n    const matcher = new Minimongo.Matcher(selector);\\n    const remove = [];\\n\\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\\n      if (matcher.documentMatches(doc).result) {\\n        remove.push(id);\\n      }\\n    });\\n\\n    const queriesToRecompute = [];\\n    const queryRemove = [];\\n\\n    for (let i = 0; i < remove.length; i++) {\\n      const removeId = remove[i];\\n      const removeDoc = this._docs.get(removeId);\\n\\n      Object.keys(this.queries).forEach(qid => {\\n        const query = this.queries[qid];\\n\\n        if (query.dirty) {\\n          return;\\n        }\\n\\n        if (query.matcher.documentMatches(removeDoc).result) {\\n          if (query.cursor.skip || query.cursor.limit) {\\n            queriesToRecompute.push(qid);\\n          } else {\\n            queryRemove.push({qid, doc: removeDoc});\\n          }\\n        }\\n      });\\n\\n      this._saveOriginal(removeId, removeDoc);\\n      this._docs.remove(removeId);\\n    }\\n\\n    // run live query callbacks _after_ we've removed the documents.\\n    queryRemove.forEach(remove => {\\n      const query = this.queries[remove.qid];\\n\\n      if (query) {\\n        query.distances && query.distances.remove(remove.doc._id);\\n        LocalCollection._removeFromResults(query, remove.doc);\\n      }\\n    });\\n\\n    queriesToRecompute.forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query) {\\n        this._recomputeResults(query);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    const result = remove.length;\\n\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, result);\\n      });\\n    }\\n\\n    return result;\\n  }\\n\\n  // Resume the observers. Observers immediately receive change\\n  // notifications to bring them to the current state of the\\n  // database. Note that this is not just replaying all the changes that\\n  // happened during the pause, it is a smarter 'coalesced' diff.\\n  resumeObservers() {\\n    // No-op if not paused.\\n    if (!this.paused) {\\n      return;\\n    }\\n\\n    // Unset the 'paused' flag. Make sure to do this first, otherwise\\n    // observer methods won't actually fire when we trigger them.\\n    this.paused = false;\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        query.dirty = false;\\n\\n        // re-compute results will perform `LocalCollection._diffQueryChanges`\\n        // automatically.\\n        this._recomputeResults(query, query.resultsSnapshot);\\n      } else {\\n        // Diff the current results against the snapshot and send to observers.\\n        // pass the query object for its observer callbacks.\\n        LocalCollection._diffQueryChanges(\\n          query.ordered,\\n          query.resultsSnapshot,\\n          query.results,\\n          query,\\n          {projectionFn: query.projectionFn}\\n        );\\n      }\\n\\n      query.resultsSnapshot = null;\\n    });\\n\\n    this._observeQueue.drain();\\n  }\\n\\n  retrieveOriginals() {\\n    if (!this._savedOriginals) {\\n      throw new Error('Called retrieveOriginals without saveOriginals');\\n    }\\n\\n    const originals = this._savedOriginals;\\n\\n    this._savedOriginals = null;\\n\\n    return originals;\\n  }\\n\\n  // To track what documents are affected by a piece of code, call\\n  // saveOriginals() before it and retrieveOriginals() after it.\\n  // retrieveOriginals returns an object whose keys are the ids of the documents\\n  // that were affected since the call to saveOriginals(), and the values are\\n  // equal to the document's contents at the time of saveOriginals. (In the case\\n  // of an inserted document, undefined is the value.) You must alternate\\n  // between calls to saveOriginals() and retrieveOriginals().\\n  saveOriginals() {\\n    if (this._savedOriginals) {\\n      throw new Error('Called saveOriginals twice without retrieveOriginals');\\n    }\\n\\n    this._savedOriginals = new LocalCollection._IdMap;\\n  }\\n\\n  // XXX atomicity: if multi is true, and one modification fails, do\\n  // we rollback the whole operation, or what?\\n  update(selector, mod, options, callback) {\\n    if (! callback && options instanceof Function) {\\n      callback = options;\\n      options = null;\\n    }\\n\\n    if (!options) {\\n      options = {};\\n    }\\n\\n    const matcher = new Minimongo.Matcher(selector, true);\\n\\n    // Save the original results of any query that we might need to\\n    // _recomputeResults on, because _modifyAndNotify will mutate the objects in\\n    // it. (We don't need to save the original results of paused queries because\\n    // they already have a resultsSnapshot and we won't be diffing in\\n    // _recomputeResults.)\\n    const qidToOriginalResults = {};\\n\\n    // We should only clone each document once, even if it appears in multiple\\n    // queries\\n    const docMap = new LocalCollection._IdMap;\\n    const idsMatched = LocalCollection._idsMatchedBySelector(selector);\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if ((query.cursor.skip || query.cursor.limit) && ! this.paused) {\\n        // Catch the case of a reactive `count()` on a cursor with skip\\n        // or limit, which registers an unordered observe. This is a\\n        // pretty rare case, so we just clone the entire result set with\\n        // no optimizations for documents that appear in these result\\n        // sets and other queries.\\n        if (query.results instanceof LocalCollection._IdMap) {\\n          qidToOriginalResults[qid] = query.results.clone();\\n          return;\\n        }\\n\\n        if (!(query.results instanceof Array)) {\\n          throw new Error('Assertion failed: query.results not an array');\\n        }\\n\\n        // Clones a document to be stored in `qidToOriginalResults`\\n        // because it may be modified before the new and old result sets\\n        // are diffed. But if we know exactly which document IDs we're\\n        // going to modify, then we only need to clone those.\\n        const memoizedCloneIfNeeded = doc => {\\n          if (docMap.has(doc._id)) {\\n            return docMap.get(doc._id);\\n          }\\n\\n          const docToMemoize = (\\n            idsMatched &&\\n            !idsMatched.some(id => EJSON.equals(id, doc._id))\\n          ) ? doc : EJSON.clone(doc);\\n\\n          docMap.set(doc._id, docToMemoize);\\n\\n          return docToMemoize;\\n        };\\n\\n        qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\\n      }\\n    });\\n\\n    const recomputeQids = {};\\n\\n    let updateCount = 0;\\n\\n    this._eachPossiblyMatchingDoc(selector, (doc, id) => {\\n      const queryResult = matcher.documentMatches(doc);\\n\\n      if (queryResult.result) {\\n        // XXX Should we save the original even if mod ends up being a no-op?\\n        this._saveOriginal(id, doc);\\n        this._modifyAndNotify(\\n          doc,\\n          mod,\\n          recomputeQids,\\n          queryResult.arrayIndices\\n        );\\n\\n        ++updateCount;\\n\\n        if (!options.multi) {\\n          return false; // break\\n        }\\n      }\\n\\n      return true;\\n    });\\n\\n    Object.keys(recomputeQids).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query) {\\n        this._recomputeResults(query, qidToOriginalResults[qid]);\\n      }\\n    });\\n\\n    this._observeQueue.drain();\\n\\n    // If we are doing an upsert, and we didn't modify any documents yet, then\\n    // it's time to do an insert. Figure out what document we are inserting, and\\n    // generate an id for it.\\n    let insertedId;\\n    if (updateCount === 0 && options.upsert) {\\n      const doc = LocalCollection._createUpsertDocument(selector, mod);\\n      if (! doc._id && options.insertedId) {\\n        doc._id = options.insertedId;\\n      }\\n\\n      insertedId = this.insert(doc);\\n      updateCount = 1;\\n    }\\n\\n    // Return the number of affected documents, or in the upsert case, an object\\n    // containing the number of affected docs and the id of the doc that was\\n    // inserted, if any.\\n    let result;\\n    if (options._returnObject) {\\n      result = {numberAffected: updateCount};\\n\\n      if (insertedId !== undefined) {\\n        result.insertedId = insertedId;\\n      }\\n    } else {\\n      result = updateCount;\\n    }\\n\\n    if (callback) {\\n      Meteor.defer(() => {\\n        callback(null, result);\\n      });\\n    }\\n\\n    return result;\\n  }\\n\\n  // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\\n  // equivalent to LocalCollection.update(sel, mod, {upsert: true,\\n  // _returnObject: true}).\\n  upsert(selector, mod, options, callback) {\\n    if (!callback && typeof options === 'function') {\\n      callback = options;\\n      options = {};\\n    }\\n\\n    return this.update(\\n      selector,\\n      mod,\\n      Object.assign({}, options, {upsert: true, _returnObject: true}),\\n      callback\\n    );\\n  }\\n\\n  // Iterates over a subset of documents that could match selector; calls\\n  // fn(doc, id) on each of them.  Specifically, if selector specifies\\n  // specific _id's, it only looks at those.  doc is *not* cloned: it is the\\n  // same object that is in _docs.\\n  _eachPossiblyMatchingDoc(selector, fn) {\\n    const specificIds = LocalCollection._idsMatchedBySelector(selector);\\n\\n    if (specificIds) {\\n      specificIds.some(id => {\\n        const doc = this._docs.get(id);\\n\\n        if (doc) {\\n          return fn(doc, id) === false;\\n        }\\n      });\\n    } else {\\n      this._docs.forEach(fn);\\n    }\\n  }\\n\\n  _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\\n    const matched_before = {};\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      if (query.ordered) {\\n        matched_before[qid] = query.matcher.documentMatches(doc).result;\\n      } else {\\n        // Because we don't support skip or limit (yet) in unordered queries, we\\n        // can just do a direct lookup.\\n        matched_before[qid] = query.results.has(doc._id);\\n      }\\n    });\\n\\n    const old_doc = EJSON.clone(doc);\\n\\n    LocalCollection._modify(doc, mod, {arrayIndices});\\n\\n    Object.keys(this.queries).forEach(qid => {\\n      const query = this.queries[qid];\\n\\n      if (query.dirty) {\\n        return;\\n      }\\n\\n      const afterMatch = query.matcher.documentMatches(doc);\\n      const after = afterMatch.result;\\n      const before = matched_before[qid];\\n\\n      if (after && query.distances && afterMatch.distance !== undefined) {\\n        query.distances.set(doc._id, afterMatch.distance);\\n      }\\n\\n      if (query.cursor.skip || query.cursor.limit) {\\n        // We need to recompute any query where the doc may have been in the\\n        // cursor's window either before or after the update. (Note that if skip\\n        // or limit is set, \\\"before\\\" and \\\"after\\\" being true do not necessarily\\n        // mean that the document is in the cursor's output after skip/limit is\\n        // applied... but if they are false, then the document definitely is NOT\\n        // in the output. So it's safe to skip recompute if neither before or\\n        // after are true.)\\n        if (before || after) {\\n          recomputeQids[qid] = true;\\n        }\\n      } else if (before && !after) {\\n        LocalCollection._removeFromResults(query, doc);\\n      } else if (!before && after) {\\n        LocalCollection._insertInResults(query, doc);\\n      } else if (before && after) {\\n        LocalCollection._updateInResults(query, doc, old_doc);\\n      }\\n    });\\n  }\\n\\n  // Recomputes the results of a query and runs observe callbacks for the\\n  // difference between the previous results and the current results (unless\\n  // paused). Used for skip/limit queries.\\n  //\\n  // When this is used by insert or remove, it can just use query.results for\\n  // the old results (and there's no need to pass in oldResults), because these\\n  // operations don't mutate the documents in the collection. Update needs to\\n  // pass in an oldResults which was deep-copied before the modifier was\\n  // applied.\\n  //\\n  // oldResults is guaranteed to be ignored if the query is not paused.\\n  _recomputeResults(query, oldResults) {\\n    if (this.paused) {\\n      // There's no reason to recompute the results now as we're still paused.\\n      // By flagging the query as \\\"dirty\\\", the recompute will be performed\\n      // when resumeObservers is called.\\n      query.dirty = true;\\n      return;\\n    }\\n\\n    if (!this.paused && !oldResults) {\\n      oldResults = query.results;\\n    }\\n\\n    if (query.distances) {\\n      query.distances.clear();\\n    }\\n\\n    query.results = query.cursor._getRawObjects({\\n      distances: query.distances,\\n      ordered: query.ordered\\n    });\\n\\n    if (!this.paused) {\\n      LocalCollection._diffQueryChanges(\\n        query.ordered,\\n        oldResults,\\n        query.results,\\n        query,\\n        {projectionFn: query.projectionFn}\\n      );\\n    }\\n  }\\n\\n  _saveOriginal(id, doc) {\\n    // Are we even trying to save originals?\\n    if (!this._savedOriginals) {\\n      return;\\n    }\\n\\n    // Have we previously mutated the original (and so 'doc' is not actually\\n    // original)?  (Note the 'has' check rather than truth: we store undefined\\n    // here for inserted docs!)\\n    if (this._savedOriginals.has(id)) {\\n      return;\\n    }\\n\\n    this._savedOriginals.set(id, EJSON.clone(doc));\\n  }\\n}\\n\\nLocalCollection.Cursor = Cursor;\\n\\nLocalCollection.ObserveHandle = ObserveHandle;\\n\\n// XXX maybe move these into another ObserveHelpers package or something\\n\\n// _CachingChangeObserver is an object which receives observeChanges callbacks\\n// and keeps a cache of the current cursor state up to date in this.docs. Users\\n// of this class should read the docs field but not modify it. You should pass\\n// the \\\"applyChange\\\" field as the callbacks to the underlying observeChanges\\n// call. Optionally, you can specify your own observeChanges callbacks which are\\n// invoked immediately before the docs field is updated; this object is made\\n// available as `this` to those callbacks.\\nLocalCollection._CachingChangeObserver = class _CachingChangeObserver {\\n  constructor(options = {}) {\\n    const orderedFromCallbacks = (\\n      options.callbacks &&\\n      LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks)\\n    );\\n\\n    if (hasOwn.call(options, 'ordered')) {\\n      this.ordered = options.ordered;\\n\\n      if (options.callbacks && options.ordered !== orderedFromCallbacks) {\\n        throw Error('ordered option doesn\\\\'t match callbacks');\\n      }\\n    } else if (options.callbacks) {\\n      this.ordered = orderedFromCallbacks;\\n    } else {\\n      throw Error('must provide ordered or callbacks');\\n    }\\n\\n    const callbacks = options.callbacks || {};\\n\\n    if (this.ordered) {\\n      this.docs = new OrderedDict(MongoID.idStringify);\\n      this.applyChange = {\\n        addedBefore: (id, fields, before) => {\\n          const doc = EJSON.clone(fields);\\n\\n          doc._id = id;\\n\\n          if (callbacks.addedBefore) {\\n            callbacks.addedBefore.call(this, id, fields, before);\\n          }\\n\\n          // This line triggers if we provide added with movedBefore.\\n          if (callbacks.added) {\\n            callbacks.added.call(this, id, fields);\\n          }\\n\\n          // XXX could `before` be a falsy ID?  Technically\\n          // idStringify seems to allow for them -- though\\n          // OrderedDict won't call stringify on a falsy arg.\\n          this.docs.putBefore(id, doc, before || null);\\n        },\\n        movedBefore: (id, before) => {\\n          const doc = this.docs.get(id);\\n\\n          if (callbacks.movedBefore) {\\n            callbacks.movedBefore.call(this, id, before);\\n          }\\n\\n          this.docs.moveBefore(id, before || null);\\n        },\\n      };\\n    } else {\\n      this.docs = new LocalCollection._IdMap;\\n      this.applyChange = {\\n        added: (id, fields) => {\\n          const doc = EJSON.clone(fields);\\n\\n          if (callbacks.added) {\\n            callbacks.added.call(this, id, fields);\\n          }\\n\\n          doc._id = id;\\n\\n          this.docs.set(id,  doc);\\n        },\\n      };\\n    }\\n\\n    // The methods in _IdMap and OrderedDict used by these callbacks are\\n    // identical.\\n    this.applyChange.changed = (id, fields) => {\\n      const doc = this.docs.get(id);\\n\\n      if (!doc) {\\n        throw new Error(`Unknown id for changed: ${id}`);\\n      }\\n\\n      if (callbacks.changed) {\\n        callbacks.changed.call(this, id, EJSON.clone(fields));\\n      }\\n\\n      DiffSequence.applyChanges(doc, fields);\\n    };\\n\\n    this.applyChange.removed = id => {\\n      if (callbacks.removed) {\\n        callbacks.removed.call(this, id);\\n      }\\n\\n      this.docs.remove(id);\\n    };\\n  }\\n};\\n\\nLocalCollection._IdMap = class _IdMap extends IdMap {\\n  constructor() {\\n    super(MongoID.idStringify, MongoID.idParse);\\n  }\\n};\\n\\n// Wrap a transform function to return objects that have the _id field\\n// of the untransformed document. This ensures that subsystems such as\\n// the observe-sequence package that call `observe` can keep track of\\n// the documents identities.\\n//\\n// - Require that it returns objects\\n// - If the return value has an _id field, verify that it matches the\\n//   original _id field\\n// - If the return value doesn't have an _id field, add it back.\\nLocalCollection.wrapTransform = transform => {\\n  if (!transform) {\\n    return null;\\n  }\\n\\n  // No need to doubly-wrap transforms.\\n  if (transform.__wrappedTransform__) {\\n    return transform;\\n  }\\n\\n  const wrapped = doc => {\\n    if (!hasOwn.call(doc, '_id')) {\\n      // XXX do we ever have a transform on the oplog's collection? because that\\n      // collection has no _id.\\n      throw new Error('can only transform documents with _id');\\n    }\\n\\n    const id = doc._id;\\n\\n    // XXX consider making tracker a weak dependency and checking\\n    // Package.tracker here\\n    const transformed = Tracker.nonreactive(() => transform(doc));\\n\\n    if (!LocalCollection._isPlainObject(transformed)) {\\n      throw new Error('transform must return object');\\n    }\\n\\n    if (hasOwn.call(transformed, '_id')) {\\n      if (!EJSON.equals(transformed._id, id)) {\\n        throw new Error('transformed document can\\\\'t have different _id');\\n      }\\n    } else {\\n      transformed._id = id;\\n    }\\n\\n    return transformed;\\n  };\\n\\n  wrapped.__wrappedTransform__ = true;\\n\\n  return wrapped;\\n};\\n\\n// XXX the sorted-query logic below is laughably inefficient. we'll\\n// need to come up with a better datastructure for this.\\n//\\n// XXX the logic for observing with a skip or a limit is even more\\n// laughably inefficient. we recompute the whole results every time!\\n\\n// This binary search puts a value between any equal values, and the first\\n// lesser value.\\nLocalCollection._binarySearch = (cmp, array, value) => {\\n  let first = 0;\\n  let range = array.length;\\n\\n  while (range > 0) {\\n    const halfRange = Math.floor(range / 2);\\n\\n    if (cmp(value, array[first + halfRange]) >= 0) {\\n      first += halfRange + 1;\\n      range -= halfRange + 1;\\n    } else {\\n      range = halfRange;\\n    }\\n  }\\n\\n  return first;\\n};\\n\\nLocalCollection._checkSupportedProjection = fields => {\\n  if (fields !== Object(fields) || Array.isArray(fields)) {\\n    throw MinimongoError('fields option must be an object');\\n  }\\n\\n  Object.keys(fields).forEach(keyPath => {\\n    if (keyPath.split('.').includes('$')) {\\n      throw MinimongoError(\\n        'Minimongo doesn\\\\'t support $ operator in projections yet.'\\n      );\\n    }\\n\\n    const value = fields[keyPath];\\n\\n    if (typeof value === 'object' &&\\n        ['$elemMatch', '$meta', '$slice'].some(key =>\\n          hasOwn.call(value, key)\\n        )) {\\n      throw MinimongoError(\\n        'Minimongo doesn\\\\'t support operators in projections yet.'\\n      );\\n    }\\n\\n    if (![1, 0, true, false].includes(value)) {\\n      throw MinimongoError(\\n        'Projection values should be one of 1, 0, true, or false'\\n      );\\n    }\\n  });\\n};\\n\\n// Knows how to compile a fields projection to a predicate function.\\n// @returns - Function: a closure that filters out an object according to the\\n//            fields projection rules:\\n//            @param obj - Object: MongoDB-styled document\\n//            @returns - Object: a document with the fields filtered out\\n//                       according to projection rules. Doesn't retain subfields\\n//                       of passed argument.\\nLocalCollection._compileProjection = fields => {\\n  LocalCollection._checkSupportedProjection(fields);\\n\\n  const _idProjection = fields._id === undefined ? true : fields._id;\\n  const details = projectionDetails(fields);\\n\\n  // returns transformed doc according to ruleTree\\n  const transform = (doc, ruleTree) => {\\n    // Special case for \\\"sets\\\"\\n    if (Array.isArray(doc)) {\\n      return doc.map(subdoc => transform(subdoc, ruleTree));\\n    }\\n\\n    const result = details.including ? {} : EJSON.clone(doc);\\n\\n    Object.keys(ruleTree).forEach(key => {\\n      if (!hasOwn.call(doc, key)) {\\n        return;\\n      }\\n\\n      const rule = ruleTree[key];\\n\\n      if (rule === Object(rule)) {\\n        // For sub-objects/subsets we branch\\n        if (doc[key] === Object(doc[key])) {\\n          result[key] = transform(doc[key], rule);\\n        }\\n      } else if (details.including) {\\n        // Otherwise we don't even touch this subfield\\n        result[key] = EJSON.clone(doc[key]);\\n      } else {\\n        delete result[key];\\n      }\\n    });\\n\\n    return result;\\n  };\\n\\n  return doc => {\\n    const result = transform(doc, details.tree);\\n\\n    if (_idProjection && hasOwn.call(doc, '_id')) {\\n      result._id = doc._id;\\n    }\\n\\n    if (!_idProjection && hasOwn.call(result, '_id')) {\\n      delete result._id;\\n    }\\n\\n    return result;\\n  };\\n};\\n\\n// Calculates the document to insert in case we're doing an upsert and the\\n// selector does not match any elements\\nLocalCollection._createUpsertDocument = (selector, modifier) => {\\n  const selectorDocument = populateDocumentWithQueryFields(selector);\\n  const isModify = LocalCollection._isModificationMod(modifier);\\n\\n  const newDoc = {};\\n\\n  if (selectorDocument._id) {\\n    newDoc._id = selectorDocument._id;\\n    delete selectorDocument._id;\\n  }\\n\\n  // This double _modify call is made to help with nested properties (see issue\\n  // #8631). We do this even if it's a replacement for validation purposes (e.g.\\n  // ambiguous id's)\\n  LocalCollection._modify(newDoc, {$set: selectorDocument});\\n  LocalCollection._modify(newDoc, modifier, {isInsert: true});\\n\\n  if (isModify) {\\n    return newDoc;\\n  }\\n\\n  // Replacement can take _id from query document\\n  const replacement = Object.assign({}, modifier);\\n  if (newDoc._id) {\\n    replacement._id = newDoc._id;\\n  }\\n\\n  return replacement;\\n};\\n\\nLocalCollection._diffObjects = (left, right, callbacks) => {\\n  return DiffSequence.diffObjects(left, right, callbacks);\\n};\\n\\n// ordered: bool.\\n// old_results and new_results: collections of documents.\\n//    if ordered, they are arrays.\\n//    if unordered, they are IdMaps\\nLocalCollection._diffQueryChanges = (ordered, oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._diffQueryOrderedChanges = (oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._diffQueryUnorderedChanges = (oldResults, newResults, observer, options) =>\\n  DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options)\\n;\\n\\nLocalCollection._findInOrderedResults = (query, doc) => {\\n  if (!query.ordered) {\\n    throw new Error('Can\\\\'t call _findInOrderedResults on unordered query');\\n  }\\n\\n  for (let i = 0; i < query.results.length; i++) {\\n    if (query.results[i] === doc) {\\n      return i;\\n    }\\n  }\\n\\n  throw Error('object missing from query');\\n};\\n\\n// If this is a selector which explicitly constrains the match by ID to a finite\\n// number of documents, returns a list of their IDs.  Otherwise returns\\n// null. Note that the selector may have other restrictions so it may not even\\n// match those document!  We care about $in and $and since those are generated\\n// access-controlled update and remove.\\nLocalCollection._idsMatchedBySelector = selector => {\\n  // Is the selector just an ID?\\n  if (LocalCollection._selectorIsId(selector)) {\\n    return [selector];\\n  }\\n\\n  if (!selector) {\\n    return null;\\n  }\\n\\n  // Do we have an _id clause?\\n  if (hasOwn.call(selector, '_id')) {\\n    // Is the _id clause just an ID?\\n    if (LocalCollection._selectorIsId(selector._id)) {\\n      return [selector._id];\\n    }\\n\\n    // Is the _id clause {_id: {$in: [\\\"x\\\", \\\"y\\\", \\\"z\\\"]}}?\\n    if (selector._id\\n        && Array.isArray(selector._id.$in)\\n        && selector._id.$in.length\\n        && selector._id.$in.every(LocalCollection._selectorIsId)) {\\n      return selector._id.$in;\\n    }\\n\\n    return null;\\n  }\\n\\n  // If this is a top-level $and, and any of the clauses constrain their\\n  // documents, then the whole selector is constrained by any one clause's\\n  // constraint. (Well, by their intersection, but that seems unlikely.)\\n  if (Array.isArray(selector.$and)) {\\n    for (let i = 0; i < selector.$and.length; ++i) {\\n      const subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\\n\\n      if (subIds) {\\n        return subIds;\\n      }\\n    }\\n  }\\n\\n  return null;\\n};\\n\\nLocalCollection._insertInResults = (query, doc) => {\\n  const fields = EJSON.clone(doc);\\n\\n  delete fields._id;\\n\\n  if (query.ordered) {\\n    if (!query.sorter) {\\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\\n      query.results.push(doc);\\n    } else {\\n      const i = LocalCollection._insertInSortedList(\\n        query.sorter.getComparator({distances: query.distances}),\\n        query.results,\\n        doc\\n      );\\n\\n      let next = query.results[i + 1];\\n      if (next) {\\n        next = next._id;\\n      } else {\\n        next = null;\\n      }\\n\\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\\n    }\\n\\n    query.added(doc._id, query.projectionFn(fields));\\n  } else {\\n    query.added(doc._id, query.projectionFn(fields));\\n    query.results.set(doc._id, doc);\\n  }\\n};\\n\\nLocalCollection._insertInSortedList = (cmp, array, value) => {\\n  if (array.length === 0) {\\n    array.push(value);\\n    return 0;\\n  }\\n\\n  const i = LocalCollection._binarySearch(cmp, array, value);\\n\\n  array.splice(i, 0, value);\\n\\n  return i;\\n};\\n\\nLocalCollection._isModificationMod = mod => {\\n  let isModify = false;\\n  let isReplace = false;\\n\\n  Object.keys(mod).forEach(key => {\\n    if (key.substr(0, 1) === '$') {\\n      isModify = true;\\n    } else {\\n      isReplace = true;\\n    }\\n  });\\n\\n  if (isModify && isReplace) {\\n    throw new Error(\\n      'Update parameter cannot have both modifier and non-modifier fields.'\\n    );\\n  }\\n\\n  return isModify;\\n};\\n\\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\\n// RegExp\\n// XXX note that _type(undefined) === 3!!!!\\nLocalCollection._isPlainObject = x => {\\n  return x && LocalCollection._f._type(x) === 3;\\n};\\n\\n// XXX need a strategy for passing the binding of $ into this\\n// function, from the compiled selector\\n//\\n// maybe just {key.up.to.just.before.dollarsign: array_index}\\n//\\n// XXX atomicity: if one modification fails, do we roll back the whole\\n// change?\\n//\\n// options:\\n//   - isInsert is set when _modify is being called to compute the document to\\n//     insert as part of an upsert operation. We use this primarily to figure\\n//     out when to set the fields in $setOnInsert, if present.\\nLocalCollection._modify = (doc, modifier, options = {}) => {\\n  if (!LocalCollection._isPlainObject(modifier)) {\\n    throw MinimongoError('Modifier must be an object');\\n  }\\n\\n  // Make sure the caller can't mutate our data structures.\\n  modifier = EJSON.clone(modifier);\\n\\n  const isModifier = isOperatorObject(modifier);\\n  const newDoc = isModifier ? EJSON.clone(doc) : modifier;\\n\\n  if (isModifier) {\\n    // apply modifiers to the doc.\\n    Object.keys(modifier).forEach(operator => {\\n      // Treat $setOnInsert as $set if this is an insert.\\n      const setOnInsert = options.isInsert && operator === '$setOnInsert';\\n      const modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\\n      const operand = modifier[operator];\\n\\n      if (!modFunc) {\\n        throw MinimongoError(`Invalid modifier specified ${operator}`);\\n      }\\n\\n      Object.keys(operand).forEach(keypath => {\\n        const arg = operand[keypath];\\n\\n        if (keypath === '') {\\n          throw MinimongoError('An empty update path is not valid.');\\n        }\\n\\n        const keyparts = keypath.split('.');\\n\\n        if (!keyparts.every(Boolean)) {\\n          throw MinimongoError(\\n            `The update path '${keypath}' contains an empty field name, ` +\\n            'which is not allowed.'\\n          );\\n        }\\n\\n        const target = findModTarget(newDoc, keyparts, {\\n          arrayIndices: options.arrayIndices,\\n          forbidArray: operator === '$rename',\\n          noCreate: NO_CREATE_MODIFIERS[operator]\\n        });\\n\\n        modFunc(target, keyparts.pop(), arg, keypath, newDoc);\\n      });\\n    });\\n\\n    if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\\n      throw MinimongoError(\\n        `After applying the update to the document {_id: \\\"${doc._id}\\\", ...},` +\\n        ' the (immutable) field \\\\'_id\\\\' was found to have been altered to ' +\\n        `_id: \\\"${newDoc._id}\\\"`\\n      );\\n    }\\n  } else {\\n    if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\\n      throw MinimongoError(\\n        `The _id field cannot be changed from {_id: \\\"${doc._id}\\\"} to ` +\\n        `{_id: \\\"${modifier._id}\\\"}`\\n      );\\n    }\\n\\n    // replace the whole document\\n    assertHasValidFieldNames(modifier);\\n  }\\n\\n  // move new document into place.\\n  Object.keys(doc).forEach(key => {\\n    // Note: this used to be for (var key in doc) however, this does not\\n    // work right in Opera. Deleting from a doc while iterating over it\\n    // would sometimes cause opera to skip some keys.\\n    if (key !== '_id') {\\n      delete doc[key];\\n    }\\n  });\\n\\n  Object.keys(newDoc).forEach(key => {\\n    doc[key] = newDoc[key];\\n  });\\n};\\n\\nLocalCollection._observeFromObserveChanges = (cursor, observeCallbacks) => {\\n  const transform = cursor.getTransform() || (doc => doc);\\n  let suppressed = !!observeCallbacks._suppress_initial;\\n\\n  let observeChangesCallbacks;\\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\\n    // The \\\"_no_indices\\\" option sets all index arguments to -1 and skips the\\n    // linear scans required to generate them.  This lets observers that don't\\n    // need absolute indices benefit from the other features of this API --\\n    // relative order, transforms, and applyChanges -- without the speed hit.\\n    const indices = !observeCallbacks._no_indices;\\n\\n    observeChangesCallbacks = {\\n      addedBefore(id, fields, before) {\\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\\n          return;\\n        }\\n\\n        const doc = transform(Object.assign(fields, {_id: id}));\\n\\n        if (observeCallbacks.addedAt) {\\n          observeCallbacks.addedAt(\\n            doc,\\n            indices\\n              ? before\\n                ? this.docs.indexOf(before)\\n                : this.docs.size()\\n              : -1,\\n            before\\n          );\\n        } else {\\n          observeCallbacks.added(doc);\\n        }\\n      },\\n      changed(id, fields) {\\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\\n          return;\\n        }\\n\\n        let doc = EJSON.clone(this.docs.get(id));\\n        if (!doc) {\\n          throw new Error(`Unknown id for changed: ${id}`);\\n        }\\n\\n        const oldDoc = transform(EJSON.clone(doc));\\n\\n        DiffSequence.applyChanges(doc, fields);\\n\\n        if (observeCallbacks.changedAt) {\\n          observeCallbacks.changedAt(\\n            transform(doc),\\n            oldDoc,\\n            indices ? this.docs.indexOf(id) : -1\\n          );\\n        } else {\\n          observeCallbacks.changed(transform(doc), oldDoc);\\n        }\\n      },\\n      movedBefore(id, before) {\\n        if (!observeCallbacks.movedTo) {\\n          return;\\n        }\\n\\n        const from = indices ? this.docs.indexOf(id) : -1;\\n        let to = indices\\n          ? before\\n            ? this.docs.indexOf(before)\\n            : this.docs.size()\\n          : -1;\\n\\n        // When not moving backwards, adjust for the fact that removing the\\n        // document slides everything back one slot.\\n        if (to > from) {\\n          --to;\\n        }\\n\\n        observeCallbacks.movedTo(\\n          transform(EJSON.clone(this.docs.get(id))),\\n          from,\\n          to,\\n          before || null\\n        );\\n      },\\n      removed(id) {\\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\\n          return;\\n        }\\n\\n        // technically maybe there should be an EJSON.clone here, but it's about\\n        // to be removed from this.docs!\\n        const doc = transform(this.docs.get(id));\\n\\n        if (observeCallbacks.removedAt) {\\n          observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\\n        } else {\\n          observeCallbacks.removed(doc);\\n        }\\n      },\\n    };\\n  } else {\\n    observeChangesCallbacks = {\\n      added(id, fields) {\\n        if (!suppressed && observeCallbacks.added) {\\n          observeCallbacks.added(transform(Object.assign(fields, {_id: id})));\\n        }\\n      },\\n      changed(id, fields) {\\n        if (observeCallbacks.changed) {\\n          const oldDoc = this.docs.get(id);\\n          const doc = EJSON.clone(oldDoc);\\n\\n          DiffSequence.applyChanges(doc, fields);\\n\\n          observeCallbacks.changed(\\n            transform(doc),\\n            transform(EJSON.clone(oldDoc))\\n          );\\n        }\\n      },\\n      removed(id) {\\n        if (observeCallbacks.removed) {\\n          observeCallbacks.removed(transform(this.docs.get(id)));\\n        }\\n      },\\n    };\\n  }\\n\\n  const changeObserver = new LocalCollection._CachingChangeObserver({\\n    callbacks: observeChangesCallbacks\\n  });\\n\\n  const handle = cursor.observeChanges(changeObserver.applyChange);\\n\\n  suppressed = false;\\n\\n  return handle;\\n};\\n\\nLocalCollection._observeCallbacksAreOrdered = callbacks => {\\n  if (callbacks.added && callbacks.addedAt) {\\n    throw new Error('Please specify only one of added() and addedAt()');\\n  }\\n\\n  if (callbacks.changed && callbacks.changedAt) {\\n    throw new Error('Please specify only one of changed() and changedAt()');\\n  }\\n\\n  if (callbacks.removed && callbacks.removedAt) {\\n    throw new Error('Please specify only one of removed() and removedAt()');\\n  }\\n\\n  return !!(\\n    callbacks.addedAt ||\\n    callbacks.changedAt ||\\n    callbacks.movedTo ||\\n    callbacks.removedAt\\n  );\\n};\\n\\nLocalCollection._observeChangesCallbacksAreOrdered = callbacks => {\\n  if (callbacks.added && callbacks.addedBefore) {\\n    throw new Error('Please specify only one of added() and addedBefore()');\\n  }\\n\\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\\n};\\n\\nLocalCollection._removeFromResults = (query, doc) => {\\n  if (query.ordered) {\\n    const i = LocalCollection._findInOrderedResults(query, doc);\\n\\n    query.removed(doc._id);\\n    query.results.splice(i, 1);\\n  } else {\\n    const id = doc._id;  // in case callback mutates doc\\n\\n    query.removed(doc._id);\\n    query.results.remove(id);\\n  }\\n};\\n\\n// Is this selector just shorthand for lookup by _id?\\nLocalCollection._selectorIsId = selector =>\\n  typeof selector === 'number' ||\\n  typeof selector === 'string' ||\\n  selector instanceof MongoID.ObjectID\\n;\\n\\n// Is the selector just lookup by _id (shorthand or not)?\\nLocalCollection._selectorIsIdPerhapsAsObject = selector =>\\n  LocalCollection._selectorIsId(selector) ||\\n  LocalCollection._selectorIsId(selector && selector._id) &&\\n  Object.keys(selector).length === 1\\n;\\n\\nLocalCollection._updateInResults = (query, doc, old_doc) => {\\n  if (!EJSON.equals(doc._id, old_doc._id)) {\\n    throw new Error('Can\\\\'t change a doc\\\\'s _id while updating');\\n  }\\n\\n  const projectionFn = query.projectionFn;\\n  const changedFields = DiffSequence.makeChangedFields(\\n    projectionFn(doc),\\n    projectionFn(old_doc)\\n  );\\n\\n  if (!query.ordered) {\\n    if (Object.keys(changedFields).length) {\\n      query.changed(doc._id, changedFields);\\n      query.results.set(doc._id, doc);\\n    }\\n\\n    return;\\n  }\\n\\n  const old_idx = LocalCollection._findInOrderedResults(query, doc);\\n\\n  if (Object.keys(changedFields).length) {\\n    query.changed(doc._id, changedFields);\\n  }\\n\\n  if (!query.sorter) {\\n    return;\\n  }\\n\\n  // just take it out and put it back in again, and see if the index changes\\n  query.results.splice(old_idx, 1);\\n\\n  const new_idx = LocalCollection._insertInSortedList(\\n    query.sorter.getComparator({distances: query.distances}),\\n    query.results,\\n    doc\\n  );\\n\\n  if (old_idx !== new_idx) {\\n    let next = query.results[new_idx + 1];\\n    if (next) {\\n      next = next._id;\\n    } else {\\n      next = null;\\n    }\\n\\n    query.movedBefore && query.movedBefore(doc._id, next);\\n  }\\n};\\n\\nconst MODIFIERS = {\\n  $currentDate(target, field, arg) {\\n    if (typeof arg === 'object' && hasOwn.call(arg, '$type')) {\\n      if (arg.$type !== 'date') {\\n        throw MinimongoError(\\n          'Minimongo does currently only support the date type in ' +\\n          '$currentDate modifiers',\\n          {field}\\n        );\\n      }\\n    } else if (arg !== true) {\\n      throw MinimongoError('Invalid $currentDate modifier', {field});\\n    }\\n\\n    target[field] = new Date();\\n  },\\n  $min(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $min allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $min modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      if (target[field] > arg) {\\n        target[field] = arg;\\n      }\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $max(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $max allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $max modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      if (target[field] < arg) {\\n        target[field] = arg;\\n      }\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $inc(target, field, arg) {\\n    if (typeof arg !== 'number') {\\n      throw MinimongoError('Modifier $inc allowed for numbers only', {field});\\n    }\\n\\n    if (field in target) {\\n      if (typeof target[field] !== 'number') {\\n        throw MinimongoError(\\n          'Cannot apply $inc modifier to non-number',\\n          {field}\\n        );\\n      }\\n\\n      target[field] += arg;\\n    } else {\\n      target[field] = arg;\\n    }\\n  },\\n  $set(target, field, arg) {\\n    if (target !== Object(target)) { // not an array or an object\\n      const error = MinimongoError(\\n        'Cannot set property on non-object field',\\n        {field}\\n      );\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    if (target === null) {\\n      const error = MinimongoError('Cannot set property on null', {field});\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    assertHasValidFieldNames(arg);\\n\\n    target[field] = arg;\\n  },\\n  $setOnInsert(target, field, arg) {\\n    // converted to `$set` in `_modify`\\n  },\\n  $unset(target, field, arg) {\\n    if (target !== undefined) {\\n      if (target instanceof Array) {\\n        if (field in target) {\\n          target[field] = null;\\n        }\\n      } else {\\n        delete target[field];\\n      }\\n    }\\n  },\\n  $push(target, field, arg) {\\n    if (target[field] === undefined) {\\n      target[field] = [];\\n    }\\n\\n    if (!(target[field] instanceof Array)) {\\n      throw MinimongoError('Cannot apply $push modifier to non-array', {field});\\n    }\\n\\n    if (!(arg && arg.$each)) {\\n      // Simple mode: not $each\\n      assertHasValidFieldNames(arg);\\n\\n      target[field].push(arg);\\n\\n      return;\\n    }\\n\\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\\n    const toPush = arg.$each;\\n    if (!(toPush instanceof Array)) {\\n      throw MinimongoError('$each must be an array', {field});\\n    }\\n\\n    assertHasValidFieldNames(toPush);\\n\\n    // Parse $position\\n    let position = undefined;\\n    if ('$position' in arg) {\\n      if (typeof arg.$position !== 'number') {\\n        throw MinimongoError('$position must be a numeric value', {field});\\n      }\\n\\n      // XXX should check to make sure integer\\n      if (arg.$position < 0) {\\n        throw MinimongoError(\\n          '$position in $push must be zero or positive',\\n          {field}\\n        );\\n      }\\n\\n      position = arg.$position;\\n    }\\n\\n    // Parse $slice.\\n    let slice = undefined;\\n    if ('$slice' in arg) {\\n      if (typeof arg.$slice !== 'number') {\\n        throw MinimongoError('$slice must be a numeric value', {field});\\n      }\\n\\n      // XXX should check to make sure integer\\n      slice = arg.$slice;\\n    }\\n\\n    // Parse $sort.\\n    let sortFunction = undefined;\\n    if (arg.$sort) {\\n      if (slice === undefined) {\\n        throw MinimongoError('$sort requires $slice to be present', {field});\\n      }\\n\\n      // XXX this allows us to use a $sort whose value is an array, but that's\\n      // actually an extension of the Node driver, so it won't work\\n      // server-side. Could be confusing!\\n      // XXX is it correct that we don't do geo-stuff here?\\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\\n\\n      toPush.forEach(element => {\\n        if (LocalCollection._f._type(element) !== 3) {\\n          throw MinimongoError(\\n            '$push like modifiers using $sort require all elements to be ' +\\n            'objects',\\n            {field}\\n          );\\n        }\\n      });\\n    }\\n\\n    // Actually push.\\n    if (position === undefined) {\\n      toPush.forEach(element => {\\n        target[field].push(element);\\n      });\\n    } else {\\n      const spliceArguments = [position, 0];\\n\\n      toPush.forEach(element => {\\n        spliceArguments.push(element);\\n      });\\n\\n      target[field].splice(...spliceArguments);\\n    }\\n\\n    // Actually sort.\\n    if (sortFunction) {\\n      target[field].sort(sortFunction);\\n    }\\n\\n    // Actually slice.\\n    if (slice !== undefined) {\\n      if (slice === 0) {\\n        target[field] = []; // differs from Array.slice!\\n      } else if (slice < 0) {\\n        target[field] = target[field].slice(slice);\\n      } else {\\n        target[field] = target[field].slice(0, slice);\\n      }\\n    }\\n  },\\n  $pushAll(target, field, arg) {\\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\\n      throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\\n    }\\n\\n    assertHasValidFieldNames(arg);\\n\\n    const toPush = target[field];\\n\\n    if (toPush === undefined) {\\n      target[field] = arg;\\n    } else if (!(toPush instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pushAll modifier to non-array',\\n        {field}\\n      );\\n    } else {\\n      toPush.push(...arg);\\n    }\\n  },\\n  $addToSet(target, field, arg) {\\n    let isEach = false;\\n\\n    if (typeof arg === 'object') {\\n      // check if first key is '$each'\\n      const keys = Object.keys(arg);\\n      if (keys[0] === '$each') {\\n        isEach = true;\\n      }\\n    }\\n\\n    const values = isEach ? arg.$each : [arg];\\n\\n    assertHasValidFieldNames(values);\\n\\n    const toAdd = target[field];\\n    if (toAdd === undefined) {\\n      target[field] = values;\\n    } else if (!(toAdd instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $addToSet modifier to non-array',\\n        {field}\\n      );\\n    } else {\\n      values.forEach(value => {\\n        if (toAdd.some(element => LocalCollection._f._equal(value, element))) {\\n          return;\\n        }\\n\\n        toAdd.push(value);\\n      });\\n    }\\n  },\\n  $pop(target, field, arg) {\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPop = target[field];\\n\\n    if (toPop === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPop instanceof Array)) {\\n      throw MinimongoError('Cannot apply $pop modifier to non-array', {field});\\n    }\\n\\n    if (typeof arg === 'number' && arg < 0) {\\n      toPop.splice(0, 1);\\n    } else {\\n      toPop.pop();\\n    }\\n  },\\n  $pull(target, field, arg) {\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPull = target[field];\\n    if (toPull === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPull instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pull/pullAll modifier to non-array',\\n        {field}\\n      );\\n    }\\n\\n    let out;\\n    if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\\n      // XXX would be much nicer to compile this once, rather than\\n      // for each document we modify.. but usually we're not\\n      // modifying that many documents, so we'll let it slide for\\n      // now\\n\\n      // XXX Minimongo.Matcher isn't up for the job, because we need\\n      // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\\n      // like {$gt: 4} is not normally a complete selector.\\n      // same issue as $elemMatch possibly?\\n      const matcher = new Minimongo.Matcher(arg);\\n\\n      out = toPull.filter(element => !matcher.documentMatches(element).result);\\n    } else {\\n      out = toPull.filter(element => !LocalCollection._f._equal(element, arg));\\n    }\\n\\n    target[field] = out;\\n  },\\n  $pullAll(target, field, arg) {\\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\\n      throw MinimongoError(\\n        'Modifier $pushAll/pullAll allowed for arrays only',\\n        {field}\\n      );\\n    }\\n\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const toPull = target[field];\\n\\n    if (toPull === undefined) {\\n      return;\\n    }\\n\\n    if (!(toPull instanceof Array)) {\\n      throw MinimongoError(\\n        'Cannot apply $pull/pullAll modifier to non-array',\\n        {field}\\n      );\\n    }\\n\\n    target[field] = toPull.filter(object =>\\n      !arg.some(element => LocalCollection._f._equal(object, element))\\n    );\\n  },\\n  $rename(target, field, arg, keypath, doc) {\\n    // no idea why mongo has this restriction..\\n    if (keypath === arg) {\\n      throw MinimongoError('$rename source must differ from target', {field});\\n    }\\n\\n    if (target === null) {\\n      throw MinimongoError('$rename source field invalid', {field});\\n    }\\n\\n    if (typeof arg !== 'string') {\\n      throw MinimongoError('$rename target must be a string', {field});\\n    }\\n\\n    if (arg.includes('\\\\0')) {\\n      // Null bytes are not allowed in Mongo field names\\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\\n      throw MinimongoError(\\n        'The \\\\'to\\\\' field for $rename cannot contain an embedded null byte',\\n        {field}\\n      );\\n    }\\n\\n    if (target === undefined) {\\n      return;\\n    }\\n\\n    const object = target[field];\\n\\n    delete target[field];\\n\\n    const keyparts = arg.split('.');\\n    const target2 = findModTarget(doc, keyparts, {forbidArray: true});\\n\\n    if (target2 === null) {\\n      throw MinimongoError('$rename target field invalid', {field});\\n    }\\n\\n    target2[keyparts.pop()] = object;\\n  },\\n  $bit(target, field, arg) {\\n    // XXX mongo only supports $bit on integers, and we only support\\n    // native javascript numbers (doubles) so far, so we can't support $bit\\n    throw MinimongoError('$bit is not supported', {field});\\n  },\\n  $v() {\\n    // As discussed in https://github.com/meteor/meteor/issues/9623,\\n    // the `$v` operator is not needed by Meteor, but problems can occur if\\n    // it's not at least callable (as of Mongo >= 3.6). It's defined here as\\n    // a no-op to work around these problems.\\n  }\\n};\\n\\nconst NO_CREATE_MODIFIERS = {\\n  $pop: true,\\n  $pull: true,\\n  $pullAll: true,\\n  $rename: true,\\n  $unset: true\\n};\\n\\n// Make sure field names do not contain Mongo restricted\\n// characters ('.', '$', '\\\\0').\\n// https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\\nconst invalidCharMsg = {\\n  $: 'start with \\\\'$\\\\'',\\n  '.': 'contain \\\\'.\\\\'',\\n  '\\\\0': 'contain null bytes'\\n};\\n\\n// checks if all field names in an object are valid\\nfunction assertHasValidFieldNames(doc) {\\n  if (doc && typeof doc === 'object') {\\n    JSON.stringify(doc, (key, value) => {\\n      assertIsValidFieldName(key);\\n      return value;\\n    });\\n  }\\n}\\n\\nfunction assertIsValidFieldName(key) {\\n  let match;\\n  if (typeof key === 'string' && (match = key.match(/^\\\\$|\\\\.|\\\\0/))) {\\n    throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\\n  }\\n}\\n\\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\\n// and then you would operate on the 'e' property of the returned\\n// object.\\n//\\n// if options.noCreate is falsey, creates intermediate levels of\\n// structure as necessary, like mkdir -p (and raises an exception if\\n// that would mean giving a non-numeric property to an array.) if\\n// options.noCreate is true, return undefined instead.\\n//\\n// may modify the last element of keyparts to signal to the caller that it needs\\n// to use a different value to index into the returned object (for example,\\n// ['a', '01'] -> ['a', 1]).\\n//\\n// if forbidArray is true, return null if the keypath goes through an array.\\n//\\n// if options.arrayIndices is set, use its first element for the (first) '$' in\\n// the path.\\nfunction findModTarget(doc, keyparts, options = {}) {\\n  let usedArrayIndex = false;\\n\\n  for (let i = 0; i < keyparts.length; i++) {\\n    const last = i === keyparts.length - 1;\\n    let keypart = keyparts[i];\\n\\n    if (!isIndexable(doc)) {\\n      if (options.noCreate) {\\n        return undefined;\\n      }\\n\\n      const error = MinimongoError(\\n        `cannot use the part '${keypart}' to traverse ${doc}`\\n      );\\n      error.setPropertyError = true;\\n      throw error;\\n    }\\n\\n    if (doc instanceof Array) {\\n      if (options.forbidArray) {\\n        return null;\\n      }\\n\\n      if (keypart === '$') {\\n        if (usedArrayIndex) {\\n          throw MinimongoError('Too many positional (i.e. \\\\'$\\\\') elements');\\n        }\\n\\n        if (!options.arrayIndices || !options.arrayIndices.length) {\\n          throw MinimongoError(\\n            'The positional operator did not find the match needed from the ' +\\n            'query'\\n          );\\n        }\\n\\n        keypart = options.arrayIndices[0];\\n        usedArrayIndex = true;\\n      } else if (isNumericKey(keypart)) {\\n        keypart = parseInt(keypart);\\n      } else {\\n        if (options.noCreate) {\\n          return undefined;\\n        }\\n\\n        throw MinimongoError(\\n          `can't append to array using string field name [${keypart}]`\\n        );\\n      }\\n\\n      if (last) {\\n        keyparts[i] = keypart; // handle 'a.01'\\n      }\\n\\n      if (options.noCreate && keypart >= doc.length) {\\n        return undefined;\\n      }\\n\\n      while (doc.length < keypart) {\\n        doc.push(null);\\n      }\\n\\n      if (!last) {\\n        if (doc.length === keypart) {\\n          doc.push({});\\n        } else if (typeof doc[keypart] !== 'object') {\\n          throw MinimongoError(\\n            `can't modify field '${keyparts[i + 1]}' of list value ` +\\n            JSON.stringify(doc[keypart])\\n          );\\n        }\\n      }\\n    } else {\\n      assertIsValidFieldName(keypart);\\n\\n      if (!(keypart in doc)) {\\n        if (options.noCreate) {\\n          return undefined;\\n        }\\n\\n        if (!last) {\\n          doc[keypart] = {};\\n        }\\n      }\\n    }\\n\\n    if (last) {\\n      return doc;\\n    }\\n\\n    doc = doc[keypart];\\n  }\\n\\n  // notreached\\n}\\n\",\"import LocalCollection from './local_collection.js';\\nimport {\\n  compileDocumentSelector,\\n  hasOwn,\\n  nothingMatcher,\\n} from './common.js';\\n\\n// The minimongo selector compiler!\\n\\n// Terminology:\\n//  - a 'selector' is the EJSON object representing a selector\\n//  - a 'matcher' is its compiled form (whether a full Minimongo.Matcher\\n//    object or one of the component lambdas that matches parts of it)\\n//  - a 'result object' is an object with a 'result' field and maybe\\n//    distance and arrayIndices.\\n//  - a 'branched value' is an object with a 'value' field and maybe\\n//    'dontIterate' and 'arrayIndices'.\\n//  - a 'document' is a top-level object that can be stored in a collection.\\n//  - a 'lookup function' is a function that takes in a document and returns\\n//    an array of 'branched values'.\\n//  - a 'branched matcher' maps from an array of branched values to a result\\n//    object.\\n//  - an 'element matcher' maps from a single value to a bool.\\n\\n// Main entry point.\\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});\\n//   if (matcher.documentMatches({a: 7})) ...\\nexport default class Matcher {\\n  constructor(selector, isUpdate) {\\n    // A set (object mapping string -> *) of all of the document paths looked\\n    // at by the selector. Also includes the empty string if it may look at any\\n    // path (eg, $where).\\n    this._paths = {};\\n    // Set to true if compilation finds a $near.\\n    this._hasGeoQuery = false;\\n    // Set to true if compilation finds a $where.\\n    this._hasWhere = false;\\n    // Set to false if compilation finds anything other than a simple equality\\n    // or one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used\\n    // with scalars as operands.\\n    this._isSimple = true;\\n    // Set to a dummy document which always matches this Matcher. Or set to null\\n    // if such document is too hard to find.\\n    this._matchingDocument = undefined;\\n    // A clone of the original selector. It may just be a function if the user\\n    // passed in a function; otherwise is definitely an object (eg, IDs are\\n    // translated into {_id: ID} first. Used by canBecomeTrueByModifier and\\n    // Sorter._useWithMatcher.\\n    this._selector = null;\\n    this._docMatcher = this._compileSelector(selector);\\n    // Set to true if selection is done for an update operation\\n    // Default is false\\n    // Used for $near array update (issue #3599)\\n    this._isUpdate = isUpdate;\\n  }\\n\\n  documentMatches(doc) {\\n    if (doc !== Object(doc)) {\\n      throw Error('documentMatches needs a document');\\n    }\\n\\n    return this._docMatcher(doc);\\n  }\\n\\n  hasGeoQuery() {\\n    return this._hasGeoQuery;\\n  }\\n\\n  hasWhere() {\\n    return this._hasWhere;\\n  }\\n\\n  isSimple() {\\n    return this._isSimple;\\n  }\\n\\n  // Given a selector, return a function that takes one argument, a\\n  // document. It returns a result object.\\n  _compileSelector(selector) {\\n    // you can pass a literal function instead of a selector\\n    if (selector instanceof Function) {\\n      this._isSimple = false;\\n      this._selector = selector;\\n      this._recordPathUsed('');\\n\\n      return doc => ({result: !!selector.call(doc)});\\n    }\\n\\n    // shorthand -- scalar _id\\n    if (LocalCollection._selectorIsId(selector)) {\\n      this._selector = {_id: selector};\\n      this._recordPathUsed('_id');\\n\\n      return doc => ({result: EJSON.equals(doc._id, selector)});\\n    }\\n\\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both\\n    // likely programmer error, and not what you want, particularly for\\n    // destructive operations.\\n    if (!selector || hasOwn.call(selector, '_id') && !selector._id) {\\n      this._isSimple = false;\\n      return nothingMatcher;\\n    }\\n\\n    // Top level can't be an array or true or binary.\\n    if (Array.isArray(selector) ||\\n        EJSON.isBinary(selector) ||\\n        typeof selector === 'boolean') {\\n      throw new Error(`Invalid selector: ${selector}`);\\n    }\\n\\n    this._selector = EJSON.clone(selector);\\n\\n    return compileDocumentSelector(selector, this, {isRoot: true});\\n  }\\n\\n  // Returns a list of key paths the given selector is looking for. It includes\\n  // the empty string if there is a $where.\\n  _getPaths() {\\n    return Object.keys(this._paths);\\n  }\\n\\n  _recordPathUsed(path) {\\n    this._paths[path] = true;\\n  }\\n}\\n\\n// helpers used by compiled selector code\\nLocalCollection._f = {\\n  // XXX for _all and _in, consider building 'inquery' at compile time..\\n  _type(v) {\\n    if (typeof v === 'number') {\\n      return 1;\\n    }\\n\\n    if (typeof v === 'string') {\\n      return 2;\\n    }\\n\\n    if (typeof v === 'boolean') {\\n      return 8;\\n    }\\n\\n    if (Array.isArray(v)) {\\n      return 4;\\n    }\\n\\n    if (v === null) {\\n      return 10;\\n    }\\n\\n    // note that typeof(/x/) === \\\"object\\\"\\n    if (v instanceof RegExp) {\\n      return 11;\\n    }\\n\\n    if (typeof v === 'function') {\\n      return 13;\\n    }\\n\\n    if (v instanceof Date) {\\n      return 9;\\n    }\\n\\n    if (EJSON.isBinary(v)) {\\n      return 5;\\n    }\\n\\n    if (v instanceof MongoID.ObjectID) {\\n      return 7;\\n    }\\n\\n    // object\\n    return 3;\\n\\n    // XXX support some/all of these:\\n    // 14, symbol\\n    // 15, javascript code with scope\\n    // 16, 18: 32-bit/64-bit integer\\n    // 17, timestamp\\n    // 255, minkey\\n    // 127, maxkey\\n  },\\n\\n  // deep equality test: use for literal document and array matches\\n  _equal(a, b) {\\n    return EJSON.equals(a, b, {keyOrderSensitive: true});\\n  },\\n\\n  // maps a type code to a value that can be used to sort values of different\\n  // types\\n  _typeorder(t) {\\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\\n    // XXX what is the correct sort position for Javascript code?\\n    // ('100' in the matrix below)\\n    // XXX minkey/maxkey\\n    return [\\n      -1,  // (not a type)\\n      1,   // number\\n      2,   // string\\n      3,   // object\\n      4,   // array\\n      5,   // binary\\n      -1,  // deprecated\\n      6,   // ObjectID\\n      7,   // bool\\n      8,   // Date\\n      0,   // null\\n      9,   // RegExp\\n      -1,  // deprecated\\n      100, // JS code\\n      2,   // deprecated (symbol)\\n      100, // JS code\\n      1,   // 32-bit int\\n      8,   // Mongo timestamp\\n      1    // 64-bit int\\n    ][t];\\n  },\\n\\n  // compare two values of unknown type according to BSON ordering\\n  // semantics. (as an extension, consider 'undefined' to be less than\\n  // any other value.) return negative if a is less, positive if b is\\n  // less, or 0 if equal\\n  _cmp(a, b) {\\n    if (a === undefined) {\\n      return b === undefined ? 0 : -1;\\n    }\\n\\n    if (b === undefined) {\\n      return 1;\\n    }\\n\\n    let ta = LocalCollection._f._type(a);\\n    let tb = LocalCollection._f._type(b);\\n\\n    const oa = LocalCollection._f._typeorder(ta);\\n    const ob = LocalCollection._f._typeorder(tb);\\n\\n    if (oa !== ob) {\\n      return oa < ob ? -1 : 1;\\n    }\\n\\n    // XXX need to implement this if we implement Symbol or integers, or\\n    // Timestamp\\n    if (ta !== tb) {\\n      throw Error('Missing type coercion logic in _cmp');\\n    }\\n\\n    if (ta === 7) { // ObjectID\\n      // Convert to string.\\n      ta = tb = 2;\\n      a = a.toHexString();\\n      b = b.toHexString();\\n    }\\n\\n    if (ta === 9) { // Date\\n      // Convert to millis.\\n      ta = tb = 1;\\n      a = a.getTime();\\n      b = b.getTime();\\n    }\\n\\n    if (ta === 1) // double\\n      return a - b;\\n\\n    if (tb === 2) // string\\n      return a < b ? -1 : a === b ? 0 : 1;\\n\\n    if (ta === 3) { // Object\\n      // this could be much more efficient in the expected case ...\\n      const toArray = object => {\\n        const result = [];\\n\\n        Object.keys(object).forEach(key => {\\n          result.push(key, object[key]);\\n        });\\n\\n        return result;\\n      };\\n\\n      return LocalCollection._f._cmp(toArray(a), toArray(b));\\n    }\\n\\n    if (ta === 4) { // Array\\n      for (let i = 0; ; i++) {\\n        if (i === a.length) {\\n          return i === b.length ? 0 : -1;\\n        }\\n\\n        if (i === b.length) {\\n          return 1;\\n        }\\n\\n        const s = LocalCollection._f._cmp(a[i], b[i]);\\n        if (s !== 0) {\\n          return s;\\n        }\\n      }\\n    }\\n\\n    if (ta === 5) { // binary\\n      // Surprisingly, a small binary blob is always less than a large one in\\n      // Mongo.\\n      if (a.length !== b.length) {\\n        return a.length - b.length;\\n      }\\n\\n      for (let i = 0; i < a.length; i++) {\\n        if (a[i] < b[i]) {\\n          return -1;\\n        }\\n\\n        if (a[i] > b[i]) {\\n          return 1;\\n        }\\n      }\\n\\n      return 0;\\n    }\\n\\n    if (ta === 8) { // boolean\\n      if (a) {\\n        return b ? 0 : 1;\\n      }\\n\\n      return b ? -1 : 0;\\n    }\\n\\n    if (ta === 10) // null\\n      return 0;\\n\\n    if (ta === 11) // regexp\\n      throw Error('Sorting not supported on regular expression'); // XXX\\n\\n    // 13: javascript code\\n    // 14: symbol\\n    // 15: javascript code with scope\\n    // 16: 32-bit integer\\n    // 17: timestamp\\n    // 18: 64-bit integer\\n    // 255: minkey\\n    // 127: maxkey\\n    if (ta === 13) // javascript code\\n      throw Error('Sorting not supported on Javascript code'); // XXX\\n\\n    throw Error('Unknown type to sort');\\n  },\\n};\\n\",\"import LocalCollection_ from './local_collection.js';\\nimport Matcher from './matcher.js';\\nimport Sorter from './sorter.js';\\n\\nLocalCollection = LocalCollection_;\\nMinimongo = {\\n    LocalCollection: LocalCollection_,\\n    Matcher,\\n    Sorter\\n};\\n\",\"// ObserveHandle: the return value of a live query.\\nexport default class ObserveHandle {}\\n\",\"import {\\n  ELEMENT_OPERATORS,\\n  equalityElementMatcher,\\n  expandArraysInBranches,\\n  hasOwn,\\n  isOperatorObject,\\n  makeLookupFunction,\\n  regexpElementMatcher,\\n} from './common.js';\\n\\n// Give a sort spec, which can be in any of these forms:\\n//   {\\\"key1\\\": 1, \\\"key2\\\": -1}\\n//   [[\\\"key1\\\", \\\"asc\\\"], [\\\"key2\\\", \\\"desc\\\"]]\\n//   [\\\"key1\\\", [\\\"key2\\\", \\\"desc\\\"]]\\n//\\n// (.. with the first form being dependent on the key enumeration\\n// behavior of your javascript VM, which usually does what you mean in\\n// this case if the key names don't look like integers ..)\\n//\\n// return a function that takes two objects, and returns -1 if the\\n// first object comes first in order, 1 if the second object comes\\n// first, or 0 if neither object comes before the other.\\n\\nexport default class Sorter {\\n  constructor(spec) {\\n    this._sortSpecParts = [];\\n    this._sortFunction = null;\\n\\n    const addSpecPart = (path, ascending) => {\\n      if (!path) {\\n        throw Error('sort keys must be non-empty');\\n      }\\n\\n      if (path.charAt(0) === '$') {\\n        throw Error(`unsupported sort key: ${path}`);\\n      }\\n\\n      this._sortSpecParts.push({\\n        ascending,\\n        lookup: makeLookupFunction(path, {forSort: true}),\\n        path\\n      });\\n    };\\n\\n    if (spec instanceof Array) {\\n      spec.forEach(element => {\\n        if (typeof element === 'string') {\\n          addSpecPart(element, true);\\n        } else {\\n          addSpecPart(element[0], element[1] !== 'desc');\\n        }\\n      });\\n    } else if (typeof spec === 'object') {\\n      Object.keys(spec).forEach(key => {\\n        addSpecPart(key, spec[key] >= 0);\\n      });\\n    } else if (typeof spec === 'function') {\\n      this._sortFunction = spec;\\n    } else {\\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\\n    }\\n\\n    // If a function is specified for sorting, we skip the rest.\\n    if (this._sortFunction) {\\n      return;\\n    }\\n\\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\\n    // affectedByModifier code; we create a selector that is affected by the\\n    // same modifiers as this sort order. This is only implemented on the\\n    // server.\\n    if (this.affectedByModifier) {\\n      const selector = {};\\n\\n      this._sortSpecParts.forEach(spec => {\\n        selector[spec.path] = 1;\\n      });\\n\\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\\n    }\\n\\n    this._keyComparator = composeComparators(\\n      this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))\\n    );\\n  }\\n\\n  getComparator(options) {\\n    // If sort is specified or have no distances, just use the comparator from\\n    // the source specification (which defaults to \\\"everything is equal\\\".\\n    // issue #3599\\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\\n    // sort effectively overrides $near\\n    if (this._sortSpecParts.length || !options || !options.distances) {\\n      return this._getBaseComparator();\\n    }\\n\\n    const distances = options.distances;\\n\\n    // Return a comparator which compares using $near distances.\\n    return (a, b) => {\\n      if (!distances.has(a._id)) {\\n        throw Error(`Missing distance for ${a._id}`);\\n      }\\n\\n      if (!distances.has(b._id)) {\\n        throw Error(`Missing distance for ${b._id}`);\\n      }\\n\\n      return distances.get(a._id) - distances.get(b._id);\\n    };\\n  }\\n\\n  // Takes in two keys: arrays whose lengths match the number of spec\\n  // parts. Returns negative, 0, or positive based on using the sort spec to\\n  // compare fields.\\n  _compareKeys(key1, key2) {\\n    if (key1.length !== this._sortSpecParts.length ||\\n        key2.length !== this._sortSpecParts.length) {\\n      throw Error('Key has wrong length');\\n    }\\n\\n    return this._keyComparator(key1, key2);\\n  }\\n\\n  // Iterates over each possible \\\"key\\\" from doc (ie, over each branch), calling\\n  // 'cb' with the key.\\n  _generateKeysFromDoc(doc, cb) {\\n    if (this._sortSpecParts.length === 0) {\\n      throw new Error('can\\\\'t generate keys without a spec');\\n    }\\n\\n    const pathFromIndices = indices => `${indices.join(',')},`;\\n\\n    let knownPaths = null;\\n\\n    // maps index -> ({'' -> value} or {path -> value})\\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\\n      // Expand any leaf arrays that we find, and ignore those arrays\\n      // themselves.  (We never sort based on an array itself.)\\n      let branches = expandArraysInBranches(spec.lookup(doc), true);\\n\\n      // If there are no values for a key (eg, key goes to an empty array),\\n      // pretend we found one undefined value.\\n      if (!branches.length) {\\n        branches = [{ value: void 0 }];\\n      }\\n\\n      const element = Object.create(null);\\n      let usedPaths = false;\\n\\n      branches.forEach(branch => {\\n        if (!branch.arrayIndices) {\\n          // If there are no array indices for a branch, then it must be the\\n          // only branch, because the only thing that produces multiple branches\\n          // is the use of arrays.\\n          if (branches.length > 1) {\\n            throw Error('multiple branches but no array used?');\\n          }\\n\\n          element[''] = branch.value;\\n          return;\\n        }\\n\\n        usedPaths = true;\\n\\n        const path = pathFromIndices(branch.arrayIndices);\\n\\n        if (hasOwn.call(element, path)) {\\n          throw Error(`duplicate path: ${path}`);\\n        }\\n\\n        element[path] = branch.value;\\n\\n        // If two sort fields both go into arrays, they have to go into the\\n        // exact same arrays and we have to find the same paths.  This is\\n        // roughly the same condition that makes MongoDB throw this strange\\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\\n        // b:1} then a and b cannot both be arrays.\\n        //\\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\\n        // #NestedArraySort\\n        // XXX achieve full compatibility here\\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\\n          throw Error('cannot index parallel arrays');\\n        }\\n      });\\n\\n      if (knownPaths) {\\n        // Similarly to above, paths must match everywhere, unless this is a\\n        // non-array field.\\n        if (!hasOwn.call(element, '') &&\\n            Object.keys(knownPaths).length !== Object.keys(element).length) {\\n          throw Error('cannot index parallel arrays!');\\n        }\\n      } else if (usedPaths) {\\n        knownPaths = {};\\n\\n        Object.keys(element).forEach(path => {\\n          knownPaths[path] = true;\\n        });\\n      }\\n\\n      return element;\\n    });\\n\\n    if (!knownPaths) {\\n      // Easy case: no use of arrays.\\n      const soleKey = valuesByIndexAndPath.map(values => {\\n        if (!hasOwn.call(values, '')) {\\n          throw Error('no value in sole key case?');\\n        }\\n\\n        return values[''];\\n      });\\n\\n      cb(soleKey);\\n\\n      return;\\n    }\\n\\n    Object.keys(knownPaths).forEach(path => {\\n      const key = valuesByIndexAndPath.map(values => {\\n        if (hasOwn.call(values, '')) {\\n          return values[''];\\n        }\\n\\n        if (!hasOwn.call(values, path)) {\\n          throw Error('missing path?');\\n        }\\n\\n        return values[path];\\n      });\\n\\n      cb(key);\\n    });\\n  }\\n\\n  // Returns a comparator that represents the sort specification (but not\\n  // including a possible geoquery distance tie-breaker).\\n  _getBaseComparator() {\\n    if (this._sortFunction) {\\n      return this._sortFunction;\\n    }\\n\\n    // If we're only sorting on geoquery distance and no specs, just say\\n    // everything is equal.\\n    if (!this._sortSpecParts.length) {\\n      return (doc1, doc2) => 0;\\n    }\\n\\n    return (doc1, doc2) => {\\n      const key1 = this._getMinKeyFromDoc(doc1);\\n      const key2 = this._getMinKeyFromDoc(doc2);\\n      return this._compareKeys(key1, key2);\\n    };\\n  }\\n\\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\\n  // \\\"minimum\\\" here but this is with respect to the sort spec, so \\\"descending\\\"\\n  // sort fields mean we're finding the max for that field.)\\n  //\\n  // Note that this is NOT \\\"find the minimum value of the first field, the\\n  // minimum value of the second field, etc\\\"... it's \\\"choose the\\n  // lexicographically minimum value of the key vector, allowing only keys which\\n  // you can find along the same paths\\\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\\n  _getMinKeyFromDoc(doc) {\\n    let minKey = null;\\n\\n    this._generateKeysFromDoc(doc, key => {\\n      if (minKey === null) {\\n        minKey = key;\\n        return;\\n      }\\n\\n      if (this._compareKeys(key, minKey) < 0) {\\n        minKey = key;\\n      }\\n    });\\n\\n    return minKey;\\n  }\\n\\n  _getPaths() {\\n    return this._sortSpecParts.map(part => part.path);\\n  }\\n\\n  // Given an index 'i', returns a comparator that compares two key arrays based\\n  // on field 'i'.\\n  _keyFieldComparator(i) {\\n    const invert = !this._sortSpecParts[i].ascending;\\n\\n    return (key1, key2) => {\\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\\n      return invert ? -compare : compare;\\n    };\\n  }\\n}\\n\\n// Given an array of comparators\\n// (functions (a,b)->(negative or positive or zero)), returns a single\\n// comparator which uses each comparator in order and returns the first\\n// non-zero value.\\nfunction composeComparators(comparatorArray) {\\n  return (a, b) => {\\n    for (let i = 0; i < comparatorArray.length; ++i) {\\n      const compare = comparatorArray[i](a, b);\\n      if (compare !== 0) {\\n        return compare;\\n      }\\n    }\\n\\n    return 0;\\n  };\\n}\\n\"]}","minifier":"terser"}