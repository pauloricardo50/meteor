{"code":"!function(){var e=Package.meteor.Meteor,o=Package.meteor.global,t=Package.meteor.meteorEnv,n=Package.tracker.Tracker,i=Package.tracker.Deps,s=Package.random.Random,r=Package[\"callback-hook\"].Hook,a=Package[\"reactive-var\"].ReactiveVar,c=Package[\"ddp-client\"].DDP,l=Package.mongo.Mongo,g=Package.modules.meteorInstall,h=Package[\"babel-runtime\"].meteorBabelHelpers,_=Package.promise.Promise,u,d,p,k,m=g({node_modules:{meteor:{\"accounts-base\":{\"client_main.js\":function(o,t,n){let i,s;n.export({Accounts:()=>u,AccountsClient:()=>i,AccountsTest:()=>s,default:()=>t}),n.link(\"./accounts_client.js\",{AccountsClient(e){i=e},AccountsTest(e){s=e}},0),n.runSetters(u=new i),e.users=u.users},\"accounts_client.js\":function(o,t,n){var i,r=o(\"@babel/runtime/helpers/interopRequireDefault\")(o(\"@babel/runtime/helpers/objectSpread\"));let l;n.export({AccountsClient:()=>g,AccountsTest:()=>d}),n.link(\"./accounts_common.js\",{AccountsCommon(e){l=e}},0);class g extends l{constructor(e){super(e),this._loggingIn=new a(!1),this._loggingOut=new a(!1),this._loginServicesHandle=this.connection.subscribe(\"meteor.loginServiceConfiguration\"),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=null,this.savedHash=window.location.hash,this._initUrlMatching(),this._initLocalStorage(),this._loginFuncs={}}userId(){return this.connection.userId()}_setLoggingIn(e){this._loggingIn.set(e)}loggingIn(){return this._loggingIn.get()}loggingOut(){return this._loggingOut.get()}registerClientLoginFunction(e,o){if(this._loginFuncs[e])throw new Error(\"\".concat(e,\" has been defined already\"));this._loginFuncs[e]=o}callLoginFunction(e){if(!this._loginFuncs[e])throw new Error(\"\".concat(e,\" was not defined\"));for(var o=arguments.length,t=new Array(o>1?o-1:0),n=1;n<o;n++)t[n-1]=arguments[n];return this._loginFuncs[e].apply(this,t)}applyLoginFunction(e,o){if(!this._loginFuncs[e])throw new Error(\"\".concat(e,\" was not defined\"));return this._loginFuncs[e].apply(this,o)}logout(e){this._loggingOut.set(!0),this.connection.apply(\"logout\",[],{wait:!0},(o,t)=>{this._loggingOut.set(!1),o?e&&e(o):(this.makeClientLoggedOut(),e&&e())})}logoutOtherClients(e){this.connection.apply(\"getNewToken\",[],{wait:!0},(e,o)=>{e||this._storeLoginToken(this.userId(),o.token,o.tokenExpires)}),this.connection.apply(\"removeOtherTokens\",[],{wait:!0},o=>e&&e(o))}callLoginMethod(e){let o;e=(0,r.default)({methodName:\"login\",methodArguments:[{}],_suppressLoggingIn:!1},e),[\"validateResult\",\"userCallback\"].forEach(o=>{e[o]||(e[o]=(()=>null))});const t=t=>{let{error:n,loginDetails:i}=t;o||(o=!0,n?this._onLoginFailureHook.each(e=>(e({error:n}),!0)):this._onLoginHook.each(e=>(e(i),!0)),e.userCallback(n,i))};let n=!1;const i=(e,o)=>{!e&&o&&o.token&&(this._reconnectStopper&&this._reconnectStopper.stop(),this._reconnectStopper=c.onReconnect(e=>{if(e!=this.connection)return;n=!0;const i=this._storedLoginToken();i&&(o={token:i,tokenExpires:this._storedLoginTokenExpires()}),o.tokenExpires||(o.tokenExpires=this._tokenExpiration(new Date)),this._tokenExpiresSoon(o.tokenExpires)?this.makeClientLoggedOut():this.callLoginMethod({methodArguments:[{resume:o.token}],_suppressLoggingIn:!0,userCallback:(e,n)=>{const i=this._storedLoginToken();e&&i&&i===o.token&&this.makeClientLoggedOut(),t({error:e,loginDetails:n})}})}))},s=(o,i)=>{if(!n){if(this._setLoggingIn(!1),o||!i)return o=o||new Error(\"No result from call to \".concat(e.methodName)),void t({error:o});try{e.validateResult(i)}catch(e){return void t({error:e})}this.makeClientLoggedIn(i.id,i.token,i.tokenExpires),t({loginDetails:{type:i.type}})}};e._suppressLoggingIn||this._setLoggingIn(!0),this.connection.apply(e.methodName,e.methodArguments,{wait:!0,onResultReceived:i},s)}makeClientLoggedOut(){this.connection._userId&&this._onLogoutHook.each(e=>(e(),!0)),this._unstoreLoginToken(),this.connection.setUserId(null),this._reconnectStopper&&this._reconnectStopper.stop()}makeClientLoggedIn(e,o,t){this._storeLoginToken(e,o,t),this.connection.setUserId(e)}loginServicesConfigured(){return this._loginServicesHandle.ready()}onPageLoadLogin(e){this._pageLoadLoginAttemptInfo?e(this._pageLoadLoginAttemptInfo):this._pageLoadLoginCallbacks.push(e)}_pageLoadLogin(o){this._pageLoadLoginAttemptInfo?e._debug(\"Ignoring unexpected duplicate page load login attempt info\"):(this._pageLoadLoginCallbacks.forEach(e=>e(o)),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=o)}loginWithToken(e,o){this.callLoginMethod({methodArguments:[{resume:e}],userCallback:o})}_enableAutoLogin(){this._autoLoginEnabled=!0,this._pollStoredLoginToken()}_isolateLoginTokenForTest(){this.LOGIN_TOKEN_KEY=this.LOGIN_TOKEN_KEY+s.id(),this.USER_ID_KEY=this.USER_ID_KEY+s.id()}_storeLoginToken(o,t,n){e._localStorage.setItem(this.USER_ID_KEY,o),e._localStorage.setItem(this.LOGIN_TOKEN_KEY,t),n||(n=this._tokenExpiration(new Date)),e._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY,n),this._lastLoginTokenWhenPolled=t}_unstoreLoginToken(){e._localStorage.removeItem(this.USER_ID_KEY),e._localStorage.removeItem(this.LOGIN_TOKEN_KEY),e._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY),this._lastLoginTokenWhenPolled=null}_storedLoginToken(){return e._localStorage.getItem(this.LOGIN_TOKEN_KEY)}_storedLoginTokenExpires(){return e._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY)}_storedUserId(){return e._localStorage.getItem(this.USER_ID_KEY)}_unstoreLoginTokenIfExpiresSoon(){const e=this._storedLoginTokenExpires();e&&this._tokenExpiresSoon(new Date(e))&&this._unstoreLoginToken()}_initLocalStorage(){this.LOGIN_TOKEN_KEY=\"Meteor.loginToken\",this.LOGIN_TOKEN_EXPIRES_KEY=\"Meteor.loginTokenExpires\",this.USER_ID_KEY=\"Meteor.userId\";const o=__meteor_runtime_config__.ROOT_URL_PATH_PREFIX;if(o||this.connection!==e.connection){let e=\":\".concat(this.connection._stream.rawUrl);o&&(e+=\":\".concat(o)),this.LOGIN_TOKEN_KEY+=e,this.LOGIN_TOKEN_EXPIRES_KEY+=e,this.USER_ID_KEY+=e}let t;if(this._autoLoginEnabled&&(this._unstoreLoginTokenIfExpiresSoon(),t=this._storedLoginToken())){const o=this._storedUserId();o&&this.connection.setUserId(o),this.loginWithToken(t,o=>{o&&(e._debug(\"Error logging in with token: \".concat(o)),this.makeClientLoggedOut()),this._pageLoadLogin({type:\"resume\",allowed:!o,error:o,methodName:\"login\",methodArguments:[{resume:t}]})})}this._lastLoginTokenWhenPolled=t,this._pollIntervalTimer&&clearInterval(this._pollIntervalTimer),this._pollIntervalTimer=setInterval(()=>{this._pollStoredLoginToken()},3e3)}_pollStoredLoginToken(){if(!this._autoLoginEnabled)return;const e=this._storedLoginToken();this._lastLoginTokenWhenPolled!=e&&(e?this.loginWithToken(e,e=>{e&&this.makeClientLoggedOut()}):this.logout()),this._lastLoginTokenWhenPolled=e}_initUrlMatching(){this._autoLoginEnabled=!0,this._accountsCallbacks={},this._attemptToMatchHash()}_attemptToMatchHash(){_(this,this.savedHash,h)}onResetPasswordLink(o){this._accountsCallbacks[\"reset-password\"]&&e._debug(\"Accounts.onResetPasswordLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"reset-password\"]=o}onEmailVerificationLink(o){this._accountsCallbacks[\"verify-email\"]&&e._debug(\"Accounts.onEmailVerificationLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"verify-email\"]=o}onEnrollmentLink(o){this._accountsCallbacks[\"enroll-account\"]&&e._debug(\"Accounts.onEnrollmentLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"enroll-account\"]=o}}if(e.loggingIn=(()=>u.loggingIn()),e.loggingOut=(()=>u.loggingOut()),e.logout=(e=>u.logout(e)),e.logoutOtherClients=(e=>u.logoutOtherClients(e)),e.loginWithToken=((e,o)=>u.loginWithToken(e,o)),Package.blaze){const{Template:o}=Package.blaze.Blaze;o.registerHelper(\"currentUser\",()=>e.user()),o.registerHelper(\"loggingIn\",()=>e.loggingIn()),o.registerHelper(\"loggingOut\",()=>e.loggingOut()),o.registerHelper(\"loggingInOrOut\",()=>e.loggingIn()||e.loggingOut())}const h=function(o,t){this._autoLoginEnabled=!1,e.startup(()=>{this._accountsCallbacks[t]&&this._accountsCallbacks[t](o,()=>this._enableAutoLogin())})},_=(e,o,t)=>{[\"reset-password\",\"verify-email\",\"enroll-account\"].forEach(n=>{let i;const s=new RegExp(\"^\\\\#\\\\/\".concat(n,\"\\\\/(.*)$\")),r=o.match(s);r&&(i=r[1],\"reset-password\"===n?e._resetPasswordToken=i:\"verify-email\"===n?e._verifyEmailToken=i:\"enroll-account\"===n&&(e._enrollAccountToken=i),window.location.hash=\"\",t.call(e,i,n))})},d={attemptToMatchHash:(e,o)=>_(u,e,o)}},\"accounts_common.js\":function(o,t,n){var i,s=o(\"@babel/runtime/helpers/interopRequireDefault\")(o(\"@babel/runtime/helpers/objectSpread\"));n.export({AccountsCommon:()=>a,EXPIRE_TOKENS_INTERVAL_MS:()=>p,CONNECTION_CLOSE_DELAY_MS:()=>k});class a{constructor(o){this._options={},this.connection=void 0,this._initConnection(o||{}),this.users=new l.Collection(\"users\",{_preventAutopublish:!0,connection:this.connection}),this._onLoginHook=new r({bindEnvironment:!1,debugPrintExceptions:\"onLogin callback\"}),this._onLoginFailureHook=new r({bindEnvironment:!1,debugPrintExceptions:\"onLoginFailure callback\"}),this._onLogoutHook=new r({bindEnvironment:!1,debugPrintExceptions:\"onLogout callback\"}),this.DEFAULT_LOGIN_EXPIRATION_DAYS=g,this.LOGIN_UNEXPIRING_TOKEN_DAYS=m;const t=\"Accounts.LoginCancelledError\";this.LoginCancelledError=e.makeErrorType(t,function(e){this.message=e}),this.LoginCancelledError.prototype.name=t,this.LoginCancelledError.numericError=145546287,e.startup(()=>{const{ServiceConfiguration:e}=Package[\"service-configuration\"];this.loginServiceConfiguration=e.configurations,this.ConfigError=e.ConfigError})}userId(){throw new Error(\"userId method not implemented\")}user(){const e=this.userId();return e?this.users.findOne(e):null}config(o){if(e.isServer?__meteor_runtime_config__.accountsConfigCalled=!0:__meteor_runtime_config__.accountsConfigCalled||e._debug(\"Accounts.config was called on the client but not on the server; some configuration options may not take effect.\"),Object.prototype.hasOwnProperty.call(o,\"oauthSecretKey\")){if(e.isClient)throw new Error(\"The oauthSecretKey option may only be specified on the server\");if(!Package[\"oauth-encryption\"])throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");Package[\"oauth-encryption\"].OAuthEncryption.loadKey(o.oauthSecretKey),delete(o=(0,s.default)({},o)).oauthSecretKey}const t=[\"sendVerificationEmail\",\"forbidClientAccountCreation\",\"passwordEnrollTokenExpirationInDays\",\"restrictCreationByEmailDomain\",\"loginExpirationInDays\",\"passwordResetTokenExpirationInDays\",\"ambiguousErrorMessages\",\"bcryptRounds\"];Object.keys(o).forEach(e=>{if(!t.includes(e))throw new Error(\"Accounts.config: Invalid key: \".concat(e))}),t.forEach(e=>{if(e in o){if(e in this._options)throw new Error(\"Can't set `\".concat(e,\"` more than once\"));this._options[e]=o[e]}})}onLogin(e){return this._onLoginHook.register(e)}onLoginFailure(e){return this._onLoginFailureHook.register(e)}onLogout(e){return this._onLogoutHook.register(e)}_initConnection(o){e.isClient&&(o.connection?this.connection=o.connection:o.ddpUrl?this.connection=c.connect(o.ddpUrl):\"undefined\"!=typeof __meteor_runtime_config__&&__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL?this.connection=c.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL):this.connection=e.connection)}_getTokenLifetimeMs(){const e=null===this._options.loginExpirationInDays?m:this._options.loginExpirationInDays;return 24*(e||g)*60*60*1e3}_getPasswordResetTokenLifetimeMs(){return 24*(this._options.passwordResetTokenExpirationInDays||h)*60*60*1e3}_getPasswordEnrollTokenLifetimeMs(){return 24*(this._options.passwordEnrollTokenExpirationInDays||_)*60*60*1e3}_tokenExpiration(e){return new Date(new Date(e).getTime()+this._getTokenLifetimeMs())}_tokenExpiresSoon(e){let o=.1*this._getTokenLifetimeMs();const t=1e3*d;return o>t&&(o=t),new Date>new Date(e)-o}}e.userId=(()=>u.userId()),e.user=(()=>u.user());const g=90,h=3,_=30,d=3600,p=6e5,k=1e4,m=36500}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/accounts-base/client_main.js\");Package._define(\"accounts-base\",m,{Accounts:u})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/accounts-base/client_main.js\",\"packages/accounts-base/accounts_client.js\",\"packages/accounts-base/accounts_common.js\"],\"names\":[\"AccountsClient\",\"AccountsTest\",\"module\",\"export\",\"Accounts\",\"default\",\"exports\",\"link\",\"v\",\"runSetters\",\"Meteor\",\"users\",\"AccountsCommon\",\"constructor\",\"options\",\"super\",\"this\",\"_loggingIn\",\"ReactiveVar\",\"_loggingOut\",\"_loginServicesHandle\",\"connection\",\"subscribe\",\"_pageLoadLoginCallbacks\",\"_pageLoadLoginAttemptInfo\",\"savedHash\",\"window\",\"location\",\"hash\",\"_initUrlMatching\",\"_initLocalStorage\",\"_loginFuncs\",\"userId\",\"_setLoggingIn\",\"x\",\"set\",\"loggingIn\",\"get\",\"loggingOut\",\"registerClientLoginFunction\",\"funcName\",\"func\",\"Error\",\"concat\",\"callLoginFunction\",\"_len\",\"arguments\",\"length\",\"funcArgs\",\"Array\",\"_key\",\"apply\",\"applyLoginFunction\",\"logout\",\"callback\",\"wait\",\"error\",\"result\",\"makeClientLoggedOut\",\"logoutOtherClients\",\"err\",\"_storeLoginToken\",\"token\",\"tokenExpires\",\"callLoginMethod\",\"called\",\"_objectSpread2\",\"methodName\",\"methodArguments\",\"_suppressLoggingIn\",\"forEach\",\"f\",\"loginCallbacks\",\"_ref\",\"loginDetails\",\"_onLoginFailureHook\",\"each\",\"_onLoginHook\",\"userCallback\",\"reconnected\",\"onResultReceived\",\"_reconnectStopper\",\"stop\",\"DDP\",\"onReconnect\",\"conn\",\"storedToken\",\"_storedLoginToken\",\"_storedLoginTokenExpires\",\"_tokenExpiration\",\"Date\",\"_tokenExpiresSoon\",\"resume\",\"storedTokenNow\",\"loggedInAndDataReadyCallback\",\"validateResult\",\"e\",\"makeClientLoggedIn\",\"id\",\"type\",\"_userId\",\"_onLogoutHook\",\"_unstoreLoginToken\",\"setUserId\",\"loginServicesConfigured\",\"ready\",\"onPageLoadLogin\",\"push\",\"_pageLoadLogin\",\"attemptInfo\",\"_debug\",\"loginWithToken\",\"_enableAutoLogin\",\"_autoLoginEnabled\",\"_pollStoredLoginToken\",\"_isolateLoginTokenForTest\",\"LOGIN_TOKEN_KEY\",\"Random\",\"USER_ID_KEY\",\"_localStorage\",\"setItem\",\"LOGIN_TOKEN_EXPIRES_KEY\",\"_lastLoginTokenWhenPolled\",\"removeItem\",\"getItem\",\"_storedUserId\",\"_unstoreLoginTokenIfExpiresSoon\",\"rootUrlPathPrefix\",\"__meteor_runtime_config__\",\"ROOT_URL_PATH_PREFIX\",\"namespace\",\"_stream\",\"rawUrl\",\"allowed\",\"_pollIntervalTimer\",\"clearInterval\",\"setInterval\",\"currentLoginToken\",\"_accountsCallbacks\",\"_attemptToMatchHash\",\"attemptToMatchHash\",\"defaultSuccessHandler\",\"onResetPasswordLink\",\"onEmailVerificationLink\",\"onEnrollmentLink\",\"Package\",\"blaze\",\"Template\",\"Blaze\",\"registerHelper\",\"user\",\"urlPart\",\"startup\",\"accounts\",\"success\",\"tokenRegex\",\"RegExp\",\"match\",\"_resetPasswordToken\",\"_verifyEmailToken\",\"_enrollAccountToken\",\"call\",\"EXPIRE_TOKENS_INTERVAL_MS\",\"CONNECTION_CLOSE_DELAY_MS\",\"_options\",\"undefined\",\"_initConnection\",\"Mongo\",\"Collection\",\"_preventAutopublish\",\"Hook\",\"bindEnvironment\",\"debugPrintExceptions\",\"DEFAULT_LOGIN_EXPIRATION_DAYS\",\"LOGIN_UNEXPIRING_TOKEN_DAYS\",\"lceName\",\"LoginCancelledError\",\"makeErrorType\",\"description\",\"message\",\"prototype\",\"name\",\"numericError\",\"ServiceConfiguration\",\"loginServiceConfiguration\",\"configurations\",\"ConfigError\",\"findOne\",\"config\",\"isServer\",\"accountsConfigCalled\",\"Object\",\"hasOwnProperty\",\"isClient\",\"OAuthEncryption\",\"loadKey\",\"oauthSecretKey\",\"VALID_KEYS\",\"keys\",\"key\",\"includes\",\"onLogin\",\"register\",\"onLoginFailure\",\"onLogout\",\"ddpUrl\",\"connect\",\"ACCOUNTS_CONNECTION_URL\",\"_getTokenLifetimeMs\",\"loginExpirationInDays\",\"_getPasswordResetTokenLifetimeMs\",\"passwordResetTokenExpirationInDays\",\"DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS\",\"_getPasswordEnrollTokenLifetimeMs\",\"passwordEnrollTokenExpirationInDays\",\"DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS\",\"when\",\"getTime\",\"minLifetimeMs\",\"minLifetimeCapMs\",\"MIN_TOKEN_LIFETIME_CAP_SECS\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {\\n  AccountsClient,\\n  AccountsTest,\\n} from \\\"./accounts_client.js\\\";\\n\\n/**\\n * @namespace Accounts\\n * @summary The namespace for all client-side accounts-related methods.\\n */\\nAccounts = new AccountsClient();\\n\\n/**\\n * @summary A [Mongo.Collection](#collections) containing user documents.\\n * @locus Anywhere\\n * @type {Mongo.Collection}\\n * @importFromPackage meteor\\n */\\nMeteor.users = Accounts.users;\\n\\nexport {\\n  Accounts,\\n  AccountsClient,\\n  AccountsTest,\\n  // For backwards compatibility. Note that exporting an object as the\\n  // default export is *not* the same as exporting its properties as named\\n  // exports, as was previously assumed.\\n  exports as default,\\n};\\n\",\"import {AccountsCommon} from \\\"./accounts_common.js\\\";\\n\\n/**\\n * @summary Constructor for the `Accounts` object on the client.\\n * @locus Client\\n * @class AccountsClient\\n * @extends AccountsCommon\\n * @instancename accountsClient\\n * @param {Object} options an object with fields:\\n * @param {Object} options.connection Optional DDP connection to reuse.\\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\\n */\\nexport class AccountsClient extends AccountsCommon {\\n  constructor(options) {\\n    super(options);\\n\\n    this._loggingIn = new ReactiveVar(false);\\n    this._loggingOut = new ReactiveVar(false);\\n\\n    this._loginServicesHandle =\\n      this.connection.subscribe(\\\"meteor.loginServiceConfiguration\\\");\\n\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = null;\\n\\n    this.savedHash = window.location.hash;\\n    this._initUrlMatching();\\n\\n    // Defined in localstorage_token.js.\\n    this._initLocalStorage();\\n\\n    // This is for .registerClientLoginFunction & .callLoginFunction.\\n    this._loginFuncs = {};\\n  }\\n\\n  ///\\n  /// CURRENT USER\\n  ///\\n\\n  // @override\\n  userId() {\\n    return this.connection.userId();\\n  }\\n\\n  // This is mostly just called within this file, but Meteor.loginWithPassword\\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\\n  // method call too.\\n  _setLoggingIn(x) {\\n    this._loggingIn.set(x);\\n  }\\n\\n  /**\\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingIn() {\\n    return this._loggingIn.get();\\n  }\\n\\n  /**\\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingOut() {\\n    return this._loggingOut.get();\\n  }\\n\\n  /**\\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\\n   * @locus Client\\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\\n   Should be the OAuth provider name accordingly.\\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\\n   */\\n  registerClientLoginFunction(funcName, func) {\\n    if (this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} has been defined already`);\\n    }\\n    this._loginFuncs[funcName] = func;\\n  }\\n\\n  /**\\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\\n   all arguments for the login function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   */\\n  callLoginFunction(funcName, ...funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\\n   function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   * @param {Array} funcArgs The `arguments` for the login function.\\n   */\\n  applyLoginFunction(funcName, funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Log the user out.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logout(callback) {\\n    this._loggingOut.set(true);\\n    this.connection.apply('logout', [], {\\n      wait: true\\n    }, (error, result) => {\\n      this._loggingOut.set(false);\\n      if (error) {\\n        callback && callback(error);\\n      } else {\\n        this.makeClientLoggedOut();\\n        callback && callback();\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logoutOtherClients(callback) {\\n    // We need to make two method calls: one to replace our current token,\\n    // and another to remove all tokens except the current one. We want to\\n    // call these two methods one after the other, without any other\\n    // methods running between them. For example, we don't want `logout`\\n    // to be called in between our two method calls (otherwise the second\\n    // method call would return an error). Another example: we don't want\\n    // logout to be called before the callback for `getNewToken`;\\n    // otherwise we would momentarily log the user out and then write a\\n    // new token to localStorage.\\n    //\\n    // To accomplish this, we make both calls as wait methods, and queue\\n    // them one after the other, without spinning off the event loop in\\n    // between. Even though we queue `removeOtherTokens` before\\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\\n    // until the `getNewToken` callback has finished running, because they\\n    // are both wait methods.\\n    this.connection.apply(\\n      'getNewToken',\\n      [],\\n      { wait: true },\\n      (err, result) => {\\n        if (! err) {\\n          this._storeLoginToken(\\n            this.userId(),\\n            result.token,\\n            result.tokenExpires\\n          );\\n        }\\n      }\\n    );\\n\\n    this.connection.apply(\\n      'removeOtherTokens',\\n      [],\\n      { wait: true },\\n      err => callback && callback(err)\\n    );\\n  }\\n\\n  ///\\n  /// LOGIN METHODS\\n  ///\\n\\n  // Call a login method on the server.\\n  //\\n  // A login method is a method which on success calls `this.setUserId(id)` and\\n  // `Accounts._setLoginToken` on the server and returns an object with fields\\n  // 'id' (containing the user id), 'token' (containing a resume token), and\\n  // optionally `tokenExpires`.\\n  //\\n  // This function takes care of:\\n  //   - Updating the Meteor.loggingIn() reactive data source\\n  //   - Calling the method in 'wait' mode\\n  //   - On success, saving the resume token to localStorage\\n  //   - On success, calling Accounts.connection.setUserId()\\n  //   - Setting up an onReconnect handler which logs in with\\n  //     the resume token\\n  //\\n  // Options:\\n  // - methodName: The method to call (default 'login')\\n  // - methodArguments: The arguments for the method\\n  // - validateResult: If provided, will be called with the result of the\\n  //                 method. If it throws, the client will not be logged in (and\\n  //                 its error will be passed to the callback).\\n  // - userCallback: Will be called with no arguments once the user is fully\\n  //                 logged in, or with the error on error.\\n  //\\n  callLoginMethod(options) {\\n    options = { \\n      methodName: 'login',\\n      methodArguments: [{}],\\n      _suppressLoggingIn: false,\\n      ...options,\\n    };\\n\\n    // Set defaults for callback arguments to no-op functions; make sure we\\n    // override falsey values too.\\n    ['validateResult', 'userCallback'].forEach(f => {\\n      if (!options[f])\\n        options[f] = () => null;\\n    })\\n\\n    // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\\n    let called;\\n    const loginCallbacks = ({ error, loginDetails }) => {\\n      if (!called) {\\n        called = true;\\n        if (!error) {\\n          this._onLoginHook.each(callback => {\\n            callback(loginDetails);\\n            return true;\\n          });\\n        } else {\\n          this._onLoginFailureHook.each(callback => {\\n            callback({ error });\\n            return true;\\n          });\\n        }\\n        options.userCallback(error, loginDetails);\\n      }\\n    }\\n\\n    let reconnected = false;\\n\\n    // We want to set up onReconnect as soon as we get a result token back from\\n    // the server, without having to wait for subscriptions to rerun. This is\\n    // because if we disconnect and reconnect between getting the result and\\n    // getting the results of subscription rerun, we WILL NOT re-send this\\n    // method (because we never re-send methods whose results we've received)\\n    // but we WILL call loggedInAndDataReadyCallback at \\\"reconnect quiesce\\\"\\n    // time. This will lead to makeClientLoggedIn(result.id) even though we\\n    // haven't actually sent a login method!\\n    //\\n    // But by making sure that we send this \\\"resume\\\" login in that case (and\\n    // calling makeClientLoggedOut if it fails), we'll end up with an accurate\\n    // client-side userId. (It's important that livedata_connection guarantees\\n    // that the \\\"reconnect quiesce\\\"-time call to loggedInAndDataReadyCallback\\n    // will occur before the callback from the resume login call.)\\n    const onResultReceived = (err, result) => {\\n      if (err || !result || !result.token) {\\n        // Leave onReconnect alone if there was an error, so that if the user was\\n        // already logged in they will still get logged in on reconnect.\\n        // See issue #4970.\\n      } else {\\n        // First clear out any previously set Acccounts login onReconnect\\n        // callback (to make sure we don't keep piling up duplicate callbacks,\\n        // which would then all be triggered when reconnecting).\\n        if (this._reconnectStopper) {\\n          this._reconnectStopper.stop();\\n        }\\n\\n        this._reconnectStopper = DDP.onReconnect(conn => {\\n          if (conn != this.connection) {\\n            return;\\n          }\\n          reconnected = true;\\n          // If our token was updated in storage, use the latest one.\\n          const storedToken = this._storedLoginToken();\\n          if (storedToken) {\\n            result = {\\n              token: storedToken,\\n              tokenExpires: this._storedLoginTokenExpires()\\n            };\\n          }\\n          if (!result.tokenExpires)\\n            result.tokenExpires = this._tokenExpiration(new Date());\\n          if (this._tokenExpiresSoon(result.tokenExpires)) {\\n            this.makeClientLoggedOut();\\n          } else {\\n            this.callLoginMethod({\\n              methodArguments: [{resume: result.token}],\\n              // Reconnect quiescence ensures that the user doesn't see an\\n              // intermediate state before the login method finishes. So we don't\\n              // need to show a logging-in animation.\\n              _suppressLoggingIn: true,\\n              userCallback: (error, loginDetails) => {\\n                const storedTokenNow = this._storedLoginToken();\\n                if (error) {\\n                  // If we had a login error AND the current stored token is the\\n                  // one that we tried to log in with, then declare ourselves\\n                  // logged out. If there's a token in storage but it's not the\\n                  // token that we tried to log in with, we don't know anything\\n                  // about whether that token is valid or not, so do nothing. The\\n                  // periodic localStorage poll will decide if we are logged in or\\n                  // out with this token, if it hasn't already. Of course, even\\n                  // with this check, another tab could insert a new valid token\\n                  // immediately before we clear localStorage here, which would\\n                  // lead to both tabs being logged out, but by checking the token\\n                  // in storage right now we hope to make that unlikely to happen.\\n                  //\\n                  // If there is no token in storage right now, we don't have to\\n                  // do anything; whatever code removed the token from storage was\\n                  // responsible for calling `makeClientLoggedOut()`, or the\\n                  // periodic localStorage poll will call `makeClientLoggedOut`\\n                  // eventually if another tab wiped the token from storage.\\n                  if (storedTokenNow && storedTokenNow === result.token) {\\n                    this.makeClientLoggedOut();\\n                  }\\n                }\\n                // Possibly a weird callback to call, but better than nothing if\\n                // there is a reconnect between \\\"login result received\\\" and \\\"data\\n                // ready\\\".\\n                loginCallbacks({ error, loginDetails });\\n              }});\\n          }\\n        });\\n      }\\n    };\\n\\n    // This callback is called once the local cache of the current-user\\n    // subscription (and all subscriptions, in fact) are guaranteed to be up to\\n    // date.\\n    const loggedInAndDataReadyCallback = (error, result) => {\\n      // If the login method returns its result but the connection is lost\\n      // before the data is in the local cache, it'll set an onReconnect (see\\n      // above). The onReconnect will try to log in using the token, and *it*\\n      // will call userCallback via its own version of this\\n      // loggedInAndDataReadyCallback. So we don't have to do anything here.\\n      if (reconnected)\\n        return;\\n\\n      // Note that we need to call this even if _suppressLoggingIn is true,\\n      // because it could be matching a _setLoggingIn(true) from a\\n      // half-completed pre-reconnect login method.\\n      this._setLoggingIn(false);\\n      if (error || !result) {\\n        error = error || new Error(\\n          `No result from call to ${options.methodName}`\\n        );\\n        loginCallbacks({ error });\\n        return;\\n      }\\n      try {\\n        options.validateResult(result);\\n      } catch (e) {\\n        loginCallbacks({ error: e });\\n        return;\\n      }\\n\\n      // Make the client logged in. (The user data should already be loaded!)\\n      this.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\\n      loginCallbacks({ loginDetails: { type: result.type } });\\n    };\\n\\n    if (!options._suppressLoggingIn) {\\n      this._setLoggingIn(true);\\n    }\\n    this.connection.apply(\\n      options.methodName,\\n      options.methodArguments,\\n      { wait: true, onResultReceived: onResultReceived },\\n      loggedInAndDataReadyCallback);\\n  }\\n\\n  makeClientLoggedOut() {\\n    // Ensure client was successfully logged in before running logout hooks.\\n    if (this.connection._userId) {\\n      this._onLogoutHook.each(callback => {\\n        callback();\\n        return true;\\n      });\\n    }\\n    this._unstoreLoginToken();\\n    this.connection.setUserId(null);\\n    this._reconnectStopper && this._reconnectStopper.stop();\\n  }\\n  \\n  makeClientLoggedIn(userId, token, tokenExpires) {\\n    this._storeLoginToken(userId, token, tokenExpires);\\n    this.connection.setUserId(userId);\\n  }\\n\\n  ///\\n  /// LOGIN SERVICES\\n  ///\\n\\n  // A reactive function returning whether the loginServiceConfiguration\\n  // subscription is ready. Used by accounts-ui to hide the login button\\n  // until we have all the configuration loaded\\n  //\\n  loginServicesConfigured() {\\n    return this._loginServicesHandle.ready();\\n  };\\n\\n  // Some login services such as the redirect login flow or the resume\\n  // login handler can log the user in at page load time.  The\\n  // Meteor.loginWithX functions have a callback argument, but the\\n  // callback function instance won't be in memory any longer if the\\n  // page was reloaded.  The `onPageLoadLogin` function allows a\\n  // callback to be registered for the case where the login was\\n  // initiated in a previous VM, and we now have the result of the login\\n  // attempt in a new VM.\\n\\n  // Register a callback to be called if we have information about a\\n  // login attempt at page load time.  Call the callback immediately if\\n  // we already have the page load login attempt info, otherwise stash\\n  // the callback to be called if and when we do get the attempt info.\\n  //\\n  onPageLoadLogin(f) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      f(this._pageLoadLoginAttemptInfo);\\n    } else {\\n      this._pageLoadLoginCallbacks.push(f);\\n    }\\n  };\\n\\n  // Receive the information about the login attempt at page load time.\\n  // Call registered callbacks, and also record the info in case\\n  // someone's callback hasn't been registered yet.\\n  //\\n  _pageLoadLogin(attemptInfo) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      Meteor._debug(\\n        'Ignoring unexpected duplicate page load login attempt info'\\n      );\\n      return;\\n    }\\n\\n    this._pageLoadLoginCallbacks.forEach(callback => callback(attemptInfo));\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = attemptInfo;\\n  };\\n\\n  ///\\n  /// LOGIN TOKENS\\n  ///\\n\\n  // These methods deal with storing a login token and user id in the\\n  // browser's localStorage facility. It polls local storage every few\\n  // seconds to synchronize login state between multiple tabs in the same\\n  // browser.\\n\\n  loginWithToken(token, callback) {\\n    this.callLoginMethod({\\n      methodArguments: [{\\n        resume: token\\n      }],\\n      userCallback: callback\\n    });\\n  };\\n\\n  // Semi-internal API. Call this function to re-enable auto login after\\n  // if it was disabled at startup.\\n  _enableAutoLogin() {\\n    this._autoLoginEnabled = true;\\n    this._pollStoredLoginToken();\\n  };\\n\\n  ///\\n  /// STORING\\n  ///\\n\\n  // Call this from the top level of the test file for any test that does\\n  // logging in and out, to protect multiple tabs running the same tests\\n  // simultaneously from interfering with each others' localStorage.\\n  _isolateLoginTokenForTest() {\\n    this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\\n    this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\\n  };\\n\\n  _storeLoginToken(userId, token, tokenExpires) {\\n    Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\\n    if (! tokenExpires)\\n      tokenExpires = this._tokenExpiration(new Date());\\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = token;\\n  };\\n\\n  _unstoreLoginToken() {\\n    Meteor._localStorage.removeItem(this.USER_ID_KEY);\\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = null;\\n  };\\n\\n  // This is private, but it is exported for now because it is used by a\\n  // test in accounts-password.\\n  _storedLoginToken() {\\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\\n  };\\n\\n  _storedLoginTokenExpires() {\\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n  };\\n\\n  _storedUserId() {\\n    return Meteor._localStorage.getItem(this.USER_ID_KEY);\\n  };\\n\\n  _unstoreLoginTokenIfExpiresSoon() {\\n    const tokenExpires = this._storedLoginTokenExpires();\\n    if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\\n      this._unstoreLoginToken();\\n    }\\n  };\\n\\n  ///\\n  /// AUTO-LOGIN\\n  ///\\n\\n  _initLocalStorage() {\\n    // Key names to use in localStorage\\n    this.LOGIN_TOKEN_KEY = \\\"Meteor.loginToken\\\";\\n    this.LOGIN_TOKEN_EXPIRES_KEY = \\\"Meteor.loginTokenExpires\\\";\\n    this.USER_ID_KEY = \\\"Meteor.userId\\\";\\n\\n    const rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\\n    if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\\n      // We want to keep using the same keys for existing apps that do not\\n      // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\\n      // to log in again after an app updates to a version of Meteor that\\n      // contains this code, but it's generally preferable to namespace the\\n      // keys so that connections from distinct apps to distinct DDP URLs\\n      // will be distinct in Meteor._localStorage.\\n      let namespace = `:${this.connection._stream.rawUrl}`;\\n      if (rootUrlPathPrefix) {\\n        namespace += `:${rootUrlPathPrefix}`;\\n      }\\n      this.LOGIN_TOKEN_KEY += namespace;\\n      this.LOGIN_TOKEN_EXPIRES_KEY += namespace;\\n      this.USER_ID_KEY += namespace;\\n    }\\n\\n    let token;\\n    if (this._autoLoginEnabled) {\\n      // Immediately try to log in via local storage, so that any DDP\\n      // messages are sent after we have established our user account\\n      this._unstoreLoginTokenIfExpiresSoon();\\n      token = this._storedLoginToken();\\n      if (token) {\\n        // On startup, optimistically present us as logged in while the\\n        // request is in flight. This reduces page flicker on startup.\\n        const userId = this._storedUserId();\\n        userId && this.connection.setUserId(userId);\\n        this.loginWithToken(token, err => {\\n          if (err) {\\n            Meteor._debug(`Error logging in with token: ${err}`);\\n            this.makeClientLoggedOut();\\n          }\\n\\n          this._pageLoadLogin({\\n            type: \\\"resume\\\",\\n            allowed: !err,\\n            error: err,\\n            methodName: \\\"login\\\",\\n            // XXX This is duplicate code with loginWithToken, but\\n            // loginWithToken can also be called at other times besides\\n            // page load.\\n            methodArguments: [{resume: token}]\\n          });\\n        });\\n      }\\n    }\\n\\n    // Poll local storage every 3 seconds to login if someone logged in in\\n    // another tab\\n    this._lastLoginTokenWhenPolled = token;\\n\\n    if (this._pollIntervalTimer) {\\n      // Unlikely that _initLocalStorage will be called more than once for\\n      // the same AccountsClient instance, but just in case...\\n      clearInterval(this._pollIntervalTimer);\\n    }\\n\\n    this._pollIntervalTimer = setInterval(() => {\\n      this._pollStoredLoginToken();\\n    }, 3000);\\n  };\\n\\n  _pollStoredLoginToken() {\\n    if (! this._autoLoginEnabled) {\\n      return;\\n    }\\n\\n    const currentLoginToken = this._storedLoginToken();\\n\\n    // != instead of !== just to make sure undefined and null are treated the same\\n    if (this._lastLoginTokenWhenPolled != currentLoginToken) {\\n      if (currentLoginToken) {\\n        this.loginWithToken(currentLoginToken, (err) => {\\n          if (err) {\\n            this.makeClientLoggedOut();\\n          }\\n        });\\n      } else {\\n        this.logout();\\n      }\\n    }\\n\\n    this._lastLoginTokenWhenPolled = currentLoginToken;\\n  };\\n\\n  ///\\n  /// URLS\\n  ///\\n\\n  _initUrlMatching() {\\n    // By default, allow the autologin process to happen.\\n    this._autoLoginEnabled = true;\\n  \\n    // We only support one callback per URL.\\n    this._accountsCallbacks = {};\\n  \\n    // Try to match the saved value of window.location.hash.\\n    this._attemptToMatchHash();\\n  };\\n  \\n  // Separate out this functionality for testing\\n  _attemptToMatchHash() {\\n    attemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\\n  };\\n\\n  /**\\n   * @summary Register a function to call when a reset password link is clicked\\n   * in an email sent by\\n   * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onResetPasswordLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword).\\n   * 2. `done`: A function to call when the password reset UI flow is complete. The normal\\n   * login process is suspended until this function is called, so that the\\n   * password for user A can be reset even if user B was logged in.\\n   * @locus Client\\n   */\\n  onResetPasswordLink(callback) {\\n    if (this._accountsCallbacks[\\\"reset-password\\\"]) {\\n      Meteor._debug(\\\"Accounts.onResetPasswordLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"reset-password\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an email verification link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEmailVerificationLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: An email verification token that can be passed to\\n   * [`Accounts.verifyEmail`](#accounts_verifyemail).\\n   * 2. `done`: A function to call when the email verification UI flow is complete.\\n   * The normal login process is suspended until this function is called, so\\n   * that the user can be notified that they are verifying their email before\\n   * being logged in.\\n   * @locus Client\\n   */\\n  onEmailVerificationLink(callback) {\\n    if (this._accountsCallbacks[\\\"verify-email\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEmailVerificationLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"verify-email\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an account enrollment link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEnrollmentLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\\n   * enrolled account a password.\\n   * 2. `done`: A function to call when the enrollment UI flow is complete.\\n   * The normal login process is suspended until this function is called, so that\\n   * user A can be enrolled even if user B was logged in.\\n   * @locus Client\\n   */\\n  onEnrollmentLink(callback) {\\n    if (this._accountsCallbacks[\\\"enroll-account\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEnrollmentLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"enroll-account\\\"] = callback;\\n  };\\n\\n};\\n\\n/**\\n * @summary True if a login method (such as `Meteor.loginWithPassword`, \\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in \\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingIn = () => Accounts.loggingIn();\\n\\n/**\\n * @summary True if a logout method (such as `Meteor.logout`) is currently in \\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingOut = () => Accounts.loggingOut();\\n\\n/**\\n * @summary Log the user out.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logout = callback => Accounts.logout(callback);\\n\\n/**\\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logoutOtherClients = callback => Accounts.logoutOtherClients(callback);\\n\\n/**\\n * @summary Login with a Meteor access token.\\n * @locus Client\\n * @param {Object} [token] Local storage token for use with login across \\n * multiple tabs in the same browser.\\n * @param {Function} [callback] Optional callback. Called with no arguments on\\n * success.\\n * @importFromPackage meteor\\n */\\nMeteor.loginWithToken = (token, callback) =>\\n  Accounts.loginWithToken(token, callback);\\n\\n///\\n/// HANDLEBARS HELPERS\\n///\\n\\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\\n// global helpers.\\nif (Package.blaze) {\\n  const { Template } = Package.blaze.Blaze;\\n\\n  /**\\n   * @global\\n   * @name  currentUser\\n   * @isHelper true\\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\\n   */\\n  Template.registerHelper('currentUser', () => Meteor.user());\\n\\n  /**\\n   * @global\\n   * @name  loggingIn\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\\n   */\\n  Template.registerHelper('loggingIn', () => Meteor.loggingIn());\\n\\n  /**\\n   * @global\\n   * @name  loggingOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper('loggingOut', () => Meteor.loggingOut());\\n\\n  /**\\n   * @global\\n   * @name  loggingInOrOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper(\\n    'loggingInOrOut', \\n    () => Meteor.loggingIn() || Meteor.loggingOut()\\n  );\\n}\\n\\nconst defaultSuccessHandler = function(token, urlPart) {\\n  // put login in a suspended state to wait for the interaction to finish\\n  this._autoLoginEnabled = false;\\n\\n  // wait for other packages to register callbacks\\n  Meteor.startup(() => {\\n    // if a callback has been registered for this kind of token, call it\\n    if (this._accountsCallbacks[urlPart]) {\\n      this._accountsCallbacks[urlPart](token, () => this._enableAutoLogin());\\n    }\\n  });\\n}\\n\\n// Note that both arguments are optional and are currently only passed by\\n// accounts_url_tests.js.\\nconst attemptToMatchHash = (accounts, hash, success) => {\\n  // All of the special hash URLs we support for accounts interactions\\n  [\\\"reset-password\\\", \\\"verify-email\\\", \\\"enroll-account\\\"].forEach(urlPart => {\\n    let token;\\n\\n    const tokenRegex = new RegExp(`^\\\\\\\\#\\\\\\\\/${urlPart}\\\\\\\\/(.*)$`);\\n    const match = hash.match(tokenRegex);\\n\\n    if (match) {\\n      token = match[1];\\n\\n      // XXX COMPAT WITH 0.9.3\\n      if (urlPart === \\\"reset-password\\\") {\\n        accounts._resetPasswordToken = token;\\n      } else if (urlPart === \\\"verify-email\\\") {\\n        accounts._verifyEmailToken = token;\\n      } else if (urlPart === \\\"enroll-account\\\") {\\n        accounts._enrollAccountToken = token;\\n      }\\n    } else {\\n      return;\\n    }\\n\\n    // If no handlers match the hash, then maybe it's meant to be consumed\\n    // by some entirely different code, so we only clear it the first time\\n    // a handler successfully matches. Note that later handlers reuse the\\n    // savedHash, so clearing window.location.hash here will not interfere\\n    // with their needs.\\n    window.location.hash = \\\"\\\";\\n\\n    // Do some stuff with the token we matched\\n    success.call(accounts, token, urlPart);\\n  });\\n}\\n\\n// Export for testing\\nexport const AccountsTest = {\\n  attemptToMatchHash: (hash, success) => \\n    attemptToMatchHash(Accounts, hash, success),\\n};\\n\",\"/**\\n * @summary Super-constructor for AccountsClient and AccountsServer.\\n * @locus Anywhere\\n * @class AccountsCommon\\n * @instancename accountsClientOrServer\\n * @param options {Object} an object with fields:\\n * - connection {Object} Optional DDP connection to reuse.\\n * - ddpUrl {String} Optional URL for creating a new DDP connection.\\n */\\nexport class AccountsCommon {\\n  constructor(options) {\\n    // Currently this is read directly by packages like accounts-password\\n    // and accounts-ui-unstyled.\\n    this._options = {};\\n\\n    // Note that setting this.connection = null causes this.users to be a\\n    // LocalCollection, which is not what we want.\\n    this.connection = undefined;\\n    this._initConnection(options || {});\\n\\n    // There is an allow call in accounts_server.js that restricts writes to\\n    // this collection.\\n    this.users = new Mongo.Collection(\\\"users\\\", {\\n      _preventAutopublish: true,\\n      connection: this.connection\\n    });\\n\\n    // Callback exceptions are printed with Meteor._debug and ignored.\\n    this._onLoginHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLogin callback\\\"\\n    });\\n\\n    this._onLoginFailureHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLoginFailure callback\\\"\\n    });\\n\\n    this._onLogoutHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLogout callback\\\"\\n    });\\n\\n    // Expose for testing.\\n    this.DEFAULT_LOGIN_EXPIRATION_DAYS = DEFAULT_LOGIN_EXPIRATION_DAYS;\\n    this.LOGIN_UNEXPIRING_TOKEN_DAYS = LOGIN_UNEXPIRING_TOKEN_DAYS;\\n\\n    // Thrown when the user cancels the login process (eg, closes an oauth\\n    // popup, declines retina scan, etc)\\n    const lceName = 'Accounts.LoginCancelledError';\\n    this.LoginCancelledError = Meteor.makeErrorType(\\n      lceName,\\n      function (description) {\\n        this.message = description;\\n      }\\n    );\\n    this.LoginCancelledError.prototype.name = lceName;\\n\\n    // This is used to transmit specific subclass errors over the wire. We\\n    // should come up with a more generic way to do this (eg, with some sort of\\n    // symbolic error code rather than a number).\\n    this.LoginCancelledError.numericError = 0x8acdc2f;\\n\\n    // loginServiceConfiguration and ConfigError are maintained for backwards compatibility\\n    Meteor.startup(() => {\\n      const { ServiceConfiguration } = Package['service-configuration'];\\n      this.loginServiceConfiguration = ServiceConfiguration.configurations;\\n      this.ConfigError = ServiceConfiguration.ConfigError;\\n    });\\n  }\\n\\n  /**\\n   * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  userId() {\\n    throw new Error(\\\"userId method not implemented\\\");\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  user() {\\n    const userId = this.userId();\\n    return userId ? this.users.findOne(userId) : null;\\n  }\\n\\n  // Set up config for the accounts system. Call this on both the client\\n  // and the server.\\n  //\\n  // Note that this method gets overridden on AccountsServer.prototype, but\\n  // the overriding method calls the overridden method.\\n  //\\n  // XXX we should add some enforcement that this is called on both the\\n  // client and the server. Otherwise, a user can\\n  // 'forbidClientAccountCreation' only on the client and while it looks\\n  // like their app is secure, the server will still accept createUser\\n  // calls. https://github.com/meteor/meteor/issues/828\\n  //\\n  // @param options {Object} an object with fields:\\n  // - sendVerificationEmail {Boolean}\\n  //     Send email address verification emails to new users created from\\n  //     client signups.\\n  // - forbidClientAccountCreation {Boolean}\\n  //     Do not allow clients to create accounts directly.\\n  // - restrictCreationByEmailDomain {Function or String}\\n  //     Require created users to have an email matching the function or\\n  //     having the string as domain.\\n  // - loginExpirationInDays {Number}\\n  //     Number of days since login until a user is logged out (login token\\n  //     expires).\\n  // - passwordResetTokenExpirationInDays {Number}\\n  //     Number of days since password reset token creation until the\\n  //     token cannt be used any longer (password reset token expires).\\n  // - ambiguousErrorMessages {Boolean}\\n  //     Return ambiguous error messages from login failures to prevent\\n  //     user enumeration.\\n  // - bcryptRounds {Number}\\n  //     Allows override of number of bcrypt rounds (aka work factor) used\\n  //     to store passwords.\\n\\n  /**\\n   * @summary Set global accounts options.\\n   * @locus Anywhere\\n   * @param {Object} options\\n   * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\\n   * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \\\"Create account\\\" link will not be available.\\n   * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\\n   * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\\n   * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specifed on the server.  See packages/oauth-encryption/README.md for details.\\n   * @param {Number} options.passwordResetTokenExpirationInDays The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.\\n   * @param {Number} options.passwordEnrollTokenExpirationInDays The number of days from when a link to set inital password is sent until token expires and user can't set password with the link anymore. Defaults to 30.\\n   * @param {Boolean} options.ambiguousErrorMessages Return ambiguous error messages from login failures to prevent user enumeration. Defaults to false.\\n   */\\n  config(options) {\\n    // We don't want users to accidentally only call Accounts.config on the\\n    // client, where some of the options will have partial effects (eg removing\\n    // the \\\"create account\\\" button from accounts-ui if forbidClientAccountCreation\\n    // is set, or redirecting Google login to a specific-domain page) without\\n    // having their full effects.\\n    if (Meteor.isServer) {\\n      __meteor_runtime_config__.accountsConfigCalled = true;\\n    } else if (!__meteor_runtime_config__.accountsConfigCalled) {\\n      // XXX would be nice to \\\"crash\\\" the client and replace the UI with an error\\n      // message, but there's no trivial way to do this.\\n      Meteor._debug(\\\"Accounts.config was called on the client but not on the \\\" +\\n                    \\\"server; some configuration options may not take effect.\\\");\\n    }\\n\\n    // We need to validate the oauthSecretKey option at the time\\n    // Accounts.config is called. We also deliberately don't store the\\n    // oauthSecretKey in Accounts._options.\\n    if (Object.prototype.hasOwnProperty.call(options, 'oauthSecretKey')) {\\n      if (Meteor.isClient) {\\n        throw new Error(\\\"The oauthSecretKey option may only be specified on the server\\\");\\n      }\\n      if (! Package[\\\"oauth-encryption\\\"]) {\\n        throw new Error(\\\"The oauth-encryption package must be loaded to set oauthSecretKey\\\");\\n      }\\n      Package[\\\"oauth-encryption\\\"].OAuthEncryption.loadKey(options.oauthSecretKey);\\n      options = { ...options };\\n      delete options.oauthSecretKey;\\n    }\\n\\n    // validate option keys\\n    const VALID_KEYS = [\\\"sendVerificationEmail\\\", \\\"forbidClientAccountCreation\\\", \\\"passwordEnrollTokenExpirationInDays\\\",\\n                      \\\"restrictCreationByEmailDomain\\\", \\\"loginExpirationInDays\\\", \\\"passwordResetTokenExpirationInDays\\\",\\n                      \\\"ambiguousErrorMessages\\\", \\\"bcryptRounds\\\"];\\n    Object.keys(options).forEach(key => {\\n      if (!VALID_KEYS.includes(key)) {\\n        throw new Error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    });\\n\\n    // set values in Accounts._options\\n    VALID_KEYS.forEach(key => {\\n      if (key in options) {\\n        if (key in this._options) {\\n          throw new Error(`Can't set \\\\`${key}\\\\` more than once`);\\n        }\\n        this._options[key] = options[key];\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when login is successful.\\n   *                        The callback receives a single object that\\n   *                        holds login details. This object contains the login\\n   *                        result type (password, resume, etc.) on both the\\n   *                        client and server. `onLogin` callbacks registered\\n   *                        on the server also receive extra data, such\\n   *                        as user details, connection information, etc.\\n   */\\n  onLogin(func) {\\n    return this._onLoginHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt fails.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called after the login has failed.\\n   */\\n  onLoginFailure(func) {\\n    return this._onLoginFailureHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a logout attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when logout is successful.\\n   */\\n  onLogout(func) {\\n    return this._onLogoutHook.register(func);\\n  }\\n\\n  _initConnection(options) {\\n    if (! Meteor.isClient) {\\n      return;\\n    }\\n\\n    // The connection used by the Accounts system. This is the connection\\n    // that will get logged in by Meteor.login(), and this is the\\n    // connection whose login state will be reflected by Meteor.userId().\\n    //\\n    // It would be much preferable for this to be in accounts_client.js,\\n    // but it has to be here because it's needed to create the\\n    // Meteor.users collection.\\n    if (options.connection) {\\n      this.connection = options.connection;\\n    } else if (options.ddpUrl) {\\n      this.connection = DDP.connect(options.ddpUrl);\\n    } else if (typeof __meteor_runtime_config__ !== \\\"undefined\\\" &&\\n               __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\\n      // Temporary, internal hook to allow the server to point the client\\n      // to a different authentication server. This is for a very\\n      // particular use case that comes up when implementing a oauth\\n      // server. Unsupported and may go away at any point in time.\\n      //\\n      // We will eventually provide a general way to use account-base\\n      // against any DDP connection, not just one special one.\\n      this.connection =\\n        DDP.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL);\\n    } else {\\n      this.connection = Meteor.connection;\\n    }\\n  }\\n\\n  _getTokenLifetimeMs() {\\n    // When loginExpirationInDays is set to null, we'll use a really high\\n    // number of days (LOGIN_UNEXPIRABLE_TOKEN_DAYS) to simulate an\\n    // unexpiring token.\\n    const loginExpirationInDays =\\n      (this._options.loginExpirationInDays === null)\\n        ? LOGIN_UNEXPIRING_TOKEN_DAYS\\n        : this._options.loginExpirationInDays;\\n    return (loginExpirationInDays\\n        || DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _getPasswordResetTokenLifetimeMs() {\\n    return (this._options.passwordResetTokenExpirationInDays ||\\n            DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _getPasswordEnrollTokenLifetimeMs() {\\n    return (this._options.passwordEnrollTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _tokenExpiration(when) {\\n    // We pass when through the Date constructor for backwards compatibility;\\n    // `when` used to be a number.\\n    return new Date((new Date(when)).getTime() + this._getTokenLifetimeMs());\\n  }\\n\\n  _tokenExpiresSoon(when) {\\n    let minLifetimeMs = .1 * this._getTokenLifetimeMs();\\n    const minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\\n    if (minLifetimeMs > minLifetimeCapMs) {\\n      minLifetimeMs = minLifetimeCapMs;\\n    }\\n    return new Date() > (new Date(when) - minLifetimeMs);\\n  }\\n}\\n\\n// Note that Accounts is defined separately in accounts_client.js and\\n// accounts_server.js.\\n\\n/**\\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere but publish functions\\n * @importFromPackage meteor\\n */\\nMeteor.userId = () => Accounts.userId();\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere but publish functions\\n * @importFromPackage meteor\\n */\\nMeteor.user = () => Accounts.user();\\n\\n// how long (in days) until a login token expires\\nconst DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\\n// how long (in days) until reset password token expires\\nconst DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS = 3;\\n// how long (in days) until enrol password token expires\\nconst DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS = 30;\\n// Clients don't try to auto-login with a token that is going to expire within\\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\\n// Tries to avoid abrupt disconnects from expiring tokens.\\nconst MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\\n// how often (in milliseconds) we check for expired tokens\\nexport const EXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\\n// called\\nexport const CONNECTION_CLOSE_DELAY_MS = 10 * 1000;\\n// A large number of expiration days (approximately 100 years worth) that is\\n// used when creating unexpiring tokens.\\nconst LOGIN_UNEXPIRING_TOKEN_DAYS = 365 * 100;\\n\"]}","minifier":"terser"}