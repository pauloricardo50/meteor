{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,i=Package.meteor.meteorEnv,s=Package.tracker.Tracker,a=Package.tracker.Deps,c=Package.ejson.EJSON,r=Package.modules.meteorInstall,n=Package[\"babel-runtime\"].meteorBabelHelpers,o=Package.promise.Promise,l,h,d,y=r({node_modules:{meteor:{\"reactive-dict\":{\"migration.js\":function(t,i,s){let a;s.export({ReactiveDict:()=>a}),s.link(\"./reactive-dict\",{ReactiveDict(e){a=e}},0);const c=Object.prototype.hasOwnProperty;if(a._migratedDictData={},a._dictsToMigrate={},a._loadMigratedDict=function(e){if(c.call(a._migratedDictData,e)){const t=a._migratedDictData[e];return delete a._migratedDictData[e],t}return null},a._registerDictForMigrate=function(e,t){if(c.call(a._dictsToMigrate,e))throw new Error(\"Duplicate ReactiveDict name: \"+e);a._dictsToMigrate[e]=t},e.isClient&&Package.reload){var r=Package.reload.Reload._migrationData(\"reactive-dict\");r&&r.dicts&&(a._migratedDictData=r.dicts),Package.reload.Reload._onMigrate(\"reactive-dict\",function(){var e=a._dictsToMigrate,t={};for(var i in e)t[i]=e[i]._getMigrationData();return[!0,{dicts:t}]})}},\"reactive-dict.js\":function(t,i,a){a.export({ReactiveDict:()=>h});const r=Object.prototype.hasOwnProperty;function n(e){return void 0===e?\"undefined\":c.stringify(e)}function o(e){if(void 0!==e&&\"undefined\"!==e)return c.parse(e)}function l(e){e&&e.changed()}class h{constructor(t,i){if(this.keys={},t)if(\"string\"==typeof t){e.isClient&&h._registerDictForMigrate(t,this);const s=e.isClient&&h._loadMigratedDict(t);s?this.keys=s:this._setObject(i||{}),this.name=t}else{if(\"object\"!=typeof t)throw new Error(\"Invalid ReactiveDict argument: \"+t);this._setObject(t)}else\"object\"==typeof i&&this._setObject(i);this.allDeps=new s.Dependency,this.keyDeps={},this.keyValueDeps={}}set(e,t){if(\"object\"==typeof e&&void 0===t)return void this._setObject(e);const i=e;t=n(t);const s=r.call(this.keys,i),a=s?this.keys[i]:\"undefined\",c=t!==a;this.keys[i]=t,!c&&s||l(this.allDeps),c&&this.keyDeps&&(l(this.keyDeps[i]),this.keyValueDeps[i]&&(l(this.keyValueDeps[i][a]),l(this.keyValueDeps[i][t])))}setDefault(e,t){if(\"object\"==typeof e&&void 0===t)return void this._setDefaultObject(e);const i=e;r.call(this.keys,i)||this.set(i,t)}get(e){return this._ensureKey(e),this.keyDeps[e].depend(),o(this.keys[e])}equals(e,t){let i=null;if(Package.mongo&&(i=Package.mongo.Mongo.ObjectID),!(\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t||void 0===t||t instanceof Date||i&&t instanceof i||null===t))throw new Error(\"ReactiveDict.equals: value must be scalar\");const a=n(t);var l;s.active&&(this._ensureKey(e),r.call(this.keyValueDeps[e],a)||(this.keyValueDeps[e][a]=new s.Dependency),this.keyValueDeps[e][a].depend()&&s.onInvalidate(()=>{this.keyValueDeps[e][a].hasDependents()||delete this.keyValueDeps[e][a]}));let h=void 0;return r.call(this.keys,e)&&(h=o(this.keys[e])),c.equals(h,t)}all(){this.allDeps.depend();let e={};return Object.keys(this.keys).forEach(t=>{e[t]=o(this.keys[t])}),e}clear(){const e=this.keys;this.keys={},this.allDeps.changed(),Object.keys(e).forEach(t=>{l(this.keyDeps[t]),this.keyValueDeps[t]&&(l(this.keyValueDeps[t][e[t]]),l(this.keyValueDeps[t][void 0]))})}delete(e){let t=!1;if(r.call(this.keys,e)){const i=this.keys[e];delete this.keys[e],l(this.keyDeps[e]),this.keyValueDeps[e]&&(l(this.keyValueDeps[e][i]),l(this.keyValueDeps[e][void 0])),this.allDeps.changed(),t=!0}return t}destroy(){this.clear(),this.name&&r.call(h._dictsToMigrate,this.name)&&delete h._dictsToMigrate[this.name]}_setObject(e){Object.keys(e).forEach(t=>{this.set(t,e[t])})}_setDefaultObject(e){Object.keys(e).forEach(t=>{this.setDefault(t,e[t])})}_ensureKey(e){e in this.keyDeps||(this.keyDeps[e]=new s.Dependency,this.keyValueDeps[e]={})}_getMigrationData(){return this.keys}}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/reactive-dict/migration.js\");Package._define(\"reactive-dict\",y,{ReactiveDict:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/reactive-dict/migration.js\",\"packages/reactive-dict/reactive-dict.js\"],\"names\":[\"ReactiveDict\",\"module\",\"export\",\"link\",\"v\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"_migratedDictData\",\"_dictsToMigrate\",\"_loadMigratedDict\",\"dictName\",\"call\",\"data\",\"_registerDictForMigrate\",\"dict\",\"Error\",\"Meteor\",\"isClient\",\"Package\",\"reload\",\"migrationData\",\"Reload\",\"_migrationData\",\"dicts\",\"_onMigrate\",\"dictsToMigrate\",\"dataToMigrate\",\"_getMigrationData\",\"stringify\",\"value\",\"undefined\",\"EJSON\",\"parse\",\"serialized\",\"changed\",\"constructor\",\"dictData\",\"this\",\"keys\",\"migratedData\",\"_setObject\",\"name\",\"allDeps\",\"Tracker\",\"Dependency\",\"keyDeps\",\"keyValueDeps\",\"set\",\"keyOrObject\",\"key\",\"keyExisted\",\"oldSerializedValue\",\"isNewValue\",\"setDefault\",\"_setDefaultObject\",\"get\",\"_ensureKey\",\"depend\",\"equals\",\"ObjectID\",\"mongo\",\"Mongo\",\"Date\",\"serializedValue\",\"isNew\",\"active\",\"onInvalidate\",\"hasDependents\",\"oldValue\",\"all\",\"ret\",\"forEach\",\"clear\",\"oldKeys\",\"delete\",\"didRemove\",\"destroy\",\"object\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { ReactiveDict } from './reactive-dict';\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nReactiveDict._migratedDictData = {}; // name -> data\\nReactiveDict._dictsToMigrate = {}; // name -> ReactiveDict\\n\\nReactiveDict._loadMigratedDict = function (dictName) {\\n  if (hasOwn.call(ReactiveDict._migratedDictData, dictName)) {\\n    const data = ReactiveDict._migratedDictData[dictName];\\n    delete ReactiveDict._migratedDictData[dictName];\\n    return data;\\n  }\\n\\n  return null;\\n};\\n\\nReactiveDict._registerDictForMigrate = function (dictName, dict) {\\n  if (hasOwn.call(ReactiveDict._dictsToMigrate, dictName))\\n    throw new Error(\\\"Duplicate ReactiveDict name: \\\" + dictName);\\n\\n  ReactiveDict._dictsToMigrate[dictName] = dict;\\n};\\n\\nif (Meteor.isClient && Package.reload) {\\n  // Put old migrated data into ReactiveDict._migratedDictData,\\n  // where it can be accessed by ReactiveDict._loadMigratedDict.\\n  var migrationData = Package.reload.Reload._migrationData('reactive-dict');\\n  if (migrationData && migrationData.dicts)\\n    ReactiveDict._migratedDictData = migrationData.dicts;\\n\\n  // On migration, assemble the data from all the dicts that have been\\n  // registered.\\n  Package.reload.Reload._onMigrate('reactive-dict', function () {\\n    var dictsToMigrate = ReactiveDict._dictsToMigrate;\\n    var dataToMigrate = {};\\n\\n    for (var dictName in dictsToMigrate)\\n      dataToMigrate[dictName] = dictsToMigrate[dictName]._getMigrationData();\\n\\n    return [true, {dicts: dataToMigrate}];\\n  });\\n}\\n\\nexport { ReactiveDict };\\n\",\"const hasOwn = Object.prototype.hasOwnProperty;\\n\\n// XXX come up with a serialization method which canonicalizes object key\\n// order, which would allow us to use objects as values for equals.\\nfunction stringify(value) {\\n  if (value === undefined) {\\n    return 'undefined';\\n  }\\n  return EJSON.stringify(value);\\n}\\n\\nfunction parse(serialized) {\\n  if (serialized === undefined || serialized === 'undefined') {\\n    return undefined;\\n  }\\n  return EJSON.parse(serialized);\\n}\\n\\nfunction changed(v) {\\n  v && v.changed();\\n}\\n\\n// XXX COMPAT WITH 0.9.1 : accept migrationData instead of dictName\\n/**\\n * @class\\n * @instanceName ReactiveDict\\n * @summary Constructor for a ReactiveDict, which represents a reactive dictionary of key/value pairs.\\n * @locus Client\\n * @param {String} [name] Optional.  When a name is passed, preserves contents across Hot Code Pushes\\n * @param {Object} [initialValue] Optional.  The default values for the dictionary\\n */\\nexport class ReactiveDict {\\n  constructor(dictName, dictData) {\\n    // this.keys: key -> value\\n    this.keys = {};\\n\\n    if (dictName) {\\n      // name given; migration will be performed\\n      if (typeof dictName === 'string') {\\n        // the normal case, argument is a string name.\\n\\n        // Only run migration logic on client, it will cause\\n        // duplicate name errors on server during reloads.\\n        // _registerDictForMigrate will throw an error on duplicate name.\\n        Meteor.isClient && ReactiveDict._registerDictForMigrate(dictName, this);\\n        const migratedData = Meteor.isClient && ReactiveDict._loadMigratedDict(dictName);\\n\\n        if (migratedData) {\\n          // Don't stringify migrated data\\n          this.keys = migratedData;\\n        } else {\\n          // Use _setObject to make sure values are stringified\\n          this._setObject(dictData || {});\\n        }\\n        this.name = dictName;\\n      } else if (typeof dictName === 'object') {\\n        // back-compat case: dictName is actually migrationData\\n        // Use _setObject to make sure values are stringified\\n        this._setObject(dictName);\\n      } else {\\n        throw new Error(\\\"Invalid ReactiveDict argument: \\\" + dictName);\\n      }\\n    } else if (typeof dictData === 'object') {\\n      this._setObject(dictData);\\n    }\\n\\n    this.allDeps = new Tracker.Dependency;\\n    this.keyDeps = {}; // key -> Dependency\\n    this.keyValueDeps = {}; // key -> Dependency\\n  }\\n\\n  // set() began as a key/value method, but we are now overloading it\\n  // to take an object of key/value pairs, similar to backbone\\n  // http://backbonejs.org/#Model-set\\n  /**\\n   * @summary Set a value for a key in the ReactiveDict. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   * @param {String} key The key to set, eg, `selectedItem`\\n   * @param {EJSONable | undefined} value The new value for `key`\\n   */\\n  set(keyOrObject, value) {\\n    if ((typeof keyOrObject === 'object') && (value === undefined)) {\\n      // Called as `dict.set({...})`\\n      this._setObject(keyOrObject);\\n      return;\\n    }\\n    // the input isn't an object, so it must be a key\\n    // and we resume with the rest of the function\\n    const key = keyOrObject;\\n\\n    value = stringify(value);\\n\\n    const keyExisted = hasOwn.call(this.keys, key);\\n    const oldSerializedValue = keyExisted ? this.keys[key] : 'undefined';\\n    const isNewValue = (value !== oldSerializedValue);\\n\\n    this.keys[key] = value;\\n\\n    if (isNewValue || !keyExisted) {\\n      // Using the changed utility function here because this.allDeps might not exist yet,\\n      // when setting initial data from constructor\\n      changed(this.allDeps);\\n    }\\n\\n    // Don't trigger changes when setting initial data from constructor,\\n    // this.KeyDeps is undefined in this case\\n    if (isNewValue && this.keyDeps) {\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldSerializedValue]);\\n        changed(this.keyValueDeps[key][value]);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @summary Set a value for a key if it hasn't been set before.\\n   * Otherwise works exactly the same as [`ReactiveDict.set`](#ReactiveDict-set).\\n   * @locus Client\\n   * @param {String} key The key to set, eg, `selectedItem`\\n   * @param {EJSONable | undefined} value The new value for `key`\\n   */\\n  setDefault(keyOrObject, value) {\\n    if ((typeof keyOrObject === 'object') && (value === undefined)) {\\n      // Called as `dict.setDefault({...})`\\n      this._setDefaultObject(keyOrObject);\\n      return;\\n    }\\n    // the input isn't an object, so it must be a key\\n    // and we resume with the rest of the function\\n    const key = keyOrObject;\\n\\n    if (! hasOwn.call(this.keys, key)) {\\n      this.set(key, value);\\n    }\\n  }\\n\\n  /**\\n   * @summary Get the value assiciated with a key. If inside a [reactive\\n   * computation](#reactivity), invalidate the computation the next time the\\n   * value associated with this key is changed by\\n   * [`ReactiveDict.set`](#ReactiveDict-set).\\n   * This returns a clone of the value, so if it's an object or an array,\\n   * mutating the returned value has no effect on the value stored in the\\n   * ReactiveDict.\\n   * @locus Client\\n   * @param {String} key The key of the element to return\\n   */\\n  get(key) {\\n    this._ensureKey(key);\\n    this.keyDeps[key].depend();\\n    return parse(this.keys[key]);\\n  }\\n\\n  /**\\n   * @summary Test if the stored entry for a key is equal to a value. If inside a\\n   * [reactive computation](#reactivity), invalidate the computation the next\\n   * time the variable changes to or from the value.\\n   * @locus Client\\n   * @param {String} key The name of the session variable to test\\n   * @param {String | Number | Boolean | null | undefined} value The value to\\n   * test against\\n   */\\n  equals(key, value) {\\n    // Mongo.ObjectID is in the 'mongo' package\\n    let ObjectID = null;\\n    if (Package.mongo) {\\n      ObjectID = Package.mongo.Mongo.ObjectID;\\n    }\\n    // We don't allow objects (or arrays that might include objects) for\\n    // .equals, because JSON.stringify doesn't canonicalize object key\\n    // order. (We can make equals have the right return value by parsing the\\n    // current value and using EJSON.equals, but we won't have a canonical\\n    // element of keyValueDeps[key] to store the dependency.) You can still use\\n    // \\\"EJSON.equals(reactiveDict.get(key), value)\\\".\\n    //\\n    // XXX we could allow arrays as long as we recursively check that there\\n    // are no objects\\n    if (typeof value !== 'string' &&\\n        typeof value !== 'number' &&\\n        typeof value !== 'boolean' &&\\n        typeof value !== 'undefined' &&\\n        !(value instanceof Date) &&\\n        !(ObjectID && value instanceof ObjectID) &&\\n        value !== null) {\\n      throw new Error(\\\"ReactiveDict.equals: value must be scalar\\\");\\n    }\\n    const serializedValue = stringify(value);\\n\\n    if (Tracker.active) {\\n      this._ensureKey(key);\\n\\n      if (! hasOwn.call(this.keyValueDeps[key], serializedValue)) {\\n        this.keyValueDeps[key][serializedValue] = new Tracker.Dependency;\\n      }\\n\\n      var isNew = this.keyValueDeps[key][serializedValue].depend();\\n      if (isNew) {\\n        Tracker.onInvalidate(() => {\\n          // clean up [key][serializedValue] if it's now empty, so we don't\\n          // use O(n) memory for n = values seen ever\\n          if (! this.keyValueDeps[key][serializedValue].hasDependents()) {\\n            delete this.keyValueDeps[key][serializedValue];\\n          }\\n        });\\n      }\\n    }\\n\\n    let oldValue = undefined;\\n    if (hasOwn.call(this.keys, key)) {\\n      oldValue = parse(this.keys[key]);\\n    }\\n    return EJSON.equals(oldValue, value);\\n  }\\n\\n  /**\\n   * @summary Get all key-value pairs as a plain object. If inside a [reactive\\n   * computation](#reactivity), invalidate the computation the next time the\\n   * value associated with any key is changed by\\n   * [`ReactiveDict.set`](#ReactiveDict-set).\\n   * This returns a clone of each value, so if it's an object or an array,\\n   * mutating the returned value has no effect on the value stored in the\\n   * ReactiveDict.\\n   * @locus Client\\n   */\\n  all() {\\n    this.allDeps.depend();\\n    let ret = {};\\n    Object.keys(this.keys).forEach(key => {\\n      ret[key] = parse(this.keys[key]);\\n    });\\n    return ret;\\n  }\\n\\n  /**\\n   * @summary remove all key-value pairs from the ReactiveDict. Notify any\\n   * listeners that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   */\\n  clear() {\\n    const oldKeys = this.keys;\\n    this.keys = {};\\n\\n    this.allDeps.changed();\\n\\n    Object.keys(oldKeys).forEach(key => {\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldKeys[key]]);\\n        changed(this.keyValueDeps[key]['undefined']);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary remove a key-value pair from the ReactiveDict. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   * @param {String} key The key to delete, eg, `selectedItem`\\n   */\\n  delete(key) {\\n    let didRemove = false;\\n\\n    if (hasOwn.call(this.keys, key)) {\\n      const oldValue = this.keys[key];\\n      delete this.keys[key];\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldValue]);\\n        changed(this.keyValueDeps[key]['undefined']);\\n      }\\n      this.allDeps.changed();\\n      didRemove = true;\\n    }\\n    return didRemove;\\n  }\\n\\n  /**\\n   * @summary Clear all values from the reactiveDict and prevent it from being\\n   * migrated on a Hot Code Pushes. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   */\\n  destroy() {\\n    this.clear();\\n    if (this.name && hasOwn.call(ReactiveDict._dictsToMigrate, this.name)) {\\n      delete ReactiveDict._dictsToMigrate[this.name];\\n    }\\n  }\\n\\n  _setObject(object) {\\n    Object.keys(object).forEach(key => {\\n      this.set(key, object[key]);\\n    });\\n  }\\n\\n  _setDefaultObject(object) {\\n    Object.keys(object).forEach(key => {\\n      this.setDefault(key, object[key]);\\n    });\\n  }\\n\\n  _ensureKey(key) {\\n    if (!(key in this.keyDeps)) {\\n      this.keyDeps[key] = new Tracker.Dependency;\\n      this.keyValueDeps[key] = {};\\n    }\\n  }\\n\\n  // Get a JSON value that can be passed to the constructor to\\n  // create a new ReactiveDict with the same contents as this one\\n  _getMigrationData() {\\n    // XXX sanitize and make sure it's JSONible?\\n    return this.keys;\\n  }\\n}\\n\"]}","minifier":"terser"}