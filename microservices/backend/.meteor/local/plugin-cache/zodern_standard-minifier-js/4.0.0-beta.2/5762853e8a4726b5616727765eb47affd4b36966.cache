{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,o=Package.meteor.meteorEnv,n=Package.minimongo.LocalCollection,r=Package.minimongo.Minimongo,i=Package.check.check,c=Package.check.Match,s=Package.ejson.EJSON,l=Package[\"ddp-client\"].DDP,a=Package.modules.meteorInstall,d=Package[\"babel-runtime\"].meteorBabelHelpers,f=Package.promise.Promise,u,h;a({node_modules:{meteor:{\"allow-deny\":{\"allow-deny.js\":function(){const t=Object.prototype.hasOwnProperty,o=(u={CollectionPrototype:{}}).CollectionPrototype;o.allow=function(e){f(this,\"allow\",e)},o.deny=function(e){f(this,\"deny\",e)},o._defineMutationMethods=function(o){const n=this;if(o=o||{},n._restricted=!1,n._insecure=void 0,n._validators={insert:{allow:[],deny:[]},update:{allow:[],deny:[]},remove:{allow:[],deny:[]},upsert:{allow:[],deny:[]},fetch:[],fetchAllFields:!1},n._name&&(n._prefix=\"/\"+n._name+\"/\",n._connection&&(n._connection===e.server||e.isClient))){const r={};[\"insert\",\"update\",\"remove\"].forEach(s=>{const l=n._prefix+s;if(o.useExisting){const t=e.isClient?\"_methodHandlers\":\"method_handlers\";if(n._connection[t]&&\"function\"==typeof n._connection[t][l])return}r[l]=function(){i(arguments,[c.Any]);const o=Array.from(arguments);try{let r=null;if(\"insert\"!==s||t.call(o[0],\"_id\")||(r=n._makeNewID()),this.isSimulation)return null!==r&&(o[0]._id=r),n._collection[s].apply(n._collection,o);if(\"insert\"!==s&&h(o[0],s),n._restricted){if(0===n._validators[s].allow.length)throw new e.Error(403,\"Access denied. No allow validators set on restricted collection for method '\"+s+\"'.\");const t=\"_validated\"+s.charAt(0).toUpperCase()+s.slice(1);return o.unshift(this.userId),\"insert\"===s&&o.push(r),n[t].apply(n,o)}if(n._isInsecure())return null!==r&&(o[0]._id=r),n._collection[s].apply(n._collection,o);throw new e.Error(403,\"Access denied\")}catch(t){throw\"MongoError\"===t.name||\"MinimongoError\"===t.name?new e.Error(409,t.toString()):t}}}),n._connection.methods(r)}},o._updateFetch=function(e){const t=this;if(!t._validators.fetchAllFields)if(e){const o=Object.create(null),n=e=>e&&e.forEach(e=>o[e]=1);n(t._validators.fetch),n(e),t._validators.fetch=Object.keys(o)}else t._validators.fetchAllFields=!0,t._validators.fetch=null},o._isInsecure=function(){const e=this;return void 0===this._insecure?!!Package.insecure:this._insecure},o._validatedInsert=function(t,o,n){const r=this;if(this._validators.insert.deny.some(e=>e(t,d(e,o,n))))throw new e.Error(403,\"Access denied\");if(this._validators.insert.allow.every(e=>!e(t,d(e,o,n))))throw new e.Error(403,\"Access denied\");null!==n&&(o._id=n),this._collection.insert.call(this._collection,o)},o._validatedUpdate=function(o,c,s,l){const d=this;if(i(s,Object),l=Object.assign(Object.create(null),l),!n._selectorIsIdPerhapsAsObject(c))throw new Error(\"validated update should be of a single ID\");if(l.upsert)throw new e.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");const f=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",u=Object.keys(s),h={};if(0===u.length)throw new e.Error(403,f);u.forEach(o=>{const n=s[o];if(\"$\"!==o.charAt(0))throw new e.Error(403,f);if(!t.call(r,o))throw new e.Error(403,\"Access denied. Operator \"+o+\" not allowed in a restricted collection.\");Object.keys(n).forEach(e=>{-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),h[e]=!0})});const _=Object.keys(h),m={transform:null};d._validators.fetchAllFields||(m.fields={},d._validators.fetch.forEach(e=>{m.fields[e]=1}));const w=d._collection.findOne(c,m);if(!w)return 0;if(d._validators.update.deny.some(e=>{const t=a(e,w);return e(o,t,_,s)}))throw new e.Error(403,\"Access denied\");if(d._validators.update.allow.every(e=>{const t=a(e,w);return!e(o,t,_,s)}))throw new e.Error(403,\"Access denied\");return l._forbidReplace=!0,d._collection.update.call(d._collection,c,s,l)};const r={$inc:1,$set:1,$unset:1,$addToSet:1,$pop:1,$pullAll:1,$pull:1,$pushAll:1,$push:1,$bit:1};function a(e,t){return e.transform?e.transform(t):t}function d(e,t,o){let n=t;return e.transform&&(n=s.clone(t),null!==o&&(n._id=o),n=e.transform(n)),n}function f(e,o,r){const i=/^(?:insert|update|remove|fetch|transform)$/;if(Object.keys(r).forEach(e=>{if(!i.test(e))throw new Error(o+\": Invalid key: \"+e)}),e._restricted=!0,[\"insert\",\"update\",\"remove\"].forEach(i=>{if(t.call(r,i)){if(!(r[i]instanceof Function))throw new Error(o+\": Value for `\"+i+\"` must be a function\");void 0===r.transform?r[i].transform=e._transform:r[i].transform=n.wrapTransform(r.transform),e._validators[i][o].push(r[i])}}),r.update||r.remove||r.fetch){if(r.fetch&&!(r.fetch instanceof Array))throw new Error(o+\": Value for `fetch` must be an array\");e._updateFetch(r.fetch)}}function h(t,o){if(!n._selectorIsIdPerhapsAsObject(t))throw new e.Error(403,\"Not permitted. Untrusted code may only \"+o+\" documents by ID.\")}function _(){var e;const t=(l._CurrentMethodInvocation||l._CurrentInvocation).get();return t&&t.isSimulation}o._validatedRemove=function(t,o){const n=this,r={transform:null};n._validators.fetchAllFields||(r.fields={},n._validators.fetch.forEach(e=>{r.fields[e]=1}));const i=n._collection.findOne(o,r);if(!i)return 0;if(n._validators.remove.deny.some(e=>e(t,a(e,i))))throw new e.Error(403,\"Access denied\");if(n._validators.remove.allow.every(e=>!e(t,a(e,i))))throw new e.Error(403,\"Access denied\");return n._collection.remove.call(n._collection,o)},o._callMutatorMethod=function t(o,n,r){!e.isClient||r||_()||(r=function(t){t&&e._debug(o+\" failed: \"+(t.reason||t.stack))});const i=\"update\"===o||\"remove\"===o;i&&!_()&&h(n[0],o);const c=this._prefix+o;return this._connection.apply(c,n,{returnStubValue:!0},r)}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/allow-deny/allow-deny.js\"),Package._define(\"allow-deny\",{AllowDeny:u})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/allow-deny/allow-deny.js\"],\"names\":[\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"CollectionPrototype\",\"AllowDeny\",\"allow\",\"options\",\"addValidator\",\"this\",\"deny\",\"_defineMutationMethods\",\"self\",\"_restricted\",\"_insecure\",\"undefined\",\"_validators\",\"insert\",\"update\",\"remove\",\"upsert\",\"fetch\",\"fetchAllFields\",\"_name\",\"_prefix\",\"_connection\",\"Meteor\",\"server\",\"isClient\",\"m\",\"forEach\",\"method\",\"methodName\",\"useExisting\",\"handlerPropName\",\"check\",\"arguments\",\"Match\",\"Any\",\"args\",\"Array\",\"from\",\"generatedId\",\"call\",\"_makeNewID\",\"isSimulation\",\"_id\",\"_collection\",\"apply\",\"throwIfSelectorIsNotId\",\"length\",\"Error\",\"validatedMethodName\",\"charAt\",\"toUpperCase\",\"slice\",\"unshift\",\"userId\",\"push\",\"_isInsecure\",\"e\",\"name\",\"toString\",\"methods\",\"_updateFetch\",\"fields\",\"union\",\"create\",\"add\",\"names\",\"keys\",\"Package\",\"insecure\",\"_validatedInsert\",\"doc\",\"some\",\"validator\",\"docToValidate\",\"every\",\"_validatedUpdate\",\"selector\",\"mutator\",\"assign\",\"LocalCollection\",\"_selectorIsIdPerhapsAsObject\",\"noReplaceError\",\"mutatorKeys\",\"modifiedFields\",\"op\",\"params\",\"ALLOWED_UPDATE_OPERATIONS\",\"field\",\"indexOf\",\"substring\",\"findOptions\",\"transform\",\"fieldName\",\"findOne\",\"factoriedDoc\",\"transformDoc\",\"_forbidReplace\",\"$inc\",\"$set\",\"$unset\",\"$addToSet\",\"$pop\",\"$pullAll\",\"$pull\",\"$pushAll\",\"$push\",\"$bit\",\"ret\",\"EJSON\",\"clone\",\"collection\",\"allowOrDeny\",\"validKeysRegEx\",\"key\",\"test\",\"Function\",\"_transform\",\"wrapTransform\",\"alreadyInSimulation\",\"CurrentInvocation\",\"enclosing\",\"DDP\",\"_CurrentMethodInvocation\",\"_CurrentInvocation\",\"get\",\"_validatedRemove\",\"_callMutatorMethod\",\"callback\",\"err\",\"_debug\",\"reason\",\"stack\",\"firstArgIsSelector\",\"mutatorMethodName\",\"returnStubValue\"],\"mappings\":\"yaAIA,MAAMA,EAASC,OAAOC,UAAUC,eAsC1BC,GANNC,GACED,yBAKoCA,oBAatCA,EAAoBE,MAAQ,SAASC,GACnCC,EAAaC,KAAM,QAASF,IAc9BH,EAAoBM,KAAO,SAASH,GAClCC,EAAaC,KAAM,OAAQF,IAG7BH,EAAoBO,uBAAyB,SAASJ,GACpD,MAAMK,EAAOH,KAsBb,GArBAF,EAAUA,MAIVK,EAAKC,aAAc,EAMnBD,EAAKE,eAAYC,EAEjBH,EAAKI,aACHC,QAASX,SAAWI,SACpBQ,QAASZ,SAAWI,SACpBS,QAASb,SAAWI,SACpBU,QAASd,SAAWI,SACpBW,SACAC,gBAAgB,GAGbV,EAAKW,QAKVX,EAAKY,QAAU,IAAMZ,EAAKW,MAAQ,IAO9BX,EAAKa,cAAgBb,EAAKa,cAAgBC,EAAOC,QAAUD,EAAOE,WAAW,CAC/E,MAAMC,MAEL,SAAU,SAAU,UAAUC,QAASC,IACtC,MAAMC,EAAapB,EAAKY,QAAUO,EAElC,GAAIxB,EAAQ0B,YAAa,CACvB,MAAMC,EAAkBR,EAAOE,SAAW,kBAAoB,kBAG9D,GAAIhB,EAAKa,YAAYS,IACsC,mBAAlDtB,EAAKa,YAAYS,GAAiBF,GAA4B,OAGzEH,EAAEG,GAAc,WAEdG,EAAMC,WAAYC,EAAMC,MACxB,MAAMC,EAAOC,MAAMC,KAAKL,WACxB,IAYE,IAAIM,EAAc,KAKlB,GAJe,WAAXX,GAAwB/B,EAAO2C,KAAKJ,EAAK,GAAI,SAC/CG,EAAc9B,EAAKgC,cAGjBnC,KAAKoC,aAKP,OAFoB,OAAhBH,IACFH,EAAK,GAAGO,IAAMJ,GACT9B,EAAKmC,YAAYhB,GAAQiB,MAC9BpC,EAAKmC,YAAaR,GAUtB,GAHe,WAAXR,GACFkB,EAAuBV,EAAK,GAAIR,GAE9BnB,EAAKC,YAAa,CAEpB,GAA8C,IAA1CD,EAAKI,YAAYe,GAAQzB,MAAM4C,OACjC,MAAM,IAAIxB,EAAOyB,MACf,IAAK,+EACyBpB,EAAS,MAG3C,MAAMqB,EACA,aAAerB,EAAOsB,OAAO,GAAGC,cAAgBvB,EAAOwB,MAAM,GAGnE,OAFAhB,EAAKiB,QAAQ/C,KAAKgD,QACP,WAAX1B,GAAuBQ,EAAKmB,KAAKhB,GAC1B9B,EAAKwC,GAAqBJ,MAAMpC,EAAM2B,GACxC,GAAI3B,EAAK+C,cAcd,OAboB,OAAhBjB,IACFH,EAAK,GAAGO,IAAMJ,GAYT9B,EAAKmC,YAAYhB,GAAQiB,MAAMpC,EAAKmC,YAAaR,GAIxD,MAAM,IAAIb,EAAOyB,MAAM,IAAK,iBAE9B,MAAOS,GACP,KAAe,eAAXA,EAAEC,MAAoC,mBAAXD,EAAEC,KACzB,IAAInC,EAAOyB,MAAM,IAAKS,EAAEE,YAExBF,MAMdhD,EAAKa,YAAYsC,QAAQlC,KAI7BzB,EAAoB4D,aAAe,SAAUC,GAC3C,MAAMrD,EAAOH,KAEb,IAAKG,EAAKI,YAAYM,eACpB,GAAI2C,EAAQ,CACV,MAAMC,EAAQjE,OAAOkE,OAAO,MACtBC,EAAMC,GAASA,GAASA,EAAMvC,QAAQ+B,GAAQK,EAAML,GAAQ,GAClEO,EAAIxD,EAAKI,YAAYK,OACrB+C,EAAIH,GACJrD,EAAKI,YAAYK,MAAQpB,OAAOqE,KAAKJ,QAErCtD,EAAKI,YAAYM,gBAAiB,EAElCV,EAAKI,YAAYK,MAAQ,MAK/BjB,EAAoBuD,YAAc,WAChC,MAAM/C,EAAOH,KACb,YAAuBM,IADVN,KACJK,YACEyD,QAAQC,SAFN/D,KAGDK,WAGdV,EAAoBqE,iBAAmB,SAAUhB,EAAQiB,EACAhC,GACvD,MAAM9B,EAAOH,KAIb,GAJaA,KAIJO,YAAYC,OAAOP,KAAKiE,KAAMC,GAC9BA,EAAUnB,EAAQoB,EAAcD,EAAWF,EAAKhC,KAEvD,MAAM,IAAIhB,EAAOyB,MAAM,IAAK,iBAG9B,GAVa1C,KAUJO,YAAYC,OAAOX,MAAMwE,MAAOF,IAC/BA,EAAUnB,EAAQoB,EAAcD,EAAWF,EAAKhC,KAExD,MAAM,IAAIhB,EAAOyB,MAAM,IAAK,iBAKV,OAAhBT,IACFgC,EAAI5B,IAAMJ,GAnBCjC,KAqBRsC,YAAY9B,OAAO0B,KArBXlC,KAqBqBsC,YAAa2B,IAOjDtE,EAAoB2E,iBAAmB,SACnCtB,EAAQuB,EAAUC,EAAS1E,GAC7B,MAAMK,EAAOH,KAMb,GAJA0B,EAAM8C,EAAShF,QAEfM,EAAUN,OAAOiF,OAAOjF,OAAOkE,OAAO,MAAO5D,IAExC4E,EAAgBC,6BAA6BJ,GAChD,MAAM,IAAI7B,MAAM,6CAIlB,GAAI5C,EAAQa,OACV,MAAM,IAAIM,EAAOyB,MAAM,IAAK,kEAG9B,MAAMkC,EAAiB,0IAIjBC,EAAcrF,OAAOqE,KAAKW,GAG1BM,KAEN,GAA2B,IAAvBD,EAAYpC,OACd,MAAM,IAAIxB,EAAOyB,MAAM,IAAKkC,GAE9BC,EAAYxD,QAAS0D,IACnB,MAAMC,EAASR,EAAQO,GACvB,GAAqB,MAAjBA,EAAGnC,OAAO,GACZ,MAAM,IAAI3B,EAAOyB,MAAM,IAAKkC,GACvB,IAAKrF,EAAO2C,KAAK+C,EAA2BF,GACjD,MAAM,IAAI9D,EAAOyB,MACf,IAAK,2BAA6BqC,EAAK,4CAEzCvF,OAAOqE,KAAKmB,GAAQ3D,QAAS6D,KAGC,IAAxBA,EAAMC,QAAQ,OAChBD,EAAQA,EAAME,UAAU,EAAGF,EAAMC,QAAQ,OAG3CL,EAAeI,IAAS,MAK9B,MAAM1B,EAAShE,OAAOqE,KAAKiB,GAErBO,GAAeC,UAAW,MAC3BnF,EAAKI,YAAYM,iBACpBwE,EAAY7B,UACZrD,EAAKI,YAAYK,MAAMS,QAASkE,IAC9BF,EAAY7B,OAAO+B,GAAa,KAIpC,MAAMtB,EAAM9D,EAAKmC,YAAYkD,QAAQjB,EAAUc,GAC/C,IAAKpB,EACH,OAAO,EAIT,GAAI9D,EAAKI,YAAYE,OAAOR,KAAKiE,KAAMC,IACrC,MAAMsB,EAAeC,EAAavB,EAAWF,GAC7C,OAAOE,EAAUnB,EACAyC,EACAjC,EACAgB,KAEjB,MAAM,IAAIvD,EAAOyB,MAAM,IAAK,iBAG9B,GAAIvC,EAAKI,YAAYE,OAAOZ,MAAMwE,MAAOF,IACvC,MAAMsB,EAAeC,EAAavB,EAAWF,GAC7C,OAAQE,EAAUnB,EACAyC,EACAjC,EACAgB,KAElB,MAAM,IAAIvD,EAAOyB,MAAM,IAAK,iBAU9B,OAPA5C,EAAQ6F,gBAAiB,EAOlBxF,EAAKmC,YAAY7B,OAAOyB,KAC7B/B,EAAKmC,YAAaiC,EAAUC,EAAS1E,IASzC,MAAMmF,GACJW,KAAK,EAAGC,KAAK,EAAGC,OAAO,EAAGC,UAAU,EAAGC,KAAK,EAAGC,SAAS,EAAGC,MAAM,EACjEC,SAAS,EAAGC,MAAM,EAAGC,KAAK,GAwE5B,SAASX,EAAavB,EAAWF,GAC/B,OAAIE,EAAUmB,UACLnB,EAAUmB,UAAUrB,GACtBA,EAGT,SAASG,EAAcD,EAAWF,EAAKhC,GACrC,IAAIqE,EAAMrC,EAaV,OAZIE,EAAUmB,YACZgB,EAAMC,EAAMC,MAAMvC,GAME,OAAhBhC,IACFqE,EAAIjE,IAAMJ,GAEZqE,EAAMnC,EAAUmB,UAAUgB,IAErBA,EAGT,SAASvG,EAAa0G,EAAYC,EAAa5G,GAE7C,MAAM6G,EAAiB,6CA+BvB,GA9BAnH,OAAOqE,KAAK/D,GAASuB,QAASuF,IAC5B,IAAKD,EAAeE,KAAKD,GACvB,MAAM,IAAIlE,MAAMgE,EAAc,kBAAoBE,KAGtDH,EAAWrG,aAAc,GAExB,SAAU,SAAU,UAAUiB,QAAS+B,IACtC,GAAI7D,EAAO2C,KAAKpC,EAASsD,GAAO,CAC9B,KAAMtD,EAAQsD,aAAiB0D,UAC7B,MAAM,IAAIpE,MAAMgE,EAAc,gBAAkBtD,EAAO,6BAM/B9C,IAAtBR,EAAQwF,UACVxF,EAAQsD,GAAMkC,UAAYmB,EAAWM,WAErCjH,EAAQsD,GAAMkC,UAAYZ,EAAgBsC,cACxClH,EAAQwF,WAGZmB,EAAWlG,YAAY6C,GAAMsD,GAAazD,KAAKnD,EAAQsD,OAOvDtD,EAAQW,QAAUX,EAAQY,QAAUZ,EAAQc,MAAO,CACrD,GAAId,EAAQc,SAAWd,EAAQc,iBAAiBmB,OAC9C,MAAM,IAAIW,MAAMgE,EAAc,wCAEhCD,EAAWlD,aAAazD,EAAQc,QAIpC,SAAS4B,EAAuB+B,EAAUhD,GACxC,IAAKmD,EAAgBC,6BAA6BJ,GAChD,MAAM,IAAItD,EAAOyB,MACf,IAAK,0CAA4CnB,EAC/C,qBAKR,SAAS0F,IACP,IAAIC,EAMJ,MAAMC,GALJC,EAAIC,0BAGJD,EAAIE,oBAE8BC,MACpC,OAAOJ,GAAaA,EAAU/E,aApJhCzC,EAAoB6H,iBAAmB,SAASxE,EAAQuB,GACtD,MAAMpE,EAAOH,KAEPqF,GAAeC,UAAW,MAC3BnF,EAAKI,YAAYM,iBACpBwE,EAAY7B,UACZrD,EAAKI,YAAYK,MAAMS,QAASkE,IAC9BF,EAAY7B,OAAO+B,GAAa,KAIpC,MAAMtB,EAAM9D,EAAKmC,YAAYkD,QAAQjB,EAAUc,GAC/C,IAAKpB,EACH,OAAO,EAIT,GAAI9D,EAAKI,YAAYG,OAAOT,KAAKiE,KAAMC,GAC9BA,EAAUnB,EAAQ0C,EAAavB,EAAWF,KAEjD,MAAM,IAAIhD,EAAOyB,MAAM,IAAK,iBAG9B,GAAIvC,EAAKI,YAAYG,OAAOb,MAAMwE,MAAOF,IAC/BA,EAAUnB,EAAQ0C,EAAavB,EAAWF,KAElD,MAAM,IAAIhD,EAAOyB,MAAM,IAAK,iBAQ9B,OAAOvC,EAAKmC,YAAY5B,OAAOwB,KAAK/B,EAAKmC,YAAaiC,IAGxD5E,EAAoB8H,mBAAqB,SAASA,EAAmBrE,EAAMtB,EAAM4F,IAC3EzG,EAAOE,UAAauG,GAAaT,MASnCS,EAAW,SAAUC,GACfA,GACF1G,EAAO2G,OAAOxE,EAAO,aAAeuE,EAAIE,QAAUF,EAAIG,UAK5D,MAAMC,EAA8B,WAAT3E,GAA8B,WAATA,EAC5C2E,IAAuBd,KAIzBzE,EAAuBV,EAAK,GAAIsB,GAGlC,MAAM4E,EAAoBhI,KAAKe,QAAUqC,EACzC,OAAOpD,KAAKgB,YAAYuB,MACtByF,EAAmBlG,GAAQmG,iBAAiB,GAAQP\",\"sourcesContent\":[\"///\\n/// Remote methods and access control.\\n///\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Restrict default mutators on collection. allow() and deny() take the\\n// same options:\\n//\\n// options.insert {Function(userId, doc)}\\n//   return true to allow/deny adding this document\\n//\\n// options.update {Function(userId, docs, fields, modifier)}\\n//   return true to allow/deny updating these documents.\\n//   `fields` is passed as an array of fields that are to be modified\\n//\\n// options.remove {Function(userId, docs)}\\n//   return true to allow/deny removing these documents\\n//\\n// options.fetch {Array}\\n//   Fields to fetch for these validators. If any call to allow or deny\\n//   does not have this option then all fields are loaded.\\n//\\n// allow and deny can be called multiple times. The validators are\\n// evaluated as follows:\\n// - If neither deny() nor allow() has been called on the collection,\\n//   then the request is allowed if and only if the \\\"insecure\\\" smart\\n//   package is in use.\\n// - Otherwise, if any deny() function returns true, the request is denied.\\n// - Otherwise, if any allow() function returns true, the request is allowed.\\n// - Otherwise, the request is denied.\\n//\\n// Meteor may call your deny() and allow() functions in any order, and may not\\n// call all of them if it is able to make a decision without calling them all\\n// (so don't include side effects).\\n\\nAllowDeny = {\\n  CollectionPrototype: {}\\n};\\n\\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\\n// methods\\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\\n\\n/**\\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\\n * @locus Server\\n * @method allow\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.allow = function(options) {\\n  addValidator(this, 'allow', options);\\n};\\n\\n/**\\n * @summary Override `allow` rules.\\n * @locus Server\\n * @method deny\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.deny = function(options) {\\n  addValidator(this, 'deny', options);\\n};\\n\\nCollectionPrototype._defineMutationMethods = function(options) {\\n  const self = this;\\n  options = options || {};\\n\\n  // set to true once we call any allow or deny methods. If true, use\\n  // allow/deny semantics. If false, use insecure mode semantics.\\n  self._restricted = false;\\n\\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\\n  // means insecure iff the insecure package is loaded. This property can be\\n  // overriden by tests or packages wishing to change insecure mode behavior of\\n  // their collections.\\n  self._insecure = undefined;\\n\\n  self._validators = {\\n    insert: {allow: [], deny: []},\\n    update: {allow: [], deny: []},\\n    remove: {allow: [], deny: []},\\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\\n    fetch: [],\\n    fetchAllFields: false\\n  };\\n\\n  if (!self._name)\\n    return; // anonymous collection\\n\\n  // XXX Think about method namespacing. Maybe methods should be\\n  // \\\"Meteor:Mongo:insert/NAME\\\"?\\n  self._prefix = '/' + self._name + '/';\\n\\n  // Mutation Methods\\n  // Minimongo on the server gets no stubs; instead, by default\\n  // it wait()s until its result is ready, yielding.\\n  // This matches the behavior of macromongo on the server better.\\n  // XXX see #MeteorServerNull\\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\\n    const m = {};\\n\\n    ['insert', 'update', 'remove'].forEach((method) => {\\n      const methodName = self._prefix + method;\\n\\n      if (options.useExisting) {\\n        const handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';\\n        // Do not try to create additional methods if this has already been called.\\n        // (Otherwise the .methods() call below will throw an error.)\\n        if (self._connection[handlerPropName] &&\\n          typeof self._connection[handlerPropName][methodName] === 'function') return;\\n      }\\n\\n      m[methodName] = function (/* ... */) {\\n        // All the methods do their own validation, instead of using check().\\n        check(arguments, [Match.Any]);\\n        const args = Array.from(arguments);\\n        try {\\n          // For an insert, if the client didn't specify an _id, generate one\\n          // now; because this uses DDP.randomStream, it will be consistent with\\n          // what the client generated. We generate it now rather than later so\\n          // that if (eg) an allow/deny rule does an insert to the same\\n          // collection (not that it really should), the generated _id will\\n          // still be the first use of the stream and will be consistent.\\n          //\\n          // However, we don't actually stick the _id onto the document yet,\\n          // because we want allow/deny rules to be able to differentiate\\n          // between arbitrary client-specified _id fields and merely\\n          // client-controlled-via-randomSeed fields.\\n          let generatedId = null;\\n          if (method === \\\"insert\\\" && !hasOwn.call(args[0], '_id')) {\\n            generatedId = self._makeNewID();\\n          }\\n\\n          if (this.isSimulation) {\\n            // In a client simulation, you can do any mutation (even with a\\n            // complex selector).\\n            if (generatedId !== null)\\n              args[0]._id = generatedId;\\n            return self._collection[method].apply(\\n              self._collection, args);\\n          }\\n\\n          // This is the server receiving a method call from the client.\\n\\n          // We don't allow arbitrary selectors in mutations from the client: only\\n          // single-ID selectors.\\n          if (method !== 'insert')\\n            throwIfSelectorIsNotId(args[0], method);\\n\\n          if (self._restricted) {\\n            // short circuit if there is no way it will pass.\\n            if (self._validators[method].allow.length === 0) {\\n              throw new Meteor.Error(\\n                403, \\\"Access denied. No allow validators set on restricted \\\" +\\n                  \\\"collection for method '\\\" + method + \\\"'.\\\");\\n            }\\n\\n            const validatedMethodName =\\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\\n            args.unshift(this.userId);\\n            method === 'insert' && args.push(generatedId);\\n            return self[validatedMethodName].apply(self, args);\\n          } else if (self._isInsecure()) {\\n            if (generatedId !== null)\\n              args[0]._id = generatedId;\\n            // In insecure mode, allow any mutation (with a simple selector).\\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\\n            //     we get from the network to this function, we should actually\\n            //     know the correct arguments for the function and pass just\\n            //     them.  For example, if you have an extraneous extra null\\n            //     argument and this is Mongo on the server, the .wrapAsync'd\\n            //     functions like update will get confused and pass the\\n            //     \\\"fut.resolver()\\\" in the wrong slot, where _update will never\\n            //     invoke it. Bam, broken DDP connection.  Probably should just\\n            //     take this whole method and write it three times, invoking\\n            //     helpers for the common code.\\n            return self._collection[method].apply(self._collection, args);\\n          } else {\\n            // In secure mode, if we haven't called allow or deny, then nothing\\n            // is permitted.\\n            throw new Meteor.Error(403, \\\"Access denied\\\");\\n          }\\n        } catch (e) {\\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {\\n            throw new Meteor.Error(409, e.toString());\\n          } else {\\n            throw e;\\n          }\\n        }\\n      };\\n    });\\n\\n    self._connection.methods(m);\\n  }\\n};\\n\\nCollectionPrototype._updateFetch = function (fields) {\\n  const self = this;\\n\\n  if (!self._validators.fetchAllFields) {\\n    if (fields) {\\n      const union = Object.create(null);\\n      const add = names => names && names.forEach(name => union[name] = 1);\\n      add(self._validators.fetch);\\n      add(fields);\\n      self._validators.fetch = Object.keys(union);\\n    } else {\\n      self._validators.fetchAllFields = true;\\n      // clear fetch just to make sure we don't accidentally read it\\n      self._validators.fetch = null;\\n    }\\n  }\\n};\\n\\nCollectionPrototype._isInsecure = function () {\\n  const self = this;\\n  if (self._insecure === undefined)\\n    return !!Package.insecure;\\n  return self._insecure;\\n};\\n\\nCollectionPrototype._validatedInsert = function (userId, doc,\\n                                                         generatedId) {\\n  const self = this;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.insert.deny.some((validator) => {\\n    return validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.insert.allow.every((validator) => {\\n    return !validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insert it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  self._collection.insert.call(self._collection, doc);\\n};\\n\\n// Simulate a mongo `update` operation while validating that the access\\n// control rules set by calls to `allow/deny` are satisfied. If all\\n// pass, rewrite the mongo operation to use $in to set the list of\\n// document ids to change ##ValidatedChange\\nCollectionPrototype._validatedUpdate = function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.update.deny.some((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return validator(userId,\\n                     factoriedDoc,\\n                     fields,\\n                     mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.update.allow.every((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return !validator(userId,\\n                      factoriedDoc,\\n                      fields,\\n                      mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.update.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\n// Only allow these operations in validated updates. Specifically\\n// whitelist operations, rather than blacklist, so new complex\\n// operations that are added aren't automatically allowed. A complex\\n// operation is one that does more than just modify its target\\n// field. For now this contains all update operations except '$rename'.\\n// http://docs.mongodb.org/manual/reference/operators/#update\\nconst ALLOWED_UPDATE_OPERATIONS = {\\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\\n  $pushAll:1, $push:1, $bit:1\\n};\\n\\n// Simulate a mongo `remove` operation while validating access control\\n// rules. See #ValidatedChange\\nCollectionPrototype._validatedRemove = function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.remove.deny.some((validator) => {\\n    return validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.remove.allow.every((validator) => {\\n    return !validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.remove.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\\n    // Client can't block, so it can't report errors by exception,\\n    // only by callback. If they forget the callback, give them a\\n    // default one that logs the error, so they aren't totally\\n    // baffled if their writes don't work because their database is\\n    // down.\\n    // Don't give a default callback in simulation, because inside stubs we\\n    // want to return the results from the local collection immediately and\\n    // not force a callback.\\n    callback = function (err) {\\n      if (err)\\n        Meteor._debug(name + \\\" failed: \\\" + (err.reason || err.stack));\\n    };\\n  }\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"update\\\" || name === \\\"remove\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.apply(\\n    mutatorMethodName, args, { returnStubValue: true }, callback);\\n}\\n\\nfunction transformDoc(validator, doc) {\\n  if (validator.transform)\\n    return validator.transform(doc);\\n  return doc;\\n}\\n\\nfunction docToValidate(validator, doc, generatedId) {\\n  let ret = doc;\\n  if (validator.transform) {\\n    ret = EJSON.clone(doc);\\n    // If you set a server-side transform on your collection, then you don't get\\n    // to tell the difference between \\\"client specified the ID\\\" and \\\"server\\n    // generated the ID\\\", because transforms expect to get _id.  If you want to\\n    // do that check, you can do it with a specific\\n    // `C.allow({insert: f, transform: null})` validator.\\n    if (generatedId !== null) {\\n      ret._id = generatedId;\\n    }\\n    ret = validator.transform(ret);\\n  }\\n  return ret;\\n}\\n\\nfunction addValidator(collection, allowOrDeny, options) {\\n  // validate keys\\n  const validKeysRegEx = /^(?:insert|update|remove|fetch|transform)$/;\\n  Object.keys(options).forEach((key) => {\\n    if (!validKeysRegEx.test(key))\\n      throw new Error(allowOrDeny + \\\": Invalid key: \\\" + key);\\n  });\\n\\n  collection._restricted = true;\\n\\n  ['insert', 'update', 'remove'].forEach((name) => {\\n    if (hasOwn.call(options, name)) {\\n      if (!(options[name] instanceof Function)) {\\n        throw new Error(allowOrDeny + \\\": Value for `\\\" + name + \\\"` must be a function\\\");\\n      }\\n\\n      // If the transform is specified at all (including as 'null') in this\\n      // call, then take that; otherwise, take the transform from the\\n      // collection.\\n      if (options.transform === undefined) {\\n        options[name].transform = collection._transform;  // already wrapped\\n      } else {\\n        options[name].transform = LocalCollection.wrapTransform(\\n          options.transform);\\n      }\\n\\n      collection._validators[name][allowOrDeny].push(options[name]);\\n    }\\n  });\\n\\n  // Only update the fetch fields if we're passed things that affect\\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\\n  // setting fetchAllFields\\n  if (options.update || options.remove || options.fetch) {\\n    if (options.fetch && !(options.fetch instanceof Array)) {\\n      throw new Error(allowOrDeny + \\\": Value for `fetch` must be an array\\\");\\n    }\\n    collection._updateFetch(options.fetch);\\n  }\\n}\\n\\nfunction throwIfSelectorIsNotId(selector, methodName) {\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n    throw new Meteor.Error(\\n      403, \\\"Not permitted. Untrusted code may only \\\" + methodName +\\n        \\\" documents by ID.\\\");\\n  }\\n};\\n\\n// Determine if we are in a DDP method simulation\\nfunction alreadyInSimulation() {\\n  var CurrentInvocation =\\n    DDP._CurrentMethodInvocation ||\\n    // For backwards compatibility, as explained in this issue:\\n    // https://github.com/meteor/meteor/issues/8947\\n    DDP._CurrentInvocation;\\n\\n  const enclosing = CurrentInvocation.get();\\n  return enclosing && enclosing.isSimulation;\\n}\\n\"]}","minifier":"terser"}