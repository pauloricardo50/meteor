{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,n=Package.meteor.meteorEnv,r=Package.base64.Base64,o=Package.modules.meteorInstall,a=Package[\"babel-runtime\"].meteorBabelHelpers,l=Package.promise.Promise,s,c,i,u=o({node_modules:{meteor:{ejson:{\"ejson.js\":function(t,n,o){o.export({EJSON:()=>a});const a={},l={},s=(e,t)=>({}).hasOwnProperty.call(e,t),c=e=>null!=e&&s(e,\"callee\"),i=e=>Number.isNaN(e)||e===1/0||e===-1/0;a.addType=((e,t)=>{if(s(l,e))throw new Error(\"Type \".concat(e,\" already present\"));l[e]=t});const u=[{matchJSONValue:e=>s(e,\"$date\")&&1===Object.keys(e).length,matchObject:e=>e instanceof Date,toJSONValue:e=>({$date:e.getTime()}),fromJSONValue:e=>new Date(e.$date)},{matchJSONValue:e=>s(e,\"$regexp\")&&s(e,\"$flags\")&&2===Object.keys(e).length,matchObject:e=>e instanceof RegExp,toJSONValue:e=>({$regexp:e.source,$flags:e.flags}),fromJSONValue:e=>new RegExp(e.$regexp,e.$flags.slice(0,50).replace(/[^gimuy]/g,\"\").replace(/(.)(?=.*\\1)/g,\"\"))},{matchJSONValue:e=>s(e,\"$InfNaN\")&&1===Object.keys(e).length,matchObject:i,toJSONValue(e){let t;return{$InfNaN:t=Number.isNaN(e)?0:e===1/0?1:-1}},fromJSONValue:e=>e.$InfNaN/0},{matchJSONValue:e=>s(e,\"$binary\")&&1===Object.keys(e).length,matchObject:e=>\"undefined\"!=typeof Uint8Array&&e instanceof Uint8Array||e&&s(e,\"$Uint8ArrayPolyfill\"),toJSONValue:e=>({$binary:r.encode(e)}),fromJSONValue:e=>r.decode(e.$binary)},{matchJSONValue:e=>s(e,\"$escape\")&&1===Object.keys(e).length,matchObject(e){let t=!1;if(e){const n=Object.keys(e).length;1!==n&&2!==n||(t=u.some(t=>t.matchJSONValue(e)))}return t},toJSONValue(e){const t={};return Object.keys(e).forEach(n=>{t[n]=a.toJSONValue(e[n])}),{$escape:t}},fromJSONValue(e){const t={};return Object.keys(e.$escape).forEach(n=>{t[n]=a.fromJSONValue(e.$escape[n])}),t}},{matchJSONValue:e=>s(e,\"$type\")&&s(e,\"$value\")&&2===Object.keys(e).length,matchObject:e=>a._isCustomType(e),toJSONValue(t){const n=e._noYieldsAllowed(()=>t.toJSONValue());return{$type:t.typeName(),$value:n}},fromJSONValue(t){const n=t.$type;if(!s(l,n))throw new Error(\"Custom EJSON type \".concat(n,\" is not defined\"));const r=l[n];return e._noYieldsAllowed(()=>r(t.$value))}}];a._isCustomType=(e=>e&&\"function\"==typeof e.toJSONValue&&\"function\"==typeof e.typeName&&s(l,e.typeName())),a._getTypes=(()=>l),a._getConverters=(()=>u);const f=e=>{for(let t=0;t<u.length;t++){const n=u[t];if(n.matchObject(e))return n.toJSONValue(e)}},y=e=>{if(null===e)return null;const t=f(e);return void 0!==t?t:\"object\"!=typeof e?e:(Object.keys(e).forEach(t=>{const n=e[t];if(\"object\"!=typeof n&&void 0!==n&&!i(n))return;const r=f(n);r?e[t]=r:y(n)}),e)};a._adjustTypesToJSONValue=y,a.toJSONValue=(e=>{const t=f(e);if(void 0!==t)return t;let n=e;return\"object\"==typeof e&&(n=a.clone(e),y(n)),n});const O=e=>{if(\"object\"==typeof e&&null!==e){const t=Object.keys(e);if(t.length<=2&&t.every(e=>\"string\"==typeof e&&\"$\"===e.substr(0,1)))for(let n=0;n<u.length;n++){const t=u[n];if(t.matchJSONValue(e))return t.fromJSONValue(e)}}return e},m=e=>{if(null===e)return null;const t=O(e);return t!==e?t:\"object\"!=typeof e?e:(Object.keys(e).forEach(t=>{const n=e[t];if(\"object\"==typeof n){const r=O(n);if(n!==r)return void(e[t]=r);m(n)}}),e)};a._adjustTypesFromJSONValue=m,a.fromJSONValue=(e=>{let t=O(e);return t===e&&\"object\"==typeof e&&(t=a.clone(e),m(t)),t}),a.stringify=((e,t)=>{let n;const r=a.toJSONValue(e);if(t&&(t.canonical||t.indent)){let e;o.link(\"./stringify\",{default(t){e=t}},0),n=e(r,t)}else n=JSON.stringify(r);return n}),a.parse=(e=>{if(\"string\"!=typeof e)throw new Error(\"EJSON.parse argument should be a string\");return a.fromJSONValue(JSON.parse(e))}),a.isBinary=(e=>!!(\"undefined\"!=typeof Uint8Array&&e instanceof Uint8Array||e&&e.$Uint8ArrayPolyfill)),a.equals=((e,t,n)=>{let r;const o=!(!n||!n.keyOrderSensitive);if(e===t)return!0;if(Number.isNaN(e)&&Number.isNaN(t))return!0;if(!e||!t)return!1;if(\"object\"!=typeof e||\"object\"!=typeof t)return!1;if(e instanceof Date&&t instanceof Date)return e.valueOf()===t.valueOf();if(a.isBinary(e)&&a.isBinary(t)){if(e.length!==t.length)return!1;for(r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}if(\"function\"==typeof e.equals)return e.equals(t,n);if(\"function\"==typeof t.equals)return t.equals(e,n);if(e instanceof Array){if(!(t instanceof Array))return!1;if(e.length!==t.length)return!1;for(r=0;r<e.length;r++)if(!a.equals(e[r],t[r],n))return!1;return!0}switch(a._isCustomType(e)+a._isCustomType(t)){case 1:return!1;case 2:return a.equals(a.toJSONValue(e),a.toJSONValue(t))}let l;const c=Object.keys(e),i=Object.keys(t);return o?(r=0,l=c.every(o=>!(r>=i.length)&&(o===i[r]&&(!!a.equals(e[o],t[i[r]],n)&&(r++,!0))))):(r=0,l=c.every(o=>!!s(t,o)&&(!!a.equals(e[o],t[o],n)&&(r++,!0)))),l&&r===i.length}),a.clone=(e=>{let t;if(\"object\"!=typeof e)return e;if(null===e)return null;if(e instanceof Date)return new Date(e.getTime());if(e instanceof RegExp)return e;if(a.isBinary(e)){t=a.newBinary(e.length);for(let n=0;n<e.length;n++)t[n]=e[n];return t}return Array.isArray(e)?e.map(e=>a.clone(e)):c(e)?Array.from(e).map(e=>a.clone(e)):\"function\"==typeof e.clone?e.clone():a._isCustomType(e)?a.fromJSONValue(a.clone(a.toJSONValue(e)),!0):(t={},Object.keys(e).forEach(n=>{t[n]=a.clone(e[n])}),t)}),a.newBinary=r.newBinary},\"stringify.js\":function(e,t,n){function r(e){return JSON.stringify(e)}const o=(e,t,n,a,l)=>{const c=t[e];switch(typeof c){case\"string\":return r(c);case\"number\":return isFinite(c)?String(c):\"null\";case\"boolean\":return String(c);case\"object\":if(!c)return\"null\";const e=a+n,t=[];if(Array.isArray(c)||{}.hasOwnProperty.call(c,\"callee\")){const r=c.length;for(let a=0;a<r;a+=1)t[a]=o(a,c,n,e,l)||\"null\";let s;return s=0===t.length?\"[]\":e?\"[\\n\"+e+t.join(\",\\n\"+e)+\"\\n\"+a+\"]\":\"[\"+t.join(\",\")+\"]\"}let i=Object.keys(c);return l&&(i=i.sort()),i.forEach(a=>{(s=o(a,c,n,e,l))&&t.push(r(a)+(e?\": \":\":\")+s)}),s=0===t.length?\"{}\":e?\"{\\n\"+e+t.join(\",\\n\"+e)+\"\\n\"+a+\"}\":\"{\"+t.join(\",\")+\"}\"}},a=(e,t)=>{const n=Object.assign({indent:\"\",canonical:!1},t);if(!0===n.indent)n.indent=\"  \";else if(\"number\"==typeof n.indent){let e=\"\";for(let t=0;t<n.indent;t++)e+=\" \";n.indent=e}return o(\"\",{\"\":e},n.indent,\"\",n.canonical)};n.exportDefault(a)}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/ejson/ejson.js\");Package._define(\"ejson\",u,{EJSON:c})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/ejson/ejson.js\",\"packages/ejson/stringify.js\"],\"names\":[\"module\",\"export\",\"EJSON\",\"customTypes\",\"hasOwn\",\"obj\",\"prop\",\"hasOwnProperty\",\"call\",\"isArguments\",\"isInfOrNan\",\"Number\",\"isNaN\",\"Infinity\",\"addType\",\"name\",\"factory\",\"Error\",\"concat\",\"builtinConverters\",\"matchJSONValue\",\"Object\",\"keys\",\"length\",\"matchObject\",\"Date\",\"toJSONValue\",\"$date\",\"getTime\",\"fromJSONValue\",\"RegExp\",\"regexp\",\"$regexp\",\"source\",\"$flags\",\"flags\",\"slice\",\"replace\",\"sign\",\"$InfNaN\",\"Uint8Array\",\"$binary\",\"Base64\",\"encode\",\"decode\",\"match\",\"keyCount\",\"some\",\"converter\",\"newObj\",\"forEach\",\"key\",\"$escape\",\"_isCustomType\",\"jsonValue\",\"Meteor\",\"_noYieldsAllowed\",\"$type\",\"typeName\",\"$value\",\"_getTypes\",\"_getConverters\",\"toJSONValueHelper\",\"item\",\"i\",\"adjustTypesToJSONValue\",\"maybeChanged\",\"undefined\",\"value\",\"changed\",\"_adjustTypesToJSONValue\",\"newItem\",\"clone\",\"fromJSONValueHelper\",\"every\",\"k\",\"substr\",\"adjustTypesFromJSONValue\",\"_adjustTypesFromJSONValue\",\"stringify\",\"options\",\"serialized\",\"json\",\"canonical\",\"indent\",\"canonicalStringify\",\"link\",\"default\",\"v\",\"JSON\",\"parse\",\"isBinary\",\"$Uint8ArrayPolyfill\",\"equals\",\"a\",\"b\",\"keyOrderSensitive\",\"valueOf\",\"Array\",\"ret\",\"aKeys\",\"bKeys\",\"newBinary\",\"isArray\",\"map\",\"from\",\"quote\",\"string\",\"str\",\"holder\",\"singleIndent\",\"outerIndent\",\"isFinite\",\"String\",\"innerIndent\",\"partial\",\"join\",\"sort\",\"push\",\"allOptions\",\"assign\",\"newIndent\",\"\",\"exportDefault\"],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * @namespace\\n * @summary Namespace for EJSON functions\\n */\\nconst EJSON = {};\\n\\n// Custom type interface definition\\n/**\\n * @class CustomType\\n * @instanceName customType\\n * @memberOf EJSON\\n * @summary The interface that a class must satisfy to be able to become an\\n * EJSON custom type via EJSON.addType.\\n */\\n\\n/**\\n * @function typeName\\n * @memberOf EJSON.CustomType\\n * @summary Return the tag used to identify this type.  This must match the\\n *          tag used to register this type with\\n *          [`EJSON.addType`](#ejson_add_type).\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function toJSONValue\\n * @memberOf EJSON.CustomType\\n * @summary Serialize this instance into a JSON-compatible value.\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function clone\\n * @memberOf EJSON.CustomType\\n * @summary Return a value `r` such that `this.equals(r)` is true, and\\n *          modifications to `r` do not affect `this` and vice versa.\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function equals\\n * @memberOf EJSON.CustomType\\n * @summary Return `true` if `other` has a value equal to `this`; `false`\\n *          otherwise.\\n * @locus Anywhere\\n * @param {Object} other Another object to compare this to.\\n * @instance\\n */\\n\\nconst customTypes = {};\\n\\nconst hasOwn = (obj, prop) => ({}).hasOwnProperty.call(obj, prop);\\n\\nconst isArguments = obj => obj != null && hasOwn(obj, 'callee');\\n\\nconst isInfOrNan =\\n  obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\\n\\n// Add a custom type, using a method of your choice to get to and\\n// from a basic JSON-able representation.  The factory argument\\n// is a function of JSON-able --> your object\\n// The type you add must have:\\n// - A toJSONValue() method, so that Meteor can serialize it\\n// - a typeName() method, to show how to look it up in our type table.\\n// It is okay if these methods are monkey-patched on.\\n// EJSON.clone will use toJSONValue and the given factory to produce\\n// a clone, but you may specify a method clone() that will be\\n// used instead.\\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\\n// but you may provide a method equals() instead.\\n/**\\n * @summary Add a custom datatype to EJSON.\\n * @locus Anywhere\\n * @param {String} name A tag for your custom type; must be unique among\\n *                      custom data types defined in your project, and must\\n *                      match the result of your type's `typeName` method.\\n * @param {Function} factory A function that deserializes a JSON-compatible\\n *                           value into an instance of your type.  This should\\n *                           match the serialization performed by your\\n *                           type's `toJSONValue` method.\\n */\\nEJSON.addType = (name, factory) => {\\n  if (hasOwn(customTypes, name)) {\\n    throw new Error(`Type ${name} already present`);\\n  }\\n  customTypes[name] = factory;\\n};\\n\\nconst builtinConverters = [\\n  { // Date\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$date') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      return obj instanceof Date;\\n    },\\n    toJSONValue(obj) {\\n      return {$date: obj.getTime()};\\n    },\\n    fromJSONValue(obj) {\\n      return new Date(obj.$date);\\n    },\\n  },\\n  { // RegExp\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$regexp')\\n        && hasOwn(obj, '$flags')\\n        && Object.keys(obj).length === 2;\\n    },\\n    matchObject(obj) {\\n      return obj instanceof RegExp;\\n    },\\n    toJSONValue(regexp) {\\n      return {\\n        $regexp: regexp.source,\\n        $flags: regexp.flags\\n      };\\n    },\\n    fromJSONValue(obj) {\\n      // Replaces duplicate / invalid flags.\\n      return new RegExp(\\n        obj.$regexp,\\n        obj.$flags\\n          // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\\n          .slice(0, 50)\\n          .replace(/[^gimuy]/g,'')\\n          .replace(/(.)(?=.*\\\\1)/g, '')\\n      );\\n    },\\n  },\\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\\n    // which we match.)\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$InfNaN') && Object.keys(obj).length === 1;\\n    },\\n    matchObject: isInfOrNan,\\n    toJSONValue(obj) {\\n      let sign;\\n      if (Number.isNaN(obj)) {\\n        sign = 0;\\n      } else if (obj === Infinity) {\\n        sign = 1;\\n      } else {\\n        sign = -1;\\n      }\\n      return {$InfNaN: sign};\\n    },\\n    fromJSONValue(obj) {\\n      return obj.$InfNaN / 0;\\n    },\\n  },\\n  { // Binary\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$binary') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\\n        || (obj && hasOwn(obj, '$Uint8ArrayPolyfill'));\\n    },\\n    toJSONValue(obj) {\\n      return {$binary: Base64.encode(obj)};\\n    },\\n    fromJSONValue(obj) {\\n      return Base64.decode(obj.$binary);\\n    },\\n  },\\n  { // Escaping one level\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$escape') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      let match = false;\\n      if (obj) {\\n        const keyCount = Object.keys(obj).length;\\n        if (keyCount === 1 || keyCount === 2) {\\n          match =\\n            builtinConverters.some(converter => converter.matchJSONValue(obj));\\n        }\\n      }\\n      return match;\\n    },\\n    toJSONValue(obj) {\\n      const newObj = {};\\n      Object.keys(obj).forEach(key => {\\n        newObj[key] = EJSON.toJSONValue(obj[key]);\\n      });\\n      return {$escape: newObj};\\n    },\\n    fromJSONValue(obj) {\\n      const newObj = {};\\n      Object.keys(obj.$escape).forEach(key => {\\n        newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\\n      });\\n      return newObj;\\n    },\\n  },\\n  { // Custom\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$type')\\n        && hasOwn(obj, '$value') && Object.keys(obj).length === 2;\\n    },\\n    matchObject(obj) {\\n      return EJSON._isCustomType(obj);\\n    },\\n    toJSONValue(obj) {\\n      const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\\n      return {$type: obj.typeName(), $value: jsonValue};\\n    },\\n    fromJSONValue(obj) {\\n      const typeName = obj.$type;\\n      if (!hasOwn(customTypes, typeName)) {\\n        throw new Error(`Custom EJSON type ${typeName} is not defined`);\\n      }\\n      const converter = customTypes[typeName];\\n      return Meteor._noYieldsAllowed(() => converter(obj.$value));\\n    },\\n  },\\n];\\n\\nEJSON._isCustomType = (obj) => (\\n  obj &&\\n  typeof obj.toJSONValue === 'function' &&\\n  typeof obj.typeName === 'function' &&\\n  hasOwn(customTypes, obj.typeName())\\n);\\n\\nEJSON._getTypes = () => customTypes;\\n\\nEJSON._getConverters = () => builtinConverters;\\n\\n// Either return the JSON-compatible version of the argument, or undefined (if\\n// the item isn't itself replaceable, but maybe some fields in it are)\\nconst toJSONValueHelper = item => {\\n  for (let i = 0; i < builtinConverters.length; i++) {\\n    const converter = builtinConverters[i];\\n    if (converter.matchObject(item)) {\\n      return converter.toJSONValue(item);\\n    }\\n  }\\n  return undefined;\\n};\\n\\n// for both arrays and objects, in-place modification.\\nconst adjustTypesToJSONValue = obj => {\\n  // Is it an atom that we need to adjust?\\n  if (obj === null) {\\n    return null;\\n  }\\n\\n  const maybeChanged = toJSONValueHelper(obj);\\n  if (maybeChanged !== undefined) {\\n    return maybeChanged;\\n  }\\n\\n  // Other atoms are unchanged.\\n  if (typeof obj !== 'object') {\\n    return obj;\\n  }\\n\\n  // Iterate over array or object structure.\\n  Object.keys(obj).forEach(key => {\\n    const value = obj[key];\\n    if (typeof value !== 'object' && value !== undefined &&\\n        !isInfOrNan(value)) {\\n      return; // continue\\n    }\\n\\n    const changed = toJSONValueHelper(value);\\n    if (changed) {\\n      obj[key] = changed;\\n      return; // on to the next key\\n    }\\n    // if we get here, value is an object but not adjustable\\n    // at this level.  recurse.\\n    adjustTypesToJSONValue(value);\\n  });\\n  return obj;\\n};\\n\\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\\n\\n/**\\n * @summary Serialize an EJSON-compatible value into its plain JSON\\n *          representation.\\n * @locus Anywhere\\n * @param {EJSON} val A value to serialize to plain JSON.\\n */\\nEJSON.toJSONValue = item => {\\n  const changed = toJSONValueHelper(item);\\n  if (changed !== undefined) {\\n    return changed;\\n  }\\n\\n  let newItem = item;\\n  if (typeof item === 'object') {\\n    newItem = EJSON.clone(item);\\n    adjustTypesToJSONValue(newItem);\\n  }\\n  return newItem;\\n};\\n\\n// Either return the argument changed to have the non-json\\n// rep of itself (the Object version) or the argument itself.\\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\\n// EJSON.fromJSONValue\\nconst fromJSONValueHelper = value => {\\n  if (typeof value === 'object' && value !== null) {\\n    const keys = Object.keys(value);\\n    if (keys.length <= 2\\n        && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\\n      for (let i = 0; i < builtinConverters.length; i++) {\\n        const converter = builtinConverters[i];\\n        if (converter.matchJSONValue(value)) {\\n          return converter.fromJSONValue(value);\\n        }\\n      }\\n    }\\n  }\\n  return value;\\n};\\n\\n// for both arrays and objects. Tries its best to just\\n// use the object you hand it, but may return something\\n// different if the object you hand it itself needs changing.\\nconst adjustTypesFromJSONValue = obj => {\\n  if (obj === null) {\\n    return null;\\n  }\\n\\n  const maybeChanged = fromJSONValueHelper(obj);\\n  if (maybeChanged !== obj) {\\n    return maybeChanged;\\n  }\\n\\n  // Other atoms are unchanged.\\n  if (typeof obj !== 'object') {\\n    return obj;\\n  }\\n\\n  Object.keys(obj).forEach(key => {\\n    const value = obj[key];\\n    if (typeof value === 'object') {\\n      const changed = fromJSONValueHelper(value);\\n      if (value !== changed) {\\n        obj[key] = changed;\\n        return;\\n      }\\n      // if we get here, value is an object but not adjustable\\n      // at this level.  recurse.\\n      adjustTypesFromJSONValue(value);\\n    }\\n  });\\n  return obj;\\n};\\n\\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\\n\\n/**\\n * @summary Deserialize an EJSON value from its plain JSON representation.\\n * @locus Anywhere\\n * @param {JSONCompatible} val A value to deserialize into EJSON.\\n */\\nEJSON.fromJSONValue = item => {\\n  let changed = fromJSONValueHelper(item);\\n  if (changed === item && typeof item === 'object') {\\n    changed = EJSON.clone(item);\\n    adjustTypesFromJSONValue(changed);\\n  }\\n  return changed;\\n};\\n\\n/**\\n * @summary Serialize a value to a string. For EJSON values, the serialization\\n *          fully represents the value. For non-EJSON values, serializes the\\n *          same way as `JSON.stringify`.\\n * @locus Anywhere\\n * @param {EJSON} val A value to stringify.\\n * @param {Object} [options]\\n * @param {Boolean | Integer | String} options.indent Indents objects and\\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\\n * integer, indents by that number of spaces; and when a string, uses the\\n * string as the indentation pattern.\\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\\n *                                    object in sorted order.\\n */\\nEJSON.stringify = (item, options) => {\\n  let serialized;\\n  const json = EJSON.toJSONValue(item);\\n  if (options && (options.canonical || options.indent)) {\\n    import canonicalStringify from './stringify';\\n    serialized = canonicalStringify(json, options);\\n  } else {\\n    serialized = JSON.stringify(json);\\n  }\\n  return serialized;\\n};\\n\\n/**\\n * @summary Parse a string into an EJSON value. Throws an error if the string\\n *          is not valid EJSON.\\n * @locus Anywhere\\n * @param {String} str A string to parse into an EJSON value.\\n */\\nEJSON.parse = item => {\\n  if (typeof item !== 'string') {\\n    throw new Error('EJSON.parse argument should be a string');\\n  }\\n  return EJSON.fromJSONValue(JSON.parse(item));\\n};\\n\\n/**\\n * @summary Returns true if `x` is a buffer of binary data, as returned from\\n *          [`EJSON.newBinary`](#ejson_new_binary).\\n * @param {Object} x The variable to check.\\n * @locus Anywhere\\n */\\nEJSON.isBinary = obj => {\\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\\n    (obj && obj.$Uint8ArrayPolyfill));\\n};\\n\\n/**\\n * @summary Return true if `a` and `b` are equal to each other.  Return false\\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\\n *          performs a deep comparison.\\n * @locus Anywhere\\n * @param {EJSON} a\\n * @param {EJSON} b\\n * @param {Object} [options]\\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\\n * default is `false`.\\n */\\nEJSON.equals = (a, b, options) => {\\n  let i;\\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\\n  if (a === b) {\\n    return true;\\n  }\\n\\n  // This differs from the IEEE spec for NaN equality, b/c we don't want\\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\\n  if (Number.isNaN(a) && Number.isNaN(b)) {\\n    return true;\\n  }\\n\\n  // if either one is falsy, they'd have to be === to be equal\\n  if (!a || !b) {\\n    return false;\\n  }\\n\\n  if (!(typeof a === 'object' && typeof b === 'object')) {\\n    return false;\\n  }\\n\\n  if (a instanceof Date && b instanceof Date) {\\n    return a.valueOf() === b.valueOf();\\n  }\\n\\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\\n    if (a.length !== b.length) {\\n      return false;\\n    }\\n    for (i = 0; i < a.length; i++) {\\n      if (a[i] !== b[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  if (typeof (a.equals) === 'function') {\\n    return a.equals(b, options);\\n  }\\n\\n  if (typeof (b.equals) === 'function') {\\n    return b.equals(a, options);\\n  }\\n\\n  if (a instanceof Array) {\\n    if (!(b instanceof Array)) {\\n      return false;\\n    }\\n    if (a.length !== b.length) {\\n      return false;\\n    }\\n    for (i = 0; i < a.length; i++) {\\n      if (!EJSON.equals(a[i], b[i], options)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  // fallback for custom types that don't implement their own equals\\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\\n    case 1: return false;\\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\\n    default: // Do nothing\\n  }\\n\\n  // fall back to structural equality of objects\\n  let ret;\\n  const aKeys = Object.keys(a);\\n  const bKeys = Object.keys(b);\\n  if (keyOrderSensitive) {\\n    i = 0;\\n    ret = aKeys.every(key => {\\n      if (i >= bKeys.length) {\\n        return false;\\n      }\\n      if (key !== bKeys[i]) {\\n        return false;\\n      }\\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\\n        return false;\\n      }\\n      i++;\\n      return true;\\n    });\\n  } else {\\n    i = 0;\\n    ret = aKeys.every(key => {\\n      if (!hasOwn(b, key)) {\\n        return false;\\n      }\\n      if (!EJSON.equals(a[key], b[key], options)) {\\n        return false;\\n      }\\n      i++;\\n      return true;\\n    });\\n  }\\n  return ret && i === bKeys.length;\\n};\\n\\n/**\\n * @summary Return a deep copy of `val`.\\n * @locus Anywhere\\n * @param {EJSON} val A value to copy.\\n */\\nEJSON.clone = v => {\\n  let ret;\\n  if (typeof v !== 'object') {\\n    return v;\\n  }\\n\\n  if (v === null) {\\n    return null; // null has typeof \\\"object\\\"\\n  }\\n\\n  if (v instanceof Date) {\\n    return new Date(v.getTime());\\n  }\\n\\n  // RegExps are not really EJSON elements (eg we don't define a serialization\\n  // for them), but they're immutable anyway, so we can support them in clone.\\n  if (v instanceof RegExp) {\\n    return v;\\n  }\\n\\n  if (EJSON.isBinary(v)) {\\n    ret = EJSON.newBinary(v.length);\\n    for (let i = 0; i < v.length; i++) {\\n      ret[i] = v[i];\\n    }\\n    return ret;\\n  }\\n\\n  if (Array.isArray(v)) {\\n    return v.map(value => EJSON.clone(value));\\n  }\\n\\n  if (isArguments(v)) {\\n    return Array.from(v).map(value => EJSON.clone(value));\\n  }\\n\\n  // handle general user-defined typed Objects if they have a clone method\\n  if (typeof v.clone === 'function') {\\n    return v.clone();\\n  }\\n\\n  // handle other custom types\\n  if (EJSON._isCustomType(v)) {\\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\\n  }\\n\\n  // handle other objects\\n  ret = {};\\n  Object.keys(v).forEach((key) => {\\n    ret[key] = EJSON.clone(v[key]);\\n  });\\n  return ret;\\n};\\n\\n/**\\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\\n * @locus Anywhere\\n * @param {Number} size The number of bytes of binary data to allocate.\\n */\\n// EJSON.newBinary is the public documented API for this functionality,\\n// but the implementation is in the 'base64' package to avoid\\n// introducing a circular dependency. (If the implementation were here,\\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\\n// also have to use 'base64'.)\\nEJSON.newBinary = Base64.newBinary;\\n\\nexport { EJSON };\\n\",\"// Based on json2.js from https://github.com/douglascrockford/JSON-js\\n//\\n//    json2.js\\n//    2012-10-08\\n//\\n//    Public Domain.\\n//\\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\\n\\nfunction quote(string) {\\n  return JSON.stringify(string);\\n}\\n\\nconst str = (key, holder, singleIndent, outerIndent, canonical) => {\\n  const value = holder[key];\\n\\n  // What happens next depends on the value's type.\\n  switch (typeof value) {\\n  case 'string':\\n    return quote(value);\\n  case 'number':\\n    // JSON numbers must be finite. Encode non-finite numbers as null.\\n    return isFinite(value) ? String(value) : 'null';\\n  case 'boolean':\\n    return String(value);\\n  // If the type is 'object', we might be dealing with an object or an array or\\n  // null.\\n  case 'object':\\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\\n    // so watch out for that case.\\n    if (!value) {\\n      return 'null';\\n    }\\n    // Make an array to hold the partial results of stringifying this object\\n    // value.\\n    const innerIndent = outerIndent + singleIndent;\\n    const partial = [];\\n\\n    // Is the value an array?\\n    if (Array.isArray(value) || ({}).hasOwnProperty.call(value, 'callee')) {\\n      // The value is an array. Stringify every element. Use null as a\\n      // placeholder for non-JSON values.\\n      const length = value.length;\\n      for (let i = 0; i < length; i += 1) {\\n        partial[i] =\\n          str(i, value, singleIndent, innerIndent, canonical) || 'null';\\n      }\\n\\n      // Join all of the elements together, separated with commas, and wrap\\n      // them in brackets.\\n      let v;\\n      if (partial.length === 0) {\\n        v = '[]';\\n      } else if (innerIndent) {\\n        v = '[\\\\n' +\\n          innerIndent +\\n          partial.join(',\\\\n' +\\n          innerIndent) +\\n          '\\\\n' +\\n          outerIndent +\\n          ']';\\n      } else {\\n        v = '[' + partial.join(',') + ']';\\n      }\\n      return v;\\n    }\\n\\n    // Iterate through all of the keys in the object.\\n    let keys = Object.keys(value);\\n    if (canonical) {\\n      keys = keys.sort();\\n    }\\n    keys.forEach(k => {\\n      v = str(k, value, singleIndent, innerIndent, canonical);\\n      if (v) {\\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\\n      }\\n    });\\n\\n    // Join all of the member texts together, separated with commas,\\n    // and wrap them in braces.\\n    if (partial.length === 0) {\\n      v = '{}';\\n    } else if (innerIndent) {\\n      v = '{\\\\n' +\\n        innerIndent +\\n        partial.join(',\\\\n' +\\n        innerIndent) +\\n        '\\\\n' +\\n        outerIndent +\\n        '}';\\n    } else {\\n      v = '{' + partial.join(',') + '}';\\n    }\\n    return v;\\n\\n  default: // Do nothing\\n  }\\n};\\n\\n// If the JSON object does not yet have a stringify method, give it one.\\nconst canonicalStringify = (value, options) => {\\n  // Make a fake root object containing our value under the key of ''.\\n  // Return the result of stringifying the value.\\n  const allOptions = Object.assign({\\n    indent: '',\\n    canonical: false,\\n  }, options);\\n  if (allOptions.indent === true) {\\n    allOptions.indent = '  ';\\n  } else if (typeof allOptions.indent === 'number') {\\n    let newIndent = '';\\n    for (let i = 0; i < allOptions.indent; i++) {\\n      newIndent += ' ';\\n    }\\n    allOptions.indent = newIndent;\\n  }\\n  return str('', {'': value}, allOptions.indent, '', allOptions.canonical);\\n};\\n\\nexport default canonicalStringify;\\n\"]}","minifier":"terser"}