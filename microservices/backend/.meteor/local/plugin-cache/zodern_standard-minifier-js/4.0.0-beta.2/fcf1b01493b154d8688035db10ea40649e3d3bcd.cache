{"code":"!function(){var e=Package.meteor.Meteor,n=Package.meteor.global,r=Package.meteor.meteorEnv,t=Package.modules.meteorInstall,l=Package[\"babel-runtime\"].meteorBabelHelpers,a=Package.promise.Promise,s,o,c=t({node_modules:{meteor:{base64:{\"base64.js\":function(e,n,r){r.export({Base64:()=>i});const t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",l=Object.create(null),a=e=>t.charAt(e),s=e=>\"=\"===e?-1:l[e];for(let h=0;h<t.length;h++)l[a(h)]=h;const o=e=>{if(\"string\"==typeof e){const n=e;e=c(n.length);for(let r=0;r<n.length;r++){const t=n.charCodeAt(r);if(t>255)throw new Error(\"Not ascii. Base64.encode can only take ascii strings.\");e[r]=t}}const n=[];let r=null,t=null,l=null,s=null;for(let o=0;o<e.length;o++)switch(o%3){case 0:r=e[o]>>2&63,t=(3&e[o])<<4;break;case 1:t|=e[o]>>4&15,l=(15&e[o])<<2;break;case 2:l|=e[o]>>6&3,s=63&e[o],n.push(a(r)),n.push(a(t)),n.push(a(l)),n.push(a(s)),r=null,t=null,l=null,s=null}return null!=r&&(n.push(a(r)),n.push(a(t)),null==l?n.push(\"=\"):n.push(a(l)),null==s&&n.push(\"=\")),n.join(\"\")},c=e=>{if(\"undefined\"==typeof Uint8Array||\"undefined\"==typeof ArrayBuffer){const n=[];for(let r=0;r<e;r++)n.push(0);return n.$Uint8ArrayPolyfill=!0,n}return new Uint8Array(new ArrayBuffer(e))},u=e=>{let n=Math.floor(3*e.length/4);\"=\"==e.charAt(e.length-1)&&(n--,\"=\"==e.charAt(e.length-2)&&n--);const r=c(n);let t=null,l=null,a=null,o=0;for(let c=0;c<e.length;c++){const n=e.charAt(c),u=s(n);switch(c%4){case 0:if(u<0)throw new Error(\"invalid base64 string\");t=u<<2;break;case 1:if(u<0)throw new Error(\"invalid base64 string\");t|=u>>4,r[o++]=t,l=(15&u)<<4;break;case 2:u>=0&&(l|=u>>2,r[o++]=l,a=(3&u)<<6);break;case 3:u>=0&&(r[o++]=a|u)}}return r},i={encode:o,decode:u,newBinary:c}}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/base64/base64.js\");Package._define(\"base64\",c,{Base64:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/base64/base64.js\"],\"names\":[\"module\",\"export\",\"Base64\",\"BASE_64_CHARS\",\"BASE_64_VALS\",\"Object\",\"create\",\"getChar\",\"val\",\"charAt\",\"getVal\",\"ch\",\"i\",\"length\",\"encode\",\"array\",\"str\",\"newBinary\",\"charCodeAt\",\"Error\",\"answer\",\"a\",\"b\",\"c\",\"d\",\"push\",\"join\",\"len\",\"Uint8Array\",\"ArrayBuffer\",\"ret\",\"$Uint8ArrayPolyfill\",\"decode\",\"Math\",\"floor\",\"arr\",\"one\",\"two\",\"three\",\"j\",\"v\"],\"mappings\":\"sQAAAA,EAAOC,QAAQC,OAAO,IAAIA,IAE1B,MAAMC,EAAgB,mEAEhBC,EAAeC,OAAOC,OAAO,MAE7BC,EAAUC,GAAOL,EAAcM,OAAOD,GACtCE,EAASC,GAAa,MAAPA,GAAc,EAAIP,EAAaO,GAEpD,IAAK,IAAIC,EAAI,EAAGA,EAAIT,EAAcU,OAAQD,IACxCR,EAAaG,EAAQK,IAAMA,EAG7B,MAAME,EAASC,IACb,GAAqB,iBAAVA,EAAoB,CAC7B,MAAMC,EAAMD,EACZA,EAAQE,EAAUD,EAAIH,QACtB,IAAK,IAAID,EAAI,EAAGA,EAAII,EAAIH,OAAQD,IAAK,CACnC,MAAMD,EAAKK,EAAIE,WAAWN,GAC1B,GAAID,EAAK,IACP,MAAM,IAAIQ,MACR,yDAGJJ,EAAMH,GAAKD,GAIf,MAAMS,KACN,IAAIC,EAAI,KACJC,EAAI,KACJC,EAAI,KACJC,EAAI,KAER,IAAK,IAAIZ,EAAI,EAAGA,EAAIG,EAAMF,OAAQD,IAChC,OAAQA,EAAI,GACV,KAAK,EACHS,EAAKN,EAAMH,IAAM,EAAK,GACtBU,GAAgB,EAAXP,EAAMH,KAAc,EACzB,MACF,KAAK,EACHU,GAASP,EAAMH,IAAM,EAAK,GAC1BW,GAAgB,GAAXR,EAAMH,KAAa,EACxB,MACF,KAAK,EACHW,GAASR,EAAMH,IAAM,EAAK,EAC1BY,EAAe,GAAXT,EAAMH,GACVQ,EAAOK,KAAKlB,EAAQc,IACpBD,EAAOK,KAAKlB,EAAQe,IACpBF,EAAOK,KAAKlB,EAAQgB,IACpBH,EAAOK,KAAKlB,EAAQiB,IACpBH,EAAI,KACJC,EAAI,KACJC,EAAI,KACJC,EAAI,KAmBV,OAdS,MAALH,IACFD,EAAOK,KAAKlB,EAAQc,IACpBD,EAAOK,KAAKlB,EAAQe,IACX,MAALC,EACFH,EAAOK,KAAK,KAEZL,EAAOK,KAAKlB,EAAQgB,IAGb,MAALC,GACFJ,EAAOK,KAAK,MAITL,EAAOM,KAAK,KAUfT,EAAYU,IAChB,GAA0B,oBAAfC,YAAqD,oBAAhBC,YAA6B,CAC3E,MAAMC,KACN,IAAK,IAAIlB,EAAI,EAAGA,EAAIe,EAAKf,IACvBkB,EAAIL,KAAK,GAIX,OADAK,EAAIC,qBAAsB,EACnBD,EAET,OAAO,IAAIF,WAAW,IAAIC,YAAYF,KAGlCK,EAAShB,IACb,IAAIW,EAAMM,KAAKC,MAAoB,EAAblB,EAAIH,OAAc,GACN,KAA9BG,EAAIP,OAAOO,EAAIH,OAAS,KAC1Bc,IACkC,KAA9BX,EAAIP,OAAOO,EAAIH,OAAS,IAC1Bc,KAIJ,MAAMQ,EAAMlB,EAAUU,GAEtB,IAAIS,EAAM,KACNC,EAAM,KACNC,EAAQ,KAERC,EAAI,EAER,IAAK,IAAI3B,EAAI,EAAGA,EAAII,EAAIH,OAAQD,IAAK,CACnC,MAAMW,EAAIP,EAAIP,OAAOG,GACf4B,EAAI9B,EAAOa,GACjB,OAAQX,EAAI,GACV,KAAK,EACH,GAAI4B,EAAI,EACN,MAAM,IAAIrB,MAAM,yBAGlBiB,EAAMI,GAAK,EACX,MACF,KAAK,EACH,GAAIA,EAAI,EACN,MAAM,IAAIrB,MAAM,yBAGlBiB,GAAaI,GAAK,EAClBL,EAAII,KAAOH,EACXC,GAAW,GAAJG,IAAa,EACpB,MACF,KAAK,EACCA,GAAK,IACPH,GAAaG,GAAK,EAClBL,EAAII,KAAOF,EACXC,GAAa,EAAJE,IAAa,GAGxB,MACF,KAAK,EACCA,GAAK,IACPL,EAAII,KAAOD,EAAQE,IAO3B,OAAOL,GAGIjC,GAAWY,OAAAA,EAAQkB,OAAAA,EAAQf,UAAAA\",\"sourcesContent\":[\"// Base 64 encoding\\n\\nconst BASE_64_CHARS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\nconst BASE_64_VALS = Object.create(null);\\n\\nconst getChar = val => BASE_64_CHARS.charAt(val);\\nconst getVal = ch => ch === '=' ? -1 : BASE_64_VALS[ch];\\n\\nfor (let i = 0; i < BASE_64_CHARS.length; i++) {\\n  BASE_64_VALS[getChar(i)] = i;\\n};\\n\\nconst encode = array => {\\n  if (typeof array === \\\"string\\\") {\\n    const str = array;\\n    array = newBinary(str.length);\\n    for (let i = 0; i < str.length; i++) {\\n      const ch = str.charCodeAt(i);\\n      if (ch > 0xFF) {\\n        throw new Error(\\n          \\\"Not ascii. Base64.encode can only take ascii strings.\\\");\\n      }\\n\\n      array[i] = ch;\\n    }\\n  }\\n\\n  const answer = [];\\n  let a = null;\\n  let b = null;\\n  let c = null;\\n  let d = null;\\n\\n  for (let i = 0; i < array.length; i++) {\\n    switch (i % 3) {\\n      case 0:\\n        a = (array[i] >> 2) & 0x3F;\\n        b = (array[i] & 0x03) << 4;\\n        break;\\n      case 1:\\n        b = b | (array[i] >> 4) & 0xF;\\n        c = (array[i] & 0xF) << 2;\\n        break;\\n      case 2:\\n        c = c | (array[i] >> 6) & 0x03;\\n        d = array[i] & 0x3F;\\n        answer.push(getChar(a));\\n        answer.push(getChar(b));\\n        answer.push(getChar(c));\\n        answer.push(getChar(d));\\n        a = null;\\n        b = null;\\n        c = null;\\n        d = null;\\n        break;\\n    }\\n  }\\n\\n  if (a != null) {\\n    answer.push(getChar(a));\\n    answer.push(getChar(b));\\n    if (c == null) {\\n      answer.push('=');\\n    } else {\\n      answer.push(getChar(c));\\n    }\\n\\n    if (d == null) {\\n      answer.push('=');\\n    }\\n  }\\n\\n  return answer.join(\\\"\\\");\\n};\\n\\n\\n\\n// XXX This is a weird place for this to live, but it's used both by\\n// this package and 'ejson', and we can't put it in 'ejson' without\\n// introducing a circular dependency. It should probably be in its own\\n// package or as a helper in a package that both 'base64' and 'ejson'\\n// use.\\nconst newBinary = len => {\\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\\n    const ret = [];\\n    for (let i = 0; i < len; i++) {\\n      ret.push(0);\\n    }\\n\\n    ret.$Uint8ArrayPolyfill = true;\\n    return ret;\\n  }\\n  return new Uint8Array(new ArrayBuffer(len));\\n};\\n\\nconst decode = str => {\\n  let len = Math.floor((str.length * 3) / 4);\\n  if (str.charAt(str.length - 1) == '=') {\\n    len--;\\n    if (str.charAt(str.length - 2) == '=') {\\n      len--;\\n    }\\n  }\\n\\n  const arr = newBinary(len);\\n\\n  let one = null;\\n  let two = null;\\n  let three = null;\\n\\n  let j = 0;\\n\\n  for (let i = 0; i < str.length; i++) {\\n    const c = str.charAt(i);\\n    const v = getVal(c);\\n    switch (i % 4) {\\n      case 0:\\n        if (v < 0) {\\n          throw new Error('invalid base64 string');\\n        }\\n\\n        one = v << 2;\\n        break;\\n      case 1:\\n        if (v < 0) {\\n          throw new Error('invalid base64 string');\\n        }\\n\\n        one = one | (v >> 4);\\n        arr[j++] = one;\\n        two = (v & 0x0F) << 4;\\n        break;\\n      case 2:\\n        if (v >= 0) {\\n          two = two | (v >> 2);\\n          arr[j++] = two;\\n          three = (v & 0x03) << 6;\\n        }\\n\\n        break;\\n      case 3:\\n        if (v >= 0) {\\n          arr[j++] = three | v;\\n        }\\n\\n        break;\\n    }\\n  }\\n\\n  return arr;\\n};\\n\\nexport const Base64 = { encode, decode, newBinary };\\n\"]}","minifier":"terser"}