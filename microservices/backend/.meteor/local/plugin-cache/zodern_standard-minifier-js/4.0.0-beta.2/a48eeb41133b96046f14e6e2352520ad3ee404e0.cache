{"code":"!function(){var e=Package.meteor.Meteor,n=Package.meteor.global,t=Package.meteor.meteorEnv,r=Package.base64.Base64,u=Package.modules.meteorInstall,a=Package[\"babel-runtime\"].meteorBabelHelpers,i=Package.promise.Promise,o=Package[\"ecmascript-runtime-client\"].Symbol,c=Package[\"ecmascript-runtime-client\"].Map,f=Package[\"ecmascript-runtime-client\"].Set,l,s,y,m=u({node_modules:{meteor:{ejson:{\"ejson.js\":function(n,t,u){var a,i=n(\"@babel/runtime/helpers/interopRequireDefault\")(n(\"@babel/runtime/helpers/typeof\"));u.export({EJSON:function(){return o}});var o={},c={},f=function(e,n){return{}.hasOwnProperty.call(e,n)},l=function(e){return null!=e&&f(e,\"callee\")},s=function(e){return Number.isNaN(e)||e===1/0||e===-1/0};o.addType=function(e,n){if(f(c,e))throw new Error(\"Type \"+e+\" already present\");c[e]=n};var y=[{matchJSONValue:function(e){return f(e,\"$date\")&&1===Object.keys(e).length},matchObject:function(e){return e instanceof Date},toJSONValue:function(e){return{$date:e.getTime()}},fromJSONValue:function(e){return new Date(e.$date)}},{matchJSONValue:function(e){return f(e,\"$regexp\")&&f(e,\"$flags\")&&2===Object.keys(e).length},matchObject:function(e){return e instanceof RegExp},toJSONValue:function(e){return{$regexp:e.source,$flags:e.flags}},fromJSONValue:function(e){return new RegExp(e.$regexp,e.$flags.slice(0,50).replace(/[^gimuy]/g,\"\").replace(/(.)(?=.*\\1)/g,\"\"))}},{matchJSONValue:function(e){return f(e,\"$InfNaN\")&&1===Object.keys(e).length},matchObject:s,toJSONValue:function(e){var n;return{$InfNaN:n=Number.isNaN(e)?0:e===1/0?1:-1}},fromJSONValue:function(e){return e.$InfNaN/0}},{matchJSONValue:function(e){return f(e,\"$binary\")&&1===Object.keys(e).length},matchObject:function(e){return\"undefined\"!=typeof Uint8Array&&e instanceof Uint8Array||e&&f(e,\"$Uint8ArrayPolyfill\")},toJSONValue:function(e){return{$binary:r.encode(e)}},fromJSONValue:function(e){return r.decode(e.$binary)}},{matchJSONValue:function(e){return f(e,\"$escape\")&&1===Object.keys(e).length},matchObject:function(e){var n=!1;if(e){var t=Object.keys(e).length;1!==t&&2!==t||(n=y.some(function(n){return n.matchJSONValue(e)}))}return n},toJSONValue:function(e){var n={};return Object.keys(e).forEach(function(t){n[t]=o.toJSONValue(e[t])}),{$escape:n}},fromJSONValue:function(e){var n={};return Object.keys(e.$escape).forEach(function(t){n[t]=o.fromJSONValue(e.$escape[t])}),n}},{matchJSONValue:function(e){return f(e,\"$type\")&&f(e,\"$value\")&&2===Object.keys(e).length},matchObject:function(e){return o._isCustomType(e)},toJSONValue:function(n){var t=e._noYieldsAllowed(function(){return n.toJSONValue()});return{$type:n.typeName(),$value:t}},fromJSONValue:function(n){var t=n.$type;if(!f(c,t))throw new Error(\"Custom EJSON type \"+t+\" is not defined\");var r=c[t];return e._noYieldsAllowed(function(){return r(n.$value)})}}];o._isCustomType=function(e){return e&&\"function\"==typeof e.toJSONValue&&\"function\"==typeof e.typeName&&f(c,e.typeName())},o._getTypes=function(){return c},o._getConverters=function(){return y};var m=function(e){for(var n=0;n<y.length;n++){var t=y[n];if(t.matchObject(e))return t.toJSONValue(e)}},O=function(e){if(null===e)return null;var n=m(e);return void 0!==n?n:\"object\"!==(0,i.default)(e)?e:(Object.keys(e).forEach(function(n){var t=e[n];if(\"object\"===(0,i.default)(t)||void 0===t||s(t)){var r=m(t);r?e[n]=r:O(t)}}),e)};o._adjustTypesToJSONValue=O,o.toJSONValue=function(e){var n=m(e);if(void 0!==n)return n;var t=e;return\"object\"===(0,i.default)(e)&&(t=o.clone(e),O(t)),t};var g=function(e){if(\"object\"===(0,i.default)(e)&&null!==e){var n=Object.keys(e);if(n.length<=2&&n.every(function(e){return\"string\"==typeof e&&\"$\"===e.substr(0,1)}))for(var t=0;t<y.length;t++){var r=y[t];if(r.matchJSONValue(e))return r.fromJSONValue(e)}}return e},p=function(e){if(null===e)return null;var n=g(e);return n!==e?n:\"object\"!==(0,i.default)(e)?e:(Object.keys(e).forEach(function(n){var t=e[n];if(\"object\"===(0,i.default)(t)){var r=g(t);if(t!==r)return void(e[n]=r);p(t)}}),e)};o._adjustTypesFromJSONValue=p,o.fromJSONValue=function(e){var n=g(e);return n===e&&\"object\"===(0,i.default)(e)&&(n=o.clone(e),p(n)),n},o.stringify=function(e,n){var t,r=o.toJSONValue(e),a;n&&(n.canonical||n.indent)?(u.link(\"./stringify\",{default:function(e){a=e}},0),t=a(r,n)):t=JSON.stringify(r);return t},o.parse=function(e){if(\"string\"!=typeof e)throw new Error(\"EJSON.parse argument should be a string\");return o.fromJSONValue(JSON.parse(e))},o.isBinary=function(e){return!!(\"undefined\"!=typeof Uint8Array&&e instanceof Uint8Array||e&&e.$Uint8ArrayPolyfill)},o.equals=function(e,n,t){var r,u=!(!t||!t.keyOrderSensitive),a;if(e===n)return!0;if(Number.isNaN(e)&&Number.isNaN(n))return!0;if(!e||!n)return!1;if(\"object\"!==(0,i.default)(e)||\"object\"!==(0,i.default)(n))return!1;if(e instanceof Date&&n instanceof Date)return e.valueOf()===n.valueOf();if(o.isBinary(e)&&o.isBinary(n)){if(e.length!==n.length)return!1;for(r=0;r<e.length;r++)if(e[r]!==n[r])return!1;return!0}if(\"function\"==typeof e.equals)return e.equals(n,t);if(\"function\"==typeof n.equals)return n.equals(e,t);if(e instanceof Array){if(!(n instanceof Array))return!1;if(e.length!==n.length)return!1;for(r=0;r<e.length;r++)if(!o.equals(e[r],n[r],t))return!1;return!0}switch(o._isCustomType(e)+o._isCustomType(n)){case 1:return!1;case 2:return o.equals(o.toJSONValue(e),o.toJSONValue(n))}var c=Object.keys(e),l=Object.keys(n);return u?(r=0,a=c.every(function(u){return!(r>=l.length)&&(u===l[r]&&(!!o.equals(e[u],n[l[r]],t)&&(r++,!0)))})):(r=0,a=c.every(function(u){return!!f(n,u)&&(!!o.equals(e[u],n[u],t)&&(r++,!0))})),a&&r===l.length},o.clone=function(e){var n;if(\"object\"!==(0,i.default)(e))return e;if(null===e)return null;if(e instanceof Date)return new Date(e.getTime());if(e instanceof RegExp)return e;if(o.isBinary(e)){n=o.newBinary(e.length);for(var t=0;t<e.length;t++)n[t]=e[t];return n}return Array.isArray(e)?e.map(function(e){return o.clone(e)}):l(e)?Array.from(e).map(function(e){return o.clone(e)}):\"function\"==typeof e.clone?e.clone():o._isCustomType(e)?o.fromJSONValue(o.clone(o.toJSONValue(e)),!0):(n={},Object.keys(e).forEach(function(t){n[t]=o.clone(e[t])}),n)},o.newBinary=r.newBinary},\"stringify.js\":function(e,n,t){var r,u=e(\"@babel/runtime/helpers/interopRequireDefault\")(e(\"@babel/runtime/helpers/typeof\"));function a(e){return JSON.stringify(e)}var i=function(e,n,t,r,o){var c=n[e];switch((0,u.default)(c)){case\"string\":return a(c);case\"number\":return isFinite(c)?String(c):\"null\";case\"boolean\":return String(c);case\"object\":if(!c)return\"null\";var f=r+t,s=[];if(Array.isArray(c)||{}.hasOwnProperty.call(c,\"callee\")){for(var y=c.length,m=0,O;m<y;m+=1)s[m]=i(m,c,t,f,o)||\"null\";return O=0===s.length?\"[]\":f?\"[\\n\"+f+s.join(\",\\n\"+f)+\"\\n\"+r+\"]\":\"[\"+s.join(\",\")+\"]\"}var g=Object.keys(c);return o&&(g=g.sort()),g.forEach(function(e){(l=i(e,c,t,f,o))&&s.push(a(e)+(f?\": \":\":\")+l)}),l=0===s.length?\"{}\":f?\"{\\n\"+f+s.join(\",\\n\"+f)+\"\\n\"+r+\"}\":\"{\"+s.join(\",\")+\"}\"}},o=function(e,n){var t=Object.assign({indent:\"\",canonical:!1},n);if(!0===t.indent)t.indent=\"  \";else if(\"number\"==typeof t.indent){for(var r=\"\",u=0;u<t.indent;u++)r+=\" \";t.indent=r}return i(\"\",{\"\":e},t.indent,\"\",t.canonical)};t.exportDefault(o)}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/ejson/ejson.js\");Package._define(\"ejson\",m,{EJSON:s})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/ejson/ejson.js\",\"packages/ejson/stringify.js\"],\"names\":[\"module\",\"export\",\"EJSON\",\"customTypes\",\"hasOwn\",\"obj\",\"prop\",\"hasOwnProperty\",\"call\",\"isArguments\",\"isInfOrNan\",\"Number\",\"isNaN\",\"Infinity\",\"addType\",\"name\",\"factory\",\"Error\",\"builtinConverters\",\"matchJSONValue\",\"Object\",\"keys\",\"length\",\"matchObject\",\"Date\",\"toJSONValue\",\"$date\",\"getTime\",\"fromJSONValue\",\"RegExp\",\"regexp\",\"$regexp\",\"source\",\"$flags\",\"flags\",\"slice\",\"replace\",\"sign\",\"$InfNaN\",\"Uint8Array\",\"$binary\",\"Base64\",\"encode\",\"decode\",\"match\",\"keyCount\",\"some\",\"converter\",\"newObj\",\"forEach\",\"key\",\"$escape\",\"_isCustomType\",\"jsonValue\",\"Meteor\",\"_noYieldsAllowed\",\"$type\",\"typeName\",\"$value\",\"_getTypes\",\"_getConverters\",\"toJSONValueHelper\",\"item\",\"i\",\"adjustTypesToJSONValue\",\"maybeChanged\",\"undefined\",\"_typeof2\",\"default\",\"value\",\"changed\",\"_adjustTypesToJSONValue\",\"newItem\",\"clone\",\"fromJSONValueHelper\",\"every\",\"k\",\"substr\",\"adjustTypesFromJSONValue\",\"_adjustTypesFromJSONValue\",\"stringify\",\"options\",\"serialized\",\"json\",\"canonicalStringify\",\"canonical\",\"indent\",\"link\",\"v\",\"JSON\",\"parse\",\"isBinary\",\"$Uint8ArrayPolyfill\",\"equals\",\"a\",\"b\",\"keyOrderSensitive\",\"ret\",\"valueOf\",\"Array\",\"aKeys\",\"bKeys\",\"newBinary\",\"isArray\",\"map\",\"from\",\"quote\",\"string\",\"str\",\"holder\",\"singleIndent\",\"outerIndent\",\"isFinite\",\"String\",\"innerIndent\",\"partial\",\"join\",\"sort\",\"push\",\"allOptions\",\"assign\",\"newIndent\",\"\",\"exportDefault\"],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * @namespace\\n * @summary Namespace for EJSON functions\\n */\\nconst EJSON = {};\\n\\n// Custom type interface definition\\n/**\\n * @class CustomType\\n * @instanceName customType\\n * @memberOf EJSON\\n * @summary The interface that a class must satisfy to be able to become an\\n * EJSON custom type via EJSON.addType.\\n */\\n\\n/**\\n * @function typeName\\n * @memberOf EJSON.CustomType\\n * @summary Return the tag used to identify this type.  This must match the\\n *          tag used to register this type with\\n *          [`EJSON.addType`](#ejson_add_type).\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function toJSONValue\\n * @memberOf EJSON.CustomType\\n * @summary Serialize this instance into a JSON-compatible value.\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function clone\\n * @memberOf EJSON.CustomType\\n * @summary Return a value `r` such that `this.equals(r)` is true, and\\n *          modifications to `r` do not affect `this` and vice versa.\\n * @locus Anywhere\\n * @instance\\n */\\n\\n/**\\n * @function equals\\n * @memberOf EJSON.CustomType\\n * @summary Return `true` if `other` has a value equal to `this`; `false`\\n *          otherwise.\\n * @locus Anywhere\\n * @param {Object} other Another object to compare this to.\\n * @instance\\n */\\n\\nconst customTypes = {};\\n\\nconst hasOwn = (obj, prop) => ({}).hasOwnProperty.call(obj, prop);\\n\\nconst isArguments = obj => obj != null && hasOwn(obj, 'callee');\\n\\nconst isInfOrNan =\\n  obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\\n\\n// Add a custom type, using a method of your choice to get to and\\n// from a basic JSON-able representation.  The factory argument\\n// is a function of JSON-able --> your object\\n// The type you add must have:\\n// - A toJSONValue() method, so that Meteor can serialize it\\n// - a typeName() method, to show how to look it up in our type table.\\n// It is okay if these methods are monkey-patched on.\\n// EJSON.clone will use toJSONValue and the given factory to produce\\n// a clone, but you may specify a method clone() that will be\\n// used instead.\\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\\n// but you may provide a method equals() instead.\\n/**\\n * @summary Add a custom datatype to EJSON.\\n * @locus Anywhere\\n * @param {String} name A tag for your custom type; must be unique among\\n *                      custom data types defined in your project, and must\\n *                      match the result of your type's `typeName` method.\\n * @param {Function} factory A function that deserializes a JSON-compatible\\n *                           value into an instance of your type.  This should\\n *                           match the serialization performed by your\\n *                           type's `toJSONValue` method.\\n */\\nEJSON.addType = (name, factory) => {\\n  if (hasOwn(customTypes, name)) {\\n    throw new Error(`Type ${name} already present`);\\n  }\\n  customTypes[name] = factory;\\n};\\n\\nconst builtinConverters = [\\n  { // Date\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$date') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      return obj instanceof Date;\\n    },\\n    toJSONValue(obj) {\\n      return {$date: obj.getTime()};\\n    },\\n    fromJSONValue(obj) {\\n      return new Date(obj.$date);\\n    },\\n  },\\n  { // RegExp\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$regexp')\\n        && hasOwn(obj, '$flags')\\n        && Object.keys(obj).length === 2;\\n    },\\n    matchObject(obj) {\\n      return obj instanceof RegExp;\\n    },\\n    toJSONValue(regexp) {\\n      return {\\n        $regexp: regexp.source,\\n        $flags: regexp.flags\\n      };\\n    },\\n    fromJSONValue(obj) {\\n      // Replaces duplicate / invalid flags.\\n      return new RegExp(\\n        obj.$regexp,\\n        obj.$flags\\n          // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\\n          .slice(0, 50)\\n          .replace(/[^gimuy]/g,'')\\n          .replace(/(.)(?=.*\\\\1)/g, '')\\n      );\\n    },\\n  },\\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\\n    // which we match.)\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$InfNaN') && Object.keys(obj).length === 1;\\n    },\\n    matchObject: isInfOrNan,\\n    toJSONValue(obj) {\\n      let sign;\\n      if (Number.isNaN(obj)) {\\n        sign = 0;\\n      } else if (obj === Infinity) {\\n        sign = 1;\\n      } else {\\n        sign = -1;\\n      }\\n      return {$InfNaN: sign};\\n    },\\n    fromJSONValue(obj) {\\n      return obj.$InfNaN / 0;\\n    },\\n  },\\n  { // Binary\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$binary') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\\n        || (obj && hasOwn(obj, '$Uint8ArrayPolyfill'));\\n    },\\n    toJSONValue(obj) {\\n      return {$binary: Base64.encode(obj)};\\n    },\\n    fromJSONValue(obj) {\\n      return Base64.decode(obj.$binary);\\n    },\\n  },\\n  { // Escaping one level\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$escape') && Object.keys(obj).length === 1;\\n    },\\n    matchObject(obj) {\\n      let match = false;\\n      if (obj) {\\n        const keyCount = Object.keys(obj).length;\\n        if (keyCount === 1 || keyCount === 2) {\\n          match =\\n            builtinConverters.some(converter => converter.matchJSONValue(obj));\\n        }\\n      }\\n      return match;\\n    },\\n    toJSONValue(obj) {\\n      const newObj = {};\\n      Object.keys(obj).forEach(key => {\\n        newObj[key] = EJSON.toJSONValue(obj[key]);\\n      });\\n      return {$escape: newObj};\\n    },\\n    fromJSONValue(obj) {\\n      const newObj = {};\\n      Object.keys(obj.$escape).forEach(key => {\\n        newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\\n      });\\n      return newObj;\\n    },\\n  },\\n  { // Custom\\n    matchJSONValue(obj) {\\n      return hasOwn(obj, '$type')\\n        && hasOwn(obj, '$value') && Object.keys(obj).length === 2;\\n    },\\n    matchObject(obj) {\\n      return EJSON._isCustomType(obj);\\n    },\\n    toJSONValue(obj) {\\n      const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\\n      return {$type: obj.typeName(), $value: jsonValue};\\n    },\\n    fromJSONValue(obj) {\\n      const typeName = obj.$type;\\n      if (!hasOwn(customTypes, typeName)) {\\n        throw new Error(`Custom EJSON type ${typeName} is not defined`);\\n      }\\n      const converter = customTypes[typeName];\\n      return Meteor._noYieldsAllowed(() => converter(obj.$value));\\n    },\\n  },\\n];\\n\\nEJSON._isCustomType = (obj) => (\\n  obj &&\\n  typeof obj.toJSONValue === 'function' &&\\n  typeof obj.typeName === 'function' &&\\n  hasOwn(customTypes, obj.typeName())\\n);\\n\\nEJSON._getTypes = () => customTypes;\\n\\nEJSON._getConverters = () => builtinConverters;\\n\\n// Either return the JSON-compatible version of the argument, or undefined (if\\n// the item isn't itself replaceable, but maybe some fields in it are)\\nconst toJSONValueHelper = item => {\\n  for (let i = 0; i < builtinConverters.length; i++) {\\n    const converter = builtinConverters[i];\\n    if (converter.matchObject(item)) {\\n      return converter.toJSONValue(item);\\n    }\\n  }\\n  return undefined;\\n};\\n\\n// for both arrays and objects, in-place modification.\\nconst adjustTypesToJSONValue = obj => {\\n  // Is it an atom that we need to adjust?\\n  if (obj === null) {\\n    return null;\\n  }\\n\\n  const maybeChanged = toJSONValueHelper(obj);\\n  if (maybeChanged !== undefined) {\\n    return maybeChanged;\\n  }\\n\\n  // Other atoms are unchanged.\\n  if (typeof obj !== 'object') {\\n    return obj;\\n  }\\n\\n  // Iterate over array or object structure.\\n  Object.keys(obj).forEach(key => {\\n    const value = obj[key];\\n    if (typeof value !== 'object' && value !== undefined &&\\n        !isInfOrNan(value)) {\\n      return; // continue\\n    }\\n\\n    const changed = toJSONValueHelper(value);\\n    if (changed) {\\n      obj[key] = changed;\\n      return; // on to the next key\\n    }\\n    // if we get here, value is an object but not adjustable\\n    // at this level.  recurse.\\n    adjustTypesToJSONValue(value);\\n  });\\n  return obj;\\n};\\n\\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\\n\\n/**\\n * @summary Serialize an EJSON-compatible value into its plain JSON\\n *          representation.\\n * @locus Anywhere\\n * @param {EJSON} val A value to serialize to plain JSON.\\n */\\nEJSON.toJSONValue = item => {\\n  const changed = toJSONValueHelper(item);\\n  if (changed !== undefined) {\\n    return changed;\\n  }\\n\\n  let newItem = item;\\n  if (typeof item === 'object') {\\n    newItem = EJSON.clone(item);\\n    adjustTypesToJSONValue(newItem);\\n  }\\n  return newItem;\\n};\\n\\n// Either return the argument changed to have the non-json\\n// rep of itself (the Object version) or the argument itself.\\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\\n// EJSON.fromJSONValue\\nconst fromJSONValueHelper = value => {\\n  if (typeof value === 'object' && value !== null) {\\n    const keys = Object.keys(value);\\n    if (keys.length <= 2\\n        && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\\n      for (let i = 0; i < builtinConverters.length; i++) {\\n        const converter = builtinConverters[i];\\n        if (converter.matchJSONValue(value)) {\\n          return converter.fromJSONValue(value);\\n        }\\n      }\\n    }\\n  }\\n  return value;\\n};\\n\\n// for both arrays and objects. Tries its best to just\\n// use the object you hand it, but may return something\\n// different if the object you hand it itself needs changing.\\nconst adjustTypesFromJSONValue = obj => {\\n  if (obj === null) {\\n    return null;\\n  }\\n\\n  const maybeChanged = fromJSONValueHelper(obj);\\n  if (maybeChanged !== obj) {\\n    return maybeChanged;\\n  }\\n\\n  // Other atoms are unchanged.\\n  if (typeof obj !== 'object') {\\n    return obj;\\n  }\\n\\n  Object.keys(obj).forEach(key => {\\n    const value = obj[key];\\n    if (typeof value === 'object') {\\n      const changed = fromJSONValueHelper(value);\\n      if (value !== changed) {\\n        obj[key] = changed;\\n        return;\\n      }\\n      // if we get here, value is an object but not adjustable\\n      // at this level.  recurse.\\n      adjustTypesFromJSONValue(value);\\n    }\\n  });\\n  return obj;\\n};\\n\\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\\n\\n/**\\n * @summary Deserialize an EJSON value from its plain JSON representation.\\n * @locus Anywhere\\n * @param {JSONCompatible} val A value to deserialize into EJSON.\\n */\\nEJSON.fromJSONValue = item => {\\n  let changed = fromJSONValueHelper(item);\\n  if (changed === item && typeof item === 'object') {\\n    changed = EJSON.clone(item);\\n    adjustTypesFromJSONValue(changed);\\n  }\\n  return changed;\\n};\\n\\n/**\\n * @summary Serialize a value to a string. For EJSON values, the serialization\\n *          fully represents the value. For non-EJSON values, serializes the\\n *          same way as `JSON.stringify`.\\n * @locus Anywhere\\n * @param {EJSON} val A value to stringify.\\n * @param {Object} [options]\\n * @param {Boolean | Integer | String} options.indent Indents objects and\\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\\n * integer, indents by that number of spaces; and when a string, uses the\\n * string as the indentation pattern.\\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\\n *                                    object in sorted order.\\n */\\nEJSON.stringify = (item, options) => {\\n  let serialized;\\n  const json = EJSON.toJSONValue(item);\\n  if (options && (options.canonical || options.indent)) {\\n    import canonicalStringify from './stringify';\\n    serialized = canonicalStringify(json, options);\\n  } else {\\n    serialized = JSON.stringify(json);\\n  }\\n  return serialized;\\n};\\n\\n/**\\n * @summary Parse a string into an EJSON value. Throws an error if the string\\n *          is not valid EJSON.\\n * @locus Anywhere\\n * @param {String} str A string to parse into an EJSON value.\\n */\\nEJSON.parse = item => {\\n  if (typeof item !== 'string') {\\n    throw new Error('EJSON.parse argument should be a string');\\n  }\\n  return EJSON.fromJSONValue(JSON.parse(item));\\n};\\n\\n/**\\n * @summary Returns true if `x` is a buffer of binary data, as returned from\\n *          [`EJSON.newBinary`](#ejson_new_binary).\\n * @param {Object} x The variable to check.\\n * @locus Anywhere\\n */\\nEJSON.isBinary = obj => {\\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\\n    (obj && obj.$Uint8ArrayPolyfill));\\n};\\n\\n/**\\n * @summary Return true if `a` and `b` are equal to each other.  Return false\\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\\n *          performs a deep comparison.\\n * @locus Anywhere\\n * @param {EJSON} a\\n * @param {EJSON} b\\n * @param {Object} [options]\\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\\n * default is `false`.\\n */\\nEJSON.equals = (a, b, options) => {\\n  let i;\\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\\n  if (a === b) {\\n    return true;\\n  }\\n\\n  // This differs from the IEEE spec for NaN equality, b/c we don't want\\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\\n  if (Number.isNaN(a) && Number.isNaN(b)) {\\n    return true;\\n  }\\n\\n  // if either one is falsy, they'd have to be === to be equal\\n  if (!a || !b) {\\n    return false;\\n  }\\n\\n  if (!(typeof a === 'object' && typeof b === 'object')) {\\n    return false;\\n  }\\n\\n  if (a instanceof Date && b instanceof Date) {\\n    return a.valueOf() === b.valueOf();\\n  }\\n\\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\\n    if (a.length !== b.length) {\\n      return false;\\n    }\\n    for (i = 0; i < a.length; i++) {\\n      if (a[i] !== b[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  if (typeof (a.equals) === 'function') {\\n    return a.equals(b, options);\\n  }\\n\\n  if (typeof (b.equals) === 'function') {\\n    return b.equals(a, options);\\n  }\\n\\n  if (a instanceof Array) {\\n    if (!(b instanceof Array)) {\\n      return false;\\n    }\\n    if (a.length !== b.length) {\\n      return false;\\n    }\\n    for (i = 0; i < a.length; i++) {\\n      if (!EJSON.equals(a[i], b[i], options)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  // fallback for custom types that don't implement their own equals\\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\\n    case 1: return false;\\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\\n    default: // Do nothing\\n  }\\n\\n  // fall back to structural equality of objects\\n  let ret;\\n  const aKeys = Object.keys(a);\\n  const bKeys = Object.keys(b);\\n  if (keyOrderSensitive) {\\n    i = 0;\\n    ret = aKeys.every(key => {\\n      if (i >= bKeys.length) {\\n        return false;\\n      }\\n      if (key !== bKeys[i]) {\\n        return false;\\n      }\\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\\n        return false;\\n      }\\n      i++;\\n      return true;\\n    });\\n  } else {\\n    i = 0;\\n    ret = aKeys.every(key => {\\n      if (!hasOwn(b, key)) {\\n        return false;\\n      }\\n      if (!EJSON.equals(a[key], b[key], options)) {\\n        return false;\\n      }\\n      i++;\\n      return true;\\n    });\\n  }\\n  return ret && i === bKeys.length;\\n};\\n\\n/**\\n * @summary Return a deep copy of `val`.\\n * @locus Anywhere\\n * @param {EJSON} val A value to copy.\\n */\\nEJSON.clone = v => {\\n  let ret;\\n  if (typeof v !== 'object') {\\n    return v;\\n  }\\n\\n  if (v === null) {\\n    return null; // null has typeof \\\"object\\\"\\n  }\\n\\n  if (v instanceof Date) {\\n    return new Date(v.getTime());\\n  }\\n\\n  // RegExps are not really EJSON elements (eg we don't define a serialization\\n  // for them), but they're immutable anyway, so we can support them in clone.\\n  if (v instanceof RegExp) {\\n    return v;\\n  }\\n\\n  if (EJSON.isBinary(v)) {\\n    ret = EJSON.newBinary(v.length);\\n    for (let i = 0; i < v.length; i++) {\\n      ret[i] = v[i];\\n    }\\n    return ret;\\n  }\\n\\n  if (Array.isArray(v)) {\\n    return v.map(value => EJSON.clone(value));\\n  }\\n\\n  if (isArguments(v)) {\\n    return Array.from(v).map(value => EJSON.clone(value));\\n  }\\n\\n  // handle general user-defined typed Objects if they have a clone method\\n  if (typeof v.clone === 'function') {\\n    return v.clone();\\n  }\\n\\n  // handle other custom types\\n  if (EJSON._isCustomType(v)) {\\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\\n  }\\n\\n  // handle other objects\\n  ret = {};\\n  Object.keys(v).forEach((key) => {\\n    ret[key] = EJSON.clone(v[key]);\\n  });\\n  return ret;\\n};\\n\\n/**\\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\\n * @locus Anywhere\\n * @param {Number} size The number of bytes of binary data to allocate.\\n */\\n// EJSON.newBinary is the public documented API for this functionality,\\n// but the implementation is in the 'base64' package to avoid\\n// introducing a circular dependency. (If the implementation were here,\\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\\n// also have to use 'base64'.)\\nEJSON.newBinary = Base64.newBinary;\\n\\nexport { EJSON };\\n\",\"// Based on json2.js from https://github.com/douglascrockford/JSON-js\\n//\\n//    json2.js\\n//    2012-10-08\\n//\\n//    Public Domain.\\n//\\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\\n\\nfunction quote(string) {\\n  return JSON.stringify(string);\\n}\\n\\nconst str = (key, holder, singleIndent, outerIndent, canonical) => {\\n  const value = holder[key];\\n\\n  // What happens next depends on the value's type.\\n  switch (typeof value) {\\n  case 'string':\\n    return quote(value);\\n  case 'number':\\n    // JSON numbers must be finite. Encode non-finite numbers as null.\\n    return isFinite(value) ? String(value) : 'null';\\n  case 'boolean':\\n    return String(value);\\n  // If the type is 'object', we might be dealing with an object or an array or\\n  // null.\\n  case 'object':\\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\\n    // so watch out for that case.\\n    if (!value) {\\n      return 'null';\\n    }\\n    // Make an array to hold the partial results of stringifying this object\\n    // value.\\n    const innerIndent = outerIndent + singleIndent;\\n    const partial = [];\\n\\n    // Is the value an array?\\n    if (Array.isArray(value) || ({}).hasOwnProperty.call(value, 'callee')) {\\n      // The value is an array. Stringify every element. Use null as a\\n      // placeholder for non-JSON values.\\n      const length = value.length;\\n      for (let i = 0; i < length; i += 1) {\\n        partial[i] =\\n          str(i, value, singleIndent, innerIndent, canonical) || 'null';\\n      }\\n\\n      // Join all of the elements together, separated with commas, and wrap\\n      // them in brackets.\\n      let v;\\n      if (partial.length === 0) {\\n        v = '[]';\\n      } else if (innerIndent) {\\n        v = '[\\\\n' +\\n          innerIndent +\\n          partial.join(',\\\\n' +\\n          innerIndent) +\\n          '\\\\n' +\\n          outerIndent +\\n          ']';\\n      } else {\\n        v = '[' + partial.join(',') + ']';\\n      }\\n      return v;\\n    }\\n\\n    // Iterate through all of the keys in the object.\\n    let keys = Object.keys(value);\\n    if (canonical) {\\n      keys = keys.sort();\\n    }\\n    keys.forEach(k => {\\n      v = str(k, value, singleIndent, innerIndent, canonical);\\n      if (v) {\\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\\n      }\\n    });\\n\\n    // Join all of the member texts together, separated with commas,\\n    // and wrap them in braces.\\n    if (partial.length === 0) {\\n      v = '{}';\\n    } else if (innerIndent) {\\n      v = '{\\\\n' +\\n        innerIndent +\\n        partial.join(',\\\\n' +\\n        innerIndent) +\\n        '\\\\n' +\\n        outerIndent +\\n        '}';\\n    } else {\\n      v = '{' + partial.join(',') + '}';\\n    }\\n    return v;\\n\\n  default: // Do nothing\\n  }\\n};\\n\\n// If the JSON object does not yet have a stringify method, give it one.\\nconst canonicalStringify = (value, options) => {\\n  // Make a fake root object containing our value under the key of ''.\\n  // Return the result of stringifying the value.\\n  const allOptions = Object.assign({\\n    indent: '',\\n    canonical: false,\\n  }, options);\\n  if (allOptions.indent === true) {\\n    allOptions.indent = '  ';\\n  } else if (typeof allOptions.indent === 'number') {\\n    let newIndent = '';\\n    for (let i = 0; i < allOptions.indent; i++) {\\n      newIndent += ' ';\\n    }\\n    allOptions.indent = newIndent;\\n  }\\n  return str('', {'': value}, allOptions.indent, '', allOptions.canonical);\\n};\\n\\nexport default canonicalStringify;\\n\"]}","minifier":"terser"}