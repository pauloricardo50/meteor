{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,a=Package.meteor.meteorEnv,o=Package.tracker.Tracker,r=Package.tracker.Deps,n=Package.modules.meteorInstall,s=Package[\"babel-runtime\"].meteorBabelHelpers,c=Package.promise.Promise,i,l,p=n({node_modules:{meteor:{\"react-meteor-data\":{\"react-meteor-data.jsx\":function(e,t,a){let o;a.link(\"meteor/tmeasday:check-npm-versions\",{checkNpmVersions(e){o=e}},0),a.link(\"./createContainer.jsx\",{default:\"createContainer\"},1),a.link(\"./ReactMeteorData.jsx\",{default:\"withTracker\"},2),a.link(\"./ReactMeteorData.jsx\",{ReactMeteorData:\"ReactMeteorData\"},3),o({react:\"15.3 - 16\"},\"react-meteor-data\")},\"ReactMeteorData.jsx\":function(e,t,a){var o,r=e(\"@babel/runtime/helpers/interopRequireDefault\")(e(\"@babel/runtime/helpers/extends\"));let n,s,c;a.export({ReactMeteorData:()=>l,default:()=>m}),a.link(\"react\",{default(e){n=e}},0),a.link(\"meteor/meteor\",{Meteor(e){s=e}},1),a.link(\"meteor/tracker\",{Tracker(e){c=e}},2);class i{constructor(e){this.component=e,this.computation=null,this.oldData=null}dispose(){this.computation&&(this.computation.stop(),this.computation=null)}calculateData(){const e=this.component;if(!e.getMeteorData)return null;if(s.isServer)return e.getMeteorData();let t;return this.computation&&(this.computation.stop(),this.computation=null),this.computation=c.nonreactive(()=>c.autorun(a=>{if(a.firstRun){const a=e.setState;try{e.setState=(()=>{throw new Error('Can\\'t call `setState` inside `getMeteorData` as this could cause an endless loop. To respond to Meteor data changing, consider making this component a \"wrapper component\" that only fetches data and passes it in as props to a child component. Then you can use `componentWillReceiveProps` in that child component.')}),t=e.getMeteorData()}finally{e.setState=a}}else a.stop(),e.forceUpdate()})),Package.mongo&&Package.mongo.Mongo&&Object.keys(t).forEach(e=>{t[e]instanceof Package.mongo.Mongo.Cursor&&console.warn(\"Warning: you are returning a Mongo cursor from getMeteorData. This value will not be reactive. You probably want to call `.fetch()` on the cursor before returning it.\")}),t}updateData(e){const t=this.component,a=this.oldData;if(!e||\"object\"!=typeof e)throw new Error(\"Expected object returned from getMeteorData\");for(let o in e)t.data[o]=e[o];if(a)for(let o in a)o in e||delete t.data[o];this.oldData=e}}const l={componentWillMount(){this.data={},this._meteorDataManager=new i(this);const e=this._meteorDataManager.calculateData();this._meteorDataManager.updateData(e)},componentWillUpdate(e,t){const a=this.props,o=this.state;let r;try{this.props=e,this.state=t,r=this._meteorDataManager.calculateData()}finally{this.props=a,this.state=o}this._meteorDataManager.updateData(r)},componentWillUnmount(){this._meteorDataManager.dispose()}};class p extends n.Component{}Object.assign(p.prototype,l);class u extends n.PureComponent{}function m(e){let t=e;\"function\"==typeof e&&(t={getMeteorData:e});const{getMeteorData:a,pure:o=!0}=t,s=o?u:p;return e=>(class t extends s{getMeteorData(){return a(this.props)}render(){return n.createElement(e,(0,r.default)({},this.props,this.data))}})}Object.assign(u.prototype,l)},\"createContainer.jsx\":function(e,t,a){let o,r,n;a.export({default:()=>c}),a.link(\"meteor/meteor\",{Meteor(e){o=e}},0),a.link(\"react\",{default(e){r=e}},1),a.link(\"./ReactMeteorData.jsx\",{default(e){n=e}},2);let s=!1;function c(e,t){return!s&&o.isDevelopment&&(console.warn(\"Warning: createContainer was deprecated in react-meteor-data@0.2.13. Use withTracker instead.\\nhttps://github.com/meteor/react-packages/tree/devel/packages/react-meteor-data#usage\"),s=!0),n(e)(t)}}}}}},{extensions:[\".js\",\".json\",\".jsx\"]})(\"/node_modules/meteor/react-meteor-data/react-meteor-data.jsx\");Package._define(\"react-meteor-data\",p,{ReactMeteorData:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/react-meteor-data/react-meteor-data.jsx\",\"packages/react-meteor-data/ReactMeteorData.jsx\",\"packages/react-meteor-data/createContainer.jsx\"],\"names\":[\"checkNpmVersions\",\"module\",\"link\",\"v\",\"default\",\"ReactMeteorData\",\"react\",\"React\",\"Meteor\",\"Tracker\",\"export\",\"connect\",\"MeteorDataManager\",\"constructor\",\"component\",\"this\",\"computation\",\"oldData\",\"dispose\",\"stop\",\"calculateData\",\"getMeteorData\",\"isServer\",\"data\",\"nonreactive\",\"autorun\",\"c\",\"firstRun\",\"savedSetState\",\"setState\",\"Error\",\"forceUpdate\",\"Package\",\"mongo\",\"Mongo\",\"Object\",\"keys\",\"forEach\",\"key\",\"Cursor\",\"console\",\"warn\",\"updateData\",\"newData\",\"componentWillMount\",\"_meteorDataManager\",\"componentWillUpdate\",\"nextProps\",\"nextState\",\"saveProps\",\"props\",\"saveState\",\"state\",\"componentWillUnmount\",\"ReactComponent\",\"Component\",\"assign\",\"prototype\",\"ReactPureComponent\",\"PureComponent\",\"options\",\"expandedOptions\",\"pure\",\"BaseComponent\",\"WrappedComponent\",\"ReactMeteorDataComponent\",\"render\",\"createElement\",\"_extends2\",\"createContainer\",\"hasDisplayedWarning\",\"isDevelopment\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { checkNpmVersions } from 'meteor/tmeasday:check-npm-versions';\\n\\ncheckNpmVersions({\\n  react: '15.3 - 16',\\n}, 'react-meteor-data');\\n\\nexport { default as createContainer } from './createContainer.jsx';\\nexport { default as withTracker } from './ReactMeteorData.jsx';\\nexport { ReactMeteorData } from './ReactMeteorData.jsx';\\n\",\"/* global Package */\\n/* eslint-disable react/prefer-stateless-function */\\n\\nimport React from 'react';\\nimport { Meteor } from 'meteor/meteor';\\nimport { Tracker } from 'meteor/tracker';\\n\\n// A class to keep the state and utility methods needed to manage\\n// the Meteor data for a component.\\nclass MeteorDataManager {\\n  constructor(component) {\\n    this.component = component;\\n    this.computation = null;\\n    this.oldData = null;\\n  }\\n\\n  dispose() {\\n    if (this.computation) {\\n      this.computation.stop();\\n      this.computation = null;\\n    }\\n  }\\n\\n  calculateData() {\\n    const component = this.component;\\n\\n    if (!component.getMeteorData) {\\n      return null;\\n    }\\n\\n    // When rendering on the server, we don't want to use the Tracker.\\n    // We only do the first rendering on the server so we can get the data right away\\n    if (Meteor.isServer) {\\n      return component.getMeteorData();\\n    }\\n\\n    if (this.computation) {\\n      this.computation.stop();\\n      this.computation = null;\\n    }\\n\\n    let data;\\n    // Use Tracker.nonreactive in case we are inside a Tracker Computation.\\n    // This can happen if someone calls `ReactDOM.render` inside a Computation.\\n    // In that case, we want to opt out of the normal behavior of nested\\n    // Computations, where if the outer one is invalidated or stopped,\\n    // it stops the inner one.\\n    this.computation = Tracker.nonreactive(() => (\\n      Tracker.autorun((c) => {\\n        if (c.firstRun) {\\n          const savedSetState = component.setState;\\n          try {\\n            component.setState = () => {\\n              throw new Error(\\n                'Can\\\\'t call `setState` inside `getMeteorData` as this could '\\n                + 'cause an endless loop. To respond to Meteor data changing, '\\n                + 'consider making this component a \\\\\\\"wrapper component\\\\\\\" that '\\n                + 'only fetches data and passes it in as props to a child '\\n                + 'component. Then you can use `componentWillReceiveProps` in '\\n                + 'that child component.');\\n            };\\n\\n            data = component.getMeteorData();\\n          } finally {\\n            component.setState = savedSetState;\\n          }\\n        } else {\\n          // Stop this computation instead of using the re-run.\\n          // We use a brand-new autorun for each call to getMeteorData\\n          // to capture dependencies on any reactive data sources that\\n          // are accessed.  The reason we can't use a single autorun\\n          // for the lifetime of the component is that Tracker only\\n          // re-runs autoruns at flush time, while we need to be able to\\n          // re-call getMeteorData synchronously whenever we want, e.g.\\n          // from componentWillUpdate.\\n          c.stop();\\n          // Calling forceUpdate() triggers componentWillUpdate which\\n          // recalculates getMeteorData() and re-renders the component.\\n          component.forceUpdate();\\n        }\\n      })\\n    ));\\n\\n    if (Package.mongo && Package.mongo.Mongo) {\\n      Object.keys(data).forEach((key) => {\\n        if (data[key] instanceof Package.mongo.Mongo.Cursor) {\\n          console.warn(\\n            'Warning: you are returning a Mongo cursor from getMeteorData. '\\n            + 'This value will not be reactive. You probably want to call '\\n            + '`.fetch()` on the cursor before returning it.'\\n          );\\n        }\\n      });\\n    }\\n\\n    return data;\\n  }\\n\\n  updateData(newData) {\\n    const component = this.component;\\n    const oldData = this.oldData;\\n\\n    if (!(newData && (typeof newData) === 'object')) {\\n      throw new Error('Expected object returned from getMeteorData');\\n    }\\n    // update componentData in place based on newData\\n    for (let key in newData) {\\n      component.data[key] = newData[key];\\n    }\\n    // if there is oldData (which is every time this method is called\\n    // except the first), delete keys in newData that aren't in\\n    // oldData.  don't interfere with other keys, in case we are\\n    // co-existing with something else that writes to a component's\\n    // this.data.\\n    if (oldData) {\\n      for (let key in oldData) {\\n        if (!(key in newData)) {\\n          delete component.data[key];\\n        }\\n      }\\n    }\\n    this.oldData = newData;\\n  }\\n}\\n\\nexport const ReactMeteorData = {\\n  componentWillMount() {\\n    this.data = {};\\n    this._meteorDataManager = new MeteorDataManager(this);\\n    const newData = this._meteorDataManager.calculateData();\\n    this._meteorDataManager.updateData(newData);\\n  },\\n\\n  componentWillUpdate(nextProps, nextState) {\\n    const saveProps = this.props;\\n    const saveState = this.state;\\n    let newData;\\n    try {\\n      // Temporarily assign this.state and this.props,\\n      // so that they are seen by getMeteorData!\\n      // This is a simulation of how the proposed Observe API\\n      // for React will work, which calls observe() after\\n      // componentWillUpdate and after props and state are\\n      // updated, but before render() is called.\\n      // See https://github.com/facebook/react/issues/3398.\\n      this.props = nextProps;\\n      this.state = nextState;\\n      newData = this._meteorDataManager.calculateData();\\n    } finally {\\n      this.props = saveProps;\\n      this.state = saveState;\\n    }\\n\\n    this._meteorDataManager.updateData(newData);\\n  },\\n\\n  componentWillUnmount() {\\n    this._meteorDataManager.dispose();\\n  },\\n};\\n\\nclass ReactComponent extends React.Component {}\\nObject.assign(ReactComponent.prototype, ReactMeteorData);\\nclass ReactPureComponent extends React.PureComponent {}\\nObject.assign(ReactPureComponent.prototype, ReactMeteorData);\\n\\nexport default function connect(options) {\\n  let expandedOptions = options;\\n  if (typeof options === 'function') {\\n    expandedOptions = {\\n      getMeteorData: options,\\n    };\\n  }\\n\\n  const { getMeteorData, pure = true } = expandedOptions;\\n\\n  const BaseComponent = pure ? ReactPureComponent : ReactComponent;\\n  return (WrappedComponent) => (\\n    class ReactMeteorDataComponent extends BaseComponent {\\n      getMeteorData() {\\n        return getMeteorData(this.props);\\n      }\\n      render() {\\n        return <WrappedComponent {...this.props} {...this.data} />;\\n      }\\n    }\\n  );\\n}\\n\",\"/**\\n * Container helper using react-meteor-data.\\n */\\n\\nimport { Meteor } from 'meteor/meteor';\\nimport React from 'react';\\nimport connect from './ReactMeteorData.jsx';\\n\\nlet hasDisplayedWarning = false;\\n\\nexport default function createContainer(options, Component) {\\n  if (!hasDisplayedWarning && Meteor.isDevelopment) {\\n    console.warn(\\n      'Warning: createContainer was deprecated in react-meteor-data@0.2.13. Use withTracker instead.\\\\n' +\\n        'https://github.com/meteor/react-packages/tree/devel/packages/react-meteor-data#usage',\\n    );\\n    hasDisplayedWarning = true;\\n  }\\n\\n  return connect(options)(Component);\\n}\\n\"]}","minifier":"terser"}