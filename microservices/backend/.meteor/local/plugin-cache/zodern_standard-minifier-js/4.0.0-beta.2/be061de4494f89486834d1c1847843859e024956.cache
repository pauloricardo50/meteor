{"code":"!function(){var n=Package.meteor.Meteor,e=Package.meteor.global,t=Package.meteor.meteorEnv,o=Package.tracker.Tracker,i=Package.tracker.Deps,r=Package.random.Random,c=Package[\"callback-hook\"].Hook,s=Package[\"reactive-var\"].ReactiveVar,a=Package[\"ddp-client\"].DDP,u=Package.mongo.Mongo,l=Package.modules.meteorInstall,g=Package[\"babel-runtime\"].meteorBabelHelpers,_=Package.promise.Promise,f=Package[\"ecmascript-runtime-client\"].Symbol,h=Package[\"ecmascript-runtime-client\"].Map,d=Package[\"ecmascript-runtime-client\"].Set,p,m,k=l({node_modules:{meteor:{\"accounts-base\":{\"client_main.js\":function(e,t,o){var i,r;o.export({Accounts:function(){return p},AccountsClient:function(){return i},AccountsTest:function(){return r},default:function(){return t}}),o.link(\"./accounts_client.js\",{AccountsClient:function(n){i=n},AccountsTest:function(n){r=n}},0),o.runSetters(p=new i),n.users=p.users},\"accounts_client.js\":function(e,t,o){var i=e(\"@babel/runtime/helpers/interopRequireDefault\"),c=i(e(\"@babel/runtime/helpers/objectSpread\")),u=i(e(\"@babel/runtime/helpers/inheritsLoose\")),l;o.export({AccountsClient:function(){return g},AccountsTest:function(){return d}}),o.link(\"./accounts_common.js\",{AccountsCommon:function(n){l=n}},0);var g=function(e){function t(n){var t;return(t=e.call(this,n)||this)._loggingIn=new s(!1),t._loggingOut=new s(!1),t._loginServicesHandle=t.connection.subscribe(\"meteor.loginServiceConfiguration\"),t._pageLoadLoginCallbacks=[],t._pageLoadLoginAttemptInfo=null,t.savedHash=window.location.hash,t._initUrlMatching(),t._initLocalStorage(),t._loginFuncs={},t}(0,u.default)(t,e);var o=t.prototype;return o.userId=function(){function n(){return this.connection.userId()}return n}(),o._setLoggingIn=function(){function n(n){this._loggingIn.set(n)}return n}(),o.loggingIn=function(){function n(){return this._loggingIn.get()}return n}(),o.loggingOut=function(){function n(){return this._loggingOut.get()}return n}(),o.registerClientLoginFunction=function(){function n(n,e){if(this._loginFuncs[n])throw new Error(n+\" has been defined already\");this._loginFuncs[n]=e}return n}(),o.callLoginFunction=function(){function n(n){if(!this._loginFuncs[n])throw new Error(n+\" was not defined\");for(var e=arguments.length,t=new Array(e>1?e-1:0),o=1;o<e;o++)t[o-1]=arguments[o];return this._loginFuncs[n].apply(this,t)}return n}(),o.applyLoginFunction=function(){function n(n,e){if(!this._loginFuncs[n])throw new Error(n+\" was not defined\");return this._loginFuncs[n].apply(this,e)}return n}(),o.logout=function(){function n(n){var e=this;this._loggingOut.set(!0),this.connection.apply(\"logout\",[],{wait:!0},function(t,o){e._loggingOut.set(!1),t?n&&n(t):(e.makeClientLoggedOut(),n&&n())})}return n}(),o.logoutOtherClients=function(){function n(n){var e=this;this.connection.apply(\"getNewToken\",[],{wait:!0},function(n,t){n||e._storeLoginToken(e.userId(),t.token,t.tokenExpires)}),this.connection.apply(\"removeOtherTokens\",[],{wait:!0},function(e){return n&&n(e)})}return n}(),o.callLoginMethod=function(){function n(n){var e=this,t;n=(0,c.default)({methodName:\"login\",methodArguments:[{}],_suppressLoggingIn:!1},n),[\"validateResult\",\"userCallback\"].forEach(function(e){n[e]||(n[e]=function(){return null})});var o=function(o){var i=o.error,r=o.loginDetails;t||(t=!0,i?e._onLoginFailureHook.each(function(n){return n({error:i}),!0}):e._onLoginHook.each(function(n){return n(r),!0}),n.userCallback(i,r))},i=!1,r=function(n,t){!n&&t&&t.token&&(e._reconnectStopper&&e._reconnectStopper.stop(),e._reconnectStopper=a.onReconnect(function(n){if(n==e.connection){i=!0;var r=e._storedLoginToken();r&&(t={token:r,tokenExpires:e._storedLoginTokenExpires()}),t.tokenExpires||(t.tokenExpires=e._tokenExpiration(new Date)),e._tokenExpiresSoon(t.tokenExpires)?e.makeClientLoggedOut():e.callLoginMethod({methodArguments:[{resume:t.token}],_suppressLoggingIn:!0,userCallback:function(n,i){var r=e._storedLoginToken();n&&r&&r===t.token&&e.makeClientLoggedOut(),o({error:n,loginDetails:i})}})}}))},s=function(t,r){if(!i){if(e._setLoggingIn(!1),t||!r)return t=t||new Error(\"No result from call to \"+n.methodName),void o({error:t});try{n.validateResult(r)}catch(n){return void o({error:n})}e.makeClientLoggedIn(r.id,r.token,r.tokenExpires),o({loginDetails:{type:r.type}})}};n._suppressLoggingIn||this._setLoggingIn(!0),this.connection.apply(n.methodName,n.methodArguments,{wait:!0,onResultReceived:r},s)}return n}(),o.makeClientLoggedOut=function(){function n(){this.connection._userId&&this._onLogoutHook.each(function(n){return n(),!0}),this._unstoreLoginToken(),this.connection.setUserId(null),this._reconnectStopper&&this._reconnectStopper.stop()}return n}(),o.makeClientLoggedIn=function(){function n(n,e,t){this._storeLoginToken(n,e,t),this.connection.setUserId(n)}return n}(),o.loginServicesConfigured=function(){function n(){return this._loginServicesHandle.ready()}return n}(),o.onPageLoadLogin=function(){function n(n){this._pageLoadLoginAttemptInfo?n(this._pageLoadLoginAttemptInfo):this._pageLoadLoginCallbacks.push(n)}return n}(),o._pageLoadLogin=function(){function e(e){this._pageLoadLoginAttemptInfo?n._debug(\"Ignoring unexpected duplicate page load login attempt info\"):(this._pageLoadLoginCallbacks.forEach(function(n){return n(e)}),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=e)}return e}(),o.loginWithToken=function(){function n(n,e){this.callLoginMethod({methodArguments:[{resume:n}],userCallback:e})}return n}(),o._enableAutoLogin=function(){function n(){this._autoLoginEnabled=!0,this._pollStoredLoginToken()}return n}(),o._isolateLoginTokenForTest=function(){function n(){this.LOGIN_TOKEN_KEY=this.LOGIN_TOKEN_KEY+r.id(),this.USER_ID_KEY=this.USER_ID_KEY+r.id()}return n}(),o._storeLoginToken=function(){function e(e,t,o){n._localStorage.setItem(this.USER_ID_KEY,e),n._localStorage.setItem(this.LOGIN_TOKEN_KEY,t),o||(o=this._tokenExpiration(new Date)),n._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY,o),this._lastLoginTokenWhenPolled=t}return e}(),o._unstoreLoginToken=function(){function e(){n._localStorage.removeItem(this.USER_ID_KEY),n._localStorage.removeItem(this.LOGIN_TOKEN_KEY),n._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY),this._lastLoginTokenWhenPolled=null}return e}(),o._storedLoginToken=function(){function e(){return n._localStorage.getItem(this.LOGIN_TOKEN_KEY)}return e}(),o._storedLoginTokenExpires=function(){function e(){return n._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY)}return e}(),o._storedUserId=function(){function e(){return n._localStorage.getItem(this.USER_ID_KEY)}return e}(),o._unstoreLoginTokenIfExpiresSoon=function(){function n(){var n=this._storedLoginTokenExpires();n&&this._tokenExpiresSoon(new Date(n))&&this._unstoreLoginToken()}return n}(),o._initLocalStorage=function(){function e(){var e=this;this.LOGIN_TOKEN_KEY=\"Meteor.loginToken\",this.LOGIN_TOKEN_EXPIRES_KEY=\"Meteor.loginTokenExpires\",this.USER_ID_KEY=\"Meteor.userId\";var t=__meteor_runtime_config__.ROOT_URL_PATH_PREFIX,o;if(t||this.connection!==n.connection){var i=\":\"+this.connection._stream.rawUrl;t&&(i+=\":\"+t),this.LOGIN_TOKEN_KEY+=i,this.LOGIN_TOKEN_EXPIRES_KEY+=i,this.USER_ID_KEY+=i}if(this._autoLoginEnabled&&(this._unstoreLoginTokenIfExpiresSoon(),o=this._storedLoginToken())){var r=this._storedUserId();r&&this.connection.setUserId(r),this.loginWithToken(o,function(t){t&&(n._debug(\"Error logging in with token: \"+t),e.makeClientLoggedOut()),e._pageLoadLogin({type:\"resume\",allowed:!t,error:t,methodName:\"login\",methodArguments:[{resume:o}]})})}this._lastLoginTokenWhenPolled=o,this._pollIntervalTimer&&clearInterval(this._pollIntervalTimer),this._pollIntervalTimer=setInterval(function(){e._pollStoredLoginToken()},3e3)}return e}(),o._pollStoredLoginToken=function(){function n(){var n=this;if(this._autoLoginEnabled){var e=this._storedLoginToken();this._lastLoginTokenWhenPolled!=e&&(e?this.loginWithToken(e,function(e){e&&n.makeClientLoggedOut()}):this.logout()),this._lastLoginTokenWhenPolled=e}}return n}(),o._initUrlMatching=function(){function n(){this._autoLoginEnabled=!0,this._accountsCallbacks={},this._attemptToMatchHash()}return n}(),o._attemptToMatchHash=function(){function n(){h(this,this.savedHash,f)}return n}(),o.onResetPasswordLink=function(){function e(e){this._accountsCallbacks[\"reset-password\"]&&n._debug(\"Accounts.onResetPasswordLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"reset-password\"]=e}return e}(),o.onEmailVerificationLink=function(){function e(e){this._accountsCallbacks[\"verify-email\"]&&n._debug(\"Accounts.onEmailVerificationLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"verify-email\"]=e}return e}(),o.onEnrollmentLink=function(){function e(e){this._accountsCallbacks[\"enroll-account\"]&&n._debug(\"Accounts.onEnrollmentLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"enroll-account\"]=e}return e}(),t}(l);if(n.loggingIn=function(){return p.loggingIn()},n.loggingOut=function(){return p.loggingOut()},n.logout=function(n){return p.logout(n)},n.logoutOtherClients=function(n){return p.logoutOtherClients(n)},n.loginWithToken=function(n,e){return p.loginWithToken(n,e)},Package.blaze){var _=Package.blaze.Blaze.Template;_.registerHelper(\"currentUser\",function(){return n.user()}),_.registerHelper(\"loggingIn\",function(){return n.loggingIn()}),_.registerHelper(\"loggingOut\",function(){return n.loggingOut()}),_.registerHelper(\"loggingInOrOut\",function(){return n.loggingIn()||n.loggingOut()})}var f=function(e,t){var o=this;this._autoLoginEnabled=!1,n.startup(function(){o._accountsCallbacks[t]&&o._accountsCallbacks[t](e,function(){return o._enableAutoLogin()})})},h=function(n,e,t){[\"reset-password\",\"verify-email\",\"enroll-account\"].forEach(function(o){var i,r=new RegExp(\"^\\\\#\\\\/\"+o+\"\\\\/(.*)$\"),c=e.match(r);c&&(i=c[1],\"reset-password\"===o?n._resetPasswordToken=i:\"verify-email\"===o?n._verifyEmailToken=i:\"enroll-account\"===o&&(n._enrollAccountToken=i),window.location.hash=\"\",t.call(n,i,o))})},d={attemptToMatchHash:function(n,e){return h(p,n,e)}}},\"accounts_common.js\":function(e,t,o){var i,r=e(\"@babel/runtime/helpers/interopRequireDefault\")(e(\"@babel/runtime/helpers/objectSpread\"));o.export({AccountsCommon:function(){return s},EXPIRE_TOKENS_INTERVAL_MS:function(){return h},CONNECTION_CLOSE_DELAY_MS:function(){return d}});var s=function(){function e(e){var t=this;this._options={},this.connection=void 0,this._initConnection(e||{}),this.users=new u.Collection(\"users\",{_preventAutopublish:!0,connection:this.connection}),this._onLoginHook=new c({bindEnvironment:!1,debugPrintExceptions:\"onLogin callback\"}),this._onLoginFailureHook=new c({bindEnvironment:!1,debugPrintExceptions:\"onLoginFailure callback\"}),this._onLogoutHook=new c({bindEnvironment:!1,debugPrintExceptions:\"onLogout callback\"}),this.DEFAULT_LOGIN_EXPIRATION_DAYS=l,this.LOGIN_UNEXPIRING_TOKEN_DAYS=m;var o=\"Accounts.LoginCancelledError\";this.LoginCancelledError=n.makeErrorType(o,function(n){this.message=n}),this.LoginCancelledError.prototype.name=o,this.LoginCancelledError.numericError=145546287,n.startup(function(){var n=Package[\"service-configuration\"].ServiceConfiguration;t.loginServiceConfiguration=n.configurations,t.ConfigError=n.ConfigError})}var t=e.prototype;return t.userId=function(){function n(){throw new Error(\"userId method not implemented\")}return n}(),t.user=function(){function n(){var n=this.userId();return n?this.users.findOne(n):null}return n}(),t.config=function(){function e(e){var t=this;if(n.isServer?__meteor_runtime_config__.accountsConfigCalled=!0:__meteor_runtime_config__.accountsConfigCalled||n._debug(\"Accounts.config was called on the client but not on the server; some configuration options may not take effect.\"),Object.prototype.hasOwnProperty.call(e,\"oauthSecretKey\")){if(n.isClient)throw new Error(\"The oauthSecretKey option may only be specified on the server\");if(!Package[\"oauth-encryption\"])throw new Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");Package[\"oauth-encryption\"].OAuthEncryption.loadKey(e.oauthSecretKey),delete(e=(0,r.default)({},e)).oauthSecretKey}var o=[\"sendVerificationEmail\",\"forbidClientAccountCreation\",\"passwordEnrollTokenExpirationInDays\",\"restrictCreationByEmailDomain\",\"loginExpirationInDays\",\"passwordResetTokenExpirationInDays\",\"ambiguousErrorMessages\",\"bcryptRounds\"];Object.keys(e).forEach(function(n){if(!o.includes(n))throw new Error(\"Accounts.config: Invalid key: \"+n)}),o.forEach(function(n){if(n in e){if(n in t._options)throw new Error(\"Can't set `\"+n+\"` more than once\");t._options[n]=e[n]}})}return e}(),t.onLogin=function(){function n(n){return this._onLoginHook.register(n)}return n}(),t.onLoginFailure=function(){function n(n){return this._onLoginFailureHook.register(n)}return n}(),t.onLogout=function(){function n(n){return this._onLogoutHook.register(n)}return n}(),t._initConnection=function(){function e(e){n.isClient&&(e.connection?this.connection=e.connection:e.ddpUrl?this.connection=a.connect(e.ddpUrl):\"undefined\"!=typeof __meteor_runtime_config__&&__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL?this.connection=a.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL):this.connection=n.connection)}return e}(),t._getTokenLifetimeMs=function(){function n(){var n;return 24*((null===this._options.loginExpirationInDays?m:this._options.loginExpirationInDays)||l)*60*60*1e3}return n}(),t._getPasswordResetTokenLifetimeMs=function(){function n(){return 24*(this._options.passwordResetTokenExpirationInDays||g)*60*60*1e3}return n}(),t._getPasswordEnrollTokenLifetimeMs=function(){function n(){return 24*(this._options.passwordEnrollTokenExpirationInDays||_)*60*60*1e3}return n}(),t._tokenExpiration=function(){function n(n){return new Date(new Date(n).getTime()+this._getTokenLifetimeMs())}return n}(),t._tokenExpiresSoon=function(){function n(n){var e=.1*this._getTokenLifetimeMs(),t=1e3*f;return e>t&&(e=t),new Date>new Date(n)-e}return n}(),e}();n.userId=function(){return p.userId()},n.user=function(){return p.user()};var l=90,g=3,_=30,f=3600,h=6e5,d=1e4,m=36500}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/accounts-base/client_main.js\");Package._define(\"accounts-base\",k,{Accounts:p})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/accounts-base/client_main.js\",\"packages/accounts-base/accounts_client.js\",\"packages/accounts-base/accounts_common.js\"],\"names\":[\"AccountsClient\",\"AccountsTest\",\"module\",\"export\",\"Accounts\",\"default\",\"exports\",\"link\",\"v\",\"runSetters\",\"Meteor\",\"users\",\"AccountsCommon\",\"options\",\"_this\",\"_AccountsCommon\",\"call\",\"this\",\"_loggingIn\",\"ReactiveVar\",\"_loggingOut\",\"_loginServicesHandle\",\"connection\",\"subscribe\",\"_pageLoadLoginCallbacks\",\"_pageLoadLoginAttemptInfo\",\"savedHash\",\"window\",\"location\",\"hash\",\"_initUrlMatching\",\"_initLocalStorage\",\"_loginFuncs\",\"userId\",\"_setLoggingIn\",\"x\",\"set\",\"loggingIn\",\"get\",\"loggingOut\",\"registerClientLoginFunction\",\"funcName\",\"func\",\"Error\",\"callLoginFunction\",\"_len\",\"arguments\",\"length\",\"funcArgs\",\"Array\",\"_key\",\"apply\",\"applyLoginFunction\",\"logout\",\"callback\",\"_this2\",\"wait\",\"error\",\"result\",\"makeClientLoggedOut\",\"logoutOtherClients\",\"_this3\",\"err\",\"_storeLoginToken\",\"token\",\"tokenExpires\",\"callLoginMethod\",\"_this4\",\"called\",\"_objectSpread2\",\"methodName\",\"methodArguments\",\"_suppressLoggingIn\",\"forEach\",\"f\",\"loginCallbacks\",\"_ref\",\"loginDetails\",\"_onLoginFailureHook\",\"each\",\"_onLoginHook\",\"userCallback\",\"reconnected\",\"onResultReceived\",\"_reconnectStopper\",\"stop\",\"DDP\",\"onReconnect\",\"conn\",\"storedToken\",\"_storedLoginToken\",\"_storedLoginTokenExpires\",\"_tokenExpiration\",\"Date\",\"_tokenExpiresSoon\",\"resume\",\"storedTokenNow\",\"loggedInAndDataReadyCallback\",\"validateResult\",\"e\",\"makeClientLoggedIn\",\"id\",\"type\",\"_userId\",\"_onLogoutHook\",\"_unstoreLoginToken\",\"setUserId\",\"loginServicesConfigured\",\"ready\",\"onPageLoadLogin\",\"push\",\"_pageLoadLogin\",\"attemptInfo\",\"_debug\",\"loginWithToken\",\"_enableAutoLogin\",\"_autoLoginEnabled\",\"_pollStoredLoginToken\",\"_isolateLoginTokenForTest\",\"LOGIN_TOKEN_KEY\",\"Random\",\"USER_ID_KEY\",\"_localStorage\",\"setItem\",\"LOGIN_TOKEN_EXPIRES_KEY\",\"_lastLoginTokenWhenPolled\",\"removeItem\",\"getItem\",\"_storedUserId\",\"_unstoreLoginTokenIfExpiresSoon\",\"_this5\",\"rootUrlPathPrefix\",\"__meteor_runtime_config__\",\"ROOT_URL_PATH_PREFIX\",\"namespace\",\"_stream\",\"rawUrl\",\"allowed\",\"_pollIntervalTimer\",\"clearInterval\",\"setInterval\",\"_this6\",\"currentLoginToken\",\"_accountsCallbacks\",\"_attemptToMatchHash\",\"attemptToMatchHash\",\"defaultSuccessHandler\",\"onResetPasswordLink\",\"onEmailVerificationLink\",\"onEnrollmentLink\",\"Package\",\"blaze\",\"Template\",\"Blaze\",\"registerHelper\",\"user\",\"urlPart\",\"_this7\",\"startup\",\"accounts\",\"success\",\"tokenRegex\",\"RegExp\",\"match\",\"_resetPasswordToken\",\"_verifyEmailToken\",\"_enrollAccountToken\",\"EXPIRE_TOKENS_INTERVAL_MS\",\"CONNECTION_CLOSE_DELAY_MS\",\"_options\",\"undefined\",\"_initConnection\",\"Mongo\",\"Collection\",\"_preventAutopublish\",\"Hook\",\"bindEnvironment\",\"debugPrintExceptions\",\"DEFAULT_LOGIN_EXPIRATION_DAYS\",\"LOGIN_UNEXPIRING_TOKEN_DAYS\",\"lceName\",\"LoginCancelledError\",\"makeErrorType\",\"description\",\"message\",\"prototype\",\"name\",\"numericError\",\"ServiceConfiguration\",\"loginServiceConfiguration\",\"configurations\",\"ConfigError\",\"findOne\",\"config\",\"isServer\",\"accountsConfigCalled\",\"Object\",\"hasOwnProperty\",\"isClient\",\"OAuthEncryption\",\"loadKey\",\"oauthSecretKey\",\"VALID_KEYS\",\"keys\",\"key\",\"includes\",\"onLogin\",\"register\",\"onLoginFailure\",\"onLogout\",\"ddpUrl\",\"connect\",\"ACCOUNTS_CONNECTION_URL\",\"_getTokenLifetimeMs\",\"loginExpirationInDays\",\"_getPasswordResetTokenLifetimeMs\",\"passwordResetTokenExpirationInDays\",\"DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS\",\"_getPasswordEnrollTokenLifetimeMs\",\"passwordEnrollTokenExpirationInDays\",\"DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS\",\"when\",\"getTime\",\"minLifetimeMs\",\"minLifetimeCapMs\",\"MIN_TOKEN_LIFETIME_CAP_SECS\"],\"mappings\":\"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\",\"sourcesContent\":[\"import {\\n  AccountsClient,\\n  AccountsTest,\\n} from \\\"./accounts_client.js\\\";\\n\\n/**\\n * @namespace Accounts\\n * @summary The namespace for all client-side accounts-related methods.\\n */\\nAccounts = new AccountsClient();\\n\\n/**\\n * @summary A [Mongo.Collection](#collections) containing user documents.\\n * @locus Anywhere\\n * @type {Mongo.Collection}\\n * @importFromPackage meteor\\n */\\nMeteor.users = Accounts.users;\\n\\nexport {\\n  Accounts,\\n  AccountsClient,\\n  AccountsTest,\\n  // For backwards compatibility. Note that exporting an object as the\\n  // default export is *not* the same as exporting its properties as named\\n  // exports, as was previously assumed.\\n  exports as default,\\n};\\n\",\"import {AccountsCommon} from \\\"./accounts_common.js\\\";\\n\\n/**\\n * @summary Constructor for the `Accounts` object on the client.\\n * @locus Client\\n * @class AccountsClient\\n * @extends AccountsCommon\\n * @instancename accountsClient\\n * @param {Object} options an object with fields:\\n * @param {Object} options.connection Optional DDP connection to reuse.\\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\\n */\\nexport class AccountsClient extends AccountsCommon {\\n  constructor(options) {\\n    super(options);\\n\\n    this._loggingIn = new ReactiveVar(false);\\n    this._loggingOut = new ReactiveVar(false);\\n\\n    this._loginServicesHandle =\\n      this.connection.subscribe(\\\"meteor.loginServiceConfiguration\\\");\\n\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = null;\\n\\n    this.savedHash = window.location.hash;\\n    this._initUrlMatching();\\n\\n    // Defined in localstorage_token.js.\\n    this._initLocalStorage();\\n\\n    // This is for .registerClientLoginFunction & .callLoginFunction.\\n    this._loginFuncs = {};\\n  }\\n\\n  ///\\n  /// CURRENT USER\\n  ///\\n\\n  // @override\\n  userId() {\\n    return this.connection.userId();\\n  }\\n\\n  // This is mostly just called within this file, but Meteor.loginWithPassword\\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\\n  // method call too.\\n  _setLoggingIn(x) {\\n    this._loggingIn.set(x);\\n  }\\n\\n  /**\\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingIn() {\\n    return this._loggingIn.get();\\n  }\\n\\n  /**\\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingOut() {\\n    return this._loggingOut.get();\\n  }\\n\\n  /**\\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\\n   * @locus Client\\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\\n   Should be the OAuth provider name accordingly.\\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\\n   */\\n  registerClientLoginFunction(funcName, func) {\\n    if (this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} has been defined already`);\\n    }\\n    this._loginFuncs[funcName] = func;\\n  }\\n\\n  /**\\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\\n   all arguments for the login function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   */\\n  callLoginFunction(funcName, ...funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\\n   function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   * @param {Array} funcArgs The `arguments` for the login function.\\n   */\\n  applyLoginFunction(funcName, funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Log the user out.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logout(callback) {\\n    this._loggingOut.set(true);\\n    this.connection.apply('logout', [], {\\n      wait: true\\n    }, (error, result) => {\\n      this._loggingOut.set(false);\\n      if (error) {\\n        callback && callback(error);\\n      } else {\\n        this.makeClientLoggedOut();\\n        callback && callback();\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logoutOtherClients(callback) {\\n    // We need to make two method calls: one to replace our current token,\\n    // and another to remove all tokens except the current one. We want to\\n    // call these two methods one after the other, without any other\\n    // methods running between them. For example, we don't want `logout`\\n    // to be called in between our two method calls (otherwise the second\\n    // method call would return an error). Another example: we don't want\\n    // logout to be called before the callback for `getNewToken`;\\n    // otherwise we would momentarily log the user out and then write a\\n    // new token to localStorage.\\n    //\\n    // To accomplish this, we make both calls as wait methods, and queue\\n    // them one after the other, without spinning off the event loop in\\n    // between. Even though we queue `removeOtherTokens` before\\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\\n    // until the `getNewToken` callback has finished running, because they\\n    // are both wait methods.\\n    this.connection.apply(\\n      'getNewToken',\\n      [],\\n      { wait: true },\\n      (err, result) => {\\n        if (! err) {\\n          this._storeLoginToken(\\n            this.userId(),\\n            result.token,\\n            result.tokenExpires\\n          );\\n        }\\n      }\\n    );\\n\\n    this.connection.apply(\\n      'removeOtherTokens',\\n      [],\\n      { wait: true },\\n      err => callback && callback(err)\\n    );\\n  }\\n\\n  ///\\n  /// LOGIN METHODS\\n  ///\\n\\n  // Call a login method on the server.\\n  //\\n  // A login method is a method which on success calls `this.setUserId(id)` and\\n  // `Accounts._setLoginToken` on the server and returns an object with fields\\n  // 'id' (containing the user id), 'token' (containing a resume token), and\\n  // optionally `tokenExpires`.\\n  //\\n  // This function takes care of:\\n  //   - Updating the Meteor.loggingIn() reactive data source\\n  //   - Calling the method in 'wait' mode\\n  //   - On success, saving the resume token to localStorage\\n  //   - On success, calling Accounts.connection.setUserId()\\n  //   - Setting up an onReconnect handler which logs in with\\n  //     the resume token\\n  //\\n  // Options:\\n  // - methodName: The method to call (default 'login')\\n  // - methodArguments: The arguments for the method\\n  // - validateResult: If provided, will be called with the result of the\\n  //                 method. If it throws, the client will not be logged in (and\\n  //                 its error will be passed to the callback).\\n  // - userCallback: Will be called with no arguments once the user is fully\\n  //                 logged in, or with the error on error.\\n  //\\n  callLoginMethod(options) {\\n    options = { \\n      methodName: 'login',\\n      methodArguments: [{}],\\n      _suppressLoggingIn: false,\\n      ...options,\\n    };\\n\\n    // Set defaults for callback arguments to no-op functions; make sure we\\n    // override falsey values too.\\n    ['validateResult', 'userCallback'].forEach(f => {\\n      if (!options[f])\\n        options[f] = () => null;\\n    })\\n\\n    // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\\n    let called;\\n    const loginCallbacks = ({ error, loginDetails }) => {\\n      if (!called) {\\n        called = true;\\n        if (!error) {\\n          this._onLoginHook.each(callback => {\\n            callback(loginDetails);\\n            return true;\\n          });\\n        } else {\\n          this._onLoginFailureHook.each(callback => {\\n            callback({ error });\\n            return true;\\n          });\\n        }\\n        options.userCallback(error, loginDetails);\\n      }\\n    }\\n\\n    let reconnected = false;\\n\\n    // We want to set up onReconnect as soon as we get a result token back from\\n    // the server, without having to wait for subscriptions to rerun. This is\\n    // because if we disconnect and reconnect between getting the result and\\n    // getting the results of subscription rerun, we WILL NOT re-send this\\n    // method (because we never re-send methods whose results we've received)\\n    // but we WILL call loggedInAndDataReadyCallback at \\\"reconnect quiesce\\\"\\n    // time. This will lead to makeClientLoggedIn(result.id) even though we\\n    // haven't actually sent a login method!\\n    //\\n    // But by making sure that we send this \\\"resume\\\" login in that case (and\\n    // calling makeClientLoggedOut if it fails), we'll end up with an accurate\\n    // client-side userId. (It's important that livedata_connection guarantees\\n    // that the \\\"reconnect quiesce\\\"-time call to loggedInAndDataReadyCallback\\n    // will occur before the callback from the resume login call.)\\n    const onResultReceived = (err, result) => {\\n      if (err || !result || !result.token) {\\n        // Leave onReconnect alone if there was an error, so that if the user was\\n        // already logged in they will still get logged in on reconnect.\\n        // See issue #4970.\\n      } else {\\n        // First clear out any previously set Acccounts login onReconnect\\n        // callback (to make sure we don't keep piling up duplicate callbacks,\\n        // which would then all be triggered when reconnecting).\\n        if (this._reconnectStopper) {\\n          this._reconnectStopper.stop();\\n        }\\n\\n        this._reconnectStopper = DDP.onReconnect(conn => {\\n          if (conn != this.connection) {\\n            return;\\n          }\\n          reconnected = true;\\n          // If our token was updated in storage, use the latest one.\\n          const storedToken = this._storedLoginToken();\\n          if (storedToken) {\\n            result = {\\n              token: storedToken,\\n              tokenExpires: this._storedLoginTokenExpires()\\n            };\\n          }\\n          if (!result.tokenExpires)\\n            result.tokenExpires = this._tokenExpiration(new Date());\\n          if (this._tokenExpiresSoon(result.tokenExpires)) {\\n            this.makeClientLoggedOut();\\n          } else {\\n            this.callLoginMethod({\\n              methodArguments: [{resume: result.token}],\\n              // Reconnect quiescence ensures that the user doesn't see an\\n              // intermediate state before the login method finishes. So we don't\\n              // need to show a logging-in animation.\\n              _suppressLoggingIn: true,\\n              userCallback: (error, loginDetails) => {\\n                const storedTokenNow = this._storedLoginToken();\\n                if (error) {\\n                  // If we had a login error AND the current stored token is the\\n                  // one that we tried to log in with, then declare ourselves\\n                  // logged out. If there's a token in storage but it's not the\\n                  // token that we tried to log in with, we don't know anything\\n                  // about whether that token is valid or not, so do nothing. The\\n                  // periodic localStorage poll will decide if we are logged in or\\n                  // out with this token, if it hasn't already. Of course, even\\n                  // with this check, another tab could insert a new valid token\\n                  // immediately before we clear localStorage here, which would\\n                  // lead to both tabs being logged out, but by checking the token\\n                  // in storage right now we hope to make that unlikely to happen.\\n                  //\\n                  // If there is no token in storage right now, we don't have to\\n                  // do anything; whatever code removed the token from storage was\\n                  // responsible for calling `makeClientLoggedOut()`, or the\\n                  // periodic localStorage poll will call `makeClientLoggedOut`\\n                  // eventually if another tab wiped the token from storage.\\n                  if (storedTokenNow && storedTokenNow === result.token) {\\n                    this.makeClientLoggedOut();\\n                  }\\n                }\\n                // Possibly a weird callback to call, but better than nothing if\\n                // there is a reconnect between \\\"login result received\\\" and \\\"data\\n                // ready\\\".\\n                loginCallbacks({ error, loginDetails });\\n              }});\\n          }\\n        });\\n      }\\n    };\\n\\n    // This callback is called once the local cache of the current-user\\n    // subscription (and all subscriptions, in fact) are guaranteed to be up to\\n    // date.\\n    const loggedInAndDataReadyCallback = (error, result) => {\\n      // If the login method returns its result but the connection is lost\\n      // before the data is in the local cache, it'll set an onReconnect (see\\n      // above). The onReconnect will try to log in using the token, and *it*\\n      // will call userCallback via its own version of this\\n      // loggedInAndDataReadyCallback. So we don't have to do anything here.\\n      if (reconnected)\\n        return;\\n\\n      // Note that we need to call this even if _suppressLoggingIn is true,\\n      // because it could be matching a _setLoggingIn(true) from a\\n      // half-completed pre-reconnect login method.\\n      this._setLoggingIn(false);\\n      if (error || !result) {\\n        error = error || new Error(\\n          `No result from call to ${options.methodName}`\\n        );\\n        loginCallbacks({ error });\\n        return;\\n      }\\n      try {\\n        options.validateResult(result);\\n      } catch (e) {\\n        loginCallbacks({ error: e });\\n        return;\\n      }\\n\\n      // Make the client logged in. (The user data should already be loaded!)\\n      this.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\\n      loginCallbacks({ loginDetails: { type: result.type } });\\n    };\\n\\n    if (!options._suppressLoggingIn) {\\n      this._setLoggingIn(true);\\n    }\\n    this.connection.apply(\\n      options.methodName,\\n      options.methodArguments,\\n      { wait: true, onResultReceived: onResultReceived },\\n      loggedInAndDataReadyCallback);\\n  }\\n\\n  makeClientLoggedOut() {\\n    // Ensure client was successfully logged in before running logout hooks.\\n    if (this.connection._userId) {\\n      this._onLogoutHook.each(callback => {\\n        callback();\\n        return true;\\n      });\\n    }\\n    this._unstoreLoginToken();\\n    this.connection.setUserId(null);\\n    this._reconnectStopper && this._reconnectStopper.stop();\\n  }\\n  \\n  makeClientLoggedIn(userId, token, tokenExpires) {\\n    this._storeLoginToken(userId, token, tokenExpires);\\n    this.connection.setUserId(userId);\\n  }\\n\\n  ///\\n  /// LOGIN SERVICES\\n  ///\\n\\n  // A reactive function returning whether the loginServiceConfiguration\\n  // subscription is ready. Used by accounts-ui to hide the login button\\n  // until we have all the configuration loaded\\n  //\\n  loginServicesConfigured() {\\n    return this._loginServicesHandle.ready();\\n  };\\n\\n  // Some login services such as the redirect login flow or the resume\\n  // login handler can log the user in at page load time.  The\\n  // Meteor.loginWithX functions have a callback argument, but the\\n  // callback function instance won't be in memory any longer if the\\n  // page was reloaded.  The `onPageLoadLogin` function allows a\\n  // callback to be registered for the case where the login was\\n  // initiated in a previous VM, and we now have the result of the login\\n  // attempt in a new VM.\\n\\n  // Register a callback to be called if we have information about a\\n  // login attempt at page load time.  Call the callback immediately if\\n  // we already have the page load login attempt info, otherwise stash\\n  // the callback to be called if and when we do get the attempt info.\\n  //\\n  onPageLoadLogin(f) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      f(this._pageLoadLoginAttemptInfo);\\n    } else {\\n      this._pageLoadLoginCallbacks.push(f);\\n    }\\n  };\\n\\n  // Receive the information about the login attempt at page load time.\\n  // Call registered callbacks, and also record the info in case\\n  // someone's callback hasn't been registered yet.\\n  //\\n  _pageLoadLogin(attemptInfo) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      Meteor._debug(\\n        'Ignoring unexpected duplicate page load login attempt info'\\n      );\\n      return;\\n    }\\n\\n    this._pageLoadLoginCallbacks.forEach(callback => callback(attemptInfo));\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = attemptInfo;\\n  };\\n\\n  ///\\n  /// LOGIN TOKENS\\n  ///\\n\\n  // These methods deal with storing a login token and user id in the\\n  // browser's localStorage facility. It polls local storage every few\\n  // seconds to synchronize login state between multiple tabs in the same\\n  // browser.\\n\\n  loginWithToken(token, callback) {\\n    this.callLoginMethod({\\n      methodArguments: [{\\n        resume: token\\n      }],\\n      userCallback: callback\\n    });\\n  };\\n\\n  // Semi-internal API. Call this function to re-enable auto login after\\n  // if it was disabled at startup.\\n  _enableAutoLogin() {\\n    this._autoLoginEnabled = true;\\n    this._pollStoredLoginToken();\\n  };\\n\\n  ///\\n  /// STORING\\n  ///\\n\\n  // Call this from the top level of the test file for any test that does\\n  // logging in and out, to protect multiple tabs running the same tests\\n  // simultaneously from interfering with each others' localStorage.\\n  _isolateLoginTokenForTest() {\\n    this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\\n    this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\\n  };\\n\\n  _storeLoginToken(userId, token, tokenExpires) {\\n    Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\\n    if (! tokenExpires)\\n      tokenExpires = this._tokenExpiration(new Date());\\n    Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = token;\\n  };\\n\\n  _unstoreLoginToken() {\\n    Meteor._localStorage.removeItem(this.USER_ID_KEY);\\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\\n    Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = null;\\n  };\\n\\n  // This is private, but it is exported for now because it is used by a\\n  // test in accounts-password.\\n  _storedLoginToken() {\\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\\n  };\\n\\n  _storedLoginTokenExpires() {\\n    return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n  };\\n\\n  _storedUserId() {\\n    return Meteor._localStorage.getItem(this.USER_ID_KEY);\\n  };\\n\\n  _unstoreLoginTokenIfExpiresSoon() {\\n    const tokenExpires = this._storedLoginTokenExpires();\\n    if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\\n      this._unstoreLoginToken();\\n    }\\n  };\\n\\n  ///\\n  /// AUTO-LOGIN\\n  ///\\n\\n  _initLocalStorage() {\\n    // Key names to use in localStorage\\n    this.LOGIN_TOKEN_KEY = \\\"Meteor.loginToken\\\";\\n    this.LOGIN_TOKEN_EXPIRES_KEY = \\\"Meteor.loginTokenExpires\\\";\\n    this.USER_ID_KEY = \\\"Meteor.userId\\\";\\n\\n    const rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\\n    if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\\n      // We want to keep using the same keys for existing apps that do not\\n      // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\\n      // to log in again after an app updates to a version of Meteor that\\n      // contains this code, but it's generally preferable to namespace the\\n      // keys so that connections from distinct apps to distinct DDP URLs\\n      // will be distinct in Meteor._localStorage.\\n      let namespace = `:${this.connection._stream.rawUrl}`;\\n      if (rootUrlPathPrefix) {\\n        namespace += `:${rootUrlPathPrefix}`;\\n      }\\n      this.LOGIN_TOKEN_KEY += namespace;\\n      this.LOGIN_TOKEN_EXPIRES_KEY += namespace;\\n      this.USER_ID_KEY += namespace;\\n    }\\n\\n    let token;\\n    if (this._autoLoginEnabled) {\\n      // Immediately try to log in via local storage, so that any DDP\\n      // messages are sent after we have established our user account\\n      this._unstoreLoginTokenIfExpiresSoon();\\n      token = this._storedLoginToken();\\n      if (token) {\\n        // On startup, optimistically present us as logged in while the\\n        // request is in flight. This reduces page flicker on startup.\\n        const userId = this._storedUserId();\\n        userId && this.connection.setUserId(userId);\\n        this.loginWithToken(token, err => {\\n          if (err) {\\n            Meteor._debug(`Error logging in with token: ${err}`);\\n            this.makeClientLoggedOut();\\n          }\\n\\n          this._pageLoadLogin({\\n            type: \\\"resume\\\",\\n            allowed: !err,\\n            error: err,\\n            methodName: \\\"login\\\",\\n            // XXX This is duplicate code with loginWithToken, but\\n            // loginWithToken can also be called at other times besides\\n            // page load.\\n            methodArguments: [{resume: token}]\\n          });\\n        });\\n      }\\n    }\\n\\n    // Poll local storage every 3 seconds to login if someone logged in in\\n    // another tab\\n    this._lastLoginTokenWhenPolled = token;\\n\\n    if (this._pollIntervalTimer) {\\n      // Unlikely that _initLocalStorage will be called more than once for\\n      // the same AccountsClient instance, but just in case...\\n      clearInterval(this._pollIntervalTimer);\\n    }\\n\\n    this._pollIntervalTimer = setInterval(() => {\\n      this._pollStoredLoginToken();\\n    }, 3000);\\n  };\\n\\n  _pollStoredLoginToken() {\\n    if (! this._autoLoginEnabled) {\\n      return;\\n    }\\n\\n    const currentLoginToken = this._storedLoginToken();\\n\\n    // != instead of !== just to make sure undefined and null are treated the same\\n    if (this._lastLoginTokenWhenPolled != currentLoginToken) {\\n      if (currentLoginToken) {\\n        this.loginWithToken(currentLoginToken, (err) => {\\n          if (err) {\\n            this.makeClientLoggedOut();\\n          }\\n        });\\n      } else {\\n        this.logout();\\n      }\\n    }\\n\\n    this._lastLoginTokenWhenPolled = currentLoginToken;\\n  };\\n\\n  ///\\n  /// URLS\\n  ///\\n\\n  _initUrlMatching() {\\n    // By default, allow the autologin process to happen.\\n    this._autoLoginEnabled = true;\\n  \\n    // We only support one callback per URL.\\n    this._accountsCallbacks = {};\\n  \\n    // Try to match the saved value of window.location.hash.\\n    this._attemptToMatchHash();\\n  };\\n  \\n  // Separate out this functionality for testing\\n  _attemptToMatchHash() {\\n    attemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\\n  };\\n\\n  /**\\n   * @summary Register a function to call when a reset password link is clicked\\n   * in an email sent by\\n   * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onResetPasswordLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword).\\n   * 2. `done`: A function to call when the password reset UI flow is complete. The normal\\n   * login process is suspended until this function is called, so that the\\n   * password for user A can be reset even if user B was logged in.\\n   * @locus Client\\n   */\\n  onResetPasswordLink(callback) {\\n    if (this._accountsCallbacks[\\\"reset-password\\\"]) {\\n      Meteor._debug(\\\"Accounts.onResetPasswordLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"reset-password\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an email verification link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEmailVerificationLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: An email verification token that can be passed to\\n   * [`Accounts.verifyEmail`](#accounts_verifyemail).\\n   * 2. `done`: A function to call when the email verification UI flow is complete.\\n   * The normal login process is suspended until this function is called, so\\n   * that the user can be notified that they are verifying their email before\\n   * being logged in.\\n   * @locus Client\\n   */\\n  onEmailVerificationLink(callback) {\\n    if (this._accountsCallbacks[\\\"verify-email\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEmailVerificationLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"verify-email\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an account enrollment link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEnrollmentLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\\n   * enrolled account a password.\\n   * 2. `done`: A function to call when the enrollment UI flow is complete.\\n   * The normal login process is suspended until this function is called, so that\\n   * user A can be enrolled even if user B was logged in.\\n   * @locus Client\\n   */\\n  onEnrollmentLink(callback) {\\n    if (this._accountsCallbacks[\\\"enroll-account\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEnrollmentLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"enroll-account\\\"] = callback;\\n  };\\n\\n};\\n\\n/**\\n * @summary True if a login method (such as `Meteor.loginWithPassword`, \\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in \\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingIn = () => Accounts.loggingIn();\\n\\n/**\\n * @summary True if a logout method (such as `Meteor.logout`) is currently in \\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingOut = () => Accounts.loggingOut();\\n\\n/**\\n * @summary Log the user out.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logout = callback => Accounts.logout(callback);\\n\\n/**\\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logoutOtherClients = callback => Accounts.logoutOtherClients(callback);\\n\\n/**\\n * @summary Login with a Meteor access token.\\n * @locus Client\\n * @param {Object} [token] Local storage token for use with login across \\n * multiple tabs in the same browser.\\n * @param {Function} [callback] Optional callback. Called with no arguments on\\n * success.\\n * @importFromPackage meteor\\n */\\nMeteor.loginWithToken = (token, callback) =>\\n  Accounts.loginWithToken(token, callback);\\n\\n///\\n/// HANDLEBARS HELPERS\\n///\\n\\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\\n// global helpers.\\nif (Package.blaze) {\\n  const { Template } = Package.blaze.Blaze;\\n\\n  /**\\n   * @global\\n   * @name  currentUser\\n   * @isHelper true\\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\\n   */\\n  Template.registerHelper('currentUser', () => Meteor.user());\\n\\n  /**\\n   * @global\\n   * @name  loggingIn\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\\n   */\\n  Template.registerHelper('loggingIn', () => Meteor.loggingIn());\\n\\n  /**\\n   * @global\\n   * @name  loggingOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper('loggingOut', () => Meteor.loggingOut());\\n\\n  /**\\n   * @global\\n   * @name  loggingInOrOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper(\\n    'loggingInOrOut', \\n    () => Meteor.loggingIn() || Meteor.loggingOut()\\n  );\\n}\\n\\nconst defaultSuccessHandler = function(token, urlPart) {\\n  // put login in a suspended state to wait for the interaction to finish\\n  this._autoLoginEnabled = false;\\n\\n  // wait for other packages to register callbacks\\n  Meteor.startup(() => {\\n    // if a callback has been registered for this kind of token, call it\\n    if (this._accountsCallbacks[urlPart]) {\\n      this._accountsCallbacks[urlPart](token, () => this._enableAutoLogin());\\n    }\\n  });\\n}\\n\\n// Note that both arguments are optional and are currently only passed by\\n// accounts_url_tests.js.\\nconst attemptToMatchHash = (accounts, hash, success) => {\\n  // All of the special hash URLs we support for accounts interactions\\n  [\\\"reset-password\\\", \\\"verify-email\\\", \\\"enroll-account\\\"].forEach(urlPart => {\\n    let token;\\n\\n    const tokenRegex = new RegExp(`^\\\\\\\\#\\\\\\\\/${urlPart}\\\\\\\\/(.*)$`);\\n    const match = hash.match(tokenRegex);\\n\\n    if (match) {\\n      token = match[1];\\n\\n      // XXX COMPAT WITH 0.9.3\\n      if (urlPart === \\\"reset-password\\\") {\\n        accounts._resetPasswordToken = token;\\n      } else if (urlPart === \\\"verify-email\\\") {\\n        accounts._verifyEmailToken = token;\\n      } else if (urlPart === \\\"enroll-account\\\") {\\n        accounts._enrollAccountToken = token;\\n      }\\n    } else {\\n      return;\\n    }\\n\\n    // If no handlers match the hash, then maybe it's meant to be consumed\\n    // by some entirely different code, so we only clear it the first time\\n    // a handler successfully matches. Note that later handlers reuse the\\n    // savedHash, so clearing window.location.hash here will not interfere\\n    // with their needs.\\n    window.location.hash = \\\"\\\";\\n\\n    // Do some stuff with the token we matched\\n    success.call(accounts, token, urlPart);\\n  });\\n}\\n\\n// Export for testing\\nexport const AccountsTest = {\\n  attemptToMatchHash: (hash, success) => \\n    attemptToMatchHash(Accounts, hash, success),\\n};\\n\",\"/**\\n * @summary Super-constructor for AccountsClient and AccountsServer.\\n * @locus Anywhere\\n * @class AccountsCommon\\n * @instancename accountsClientOrServer\\n * @param options {Object} an object with fields:\\n * - connection {Object} Optional DDP connection to reuse.\\n * - ddpUrl {String} Optional URL for creating a new DDP connection.\\n */\\nexport class AccountsCommon {\\n  constructor(options) {\\n    // Currently this is read directly by packages like accounts-password\\n    // and accounts-ui-unstyled.\\n    this._options = {};\\n\\n    // Note that setting this.connection = null causes this.users to be a\\n    // LocalCollection, which is not what we want.\\n    this.connection = undefined;\\n    this._initConnection(options || {});\\n\\n    // There is an allow call in accounts_server.js that restricts writes to\\n    // this collection.\\n    this.users = new Mongo.Collection(\\\"users\\\", {\\n      _preventAutopublish: true,\\n      connection: this.connection\\n    });\\n\\n    // Callback exceptions are printed with Meteor._debug and ignored.\\n    this._onLoginHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLogin callback\\\"\\n    });\\n\\n    this._onLoginFailureHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLoginFailure callback\\\"\\n    });\\n\\n    this._onLogoutHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: \\\"onLogout callback\\\"\\n    });\\n\\n    // Expose for testing.\\n    this.DEFAULT_LOGIN_EXPIRATION_DAYS = DEFAULT_LOGIN_EXPIRATION_DAYS;\\n    this.LOGIN_UNEXPIRING_TOKEN_DAYS = LOGIN_UNEXPIRING_TOKEN_DAYS;\\n\\n    // Thrown when the user cancels the login process (eg, closes an oauth\\n    // popup, declines retina scan, etc)\\n    const lceName = 'Accounts.LoginCancelledError';\\n    this.LoginCancelledError = Meteor.makeErrorType(\\n      lceName,\\n      function (description) {\\n        this.message = description;\\n      }\\n    );\\n    this.LoginCancelledError.prototype.name = lceName;\\n\\n    // This is used to transmit specific subclass errors over the wire. We\\n    // should come up with a more generic way to do this (eg, with some sort of\\n    // symbolic error code rather than a number).\\n    this.LoginCancelledError.numericError = 0x8acdc2f;\\n\\n    // loginServiceConfiguration and ConfigError are maintained for backwards compatibility\\n    Meteor.startup(() => {\\n      const { ServiceConfiguration } = Package['service-configuration'];\\n      this.loginServiceConfiguration = ServiceConfiguration.configurations;\\n      this.ConfigError = ServiceConfiguration.ConfigError;\\n    });\\n  }\\n\\n  /**\\n   * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  userId() {\\n    throw new Error(\\\"userId method not implemented\\\");\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  user() {\\n    const userId = this.userId();\\n    return userId ? this.users.findOne(userId) : null;\\n  }\\n\\n  // Set up config for the accounts system. Call this on both the client\\n  // and the server.\\n  //\\n  // Note that this method gets overridden on AccountsServer.prototype, but\\n  // the overriding method calls the overridden method.\\n  //\\n  // XXX we should add some enforcement that this is called on both the\\n  // client and the server. Otherwise, a user can\\n  // 'forbidClientAccountCreation' only on the client and while it looks\\n  // like their app is secure, the server will still accept createUser\\n  // calls. https://github.com/meteor/meteor/issues/828\\n  //\\n  // @param options {Object} an object with fields:\\n  // - sendVerificationEmail {Boolean}\\n  //     Send email address verification emails to new users created from\\n  //     client signups.\\n  // - forbidClientAccountCreation {Boolean}\\n  //     Do not allow clients to create accounts directly.\\n  // - restrictCreationByEmailDomain {Function or String}\\n  //     Require created users to have an email matching the function or\\n  //     having the string as domain.\\n  // - loginExpirationInDays {Number}\\n  //     Number of days since login until a user is logged out (login token\\n  //     expires).\\n  // - passwordResetTokenExpirationInDays {Number}\\n  //     Number of days since password reset token creation until the\\n  //     token cannt be used any longer (password reset token expires).\\n  // - ambiguousErrorMessages {Boolean}\\n  //     Return ambiguous error messages from login failures to prevent\\n  //     user enumeration.\\n  // - bcryptRounds {Number}\\n  //     Allows override of number of bcrypt rounds (aka work factor) used\\n  //     to store passwords.\\n\\n  /**\\n   * @summary Set global accounts options.\\n   * @locus Anywhere\\n   * @param {Object} options\\n   * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\\n   * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \\\"Create account\\\" link will not be available.\\n   * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\\n   * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\\n   * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specifed on the server.  See packages/oauth-encryption/README.md for details.\\n   * @param {Number} options.passwordResetTokenExpirationInDays The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.\\n   * @param {Number} options.passwordEnrollTokenExpirationInDays The number of days from when a link to set inital password is sent until token expires and user can't set password with the link anymore. Defaults to 30.\\n   * @param {Boolean} options.ambiguousErrorMessages Return ambiguous error messages from login failures to prevent user enumeration. Defaults to false.\\n   */\\n  config(options) {\\n    // We don't want users to accidentally only call Accounts.config on the\\n    // client, where some of the options will have partial effects (eg removing\\n    // the \\\"create account\\\" button from accounts-ui if forbidClientAccountCreation\\n    // is set, or redirecting Google login to a specific-domain page) without\\n    // having their full effects.\\n    if (Meteor.isServer) {\\n      __meteor_runtime_config__.accountsConfigCalled = true;\\n    } else if (!__meteor_runtime_config__.accountsConfigCalled) {\\n      // XXX would be nice to \\\"crash\\\" the client and replace the UI with an error\\n      // message, but there's no trivial way to do this.\\n      Meteor._debug(\\\"Accounts.config was called on the client but not on the \\\" +\\n                    \\\"server; some configuration options may not take effect.\\\");\\n    }\\n\\n    // We need to validate the oauthSecretKey option at the time\\n    // Accounts.config is called. We also deliberately don't store the\\n    // oauthSecretKey in Accounts._options.\\n    if (Object.prototype.hasOwnProperty.call(options, 'oauthSecretKey')) {\\n      if (Meteor.isClient) {\\n        throw new Error(\\\"The oauthSecretKey option may only be specified on the server\\\");\\n      }\\n      if (! Package[\\\"oauth-encryption\\\"]) {\\n        throw new Error(\\\"The oauth-encryption package must be loaded to set oauthSecretKey\\\");\\n      }\\n      Package[\\\"oauth-encryption\\\"].OAuthEncryption.loadKey(options.oauthSecretKey);\\n      options = { ...options };\\n      delete options.oauthSecretKey;\\n    }\\n\\n    // validate option keys\\n    const VALID_KEYS = [\\\"sendVerificationEmail\\\", \\\"forbidClientAccountCreation\\\", \\\"passwordEnrollTokenExpirationInDays\\\",\\n                      \\\"restrictCreationByEmailDomain\\\", \\\"loginExpirationInDays\\\", \\\"passwordResetTokenExpirationInDays\\\",\\n                      \\\"ambiguousErrorMessages\\\", \\\"bcryptRounds\\\"];\\n    Object.keys(options).forEach(key => {\\n      if (!VALID_KEYS.includes(key)) {\\n        throw new Error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    });\\n\\n    // set values in Accounts._options\\n    VALID_KEYS.forEach(key => {\\n      if (key in options) {\\n        if (key in this._options) {\\n          throw new Error(`Can't set \\\\`${key}\\\\` more than once`);\\n        }\\n        this._options[key] = options[key];\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when login is successful.\\n   *                        The callback receives a single object that\\n   *                        holds login details. This object contains the login\\n   *                        result type (password, resume, etc.) on both the\\n   *                        client and server. `onLogin` callbacks registered\\n   *                        on the server also receive extra data, such\\n   *                        as user details, connection information, etc.\\n   */\\n  onLogin(func) {\\n    return this._onLoginHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt fails.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called after the login has failed.\\n   */\\n  onLoginFailure(func) {\\n    return this._onLoginFailureHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a logout attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when logout is successful.\\n   */\\n  onLogout(func) {\\n    return this._onLogoutHook.register(func);\\n  }\\n\\n  _initConnection(options) {\\n    if (! Meteor.isClient) {\\n      return;\\n    }\\n\\n    // The connection used by the Accounts system. This is the connection\\n    // that will get logged in by Meteor.login(), and this is the\\n    // connection whose login state will be reflected by Meteor.userId().\\n    //\\n    // It would be much preferable for this to be in accounts_client.js,\\n    // but it has to be here because it's needed to create the\\n    // Meteor.users collection.\\n    if (options.connection) {\\n      this.connection = options.connection;\\n    } else if (options.ddpUrl) {\\n      this.connection = DDP.connect(options.ddpUrl);\\n    } else if (typeof __meteor_runtime_config__ !== \\\"undefined\\\" &&\\n               __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL) {\\n      // Temporary, internal hook to allow the server to point the client\\n      // to a different authentication server. This is for a very\\n      // particular use case that comes up when implementing a oauth\\n      // server. Unsupported and may go away at any point in time.\\n      //\\n      // We will eventually provide a general way to use account-base\\n      // against any DDP connection, not just one special one.\\n      this.connection =\\n        DDP.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL);\\n    } else {\\n      this.connection = Meteor.connection;\\n    }\\n  }\\n\\n  _getTokenLifetimeMs() {\\n    // When loginExpirationInDays is set to null, we'll use a really high\\n    // number of days (LOGIN_UNEXPIRABLE_TOKEN_DAYS) to simulate an\\n    // unexpiring token.\\n    const loginExpirationInDays =\\n      (this._options.loginExpirationInDays === null)\\n        ? LOGIN_UNEXPIRING_TOKEN_DAYS\\n        : this._options.loginExpirationInDays;\\n    return (loginExpirationInDays\\n        || DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _getPasswordResetTokenLifetimeMs() {\\n    return (this._options.passwordResetTokenExpirationInDays ||\\n            DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _getPasswordEnrollTokenLifetimeMs() {\\n    return (this._options.passwordEnrollTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\\n  }\\n\\n  _tokenExpiration(when) {\\n    // We pass when through the Date constructor for backwards compatibility;\\n    // `when` used to be a number.\\n    return new Date((new Date(when)).getTime() + this._getTokenLifetimeMs());\\n  }\\n\\n  _tokenExpiresSoon(when) {\\n    let minLifetimeMs = .1 * this._getTokenLifetimeMs();\\n    const minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\\n    if (minLifetimeMs > minLifetimeCapMs) {\\n      minLifetimeMs = minLifetimeCapMs;\\n    }\\n    return new Date() > (new Date(when) - minLifetimeMs);\\n  }\\n}\\n\\n// Note that Accounts is defined separately in accounts_client.js and\\n// accounts_server.js.\\n\\n/**\\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere but publish functions\\n * @importFromPackage meteor\\n */\\nMeteor.userId = () => Accounts.userId();\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere but publish functions\\n * @importFromPackage meteor\\n */\\nMeteor.user = () => Accounts.user();\\n\\n// how long (in days) until a login token expires\\nconst DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\\n// how long (in days) until reset password token expires\\nconst DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS = 3;\\n// how long (in days) until enrol password token expires\\nconst DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS = 30;\\n// Clients don't try to auto-login with a token that is going to expire within\\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\\n// Tries to avoid abrupt disconnects from expiring tokens.\\nconst MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\\n// how often (in milliseconds) we check for expired tokens\\nexport const EXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\\n// called\\nexport const CONNECTION_CLOSE_DELAY_MS = 10 * 1000;\\n// A large number of expiration days (approximately 100 years worth) that is\\n// used when creating unexpiring tokens.\\nconst LOGIN_UNEXPIRING_TOKEN_DAYS = 365 * 100;\\n\"]}","minifier":"terser"}