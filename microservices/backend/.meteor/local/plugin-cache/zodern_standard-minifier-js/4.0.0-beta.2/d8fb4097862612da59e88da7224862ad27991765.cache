{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,i=Package.meteor.meteorEnv,a=Package.tracker.Tracker,n=Package.tracker.Deps,r=Package.ejson.EJSON,s=Package.modules.meteorInstall,c=Package[\"babel-runtime\"].meteorBabelHelpers,o=Package.promise.Promise,u=Package[\"ecmascript-runtime-client\"].Symbol,l=Package[\"ecmascript-runtime-client\"].Map,f=Package[\"ecmascript-runtime-client\"].Set,d,h,k=s({node_modules:{meteor:{\"reactive-dict\":{\"migration.js\":function(t,i,a){var n;a.export({ReactiveDict:function(){return n}}),a.link(\"./reactive-dict\",{ReactiveDict:function(e){n=e}},0);var r=Object.prototype.hasOwnProperty;if(n._migratedDictData={},n._dictsToMigrate={},n._loadMigratedDict=function(e){if(r.call(n._migratedDictData,e)){var t=n._migratedDictData[e];return delete n._migratedDictData[e],t}return null},n._registerDictForMigrate=function(e,t){if(r.call(n._dictsToMigrate,e))throw new Error(\"Duplicate ReactiveDict name: \"+e);n._dictsToMigrate[e]=t},e.isClient&&Package.reload){var s=Package.reload.Reload._migrationData(\"reactive-dict\");s&&s.dicts&&(n._migratedDictData=s.dicts),Package.reload.Reload._onMigrate(\"reactive-dict\",function(){var e=n._dictsToMigrate,t={};for(var i in c.sanitizeForInObject(e))t[i]=e[i]._getMigrationData();return[!0,{dicts:t}]})}},\"reactive-dict.js\":function(t,i,n){var s,c=t(\"@babel/runtime/helpers/interopRequireDefault\")(t(\"@babel/runtime/helpers/typeof\"));n.export({ReactiveDict:function(){return d}});var o=Object.prototype.hasOwnProperty;function u(e){return void 0===e?\"undefined\":r.stringify(e)}function l(e){if(void 0!==e&&\"undefined\"!==e)return r.parse(e)}function f(e){e&&e.changed()}var d=function(){function t(i,n){if(this.keys={},i)if(\"string\"==typeof i){e.isClient&&t._registerDictForMigrate(i,this);var r=e.isClient&&t._loadMigratedDict(i);r?this.keys=r:this._setObject(n||{}),this.name=i}else{if(\"object\"!==(0,c.default)(i))throw new Error(\"Invalid ReactiveDict argument: \"+i);this._setObject(i)}else\"object\"===(0,c.default)(n)&&this._setObject(n);this.allDeps=new a.Dependency,this.keyDeps={},this.keyValueDeps={}}var i=t.prototype;return i.set=function(){function e(e,t){if(\"object\"!==(0,c.default)(e)||void 0!==t){var i=e;t=u(t);var a=o.call(this.keys,i),n=a?this.keys[i]:\"undefined\",r=t!==n;this.keys[i]=t,!r&&a||f(this.allDeps),r&&this.keyDeps&&(f(this.keyDeps[i]),this.keyValueDeps[i]&&(f(this.keyValueDeps[i][n]),f(this.keyValueDeps[i][t])))}else this._setObject(e)}return e}(),i.setDefault=function(){function e(e,t){if(\"object\"!==(0,c.default)(e)||void 0!==t){var i=e;o.call(this.keys,i)||this.set(i,t)}else this._setDefaultObject(e)}return e}(),i.get=function(){function e(e){return this._ensureKey(e),this.keyDeps[e].depend(),l(this.keys[e])}return e}(),i.equals=function(){function e(e,t){var i=this,n=null;if(Package.mongo&&(n=Package.mongo.Mongo.ObjectID),!(\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t||void 0===t||t instanceof Date||n&&t instanceof n||null===t))throw new Error(\"ReactiveDict.equals: value must be scalar\");var s=u(t),c;a.active&&(this._ensureKey(e),o.call(this.keyValueDeps[e],s)||(this.keyValueDeps[e][s]=new a.Dependency),this.keyValueDeps[e][s].depend()&&a.onInvalidate(function(){i.keyValueDeps[e][s].hasDependents()||delete i.keyValueDeps[e][s]}));var f=void 0;return o.call(this.keys,e)&&(f=l(this.keys[e])),r.equals(f,t)}return e}(),i.all=function(){function e(){var e=this;this.allDeps.depend();var t={};return Object.keys(this.keys).forEach(function(i){t[i]=l(e.keys[i])}),t}return e}(),i.clear=function(){function e(){var e=this,t=this.keys;this.keys={},this.allDeps.changed(),Object.keys(t).forEach(function(i){f(e.keyDeps[i]),e.keyValueDeps[i]&&(f(e.keyValueDeps[i][t[i]]),f(e.keyValueDeps[i][void 0]))})}return e}(),i.delete=function(){function e(e){var t=!1;if(o.call(this.keys,e)){var i=this.keys[e];delete this.keys[e],f(this.keyDeps[e]),this.keyValueDeps[e]&&(f(this.keyValueDeps[e][i]),f(this.keyValueDeps[e][void 0])),this.allDeps.changed(),t=!0}return t}return e}(),i.destroy=function(){function e(){this.clear(),this.name&&o.call(t._dictsToMigrate,this.name)&&delete t._dictsToMigrate[this.name]}return e}(),i._setObject=function(){function e(e){var t=this;Object.keys(e).forEach(function(i){t.set(i,e[i])})}return e}(),i._setDefaultObject=function(){function e(e){var t=this;Object.keys(e).forEach(function(i){t.setDefault(i,e[i])})}return e}(),i._ensureKey=function(){function e(e){e in this.keyDeps||(this.keyDeps[e]=new a.Dependency,this.keyValueDeps[e]={})}return e}(),i._getMigrationData=function(){function e(){return this.keys}return e}(),t}()}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/reactive-dict/migration.js\");Package._define(\"reactive-dict\",k,{ReactiveDict:void 0})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/reactive-dict/migration.js\",\"packages/reactive-dict/reactive-dict.js\"],\"names\":[\"ReactiveDict\",\"module\",\"export\",\"link\",\"v\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"_migratedDictData\",\"_dictsToMigrate\",\"_loadMigratedDict\",\"dictName\",\"call\",\"data\",\"_registerDictForMigrate\",\"dict\",\"Error\",\"Meteor\",\"isClient\",\"Package\",\"reload\",\"migrationData\",\"Reload\",\"_migrationData\",\"dicts\",\"_onMigrate\",\"dictsToMigrate\",\"dataToMigrate\",\"meteorBabelHelpers\",\"sanitizeForInObject\",\"_getMigrationData\",\"stringify\",\"value\",\"undefined\",\"EJSON\",\"parse\",\"serialized\",\"changed\",\"dictData\",\"this\",\"keys\",\"migratedData\",\"_setObject\",\"name\",\"_typeof2\",\"default\",\"allDeps\",\"Tracker\",\"Dependency\",\"keyDeps\",\"keyValueDeps\",\"set\",\"keyOrObject\",\"key\",\"keyExisted\",\"oldSerializedValue\",\"isNewValue\",\"setDefault\",\"_setDefaultObject\",\"get\",\"_ensureKey\",\"depend\",\"equals\",\"_this\",\"ObjectID\",\"mongo\",\"Mongo\",\"Date\",\"serializedValue\",\"isNew\",\"active\",\"onInvalidate\",\"hasDependents\",\"oldValue\",\"all\",\"_this2\",\"ret\",\"forEach\",\"clear\",\"_this3\",\"oldKeys\",\"delete\",\"_delete\",\"didRemove\",\"destroy\",\"object\",\"_this4\",\"_this5\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { ReactiveDict } from './reactive-dict';\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nReactiveDict._migratedDictData = {}; // name -> data\\nReactiveDict._dictsToMigrate = {}; // name -> ReactiveDict\\n\\nReactiveDict._loadMigratedDict = function (dictName) {\\n  if (hasOwn.call(ReactiveDict._migratedDictData, dictName)) {\\n    const data = ReactiveDict._migratedDictData[dictName];\\n    delete ReactiveDict._migratedDictData[dictName];\\n    return data;\\n  }\\n\\n  return null;\\n};\\n\\nReactiveDict._registerDictForMigrate = function (dictName, dict) {\\n  if (hasOwn.call(ReactiveDict._dictsToMigrate, dictName))\\n    throw new Error(\\\"Duplicate ReactiveDict name: \\\" + dictName);\\n\\n  ReactiveDict._dictsToMigrate[dictName] = dict;\\n};\\n\\nif (Meteor.isClient && Package.reload) {\\n  // Put old migrated data into ReactiveDict._migratedDictData,\\n  // where it can be accessed by ReactiveDict._loadMigratedDict.\\n  var migrationData = Package.reload.Reload._migrationData('reactive-dict');\\n  if (migrationData && migrationData.dicts)\\n    ReactiveDict._migratedDictData = migrationData.dicts;\\n\\n  // On migration, assemble the data from all the dicts that have been\\n  // registered.\\n  Package.reload.Reload._onMigrate('reactive-dict', function () {\\n    var dictsToMigrate = ReactiveDict._dictsToMigrate;\\n    var dataToMigrate = {};\\n\\n    for (var dictName in dictsToMigrate)\\n      dataToMigrate[dictName] = dictsToMigrate[dictName]._getMigrationData();\\n\\n    return [true, {dicts: dataToMigrate}];\\n  });\\n}\\n\\nexport { ReactiveDict };\\n\",\"const hasOwn = Object.prototype.hasOwnProperty;\\n\\n// XXX come up with a serialization method which canonicalizes object key\\n// order, which would allow us to use objects as values for equals.\\nfunction stringify(value) {\\n  if (value === undefined) {\\n    return 'undefined';\\n  }\\n  return EJSON.stringify(value);\\n}\\n\\nfunction parse(serialized) {\\n  if (serialized === undefined || serialized === 'undefined') {\\n    return undefined;\\n  }\\n  return EJSON.parse(serialized);\\n}\\n\\nfunction changed(v) {\\n  v && v.changed();\\n}\\n\\n// XXX COMPAT WITH 0.9.1 : accept migrationData instead of dictName\\n/**\\n * @class\\n * @instanceName ReactiveDict\\n * @summary Constructor for a ReactiveDict, which represents a reactive dictionary of key/value pairs.\\n * @locus Client\\n * @param {String} [name] Optional.  When a name is passed, preserves contents across Hot Code Pushes\\n * @param {Object} [initialValue] Optional.  The default values for the dictionary\\n */\\nexport class ReactiveDict {\\n  constructor(dictName, dictData) {\\n    // this.keys: key -> value\\n    this.keys = {};\\n\\n    if (dictName) {\\n      // name given; migration will be performed\\n      if (typeof dictName === 'string') {\\n        // the normal case, argument is a string name.\\n\\n        // Only run migration logic on client, it will cause\\n        // duplicate name errors on server during reloads.\\n        // _registerDictForMigrate will throw an error on duplicate name.\\n        Meteor.isClient && ReactiveDict._registerDictForMigrate(dictName, this);\\n        const migratedData = Meteor.isClient && ReactiveDict._loadMigratedDict(dictName);\\n\\n        if (migratedData) {\\n          // Don't stringify migrated data\\n          this.keys = migratedData;\\n        } else {\\n          // Use _setObject to make sure values are stringified\\n          this._setObject(dictData || {});\\n        }\\n        this.name = dictName;\\n      } else if (typeof dictName === 'object') {\\n        // back-compat case: dictName is actually migrationData\\n        // Use _setObject to make sure values are stringified\\n        this._setObject(dictName);\\n      } else {\\n        throw new Error(\\\"Invalid ReactiveDict argument: \\\" + dictName);\\n      }\\n    } else if (typeof dictData === 'object') {\\n      this._setObject(dictData);\\n    }\\n\\n    this.allDeps = new Tracker.Dependency;\\n    this.keyDeps = {}; // key -> Dependency\\n    this.keyValueDeps = {}; // key -> Dependency\\n  }\\n\\n  // set() began as a key/value method, but we are now overloading it\\n  // to take an object of key/value pairs, similar to backbone\\n  // http://backbonejs.org/#Model-set\\n  /**\\n   * @summary Set a value for a key in the ReactiveDict. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   * @param {String} key The key to set, eg, `selectedItem`\\n   * @param {EJSONable | undefined} value The new value for `key`\\n   */\\n  set(keyOrObject, value) {\\n    if ((typeof keyOrObject === 'object') && (value === undefined)) {\\n      // Called as `dict.set({...})`\\n      this._setObject(keyOrObject);\\n      return;\\n    }\\n    // the input isn't an object, so it must be a key\\n    // and we resume with the rest of the function\\n    const key = keyOrObject;\\n\\n    value = stringify(value);\\n\\n    const keyExisted = hasOwn.call(this.keys, key);\\n    const oldSerializedValue = keyExisted ? this.keys[key] : 'undefined';\\n    const isNewValue = (value !== oldSerializedValue);\\n\\n    this.keys[key] = value;\\n\\n    if (isNewValue || !keyExisted) {\\n      // Using the changed utility function here because this.allDeps might not exist yet,\\n      // when setting initial data from constructor\\n      changed(this.allDeps);\\n    }\\n\\n    // Don't trigger changes when setting initial data from constructor,\\n    // this.KeyDeps is undefined in this case\\n    if (isNewValue && this.keyDeps) {\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldSerializedValue]);\\n        changed(this.keyValueDeps[key][value]);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @summary Set a value for a key if it hasn't been set before.\\n   * Otherwise works exactly the same as [`ReactiveDict.set`](#ReactiveDict-set).\\n   * @locus Client\\n   * @param {String} key The key to set, eg, `selectedItem`\\n   * @param {EJSONable | undefined} value The new value for `key`\\n   */\\n  setDefault(keyOrObject, value) {\\n    if ((typeof keyOrObject === 'object') && (value === undefined)) {\\n      // Called as `dict.setDefault({...})`\\n      this._setDefaultObject(keyOrObject);\\n      return;\\n    }\\n    // the input isn't an object, so it must be a key\\n    // and we resume with the rest of the function\\n    const key = keyOrObject;\\n\\n    if (! hasOwn.call(this.keys, key)) {\\n      this.set(key, value);\\n    }\\n  }\\n\\n  /**\\n   * @summary Get the value assiciated with a key. If inside a [reactive\\n   * computation](#reactivity), invalidate the computation the next time the\\n   * value associated with this key is changed by\\n   * [`ReactiveDict.set`](#ReactiveDict-set).\\n   * This returns a clone of the value, so if it's an object or an array,\\n   * mutating the returned value has no effect on the value stored in the\\n   * ReactiveDict.\\n   * @locus Client\\n   * @param {String} key The key of the element to return\\n   */\\n  get(key) {\\n    this._ensureKey(key);\\n    this.keyDeps[key].depend();\\n    return parse(this.keys[key]);\\n  }\\n\\n  /**\\n   * @summary Test if the stored entry for a key is equal to a value. If inside a\\n   * [reactive computation](#reactivity), invalidate the computation the next\\n   * time the variable changes to or from the value.\\n   * @locus Client\\n   * @param {String} key The name of the session variable to test\\n   * @param {String | Number | Boolean | null | undefined} value The value to\\n   * test against\\n   */\\n  equals(key, value) {\\n    // Mongo.ObjectID is in the 'mongo' package\\n    let ObjectID = null;\\n    if (Package.mongo) {\\n      ObjectID = Package.mongo.Mongo.ObjectID;\\n    }\\n    // We don't allow objects (or arrays that might include objects) for\\n    // .equals, because JSON.stringify doesn't canonicalize object key\\n    // order. (We can make equals have the right return value by parsing the\\n    // current value and using EJSON.equals, but we won't have a canonical\\n    // element of keyValueDeps[key] to store the dependency.) You can still use\\n    // \\\"EJSON.equals(reactiveDict.get(key), value)\\\".\\n    //\\n    // XXX we could allow arrays as long as we recursively check that there\\n    // are no objects\\n    if (typeof value !== 'string' &&\\n        typeof value !== 'number' &&\\n        typeof value !== 'boolean' &&\\n        typeof value !== 'undefined' &&\\n        !(value instanceof Date) &&\\n        !(ObjectID && value instanceof ObjectID) &&\\n        value !== null) {\\n      throw new Error(\\\"ReactiveDict.equals: value must be scalar\\\");\\n    }\\n    const serializedValue = stringify(value);\\n\\n    if (Tracker.active) {\\n      this._ensureKey(key);\\n\\n      if (! hasOwn.call(this.keyValueDeps[key], serializedValue)) {\\n        this.keyValueDeps[key][serializedValue] = new Tracker.Dependency;\\n      }\\n\\n      var isNew = this.keyValueDeps[key][serializedValue].depend();\\n      if (isNew) {\\n        Tracker.onInvalidate(() => {\\n          // clean up [key][serializedValue] if it's now empty, so we don't\\n          // use O(n) memory for n = values seen ever\\n          if (! this.keyValueDeps[key][serializedValue].hasDependents()) {\\n            delete this.keyValueDeps[key][serializedValue];\\n          }\\n        });\\n      }\\n    }\\n\\n    let oldValue = undefined;\\n    if (hasOwn.call(this.keys, key)) {\\n      oldValue = parse(this.keys[key]);\\n    }\\n    return EJSON.equals(oldValue, value);\\n  }\\n\\n  /**\\n   * @summary Get all key-value pairs as a plain object. If inside a [reactive\\n   * computation](#reactivity), invalidate the computation the next time the\\n   * value associated with any key is changed by\\n   * [`ReactiveDict.set`](#ReactiveDict-set).\\n   * This returns a clone of each value, so if it's an object or an array,\\n   * mutating the returned value has no effect on the value stored in the\\n   * ReactiveDict.\\n   * @locus Client\\n   */\\n  all() {\\n    this.allDeps.depend();\\n    let ret = {};\\n    Object.keys(this.keys).forEach(key => {\\n      ret[key] = parse(this.keys[key]);\\n    });\\n    return ret;\\n  }\\n\\n  /**\\n   * @summary remove all key-value pairs from the ReactiveDict. Notify any\\n   * listeners that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   */\\n  clear() {\\n    const oldKeys = this.keys;\\n    this.keys = {};\\n\\n    this.allDeps.changed();\\n\\n    Object.keys(oldKeys).forEach(key => {\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldKeys[key]]);\\n        changed(this.keyValueDeps[key]['undefined']);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * @summary remove a key-value pair from the ReactiveDict. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   * @param {String} key The key to delete, eg, `selectedItem`\\n   */\\n  delete(key) {\\n    let didRemove = false;\\n\\n    if (hasOwn.call(this.keys, key)) {\\n      const oldValue = this.keys[key];\\n      delete this.keys[key];\\n      changed(this.keyDeps[key]);\\n      if (this.keyValueDeps[key]) {\\n        changed(this.keyValueDeps[key][oldValue]);\\n        changed(this.keyValueDeps[key]['undefined']);\\n      }\\n      this.allDeps.changed();\\n      didRemove = true;\\n    }\\n    return didRemove;\\n  }\\n\\n  /**\\n   * @summary Clear all values from the reactiveDict and prevent it from being\\n   * migrated on a Hot Code Pushes. Notify any listeners\\n   * that the value has changed (eg: redraw templates, and rerun any\\n   * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n   * [`ReactiveDict.get`](#ReactiveDict_get) on this `key`.)\\n   * @locus Client\\n   */\\n  destroy() {\\n    this.clear();\\n    if (this.name && hasOwn.call(ReactiveDict._dictsToMigrate, this.name)) {\\n      delete ReactiveDict._dictsToMigrate[this.name];\\n    }\\n  }\\n\\n  _setObject(object) {\\n    Object.keys(object).forEach(key => {\\n      this.set(key, object[key]);\\n    });\\n  }\\n\\n  _setDefaultObject(object) {\\n    Object.keys(object).forEach(key => {\\n      this.setDefault(key, object[key]);\\n    });\\n  }\\n\\n  _ensureKey(key) {\\n    if (!(key in this.keyDeps)) {\\n      this.keyDeps[key] = new Tracker.Dependency;\\n      this.keyValueDeps[key] = {};\\n    }\\n  }\\n\\n  // Get a JSON value that can be passed to the constructor to\\n  // create a new ReactiveDict with the same contents as this one\\n  _getMigrationData() {\\n    // XXX sanitize and make sure it's JSONible?\\n    return this.keys;\\n  }\\n}\\n\"]}","minifier":"terser"}