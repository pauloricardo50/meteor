{"code":"!function(){var e=Package.meteor.Meteor,t=Package.meteor.global,r=Package.meteor.meteorEnv,n=Package.minimongo.LocalCollection,o=Package.minimongo.Minimongo,i=Package.check.check,a=Package.check.Match,c=Package.ejson.EJSON,s=Package[\"ddp-client\"].DDP,l=Package.modules.meteorInstall,d=Package[\"babel-runtime\"].meteorBabelHelpers,u=Package.promise.Promise,f=Package[\"ecmascript-runtime-client\"].Symbol,h=Package[\"ecmascript-runtime-client\"].Map,_=Package[\"ecmascript-runtime-client\"].Set,v,m;l({node_modules:{meteor:{\"allow-deny\":{\"allow-deny.js\":function(){var t=Object.prototype.hasOwnProperty,r=(v={CollectionPrototype:{}}).CollectionPrototype;r.allow=function(e){u(this,\"allow\",e)},r.deny=function(e){u(this,\"deny\",e)},r._defineMutationMethods=function(r){var n=this;if(r=r||{},n._restricted=!1,n._insecure=void 0,n._validators={insert:{allow:[],deny:[]},update:{allow:[],deny:[]},remove:{allow:[],deny:[]},upsert:{allow:[],deny:[]},fetch:[],fetchAllFields:!1},n._name&&(n._prefix=\"/\"+n._name+\"/\",n._connection&&(n._connection===e.server||e.isClient))){var o={};[\"insert\",\"update\",\"remove\"].forEach(function(c){var s=n._prefix+c;if(r.useExisting){var l=e.isClient?\"_methodHandlers\":\"method_handlers\";if(n._connection[l]&&\"function\"==typeof n._connection[l][s])return}o[s]=function(){i(arguments,[a.Any]);var r=Array.from(arguments);try{var o=null;if(\"insert\"!==c||t.call(r[0],\"_id\")||(o=n._makeNewID()),this.isSimulation)return null!==o&&(r[0]._id=o),n._collection[c].apply(n._collection,r);if(\"insert\"!==c&&f(r[0],c),n._restricted){if(0===n._validators[c].allow.length)throw new e.Error(403,\"Access denied. No allow validators set on restricted collection for method '\"+c+\"'.\");var s=\"_validated\"+c.charAt(0).toUpperCase()+c.slice(1);return r.unshift(this.userId),\"insert\"===c&&r.push(o),n[s].apply(n,r)}if(n._isInsecure())return null!==o&&(r[0]._id=o),n._collection[c].apply(n._collection,r);throw new e.Error(403,\"Access denied\")}catch(t){throw\"MongoError\"===t.name||\"MinimongoError\"===t.name?new e.Error(409,t.toString()):t}}}),n._connection.methods(o)}},r._updateFetch=function(e){var t=this;if(!this._validators.fetchAllFields)if(e){var r=Object.create(null),n=function(e){return e&&e.forEach(function(e){return r[e]=1})};n(this._validators.fetch),n(e),this._validators.fetch=Object.keys(r)}else this._validators.fetchAllFields=!0,this._validators.fetch=null},r._isInsecure=function(){var e=this;return void 0===this._insecure?!!Package.insecure:this._insecure},r._validatedInsert=function(t,r,n){var o=this;if(this._validators.insert.deny.some(function(e){return e(t,d(e,r,n))}))throw new e.Error(403,\"Access denied\");if(this._validators.insert.allow.every(function(e){return!e(t,d(e,r,n))}))throw new e.Error(403,\"Access denied\");null!==n&&(r._id=n),this._collection.insert.call(this._collection,r)},r._validatedUpdate=function(r,a,c,s){var d=this;if(i(c,Object),s=Object.assign(Object.create(null),s),!n._selectorIsIdPerhapsAsObject(a))throw new Error(\"validated update should be of a single ID\");if(s.upsert)throw new e.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");var u=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",f=Object.keys(c),h={};if(0===f.length)throw new e.Error(403,u);f.forEach(function(r){var n=c[r];if(\"$\"!==r.charAt(0))throw new e.Error(403,u);if(!t.call(o,r))throw new e.Error(403,\"Access denied. Operator \"+r+\" not allowed in a restricted collection.\");Object.keys(n).forEach(function(e){-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),h[e]=!0})});var _=Object.keys(h),v={transform:null};this._validators.fetchAllFields||(v.fields={},this._validators.fetch.forEach(function(e){v.fields[e]=1}));var m=this._collection.findOne(a,v);if(!m)return 0;if(this._validators.update.deny.some(function(e){var t=l(e,m);return e(r,t,_,c)}))throw new e.Error(403,\"Access denied\");if(this._validators.update.allow.every(function(e){var t=l(e,m);return!e(r,t,_,c)}))throw new e.Error(403,\"Access denied\");return s._forbidReplace=!0,this._collection.update.call(this._collection,a,c,s)};var o={$inc:1,$set:1,$unset:1,$addToSet:1,$pop:1,$pullAll:1,$pull:1,$pushAll:1,$push:1,$bit:1};function l(e,t){return e.transform?e.transform(t):t}function d(e,t,r){var n=t;return e.transform&&(n=c.clone(t),null!==r&&(n._id=r),n=e.transform(n)),n}function u(e,r,o){var i=/^(?:insert|update|remove|fetch|transform)$/;if(Object.keys(o).forEach(function(e){if(!i.test(e))throw new Error(r+\": Invalid key: \"+e)}),e._restricted=!0,[\"insert\",\"update\",\"remove\"].forEach(function(i){if(t.call(o,i)){if(!(o[i]instanceof Function))throw new Error(r+\": Value for `\"+i+\"` must be a function\");void 0===o.transform?o[i].transform=e._transform:o[i].transform=n.wrapTransform(o.transform),e._validators[i][r].push(o[i])}}),o.update||o.remove||o.fetch){if(o.fetch&&!(o.fetch instanceof Array))throw new Error(r+\": Value for `fetch` must be an array\");e._updateFetch(o.fetch)}}function f(t,r){if(!n._selectorIsIdPerhapsAsObject(t))throw new e.Error(403,\"Not permitted. Untrusted code may only \"+r+\" documents by ID.\")}function h(){var e,t=(s._CurrentMethodInvocation||s._CurrentInvocation).get();return t&&t.isSimulation}r._validatedRemove=function(t,r){var n=this,o={transform:null};this._validators.fetchAllFields||(o.fields={},this._validators.fetch.forEach(function(e){o.fields[e]=1}));var i=this._collection.findOne(r,o);if(!i)return 0;if(this._validators.remove.deny.some(function(e){return e(t,l(e,i))}))throw new e.Error(403,\"Access denied\");if(this._validators.remove.allow.every(function(e){return!e(t,l(e,i))}))throw new e.Error(403,\"Access denied\");return this._collection.remove.call(this._collection,r)},r._callMutatorMethod=function(){function t(t,r,n){var o;!e.isClient||n||h()||(n=function(r){r&&e._debug(t+\" failed: \"+(r.reason||r.stack))}),(\"update\"===t||\"remove\"===t)&&!h()&&f(r[0],t);var i=this._prefix+t;return this._connection.apply(i,r,{returnStubValue:!0},n)}return t}()}}}}},{extensions:[\".js\",\".json\"]})(\"/node_modules/meteor/allow-deny/allow-deny.js\"),Package._define(\"allow-deny\",{AllowDeny:v})}();","sourcemap":"{\"version\":3,\"sources\":[\"packages/allow-deny/allow-deny.js\"],\"names\":[\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"CollectionPrototype\",\"AllowDeny\",\"allow\",\"options\",\"addValidator\",\"this\",\"deny\",\"_defineMutationMethods\",\"self\",\"_restricted\",\"_insecure\",\"undefined\",\"_validators\",\"insert\",\"update\",\"remove\",\"upsert\",\"fetch\",\"fetchAllFields\",\"_name\",\"_prefix\",\"_connection\",\"Meteor\",\"server\",\"isClient\",\"m\",\"forEach\",\"method\",\"methodName\",\"useExisting\",\"handlerPropName\",\"check\",\"arguments\",\"Match\",\"Any\",\"args\",\"Array\",\"from\",\"generatedId\",\"call\",\"_makeNewID\",\"isSimulation\",\"_id\",\"_collection\",\"apply\",\"throwIfSelectorIsNotId\",\"length\",\"Error\",\"validatedMethodName\",\"charAt\",\"toUpperCase\",\"slice\",\"unshift\",\"userId\",\"push\",\"_isInsecure\",\"e\",\"name\",\"toString\",\"methods\",\"_updateFetch\",\"fields\",\"union\",\"create\",\"add\",\"names\",\"keys\",\"Package\",\"insecure\",\"_validatedInsert\",\"doc\",\"some\",\"validator\",\"docToValidate\",\"every\",\"_validatedUpdate\",\"selector\",\"mutator\",\"assign\",\"LocalCollection\",\"_selectorIsIdPerhapsAsObject\",\"noReplaceError\",\"mutatorKeys\",\"modifiedFields\",\"op\",\"params\",\"ALLOWED_UPDATE_OPERATIONS\",\"field\",\"indexOf\",\"substring\",\"findOptions\",\"transform\",\"fieldName\",\"findOne\",\"factoriedDoc\",\"transformDoc\",\"_forbidReplace\",\"$inc\",\"$set\",\"$unset\",\"$addToSet\",\"$pop\",\"$pullAll\",\"$pull\",\"$pushAll\",\"$push\",\"$bit\",\"ret\",\"EJSON\",\"clone\",\"collection\",\"allowOrDeny\",\"validKeysRegEx\",\"key\",\"test\",\"Function\",\"_transform\",\"wrapTransform\",\"alreadyInSimulation\",\"CurrentInvocation\",\"enclosing\",\"DDP\",\"_CurrentMethodInvocation\",\"_CurrentInvocation\",\"get\",\"_validatedRemove\",\"_callMutatorMethod\",\"callback\",\"firstArgIsSelector\",\"err\",\"_debug\",\"reason\",\"stack\",\"mutatorMethodName\",\"returnStubValue\"],\"mappings\":\"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\",\"sourcesContent\":[\"///\\n/// Remote methods and access control.\\n///\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Restrict default mutators on collection. allow() and deny() take the\\n// same options:\\n//\\n// options.insert {Function(userId, doc)}\\n//   return true to allow/deny adding this document\\n//\\n// options.update {Function(userId, docs, fields, modifier)}\\n//   return true to allow/deny updating these documents.\\n//   `fields` is passed as an array of fields that are to be modified\\n//\\n// options.remove {Function(userId, docs)}\\n//   return true to allow/deny removing these documents\\n//\\n// options.fetch {Array}\\n//   Fields to fetch for these validators. If any call to allow or deny\\n//   does not have this option then all fields are loaded.\\n//\\n// allow and deny can be called multiple times. The validators are\\n// evaluated as follows:\\n// - If neither deny() nor allow() has been called on the collection,\\n//   then the request is allowed if and only if the \\\"insecure\\\" smart\\n//   package is in use.\\n// - Otherwise, if any deny() function returns true, the request is denied.\\n// - Otherwise, if any allow() function returns true, the request is allowed.\\n// - Otherwise, the request is denied.\\n//\\n// Meteor may call your deny() and allow() functions in any order, and may not\\n// call all of them if it is able to make a decision without calling them all\\n// (so don't include side effects).\\n\\nAllowDeny = {\\n  CollectionPrototype: {}\\n};\\n\\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\\n// methods\\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\\n\\n/**\\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\\n * @locus Server\\n * @method allow\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.allow = function(options) {\\n  addValidator(this, 'allow', options);\\n};\\n\\n/**\\n * @summary Override `allow` rules.\\n * @locus Server\\n * @method deny\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.deny = function(options) {\\n  addValidator(this, 'deny', options);\\n};\\n\\nCollectionPrototype._defineMutationMethods = function(options) {\\n  const self = this;\\n  options = options || {};\\n\\n  // set to true once we call any allow or deny methods. If true, use\\n  // allow/deny semantics. If false, use insecure mode semantics.\\n  self._restricted = false;\\n\\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\\n  // means insecure iff the insecure package is loaded. This property can be\\n  // overriden by tests or packages wishing to change insecure mode behavior of\\n  // their collections.\\n  self._insecure = undefined;\\n\\n  self._validators = {\\n    insert: {allow: [], deny: []},\\n    update: {allow: [], deny: []},\\n    remove: {allow: [], deny: []},\\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\\n    fetch: [],\\n    fetchAllFields: false\\n  };\\n\\n  if (!self._name)\\n    return; // anonymous collection\\n\\n  // XXX Think about method namespacing. Maybe methods should be\\n  // \\\"Meteor:Mongo:insert/NAME\\\"?\\n  self._prefix = '/' + self._name + '/';\\n\\n  // Mutation Methods\\n  // Minimongo on the server gets no stubs; instead, by default\\n  // it wait()s until its result is ready, yielding.\\n  // This matches the behavior of macromongo on the server better.\\n  // XXX see #MeteorServerNull\\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\\n    const m = {};\\n\\n    ['insert', 'update', 'remove'].forEach((method) => {\\n      const methodName = self._prefix + method;\\n\\n      if (options.useExisting) {\\n        const handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';\\n        // Do not try to create additional methods if this has already been called.\\n        // (Otherwise the .methods() call below will throw an error.)\\n        if (self._connection[handlerPropName] &&\\n          typeof self._connection[handlerPropName][methodName] === 'function') return;\\n      }\\n\\n      m[methodName] = function (/* ... */) {\\n        // All the methods do their own validation, instead of using check().\\n        check(arguments, [Match.Any]);\\n        const args = Array.from(arguments);\\n        try {\\n          // For an insert, if the client didn't specify an _id, generate one\\n          // now; because this uses DDP.randomStream, it will be consistent with\\n          // what the client generated. We generate it now rather than later so\\n          // that if (eg) an allow/deny rule does an insert to the same\\n          // collection (not that it really should), the generated _id will\\n          // still be the first use of the stream and will be consistent.\\n          //\\n          // However, we don't actually stick the _id onto the document yet,\\n          // because we want allow/deny rules to be able to differentiate\\n          // between arbitrary client-specified _id fields and merely\\n          // client-controlled-via-randomSeed fields.\\n          let generatedId = null;\\n          if (method === \\\"insert\\\" && !hasOwn.call(args[0], '_id')) {\\n            generatedId = self._makeNewID();\\n          }\\n\\n          if (this.isSimulation) {\\n            // In a client simulation, you can do any mutation (even with a\\n            // complex selector).\\n            if (generatedId !== null)\\n              args[0]._id = generatedId;\\n            return self._collection[method].apply(\\n              self._collection, args);\\n          }\\n\\n          // This is the server receiving a method call from the client.\\n\\n          // We don't allow arbitrary selectors in mutations from the client: only\\n          // single-ID selectors.\\n          if (method !== 'insert')\\n            throwIfSelectorIsNotId(args[0], method);\\n\\n          if (self._restricted) {\\n            // short circuit if there is no way it will pass.\\n            if (self._validators[method].allow.length === 0) {\\n              throw new Meteor.Error(\\n                403, \\\"Access denied. No allow validators set on restricted \\\" +\\n                  \\\"collection for method '\\\" + method + \\\"'.\\\");\\n            }\\n\\n            const validatedMethodName =\\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\\n            args.unshift(this.userId);\\n            method === 'insert' && args.push(generatedId);\\n            return self[validatedMethodName].apply(self, args);\\n          } else if (self._isInsecure()) {\\n            if (generatedId !== null)\\n              args[0]._id = generatedId;\\n            // In insecure mode, allow any mutation (with a simple selector).\\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\\n            //     we get from the network to this function, we should actually\\n            //     know the correct arguments for the function and pass just\\n            //     them.  For example, if you have an extraneous extra null\\n            //     argument and this is Mongo on the server, the .wrapAsync'd\\n            //     functions like update will get confused and pass the\\n            //     \\\"fut.resolver()\\\" in the wrong slot, where _update will never\\n            //     invoke it. Bam, broken DDP connection.  Probably should just\\n            //     take this whole method and write it three times, invoking\\n            //     helpers for the common code.\\n            return self._collection[method].apply(self._collection, args);\\n          } else {\\n            // In secure mode, if we haven't called allow or deny, then nothing\\n            // is permitted.\\n            throw new Meteor.Error(403, \\\"Access denied\\\");\\n          }\\n        } catch (e) {\\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {\\n            throw new Meteor.Error(409, e.toString());\\n          } else {\\n            throw e;\\n          }\\n        }\\n      };\\n    });\\n\\n    self._connection.methods(m);\\n  }\\n};\\n\\nCollectionPrototype._updateFetch = function (fields) {\\n  const self = this;\\n\\n  if (!self._validators.fetchAllFields) {\\n    if (fields) {\\n      const union = Object.create(null);\\n      const add = names => names && names.forEach(name => union[name] = 1);\\n      add(self._validators.fetch);\\n      add(fields);\\n      self._validators.fetch = Object.keys(union);\\n    } else {\\n      self._validators.fetchAllFields = true;\\n      // clear fetch just to make sure we don't accidentally read it\\n      self._validators.fetch = null;\\n    }\\n  }\\n};\\n\\nCollectionPrototype._isInsecure = function () {\\n  const self = this;\\n  if (self._insecure === undefined)\\n    return !!Package.insecure;\\n  return self._insecure;\\n};\\n\\nCollectionPrototype._validatedInsert = function (userId, doc,\\n                                                         generatedId) {\\n  const self = this;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.insert.deny.some((validator) => {\\n    return validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.insert.allow.every((validator) => {\\n    return !validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insert it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  self._collection.insert.call(self._collection, doc);\\n};\\n\\n// Simulate a mongo `update` operation while validating that the access\\n// control rules set by calls to `allow/deny` are satisfied. If all\\n// pass, rewrite the mongo operation to use $in to set the list of\\n// document ids to change ##ValidatedChange\\nCollectionPrototype._validatedUpdate = function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.update.deny.some((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return validator(userId,\\n                     factoriedDoc,\\n                     fields,\\n                     mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.update.allow.every((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return !validator(userId,\\n                      factoriedDoc,\\n                      fields,\\n                      mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.update.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\n// Only allow these operations in validated updates. Specifically\\n// whitelist operations, rather than blacklist, so new complex\\n// operations that are added aren't automatically allowed. A complex\\n// operation is one that does more than just modify its target\\n// field. For now this contains all update operations except '$rename'.\\n// http://docs.mongodb.org/manual/reference/operators/#update\\nconst ALLOWED_UPDATE_OPERATIONS = {\\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\\n  $pushAll:1, $push:1, $bit:1\\n};\\n\\n// Simulate a mongo `remove` operation while validating access control\\n// rules. See #ValidatedChange\\nCollectionPrototype._validatedRemove = function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.remove.deny.some((validator) => {\\n    return validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.remove.allow.every((validator) => {\\n    return !validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.remove.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\\n    // Client can't block, so it can't report errors by exception,\\n    // only by callback. If they forget the callback, give them a\\n    // default one that logs the error, so they aren't totally\\n    // baffled if their writes don't work because their database is\\n    // down.\\n    // Don't give a default callback in simulation, because inside stubs we\\n    // want to return the results from the local collection immediately and\\n    // not force a callback.\\n    callback = function (err) {\\n      if (err)\\n        Meteor._debug(name + \\\" failed: \\\" + (err.reason || err.stack));\\n    };\\n  }\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"update\\\" || name === \\\"remove\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.apply(\\n    mutatorMethodName, args, { returnStubValue: true }, callback);\\n}\\n\\nfunction transformDoc(validator, doc) {\\n  if (validator.transform)\\n    return validator.transform(doc);\\n  return doc;\\n}\\n\\nfunction docToValidate(validator, doc, generatedId) {\\n  let ret = doc;\\n  if (validator.transform) {\\n    ret = EJSON.clone(doc);\\n    // If you set a server-side transform on your collection, then you don't get\\n    // to tell the difference between \\\"client specified the ID\\\" and \\\"server\\n    // generated the ID\\\", because transforms expect to get _id.  If you want to\\n    // do that check, you can do it with a specific\\n    // `C.allow({insert: f, transform: null})` validator.\\n    if (generatedId !== null) {\\n      ret._id = generatedId;\\n    }\\n    ret = validator.transform(ret);\\n  }\\n  return ret;\\n}\\n\\nfunction addValidator(collection, allowOrDeny, options) {\\n  // validate keys\\n  const validKeysRegEx = /^(?:insert|update|remove|fetch|transform)$/;\\n  Object.keys(options).forEach((key) => {\\n    if (!validKeysRegEx.test(key))\\n      throw new Error(allowOrDeny + \\\": Invalid key: \\\" + key);\\n  });\\n\\n  collection._restricted = true;\\n\\n  ['insert', 'update', 'remove'].forEach((name) => {\\n    if (hasOwn.call(options, name)) {\\n      if (!(options[name] instanceof Function)) {\\n        throw new Error(allowOrDeny + \\\": Value for `\\\" + name + \\\"` must be a function\\\");\\n      }\\n\\n      // If the transform is specified at all (including as 'null') in this\\n      // call, then take that; otherwise, take the transform from the\\n      // collection.\\n      if (options.transform === undefined) {\\n        options[name].transform = collection._transform;  // already wrapped\\n      } else {\\n        options[name].transform = LocalCollection.wrapTransform(\\n          options.transform);\\n      }\\n\\n      collection._validators[name][allowOrDeny].push(options[name]);\\n    }\\n  });\\n\\n  // Only update the fetch fields if we're passed things that affect\\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\\n  // setting fetchAllFields\\n  if (options.update || options.remove || options.fetch) {\\n    if (options.fetch && !(options.fetch instanceof Array)) {\\n      throw new Error(allowOrDeny + \\\": Value for `fetch` must be an array\\\");\\n    }\\n    collection._updateFetch(options.fetch);\\n  }\\n}\\n\\nfunction throwIfSelectorIsNotId(selector, methodName) {\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n    throw new Meteor.Error(\\n      403, \\\"Not permitted. Untrusted code may only \\\" + methodName +\\n        \\\" documents by ID.\\\");\\n  }\\n};\\n\\n// Determine if we are in a DDP method simulation\\nfunction alreadyInSimulation() {\\n  var CurrentInvocation =\\n    DDP._CurrentMethodInvocation ||\\n    // For backwards compatibility, as explained in this issue:\\n    // https://github.com/meteor/meteor/issues/8947\\n    DDP._CurrentInvocation;\\n\\n  const enclosing = CurrentInvocation.get();\\n  return enclosing && enclosing.isSimulation;\\n}\\n\"]}","minifier":"terser"}