{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js","passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js"}},"code":"module.export({\n  default: () => PublicationEntry\n});\nlet ObservableCollection;\nmodule.link(\"./ObservableCollection\", {\n  default(v) {\n    ObservableCollection = v;\n  }\n\n}, 0);\nlet RedisSubscriber;\nmodule.link(\"../redis/RedisSubscriber\", {\n  default(v) {\n    RedisSubscriber = v;\n  }\n\n}, 1);\nlet Strategy;\nmodule.link(\"../constants\", {\n  Strategy(v) {\n    Strategy = v;\n  }\n\n}, 2);\nlet debug;\nmodule.link(\"../debug\", {\n  default(v) {\n    debug = v;\n  }\n\n}, 3);\nlet getStrategy;\nmodule.link(\"../processors\", {\n  getStrategy(v) {\n    getStrategy = v;\n  }\n\n}, 4);\nlet DDP;\nmodule.link(\"meteor/ddp-client\", {\n  DDP(v) {\n    DDP = v;\n  }\n\n}, 5);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 6);\nlet Config;\nmodule.link(\"../config\", {\n  default(v) {\n    Config = v;\n  }\n\n}, 7);\n\nclass PublicationEntry {\n  constructor(id, cursor, factory) {\n    this.id = id;\n    this.factory = factory;\n    this.cursor = cursor;\n    this.observers = [];\n    /**\n     * @var {ObservableCollection}\n     */\n\n    this.observableCollection = new ObservableCollection(this, cursor);\n    this.init();\n  }\n  /**\n   * Initializes subscriptions and the client image on the server\n   */\n\n\n  init() {\n    Package.facts && Package.facts.Facts.incrementServerFact('mongo-livedata', 'observe-multiplexers', 1);\n    const strategy = getStrategy(this.observableCollection.selector, this.observableCollection.options); // We do this because if we have dedicated channels, we may not need to interogate the db for eligibility\n\n    if (strategy === Strategy.DEDICATED_CHANNELS) {\n      let oc = this.observableCollection;\n\n      if (oc.selector._id) {\n        oc.__containsOtherSelectorsThanId = _.keys(oc.selector).length > 1;\n      }\n    }\n\n    this.redisSubscriber = new RedisSubscriber(this, strategy);\n  }\n  /**\n   * Handler for stopping the subscription\n   */\n\n\n  stop() {\n    Package.facts && Package.facts.Facts.incrementServerFact('mongo-livedata', 'observe-multiplexers', -1);\n    this.redisSubscriber.stop();\n    this.observableCollection.clearStore();\n  }\n  /**\n   * @param observer\n   */\n\n\n  addObserver(observer) {\n    Package.facts && Package.facts.Facts.incrementServerFact('mongo-livedata', 'observe-handles', 1);\n\n    if (observer.added) {\n      this._performInitialAddForObserver(observer);\n    }\n\n    this.observers.push(observer);\n  }\n  /**\n   * @param observer\n   */\n\n\n  removeObserver(observer) {\n    Package.facts && Package.facts.Facts.incrementServerFact('mongo-livedata', 'observe-handles', -1);\n    this.observers = _.without(this.observers, observer);\n\n    if (this.isObserversEmpty()) {\n      debug(`[PublicationEntry] No other observers for: ${this.id}. Stopping subscription to redis.`);\n      this.stop();\n      this.factory.remove(this.id);\n    }\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isObserversEmpty() {\n    return this.observers.length === 0;\n  }\n  /**\n   * @param action\n   * @param args\n   */\n\n\n  send(action, ...args) {\n    // The idea here is that if you are doing an optimistic-ui mutation from a method\n    // Before the method returns, it should write to the DDP's fence the changes\n    // otherwise with an optimistic ui you will get a flicker (insert client side, response from method => removed, insert again from redis later)\n    // So we will send added events in sync for the current observer, then defer the rest\n    // We should not worry about duplicates because when we send a latency compensated event\n    // We give it a random uuid, and if the listener of redis on this server gets a message with the last uuid, it will not process it\n    // If it's different, and it can still happen, it will process it again, changes are very small.\n    const invoke = DDP._CurrentInvocation.get();\n\n    if (invoke && invoke.connection && invoke.connection.id) {\n      // we send first to all watchers for invoke.connection.id\n      const currentId = invoke.connection.id;\n\n      const currentObservers = _.filter(this.observers, o => {\n        return o.connection && o.connection.id == currentId;\n      });\n\n      if (currentObservers.length) {\n        currentObservers.forEach(observer => {\n          observer[action].call(observer, ...args);\n        });\n      } // defer the rest so that the method yields quickly to the user, because we have applied it's changes.\n\n\n      Meteor.defer(() => {\n        this.observers.forEach(observer => {\n          if (!observer.connection || observer.connection.id != currentId) {\n            observer[action].call(observer, ...args);\n          }\n        });\n      });\n    } else {\n      this.observers.forEach(observer => {\n        observer[action].call(observer, ...args);\n      });\n    }\n  }\n  /**\n   * The first batch of documents that need to be added.\n   * @param observer\n   */\n\n\n  _performInitialAddForObserver(observer) {\n    debug('[PublicationEntry] Performing initial add for observer');\n    this.observableCollection.init();\n    this.observableCollection.store.forEach((doc, _id) => {\n      // prevents error if document was removed while the _.each is running\n      if (!doc) {\n        return;\n      }\n\n      observer.added.call(observer, this.observableCollection.collectionName, _id, doc);\n    });\n    debug('[PublicationEntry] Completed initial add for observer');\n  }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:redis-oplog/lib/cache/PublicationEntry.js"],"names":["module","export","default","PublicationEntry","ObservableCollection","link","v","RedisSubscriber","Strategy","debug","getStrategy","DDP","_","Config","constructor","id","cursor","factory","observers","observableCollection","init","Package","facts","Facts","incrementServerFact","strategy","selector","options","DEDICATED_CHANNELS","oc","_id","__containsOtherSelectorsThanId","keys","length","redisSubscriber","stop","clearStore","addObserver","observer","added","_performInitialAddForObserver","push","removeObserver","without","isObserversEmpty","remove","send","action","args","invoke","_CurrentInvocation","get","connection","currentId","currentObservers","filter","o","forEach","call","Meteor","defer","store","doc","collectionName"],"mappings":"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","sourcesContent":["import ObservableCollection from './ObservableCollection';\nimport RedisSubscriber from '../redis/RedisSubscriber';\nimport { Strategy } from '../constants';\nimport debug from '../debug';\nimport { getStrategy } from '../processors';\nimport { DDP } from 'meteor/ddp-client';\nimport { _ } from 'meteor/underscore';\nimport Config from '../config';\n\nexport default class PublicationEntry {\n    constructor(id, cursor, factory) {\n        this.id = id;\n        this.factory = factory;\n        this.cursor = cursor;\n        this.observers = [];\n\n        /**\n         * @var {ObservableCollection}\n         */\n        this.observableCollection = new ObservableCollection(this, cursor);\n\n        this.init();\n    }\n\n    /**\n     * Initializes subscriptions and the client image on the server\n     */\n    init() {\n        Package.facts &&\n            Package.facts.Facts.incrementServerFact(\n                'mongo-livedata',\n                'observe-multiplexers',\n                1\n            );\n\n        const strategy = getStrategy(\n            this.observableCollection.selector,\n            this.observableCollection.options\n        );\n\n        // We do this because if we have dedicated channels, we may not need to interogate the db for eligibility\n        if (strategy === Strategy.DEDICATED_CHANNELS) {\n            let oc = this.observableCollection;\n            if (oc.selector._id) {\n                oc.__containsOtherSelectorsThanId =\n                    _.keys(oc.selector).length > 1;\n            }\n        }\n\n        this.redisSubscriber = new RedisSubscriber(this, strategy);\n    }\n\n    /**\n     * Handler for stopping the subscription\n     */\n    stop() {\n        Package.facts &&\n            Package.facts.Facts.incrementServerFact(\n                'mongo-livedata',\n                'observe-multiplexers',\n                -1\n            );\n\n        this.redisSubscriber.stop();\n        this.observableCollection.clearStore();\n    }\n\n    /**\n     * @param observer\n     */\n    addObserver(observer) {\n        Package.facts &&\n            Package.facts.Facts.incrementServerFact(\n                'mongo-livedata',\n                'observe-handles',\n                1\n            );\n\n        if (observer.added) {\n            this._performInitialAddForObserver(observer);\n        }\n\n        this.observers.push(observer);\n    }\n\n    /**\n     * @param observer\n     */\n    removeObserver(observer) {\n        Package.facts &&\n            Package.facts.Facts.incrementServerFact(\n                'mongo-livedata',\n                'observe-handles',\n                -1\n            );\n\n        this.observers = _.without(this.observers, observer);\n\n        if (this.isObserversEmpty()) {\n            debug(\n                `[PublicationEntry] No other observers for: ${\n                    this.id\n                }. Stopping subscription to redis.`\n            );\n            this.stop();\n            this.factory.remove(this.id);\n        }\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isObserversEmpty() {\n        return this.observers.length === 0;\n    }\n\n    /**\n     * @param action\n     * @param args\n     */\n    send(action, ...args) {\n        // The idea here is that if you are doing an optimistic-ui mutation from a method\n        // Before the method returns, it should write to the DDP's fence the changes\n        // otherwise with an optimistic ui you will get a flicker (insert client side, response from method => removed, insert again from redis later)\n        // So we will send added events in sync for the current observer, then defer the rest\n        // We should not worry about duplicates because when we send a latency compensated event\n        // We give it a random uuid, and if the listener of redis on this server gets a message with the last uuid, it will not process it\n        // If it's different, and it can still happen, it will process it again, changes are very small.\n        const invoke = DDP._CurrentInvocation.get();\n\n        if (invoke && invoke.connection && invoke.connection.id) {\n            // we send first to all watchers for invoke.connection.id\n            const currentId = invoke.connection.id;\n\n            const currentObservers = _.filter(this.observers, o => {\n                return o.connection && o.connection.id == currentId;\n            });\n\n            if (currentObservers.length) {\n                currentObservers.forEach(observer => {\n                    observer[action].call(observer, ...args);\n                });\n            }\n\n            // defer the rest so that the method yields quickly to the user, because we have applied it's changes.\n            Meteor.defer(() => {\n                this.observers.forEach(observer => {\n                    if (\n                        !observer.connection ||\n                        observer.connection.id != currentId\n                    ) {\n                        observer[action].call(observer, ...args);\n                    }\n                });\n            });\n        } else {\n            this.observers.forEach(observer => {\n                observer[action].call(observer, ...args);\n            });\n        }\n    }\n\n    /**\n     * The first batch of documents that need to be added.\n     * @param observer\n     */\n    _performInitialAddForObserver(observer) {\n        debug('[PublicationEntry] Performing initial add for observer');\n\n        this.observableCollection.init();\n\n        this.observableCollection.store.forEach((doc, _id) => {\n            // prevents error if document was removed while the _.each is running\n            if (!doc) {\n                return;\n            }\n            observer.added.call(\n                observer,\n                this.observableCollection.collectionName,\n                _id,\n                doc\n            );\n        });\n\n        debug('[PublicationEntry] Completed initial add for observer');\n    }\n}\n"]},"sourceType":"script","hash":"c34810b5dfbaea54c08cd3c2dbf93dc4b7ab7a2e"}
