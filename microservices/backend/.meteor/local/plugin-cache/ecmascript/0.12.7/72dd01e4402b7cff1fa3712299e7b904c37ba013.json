{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/formArrayHelpers.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties",["flow",{}],"jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"imports/core/utils/formArrayHelpers.js","filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/formArrayHelpers.js","inputSourceMap":{"version":3,"sources":["imports/core/utils/formArrayHelpers.js"],"names":["get","arrayify","simpleHash","getCurrentValue","input","doc","id","formFieldType","condition","required","disabled","type","shouldCountField","formField","undefined","conditionalInputIsTriggered","rootField","inputs","conditionalTrueValue","getCountedArray","formArray","shouldCountAllFields","arr","forEach","i","push","fieldIsValid","field","currentValue","Array","isArray","length","getMissingFieldIds","reduce","missingFieldIds","conditionalField","additionalFields","missingConditionalFields","additionalField","getFormValuesHash","values","getFormValuesHashMultiple","combos","tot"],"mappings":"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","sourcesContent":["// @flow\nimport get from 'lodash/get';\n\nimport { arrayify, simpleHash } from './general';\n\n// Returns the current value of an autoForm input\nconst getCurrentValue = (input, doc) => get(doc, input.id);\n\ntype formFieldType = {\n  condition?: boolean,\n  required?: boolean,\n  disabled?: boolean,\n  type: string,\n};\n\n// shouldCountField - A boolean to determine if a field in an array\n// should be counted or not\nexport const shouldCountField = (formField: formFieldType) =>\n  (formField.condition === undefined || formField.condition === true)\n  && formField.required !== false\n  && !formField.disabled\n  && formField.type !== 'h3';\n\nconst conditionalInputIsTriggered = (rootField, doc) =>\n  getCurrentValue(rootField.inputs[0], doc) === rootField.conditionalTrueValue;\n\n// getCountedArray - Returns an array of values that are mandatory and should\n// be counted to determine a completion percentage of a form\nexport const getCountedArray = (formArray, doc, shouldCountAllFields) => {\n  const arr = [];\n\n  formArray.forEach((i) => {\n    if (shouldCountAllFields || shouldCountField(i)) {\n      if (i.type === 'conditionalInput') {\n        if (conditionalInputIsTriggered(i, doc)) {\n          // If the conditional input is triggering the next input, add all values\n          i.inputs.forEach((input) => {\n            if (shouldCountField(input)) {\n              arr.push(getCurrentValue(input, doc));\n            }\n          });\n        } else {\n          // If conditional value is not triggering\n          arr.push(getCurrentValue(i.inputs[0], doc));\n        }\n      } else {\n        arr.push(getCurrentValue(i, doc));\n      }\n    }\n  });\n\n  return arr;\n};\n\nconst fieldIsValid = (field, doc) => {\n  const currentValue = getCurrentValue(field, doc);\n\n  if (Array.isArray(currentValue)) {\n    return currentValue.length > 0;\n  }\n\n  return currentValue !== undefined;\n};\n\n// Returns a list of fields that are missing from the doc, given a form array\n// Helps you know which fields still need to be filled\nexport const getMissingFieldIds = (formArray, doc) =>\n  formArray.reduce((missingFieldIds, field) => {\n    const { type, id, inputs } = field;\n    if (!shouldCountField(field)) {\n      return missingFieldIds;\n    }\n\n    if (type === 'conditionalInput') {\n      const [conditionalField, ...additionalFields] = inputs;\n      if (conditionalInputIsTriggered(field, doc)) {\n        return [\n          ...missingFieldIds,\n          ...additionalFields.reduce(\n            (missingConditionalFields, additionalField) => {\n              if (\n                fieldIsValid(additionalField, doc)\n                || !shouldCountField(additionalField)\n              ) {\n                return missingConditionalFields;\n              }\n\n              return [...missingConditionalFields, additionalField.id];\n            },\n            [],\n          ),\n        ];\n      }\n\n      if (!fieldIsValid(conditionalField, doc)) {\n        return [...missingFieldIds, conditionalField.id];\n      }\n\n      return missingFieldIds;\n    }\n\n    if (!fieldIsValid(field, doc)) {\n      return [...missingFieldIds, id];\n    }\n\n    return missingFieldIds;\n  }, []);\n\n/**\n * Returns the hash of a form's values\n *\n * @param {Array} formArray\n * @param {Object} doc\n * @returns {Number} 32-bit integer hash\n */\nexport const getFormValuesHash = (formArray, doc) => {\n  const values = getCountedArray(formArray, doc, true);\n\n  return simpleHash(values);\n};\n\n// Sums multiple hashes together from multiple forms\nexport const getFormValuesHashMultiple = combos =>\n  combos.reduce(\n    (tot, { formArray, doc }) => tot + getFormValuesHash(formArray, doc),\n    0,\n  );\n"]},"passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/formArrayHelpers.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/core/utils/formArrayHelpers.js"}},"code":"module.export({\n  shouldCountField: () => shouldCountField,\n  getCountedArray: () => getCountedArray,\n  getMissingFieldIds: () => getMissingFieldIds,\n  getFormValuesHash: () => getFormValuesHash,\n  getFormValuesHashMultiple: () => getFormValuesHashMultiple\n});\nlet get;\nmodule.link(\"lodash/get\", {\n  default(v) {\n    get = v;\n  }\n\n}, 0);\nlet arrayify, simpleHash;\nmodule.link(\"./general\", {\n  arrayify(v) {\n    arrayify = v;\n  },\n\n  simpleHash(v) {\n    simpleHash = v;\n  }\n\n}, 1);\n\n// Returns the current value of an autoForm input\nconst getCurrentValue = (input, doc) => get(doc, input.id);\n\nconst shouldCountField = formField => (formField.condition === undefined || formField.condition === true) && formField.required !== false && !formField.disabled && formField.type !== 'h3';\n\nconst conditionalInputIsTriggered = (rootField, doc) => getCurrentValue(rootField.inputs[0], doc) === rootField.conditionalTrueValue; // getCountedArray - Returns an array of values that are mandatory and should\n// be counted to determine a completion percentage of a form\n\n\nconst getCountedArray = (formArray, doc, shouldCountAllFields) => {\n  const arr = [];\n  formArray.forEach(i => {\n    if (shouldCountAllFields || shouldCountField(i)) {\n      if (i.type === 'conditionalInput') {\n        if (conditionalInputIsTriggered(i, doc)) {\n          // If the conditional input is triggering the next input, add all values\n          i.inputs.forEach(input => {\n            if (shouldCountField(input)) {\n              arr.push(getCurrentValue(input, doc));\n            }\n          });\n        } else {\n          // If conditional value is not triggering\n          arr.push(getCurrentValue(i.inputs[0], doc));\n        }\n      } else {\n        arr.push(getCurrentValue(i, doc));\n      }\n    }\n  });\n  return arr;\n};\n\nconst fieldIsValid = (field, doc) => {\n  const currentValue = getCurrentValue(field, doc);\n\n  if (Array.isArray(currentValue)) {\n    return currentValue.length > 0;\n  }\n\n  return currentValue !== undefined;\n}; // Returns a list of fields that are missing from the doc, given a form array\n// Helps you know which fields still need to be filled\n\n\nconst getMissingFieldIds = (formArray, doc) => formArray.reduce((missingFieldIds, field) => {\n  const {\n    type,\n    id,\n    inputs\n  } = field;\n\n  if (!shouldCountField(field)) {\n    return missingFieldIds;\n  }\n\n  if (type === 'conditionalInput') {\n    const [conditionalField, ...additionalFields] = inputs;\n\n    if (conditionalInputIsTriggered(field, doc)) {\n      return [...missingFieldIds, ...additionalFields.reduce((missingConditionalFields, additionalField) => {\n        if (fieldIsValid(additionalField, doc) || !shouldCountField(additionalField)) {\n          return missingConditionalFields;\n        }\n\n        return [...missingConditionalFields, additionalField.id];\n      }, [])];\n    }\n\n    if (!fieldIsValid(conditionalField, doc)) {\n      return [...missingFieldIds, conditionalField.id];\n    }\n\n    return missingFieldIds;\n  }\n\n  if (!fieldIsValid(field, doc)) {\n    return [...missingFieldIds, id];\n  }\n\n  return missingFieldIds;\n}, []);\n\nconst getFormValuesHash = (formArray, doc) => {\n  const values = getCountedArray(formArray, doc, true);\n  return simpleHash(values);\n};\n\nconst getFormValuesHashMultiple = combos => combos.reduce((tot, {\n  formArray,\n  doc\n}) => tot + getFormValuesHash(formArray, doc), 0);","map":{"version":3,"sources":["imports/core/utils/formArrayHelpers.js"],"names":["getCurrentValue","get","input","shouldCountField","formField","conditionalInputIsTriggered","rootField","getCountedArray","arr","formArray","i","shouldCountAllFields","fieldIsValid","currentValue","Array","getMissingFieldIds","inputs","type","additionalField","conditionalField","getFormValuesHash","values","simpleHash","getFormValuesHashMultiple","combos","doc","tot"],"mappings":"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","sourcesContent":["// @flow\nimport get from 'lodash/get';\n\nimport { arrayify, simpleHash } from './general';\n\n// Returns the current value of an autoForm input\nconst getCurrentValue = (input, doc) => get(doc, input.id);\n\ntype formFieldType = {\n  condition?: boolean,\n  required?: boolean,\n  disabled?: boolean,\n  type: string,\n};\n\n// shouldCountField - A boolean to determine if a field in an array\n// should be counted or not\nexport const shouldCountField = (formField: formFieldType) =>\n  (formField.condition === undefined || formField.condition === true)\n  && formField.required !== false\n  && !formField.disabled\n  && formField.type !== 'h3';\n\nconst conditionalInputIsTriggered = (rootField, doc) =>\n  getCurrentValue(rootField.inputs[0], doc) === rootField.conditionalTrueValue;\n\n// getCountedArray - Returns an array of values that are mandatory and should\n// be counted to determine a completion percentage of a form\nexport const getCountedArray = (formArray, doc, shouldCountAllFields) => {\n  const arr = [];\n\n  formArray.forEach((i) => {\n    if (shouldCountAllFields || shouldCountField(i)) {\n      if (i.type === 'conditionalInput') {\n        if (conditionalInputIsTriggered(i, doc)) {\n          // If the conditional input is triggering the next input, add all values\n          i.inputs.forEach((input) => {\n            if (shouldCountField(input)) {\n              arr.push(getCurrentValue(input, doc));\n            }\n          });\n        } else {\n          // If conditional value is not triggering\n          arr.push(getCurrentValue(i.inputs[0], doc));\n        }\n      } else {\n        arr.push(getCurrentValue(i, doc));\n      }\n    }\n  });\n\n  return arr;\n};\n\nconst fieldIsValid = (field, doc) => {\n  const currentValue = getCurrentValue(field, doc);\n\n  if (Array.isArray(currentValue)) {\n    return currentValue.length > 0;\n  }\n\n  return currentValue !== undefined;\n};\n\n// Returns a list of fields that are missing from the doc, given a form array\n// Helps you know which fields still need to be filled\nexport const getMissingFieldIds = (formArray, doc) =>\n  formArray.reduce((missingFieldIds, field) => {\n    const { type, id, inputs } = field;\n    if (!shouldCountField(field)) {\n      return missingFieldIds;\n    }\n\n    if (type === 'conditionalInput') {\n      const [conditionalField, ...additionalFields] = inputs;\n      if (conditionalInputIsTriggered(field, doc)) {\n        return [\n          ...missingFieldIds,\n          ...additionalFields.reduce(\n            (missingConditionalFields, additionalField) => {\n              if (\n                fieldIsValid(additionalField, doc)\n                || !shouldCountField(additionalField)\n              ) {\n                return missingConditionalFields;\n              }\n\n              return [...missingConditionalFields, additionalField.id];\n            },\n            [],\n          ),\n        ];\n      }\n\n      if (!fieldIsValid(conditionalField, doc)) {\n        return [...missingFieldIds, conditionalField.id];\n      }\n\n      return missingFieldIds;\n    }\n\n    if (!fieldIsValid(field, doc)) {\n      return [...missingFieldIds, id];\n    }\n\n    return missingFieldIds;\n  }, []);\n\n/**\n * Returns the hash of a form's values\n *\n * @param {Array} formArray\n * @param {Object} doc\n * @returns {Number} 32-bit integer hash\n */\nexport const getFormValuesHash = (formArray, doc) => {\n  const values = getCountedArray(formArray, doc, true);\n\n  return simpleHash(values);\n};\n\n// Sums multiple hashes together from multiple forms\nexport const getFormValuesHashMultiple = combos =>\n  combos.reduce(\n    (tot, { formArray, doc }) => tot + getFormValuesHash(formArray, doc),\n    0,\n  );\n"]},"sourceType":"script","hash":"72dd01e4402b7cff1fa3712299e7b904c37ba013"}
