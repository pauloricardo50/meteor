{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js","passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js"}},"code":"module.export({\n  default: () => validatedUpdate\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 1);\nlet LocalCollection;\nmodule.link(\"meteor/minimongo\", {\n  LocalCollection(v) {\n    LocalCollection = v;\n  }\n\n}, 2);\nlet check;\nmodule.link(\"meteor/check\", {\n  check(v) {\n    check = v;\n  }\n\n}, 3);\nlet transformDoc;\nmodule.link(\"./transformDoc\", {\n  default(v) {\n    transformDoc = v;\n  }\n\n}, 4);\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc: 1,\n  $set: 1,\n  $unset: 1,\n  $addToSet: 1,\n  $pop: 1,\n  $pullAll: 1,\n  $pull: 1,\n  $pushAll: 1,\n  $push: 1,\n  $bit: 1 // Simulate a mongo `update` operation while validating that the access\n  // control rules set by calls to `allow/deny` are satisfied. If all\n  // pass, rewrite the mongo operation to use $in to set the list of\n  // document ids to change ##ValidatedChange\n\n};\n\nfunction validatedUpdate(userId, selector, mutator, options) {\n  check(mutator, Object);\n  options = _.clone(options) || {};\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Error('validated update should be of a single ID');\n  } // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n\n\n  if (options.upsert) {\n    throw new Meteor.Error(403, 'Access denied. Upserts not ' + 'allowed in a restricted collection.');\n  }\n\n  const noReplaceError = 'Access denied. In a restricted collection you can only' + ' update documents, not replace them. Use a Mongo update operator, such ' + \"as '$set'.\"; // compute modified fields\n\n  const fields = [];\n\n  if (_.isEmpty(mutator)) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n\n  _.each(mutator, (params, op) => {\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(403, `Access denied. Operator ${op} not allowed in a restricted collection.`);\n    } else {\n      _.each(_.keys(params), field => {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1) {\n          field = field.substring(0, field.indexOf('.'));\n        } // record the field we are trying to change\n\n\n        if (!_.contains(fields, field)) {\n          fields.push(field);\n        }\n      });\n    }\n  });\n\n  const findOptions = {\n    transform: null\n  };\n\n  if (!this._validators.fetchAllFields) {\n    findOptions.fields = {};\n\n    _.each(this._validators.fetch, fieldName => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = this._collection.findOne(selector, findOptions);\n\n  if (!doc) {\n    // none satisfied!\n    return 0;\n  } // call user validators.\n  // Any deny returns true means denied.\n\n\n  if (_.any(this._validators.update.deny, validator => {\n    const factoriedDoc = transformDoc(validator, doc);\n    return validator(userId, factoriedDoc, fields, mutator);\n  })) {\n    throw new Meteor.Error(403, 'Access denied');\n  } // Any allow returns true means proceed. Throw error if they all fail.\n\n\n  if (_.all(this._validators.update.allow, validator => {\n    const factoriedDoc = transformDoc(validator, doc);\n    return !validator(userId, factoriedDoc, fields, mutator);\n  })) {\n    throw new Meteor.Error(403, 'Access denied');\n  }\n\n  options._forbidReplace = true; // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return this.update(selector, mutator, _.extend(options, {\n    optimistic: true\n  }));\n}","map":{"version":3,"sources":["packages/cultofcoders:redis-oplog/lib/mongo/allow-deny/validatedUpdate.js"],"names":["module","export","default","validatedUpdate","Meteor","link","v","_","LocalCollection","check","transformDoc","ALLOWED_UPDATE_OPERATIONS","$inc","$set","$unset","$addToSet","$pop","$pullAll","$pull","$pushAll","$push","$bit","userId","selector","mutator","options","Object","clone","_selectorIsIdPerhapsAsObject","Error","upsert","noReplaceError","fields","isEmpty","each","params","op","charAt","has","keys","field","indexOf","substring","contains","push","findOptions","transform","_validators","fetchAllFields","fetch","fieldName","doc","_collection","findOne","any","update","deny","validator","factoriedDoc","all","allow","_forbidReplace","extend","optimistic"],"mappings":"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","sourcesContent":["/* eslint no-param-reassign: 0 no-underscore-dangle: 0 */\nimport {Meteor} from 'meteor/meteor'\nimport {_} from 'meteor/underscore'\nimport {LocalCollection} from 'meteor/minimongo'\nimport {check} from 'meteor/check'\nimport transformDoc from './transformDoc'\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n    $inc: 1,\n    $set: 1,\n    $unset: 1,\n    $addToSet: 1,\n    $pop: 1,\n    $pullAll: 1,\n    $pull: 1,\n    $pushAll: 1,\n    $push: 1,\n    $bit: 1,\n}\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nexport default function validatedUpdate(userId, selector, mutator, options) {\n    check(mutator, Object)\n    options = _.clone(options) || {}\n\n    if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n        throw new Error('validated update should be of a single ID')\n    }\n\n    // We don't support upserts because they don't fit nicely into allow/deny\n    // rules.\n    if (options.upsert) {\n        throw new Meteor.Error(403, 'Access denied. Upserts not ' +\n            'allowed in a restricted collection.')\n    }\n\n    const noReplaceError = 'Access denied. In a restricted collection you can only' +\n        ' update documents, not replace them. Use a Mongo update operator, such ' +\n        \"as '$set'.\"\n\n    // compute modified fields\n    const fields = []\n    if (_.isEmpty(mutator)) {\n        throw new Meteor.Error(403, noReplaceError)\n    }\n    _.each(mutator, (params, op) => {\n        if (op.charAt(0) !== '$') {\n            throw new Meteor.Error(403, noReplaceError)\n        } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n            throw new Meteor.Error(\n                403, `Access denied. Operator ${op} not allowed in a restricted collection.`)\n        } else {\n            _.each(_.keys(params), field => {\n                // treat dotted fields as if they are replacing their\n                // top-level part\n                if (field.indexOf('.') !== -1) {\n                    field = field.substring(0, field.indexOf('.'))\n                }\n\n                // record the field we are trying to change\n                if (!_.contains(fields, field)) {\n                    fields.push(field)\n                }\n            })\n        }\n    })\n\n    const findOptions = {transform: null}\n    if (!this._validators.fetchAllFields) {\n        findOptions.fields = {}\n        _.each(this._validators.fetch, fieldName => {\n            findOptions.fields[fieldName] = 1\n        })\n    }\n\n    const doc = this._collection.findOne(selector, findOptions)\n    if (!doc) { // none satisfied!\n        return 0\n    }\n\n    // call user validators.\n    // Any deny returns true means denied.\n    if (_.any(this._validators.update.deny, validator => {\n            const factoriedDoc = transformDoc(validator, doc)\n            return validator(userId,\n                factoriedDoc,\n                fields,\n                mutator)\n        })) {\n        throw new Meteor.Error(403, 'Access denied')\n    }\n    // Any allow returns true means proceed. Throw error if they all fail.\n    if (_.all(this._validators.update.allow, validator => {\n            const factoriedDoc = transformDoc(validator, doc)\n            return !validator(userId,\n                factoriedDoc,\n                fields,\n                mutator)\n        })) {\n        throw new Meteor.Error(403, 'Access denied')\n    }\n\n    options._forbidReplace = true\n\n    // Back when we supported arbitrary client-provided selectors, we actually\n    // rewrote the selector to include an _id clause before passing to Mongo to\n    // avoid races, but since selector is guaranteed to already just be an ID, we\n    // don't have to any more.\n\n    return this.update(selector, mutator, _.extend(options, {\n        optimistic: true\n    }))\n}\n"]},"sourceType":"script","hash":"a637687679183ef99b57a4313c7973ce7a884fcd"}
