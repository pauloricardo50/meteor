{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/notaryFees/degressive.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties",["flow",{}],"dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"imports/core/utils/notaryFees/degressive.js","filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/notaryFees/degressive.js","inputSourceMap":{"version":3,"sources":["imports/core/utils/notaryFees/degressive.js"],"names":["INFINITY","degressiveArgs","amount","brackets","Array","rate","max","maxTax","minTax","degressive","tax","every","index","allBrackets","previousBracket","Error","bracketTax","Math","min"],"mappings":"AAAA;AAEA,MAAMA,QAAQ,GAAG,eAAjB;AAEA,KAAKC,cAAL,GAAsB;AACpBC,EAAAA,MAAM,EAAE,MADY;AAEpBC,EAAAA,QAAQ,EAAEC,KAAK,CAAC;AAAEC,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,GAAG,EAAE,MAArB;AAAA,GAAD,CAFK;AAGpBC,EAAAA,MAAM,GAAG,MAHW;AAIpBC,EAAAA,MAAM,GAAG,MAJW;AAAA,CAAtB,C,CAOA;;AACA,MAAMC,UAAU,GAAG,CAAC;AAClBP,EAAAA,MADkB;AAElBC,EAAAA,QAAQ,GAAG,EAFO;AAGlBI,EAAAA,MAHkB;AAIlBC,EAAAA;AAJkB,CAKnB,EAAEP,cALgB,CAKD,EAAE,MALD,IAKW;AAC5B,MAAIC,MAAM,IAAI,CAAd,EAAiB;AACf,WAAO,CAAP;AACD;;AAED,MAAIQ,GAAG,GAAG,CAAV;AAEAP,EAAAA,QAAQ,CAACQ,KAAT,CAAe,CAAC;AAAEL,IAAAA,GAAG,GAAGN,QAAR;AAAkBK,IAAAA;AAAlB,GAAD,EAA2BO,KAA3B,EAAkCC,WAAlC,KAAkD;AAC/D,QAAIC,eAAe,GAAG;AAAET,MAAAA,IAAI,EAAE,CAAR;AAAWC,MAAAA,GAAG,EAAE;AAAhB,KAAtB;;AACA,QAAIM,KAAK,GAAG,CAAZ,EAAe;AACbE,MAAAA,eAAe,GAAGD,WAAW,CAACD,KAAK,GAAG,CAAT,CAA7B;AACD;;AAED,QAAIN,GAAG,GAAGQ,eAAe,CAACR,GAA1B,EAA+B;AAC7B,YAAM,IAAIS,KAAJ,CAAW,2DACfD,eAAe,CAACR,GACjB,OAAMA,GAAI,EAFL,CAAN;AAGD;;AAED,UAAMU,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAShB,MAAM,GAAGY,eAAe,CAACR,GAAlC,EAAuCA,GAAG,GAAGQ,eAAe,CAACR,GAA7D,IAAoED,IAAvF;AAEAK,IAAAA,GAAG,IAAIM,UAAP,CAd+D,CAgB/D;;AACA,WAAOV,GAAG,IAAIJ,MAAd;AACD,GAlBD;;AAoBA,MAAIK,MAAJ,EAAY;AACVG,IAAAA,GAAG,GAAGO,IAAI,CAACC,GAAL,CAASR,GAAT,EAAcH,MAAd,CAAN;AACD;;AAED,MAAIC,MAAJ,EAAY;AACVE,IAAAA,GAAG,GAAGO,IAAI,CAACX,GAAL,CAASI,GAAT,EAAcF,MAAd,CAAN;AACD;;AAED,SAAOE,GAAP;AACD,CAzCD;;AA2CA,eAAeD,UAAf","sourcesContent":["// @flow\n\nconst INFINITY = 100000000000000;\n\ntype degressiveArgs = {\n  amount: number,\n  brackets: Array<{ rate: number, max: number }>,\n  maxTax?: number,\n  minTax?: number,\n};\n\n// Calculates the degressive tax on an amount, based on brackets with varying rates\nconst degressive = ({\n  amount,\n  brackets = [],\n  maxTax,\n  minTax,\n}: degressiveArgs): number => {\n  if (amount <= 0) {\n    return 0;\n  }\n\n  let tax = 0;\n\n  brackets.every(({ max = INFINITY, rate }, index, allBrackets) => {\n    let previousBracket = { rate: 0, max: 0 };\n    if (index > 0) {\n      previousBracket = allBrackets[index - 1];\n    }\n\n    if (max < previousBracket.max) {\n      throw new Error(`Tax brackets should come in increasing order, but found ${\n        previousBracket.max\n      } -> ${max}`);\n    }\n\n    const bracketTax = Math.min(amount - previousBracket.max, max - previousBracket.max) * rate;\n\n    tax += bracketTax;\n\n    // Stop calculating once you've reached the highest bracket you're in\n    return max <= amount;\n  });\n\n  if (maxTax) {\n    tax = Math.min(tax, maxTax);\n  }\n\n  if (minTax) {\n    tax = Math.max(tax, minTax);\n  }\n\n  return tax;\n};\n\nexport default degressive;\n"]},"passPerPreset":false,"envName":"development","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/notaryFees/degressive.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/core/utils/notaryFees/degressive.js"}},"code":"var INFINITY = 100000000000000;\n\n// Calculates the degressive tax on an amount, based on brackets with varying rates\nvar degressive = function (_ref) {\n  var amount = _ref.amount,\n      _ref$brackets = _ref.brackets,\n      brackets = _ref$brackets === void 0 ? [] : _ref$brackets,\n      maxTax = _ref.maxTax,\n      minTax = _ref.minTax;\n\n  if (amount <= 0) {\n    return 0;\n  }\n\n  var tax = 0;\n  brackets.every(function (_ref2, index, allBrackets) {\n    var _ref2$max = _ref2.max,\n        max = _ref2$max === void 0 ? INFINITY : _ref2$max,\n        rate = _ref2.rate;\n    var previousBracket = {\n      rate: 0,\n      max: 0\n    };\n\n    if (index > 0) {\n      previousBracket = allBrackets[index - 1];\n    }\n\n    if (max < previousBracket.max) {\n      throw new Error(\"Tax brackets should come in increasing order, but found \" + previousBracket.max + \" -> \" + max);\n    }\n\n    var bracketTax = Math.min(amount - previousBracket.max, max - previousBracket.max) * rate;\n    tax += bracketTax; // Stop calculating once you've reached the highest bracket you're in\n\n    return max <= amount;\n  });\n\n  if (maxTax) {\n    tax = Math.min(tax, maxTax);\n  }\n\n  if (minTax) {\n    tax = Math.max(tax, minTax);\n  }\n\n  return tax;\n};\n\nmodule.exportDefault(degressive);","map":{"version":3,"sources":["imports/core/utils/notaryFees/degressive.js"],"names":["INFINITY","degressive","brackets","minTax","amount","tax","max","rate","previousBracket","index","allBrackets","bracketTax","Math"],"mappings":"AAEA,IAAMA,QAAQ,GAAd,eAAA;;AASA;AACA,IAAMC,UAAU,GAAG,gBAKW;AAAA,MALV,MAKU,QALV,MAKU;AAAA,2BAH5BC,QAG4B;AAAA,MAH5BA,QAG4B,8BALV,EAKU;AAAA,MALV,MAKU,QALV,MAKU;AAAA,MAD5BC,MAC4B,QAD5BA,MAC4B;;AAC5B,MAAIC,MAAM,IAAV,CAAA,EAAiB;AACf,WAAA,CAAA;AACD;;AAED,MAAIC,GAAG,GAAP,CAAA;AAEAH,EAAAA,QAAQ,CAARA,KAAAA,CAAe,iBAAA,KAAA,EAAA,WAAA,EAAkD;AAAA,0BAA/CI,GAA+C;AAAA,QAA/CA,GAA+C,0BAAjD,QAAiD;AAAA,QAA/BC,IAA+B,SAA/BA,IAA+B;AAC/D,QAAIC,eAAe,GAAG;AAAED,MAAAA,IAAI,EAAN,CAAA;AAAWD,MAAAA,GAAG,EAAE;AAAhB,KAAtB;;AACA,QAAIG,KAAK,GAAT,CAAA,EAAe;AACbD,MAAAA,eAAe,GAAGE,WAAW,CAACD,KAAK,GAAnCD,CAA6B,CAA7BA;AACD;;AAED,QAAIF,GAAG,GAAGE,eAAe,CAAzB,GAAA,EAA+B;AAC7B,YAAM,IAAA,KAAA,8DACJA,eAAe,CAACF,GADZ,YAAN,GAAM,CAAN;AAGD;;AAED,QAAMK,UAAU,GAAGC,IAAI,CAAJA,GAAAA,CAASR,MAAM,GAAGI,eAAe,CAAjCI,GAAAA,EAAuCN,GAAG,GAAGE,eAAe,CAA5DI,GAAAA,IAAnB,IAAA;AAEAP,IAAAA,GAAG,IAd4D,UAc/DA,CAd+D,CAgB/D;;AACA,WAAOC,GAAG,IAAV,MAAA;AAjBFJ,GAAAA;;AAoBA,MAAA,MAAA,EAAY;AACVG,IAAAA,GAAG,GAAGO,IAAI,CAAJA,GAAAA,CAAAA,GAAAA,EAANP,MAAMO,CAANP;AACD;;AAED,MAAA,MAAA,EAAY;AACVA,IAAAA,GAAG,GAAGO,IAAI,CAAJA,GAAAA,CAAAA,GAAAA,EAANP,MAAMO,CAANP;AACD;;AAED,SAAA,GAAA;AAxCF,CAAA;;AAZA,MAAA,CAAA,aAAA,CAuDA,UAvDA","sourcesContent":["// @flow\n\nconst INFINITY = 100000000000000;\n\ntype degressiveArgs = {\n  amount: number,\n  brackets: Array<{ rate: number, max: number }>,\n  maxTax?: number,\n  minTax?: number,\n};\n\n// Calculates the degressive tax on an amount, based on brackets with varying rates\nconst degressive = ({\n  amount,\n  brackets = [],\n  maxTax,\n  minTax,\n}: degressiveArgs): number => {\n  if (amount <= 0) {\n    return 0;\n  }\n\n  let tax = 0;\n\n  brackets.every(({ max = INFINITY, rate }, index, allBrackets) => {\n    let previousBracket = { rate: 0, max: 0 };\n    if (index > 0) {\n      previousBracket = allBrackets[index - 1];\n    }\n\n    if (max < previousBracket.max) {\n      throw new Error(`Tax brackets should come in increasing order, but found ${\n        previousBracket.max\n      } -> ${max}`);\n    }\n\n    const bracketTax = Math.min(amount - previousBracket.max, max - previousBracket.max) * rate;\n\n    tax += bracketTax;\n\n    // Stop calculating once you've reached the highest bracket you're in\n    return max <= amount;\n  });\n\n  if (maxTax) {\n    tax = Math.min(tax, maxTax);\n  }\n\n  if (minTax) {\n    tax = Math.max(tax, minTax);\n  }\n\n  return tax;\n};\n\nexport default degressive;\n"]},"sourceType":"script","hash":"2cd5392cfead7379192627134742d4a7eaee031b"}
