{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/imports/core/components/tooltips/AutoTooltip.jsx","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties",["flow",{}],"dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"imports/core/components/tooltips/AutoTooltip.jsx","filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/components/tooltips/AutoTooltip.jsx","inputSourceMap":{"version":3,"sources":["imports/core/components/tooltips/AutoTooltip.jsx"],"names":["React","PropTypes","reactStringReplace","tooltips","TOOLTIP_LISTS","TooltipOverlay","TooltipContainer","createRegexThatFindsAnyWordFromList","list","RegExp","Object","keys","join","reformatString","string","replace","parseTextForTooltips","props","children","tooltipList","match","index","autoTooltipParser","GENERAL","AutoTooltip","tooltipId","content","propTypes","node","defaultProps"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA,OAAOC,kBAAP,MAA+B,sBAA/B;AAEA,SAASC,QAAT,EAAmBC,aAAnB;AACA,OAAOC,cAAP;AACA,SAASC,gBAAT;AAEA,OAAO,MAAMC,mCAAmC,GAAIC,IAAD,IAAU;AAC3D,MAAIA,IAAJ,EAAU;AACR,WAAO,IAAIC,MAAJ,CAAY,IAAGC,MAAM,CAACC,IAAP,CAAYR,QAAQ,CAACK,IAAD,CAApB,EAA4BI,IAA5B,CAAiC,GAAjC,CAAsC,GAArD,EAAyD,IAAzD,CAAP;AACD;;AAED,SAAO,IAAP;AACD,CANM;AAQP,OAAO,MAAMC,cAAc,GAAGC,MAAM,IAAIA,MAAM,CAACC,OAAP,CAAe,KAAf,EAAsB,GAAtB,CAAjC;;AAEP,MAAMC,oBAAoB,GAAGC,KAAK,IAChCf,kBAAkB,CAChBW,cAAc,CAACI,KAAK,CAACC,QAAP,CADE,EAEhBX,mCAAmC,CAACU,KAAK,CAACE,WAAP,CAFnB,EAGhB,CAACC,KAAD,EAAQC,KAAR,KACE,CAAC,cAAD,CAAgB,IAAIJ,KAAJ,CAAhB,CAA2B,IAAI,CAACI,KAAD,CAA/B,CAAuC,MAAM,CAACD,KAAD,CAA7C;QACE,CAACA,KAAD;MACF,EAAE,cAAF,CANc,CADpB;;AAWA,OAAO,MAAME,iBAAiB,GAAG,CAC/BR,MAD+B,EAE/BK,WAAW,GAAGf,aAAa,CAACmB,OAFG,KAG5BP,oBAAoB,CAAC;AAAEE,EAAAA,QAAQ,EAAEJ,MAAZ;AAAoBK,EAAAA;AAApB,CAAD,CAHlB;AAKP,OAAO,MAAMK,WAAW,GAAIP,KAAD,IAAW;AACpC,QAAM;AAAEC,IAAAA,QAAF;AAAYO,IAAAA;AAAZ,MAA0BR,KAAhC;;AACA,MAAI,CAACC,QAAL,EAAe;AACb,WAAO,IAAP;AACD;;AAED,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC;AACA,WAAOA,QAAP;AACD;;AAED,MAAIO,SAAJ,EAAe;AACb,WAAO,CAAC,cAAD,CAAgB,IAAIR,KAAJ,CAAhB,CAA2B,CAACC,QAAD,CAAU,EAAE,cAAF,CAA5C;AACD,GAbmC,CAepC;AACA;;;AACA,QAAMQ,OAAO,GAAGV,oBAAoB,CAACC,KAAD,CAApC;AAEA,SAAO,CAAC,IAAD,CAAM,CAACS,OAAD,CAAS,EAAE,IAAF,CAAtB;AACD,CApBM;AAsBPF,WAAW,CAACG,SAAZ,GAAwB;AACtBT,EAAAA,QAAQ,EAAEjB,SAAS,CAAC2B,IADE;AAEtBT,EAAAA,WAAW,EAAElB,SAAS,CAACa;AAFD,CAAxB;AAKAU,WAAW,CAACK,YAAZ,GAA2B;AACzBX,EAAAA,QAAQ,EAAE,IADe;AAEzBC,EAAAA,WAAW,EAAEf,aAAa,CAACmB;AAFF,CAA3B;AAKA,eAAejB,gBAAgB,CAACkB,WAAD,CAA/B","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport reactStringReplace from 'react-string-replace';\n\nimport { tooltips, TOOLTIP_LISTS } from 'core/arrays/tooltips';\nimport TooltipOverlay from './TooltipOverlay';\nimport { TooltipContainer } from './TooltipContext';\n\nexport const createRegexThatFindsAnyWordFromList = (list) => {\n  if (list) {\n    return new RegExp(`(${Object.keys(tooltips(list)).join('|')})`, 'gi');\n  }\n\n  return null;\n};\n\nexport const reformatString = string => string.replace(/’/gi, \"'\");\n\nconst parseTextForTooltips = props =>\n  reactStringReplace(\n    reformatString(props.children),\n    createRegexThatFindsAnyWordFromList(props.tooltipList),\n    (match, index) => (\n      <TooltipOverlay {...props} key={index} match={match}>\n        {match}\n      </TooltipOverlay>\n    ),\n  );\n\nexport const autoTooltipParser = (\n  string,\n  tooltipList = TOOLTIP_LISTS.GENERAL,\n) => parseTextForTooltips({ children: string, tooltipList });\n\nexport const AutoTooltip = (props) => {\n  const { children, tooltipId } = props;\n  if (!children) {\n    return null;\n  }\n\n  if (typeof children !== 'string') {\n    // If no id is given and children is not a string, return\n    return children;\n  }\n\n  if (tooltipId) {\n    return <TooltipOverlay {...props}>{children}</TooltipOverlay>;\n  }\n\n  // If no id is given and children is a string,\n  // automatically replace all matching strings with tooltips\n  const content = parseTextForTooltips(props);\n\n  return <span>{content}</span>;\n};\n\nAutoTooltip.propTypes = {\n  children: PropTypes.node,\n  tooltipList: PropTypes.string,\n};\n\nAutoTooltip.defaultProps = {\n  children: null,\n  tooltipList: TOOLTIP_LISTS.GENERAL,\n};\n\nexport default TooltipContainer(AutoTooltip);\n"]},"passPerPreset":false,"envName":"development","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/components/tooltips/AutoTooltip.jsx","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/core/components/tooltips/AutoTooltip.jsx"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nmodule.export({\n  createRegexThatFindsAnyWordFromList: () => createRegexThatFindsAnyWordFromList,\n  reformatString: () => reformatString,\n  autoTooltipParser: () => autoTooltipParser,\n  AutoTooltip: () => AutoTooltip\n});\nlet React;\nmodule.link(\"react\", {\n  default(v) {\n    React = v;\n  }\n\n}, 0);\nlet PropTypes;\nmodule.link(\"prop-types\", {\n  default(v) {\n    PropTypes = v;\n  }\n\n}, 1);\nlet reactStringReplace;\nmodule.link(\"react-string-replace\", {\n  default(v) {\n    reactStringReplace = v;\n  }\n\n}, 2);\nlet tooltips, TOOLTIP_LISTS;\nmodule.link(\"../../arrays/tooltips\", {\n  tooltips(v) {\n    tooltips = v;\n  },\n\n  TOOLTIP_LISTS(v) {\n    TOOLTIP_LISTS = v;\n  }\n\n}, 3);\nlet TooltipOverlay;\nmodule.link(\"./TooltipOverlay\", {\n  default(v) {\n    TooltipOverlay = v;\n  }\n\n}, 4);\nlet TooltipContainer;\nmodule.link(\"./TooltipContext\", {\n  TooltipContainer(v) {\n    TooltipContainer = v;\n  }\n\n}, 5);\n\nconst createRegexThatFindsAnyWordFromList = list => {\n  if (list) {\n    return new RegExp(\"(\".concat(Object.keys(tooltips(list)).join('|'), \")\"), 'gi');\n  }\n\n  return null;\n};\n\nconst reformatString = string => string.replace(/’/gi, \"'\");\n\nconst parseTextForTooltips = props => reactStringReplace(reformatString(props.children), createRegexThatFindsAnyWordFromList(props.tooltipList), (match, index) => React.createElement(TooltipOverlay, (0, _extends2.default)({}, props, {\n  key: index,\n  match: match\n}), match));\n\nconst autoTooltipParser = function (string) {\n  let tooltipList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TOOLTIP_LISTS.GENERAL;\n  return parseTextForTooltips({\n    children: string,\n    tooltipList\n  });\n};\n\nconst AutoTooltip = props => {\n  const {\n    children,\n    tooltipId\n  } = props;\n\n  if (!children) {\n    return null;\n  }\n\n  if (typeof children !== 'string') {\n    // If no id is given and children is not a string, return\n    return children;\n  }\n\n  if (tooltipId) {\n    return React.createElement(TooltipOverlay, props, children);\n  } // If no id is given and children is a string,\n  // automatically replace all matching strings with tooltips\n\n\n  const content = parseTextForTooltips(props);\n  return React.createElement(\"span\", null, content);\n};\n\nAutoTooltip.propTypes = {\n  children: PropTypes.node,\n  tooltipList: PropTypes.string\n};\nAutoTooltip.defaultProps = {\n  children: null,\n  tooltipList: TOOLTIP_LISTS.GENERAL\n};\nmodule.exportDefault(TooltipContainer(AutoTooltip));","map":{"version":3,"sources":["imports/core/components/tooltips/AutoTooltip.jsx"],"names":["createRegexThatFindsAnyWordFromList","list","Object","tooltips","reformatString","string","parseTextForTooltips","props","reactStringReplace","autoTooltipParser","tooltipList","TOOLTIP_LISTS","children","AutoTooltip","tooltipId","content","PropTypes","GENERAL","TooltipContainer"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport reactStringReplace from 'react-string-replace';\n\nimport { tooltips, TOOLTIP_LISTS } from 'core/arrays/tooltips';\nimport TooltipOverlay from './TooltipOverlay';\nimport { TooltipContainer } from './TooltipContext';\n\nexport const createRegexThatFindsAnyWordFromList = (list) => {\n  if (list) {\n    return new RegExp(`(${Object.keys(tooltips(list)).join('|')})`, 'gi');\n  }\n\n  return null;\n};\n\nexport const reformatString = string => string.replace(/’/gi, \"'\");\n\nconst parseTextForTooltips = props =>\n  reactStringReplace(\n    reformatString(props.children),\n    createRegexThatFindsAnyWordFromList(props.tooltipList),\n    (match, index) => (\n      <TooltipOverlay {...props} key={index} match={match}>\n        {match}\n      </TooltipOverlay>\n    ),\n  );\n\nexport const autoTooltipParser = (\n  string,\n  tooltipList = TOOLTIP_LISTS.GENERAL,\n) => parseTextForTooltips({ children: string, tooltipList });\n\nexport const AutoTooltip = (props) => {\n  const { children, tooltipId } = props;\n  if (!children) {\n    return null;\n  }\n\n  if (typeof children !== 'string') {\n    // If no id is given and children is not a string, return\n    return children;\n  }\n\n  if (tooltipId) {\n    return <TooltipOverlay {...props}>{children}</TooltipOverlay>;\n  }\n\n  // If no id is given and children is a string,\n  // automatically replace all matching strings with tooltips\n  const content = parseTextForTooltips(props);\n\n  return <span>{content}</span>;\n};\n\nAutoTooltip.propTypes = {\n  children: PropTypes.node,\n  tooltipList: PropTypes.string,\n};\n\nAutoTooltip.defaultProps = {\n  children: null,\n  tooltipList: TOOLTIP_LISTS.GENERAL,\n};\n\nexport default TooltipContainer(AutoTooltip);\n"]},"sourceType":"script","hash":"4739a1c0f6123383eaba785ba3fe7e05e67f17db"}
