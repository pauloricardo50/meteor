{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js","passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js"}},"code":"module.export({\n  default: () => Mutator\n});\nlet getMutationConfig;\nmodule.link(\"./lib/getMutationConfig\", {\n  default(v) {\n    getMutationConfig = v;\n  }\n\n}, 0);\nlet getFields;\nmodule.link(\"../utils/getFields\", {\n  default(v) {\n    getFields = v;\n  }\n\n}, 1);\nlet dispatchInsert, dispatchUpdate, dispatchRemove;\nmodule.link(\"./lib/dispatchers\", {\n  dispatchInsert(v) {\n    dispatchInsert = v;\n  },\n\n  dispatchUpdate(v) {\n    dispatchUpdate = v;\n  },\n\n  dispatchRemove(v) {\n    dispatchRemove = v;\n  }\n\n}, 2);\nlet Config;\nmodule.link(\"../config\", {\n  default(v) {\n    Config = v;\n  }\n\n}, 3);\nlet Events;\nmodule.link(\"../constants\", {\n  Events(v) {\n    Events = v;\n  }\n\n}, 4);\n\nfunction runCallbackInBackground(fn) {\n  Meteor.defer(Meteor.bindEnvironment(fn));\n}\n/**\n * The Mutator is the interface that does the required updates\n */\n\n\nclass Mutator {\n  static init() {\n    Mutator.passConfigDown = Config.passConfigDown; // regardless of your choice, these 2 packages must passConfigDown\n    // we do like this until we find a more elegant way\n\n    if (Package['aldeed:collection2'] !== undefined || Package['aldeed:collection2-core'] !== undefined) {\n      Mutator.passConfigDown = true;\n    }\n  }\n\n  static insert(Originals, data, _config) {\n    const config = getMutationConfig(this, _config, {\n      doc: data,\n      event: Events.INSERT\n    });\n\n    if (canUseOriginalMethod(config)) {\n      return Originals.insert.call(this, data);\n    }\n\n    try {\n      const docId = Originals.insert.call(this, data); // It's a callback\n\n      if (_.isFunction(_config)) {\n        const self = this;\n        runCallbackInBackground(function () {\n          _config.call(self, null, docId);\n        });\n      }\n\n      dispatchInsert(config.optimistic, this._name, config._channels, docId);\n      return docId;\n    } catch (e) {\n      if (_.isFunction(_config)) {\n        Meteor.defer(() => {\n          return _config.call(this, e);\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   * @param Originals\n   * @param selector\n   * @param modifier\n   * @param _config\n   * @param callback\n   * @returns {*}\n   */\n\n\n  static update(Originals, selector, modifier, _config, callback) {\n    if (_.isString(selector)) {\n      selector = {\n        _id: selector\n      };\n    }\n\n    if (_.isFunction(_config)) {\n      callback = _config;\n      _config = {};\n    }\n\n    const config = getMutationConfig(this, _config, {\n      event: Events.UPDATE,\n      selector,\n      modifier\n    });\n\n    if (canUseOriginalMethod(config)) {\n      return Originals.update.call(this, selector, modifier, config);\n    } // searching the elements that will get updated by id\n\n\n    const findOptions = {\n      fields: {\n        _id: 1\n      },\n      transform: null\n    };\n\n    if (!config.multi) {\n      findOptions.limit = 1;\n    }\n\n    let docIds = this.find(selector, findOptions).fetch().map(doc => doc._id);\n\n    if (config && config.upsert) {\n      return Mutator._handleUpsert.call(this, Originals, selector, modifier, config, callback, docIds);\n    } // we do this because when we send to redis\n    // we need the exact _ids\n    // and we extend the selector, because if between finding the docIds and updating\n    // another matching insert sneaked in, it's update will not be pushed\n\n\n    const updateSelector = _.extend({}, selector, {\n      _id: {\n        $in: docIds\n      }\n    });\n\n    try {\n      const result = Originals.update.call(this, updateSelector, modifier, config); // phony callback emulation\n\n      if (callback) {\n        const self = this;\n        runCallbackInBackground(function () {\n          callback.call(self, null, result);\n        });\n      }\n\n      const {\n        fields\n      } = getFields(modifier);\n      dispatchUpdate(config.optimistic, this._name, config._channels, docIds, fields);\n      return result;\n    } catch (e) {\n      if (callback) {\n        const self = this;\n        runCallbackInBackground(function () {\n          callback.call(self, e);\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   * @param Originals\n   * @param selector\n   * @param modifier\n   * @param config\n   * @param callback\n   * @param docIds\n   */\n\n\n  static _handleUpsert(Originals, selector, modifier, config, callback, docIds) {\n    try {\n      const data = Originals.update.call(this, selector, modifier, _.extend({}, config, {\n        _returnObject: true\n      }));\n      let {\n        insertedId,\n        numberAffected\n      } = data;\n\n      if (callback) {\n        const self = this;\n        runCallbackInBackground(function () {\n          callback.call(this, null, {\n            insertedId,\n            numberAffected\n          });\n        });\n      }\n\n      if (config.pushToRedis) {\n        if (insertedId) {\n          dispatchInsert(config.optimistic, this._name, config._channels, insertedId);\n        } else {\n          // it means that we ran an upsert thinking there will be no docs\n          if (docIds.length === 0 || numberAffected !== docIds.length) {\n            // there were no docs initially found matching the selector\n            // however a document sneeked in, resulting in a race-condition\n            // and if we look again for that document, we cannot retrieve it.\n            // or a new document was added/modified to match selector before the actual update\n            console.warn('RedisOplog - Warning - A race condition occurred when running upsert.');\n          } else {\n            const {\n              fields\n            } = getFields(modifier);\n            dispatchUpdate(config.optimistic, this._name, config._channels, docIds, fields);\n          }\n        }\n      }\n\n      return {\n        insertedId,\n        numberAffected\n      };\n    } catch (e) {\n      if (callback) {\n        const self = this;\n        runCallbackInBackground(function () {\n          callback.call(self, e);\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   * @param Originals\n   * @param selector\n   * @param _config\n   * @returns {*}\n   */\n\n\n  static remove(Originals, selector, _config) {\n    if (_.isString(selector)) {\n      selector = {\n        _id: selector\n      };\n    }\n\n    const config = getMutationConfig(this, _config, {\n      selector,\n      event: Events.REMOVE\n    });\n\n    if (canUseOriginalMethod(config)) {\n      return Originals.remove.call(this, selector);\n    }\n\n    const removeSelector = _.extend({}, selector); // TODO: optimization check if it has _id or _id with {$in} so we don't have to redo this.\n\n\n    let docIds = this.find(selector, {\n      fields: {\n        _id: 1\n      },\n      transform: null\n    }).fetch().map(doc => doc._id);\n\n    if (!selector._id) {\n      removeSelector._id = {\n        $in: docIds\n      };\n    }\n\n    try {\n      const result = Originals.remove.call(this, removeSelector);\n\n      if (_.isFunction(_config)) {\n        const self = this;\n        runCallbackInBackground(function () {\n          _config.call(self, null);\n        });\n      }\n\n      dispatchRemove(config.optimistic, this._name, config._channels, docIds);\n      return result;\n    } catch (e) {\n      if (_.isFunction(_config)) {\n        const self = this;\n        runCallbackInBackground(function () {\n          _config.call(self, e);\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n\n}\n\nfunction canUseOriginalMethod(mutationConfig) {\n  // There are two cases where we can use the original mutators rather than\n  // our overriden ones:\n  //\n  // 1) The user set pushToRedis: false, indicating they don't need realtime\n  //    updates at all.\n  //\n  // 2) The user is using an external redis publisher, so we don't need to\n  //    figure out what to publish to redis, and this update doesn't need\n  //    optimistic-ui processing, so we don't need to synchronously run\n  //    observers.\n  return !mutationConfig.pushToRedis || Config.externalRedisPublisher && !mutationConfig.optimistic;\n}","map":{"version":3,"sources":["packages/cultofcoders:redis-oplog/lib/mongo/Mutator.js"],"names":["module","export","default","Mutator","getMutationConfig","link","v","getFields","dispatchInsert","dispatchUpdate","dispatchRemove","Config","Events","runCallbackInBackground","fn","Meteor","defer","bindEnvironment","init","passConfigDown","Package","undefined","insert","Originals","data","_config","config","doc","event","INSERT","canUseOriginalMethod","call","docId","_","isFunction","self","optimistic","_name","_channels","e","update","selector","modifier","callback","isString","_id","UPDATE","findOptions","fields","transform","multi","limit","docIds","find","fetch","map","upsert","_handleUpsert","updateSelector","extend","$in","result","_returnObject","insertedId","numberAffected","pushToRedis","length","console","warn","remove","REMOVE","removeSelector","mutationConfig","externalRedisPublisher"],"mappings":"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","sourcesContent":["import getMutationConfig from './lib/getMutationConfig';\nimport getFields from '../utils/getFields';\nimport {\n    dispatchInsert,\n    dispatchUpdate,\n    dispatchRemove,\n} from './lib/dispatchers';\nimport Config from '../config';\nimport { Events } from '../constants';\n\nfunction runCallbackInBackground(fn) {\n    Meteor.defer(Meteor.bindEnvironment(fn));\n}\n\n/**\n * The Mutator is the interface that does the required updates\n */\nexport default class Mutator {\n    static init() {\n        Mutator.passConfigDown = Config.passConfigDown;\n\n        // regardless of your choice, these 2 packages must passConfigDown\n        // we do like this until we find a more elegant way\n        if (\n            Package['aldeed:collection2'] !== undefined ||\n            Package['aldeed:collection2-core'] !== undefined\n        ) {\n            Mutator.passConfigDown = true;\n        }\n    }\n\n    static insert(Originals, data, _config) {\n        const config = getMutationConfig(this, _config, {\n            doc: data,\n            event: Events.INSERT,\n        });\n\n        if (canUseOriginalMethod(config)) {\n            return Originals.insert.call(this, data);\n        }\n\n        try {\n            const docId = Originals.insert.call(this, data);\n\n            // It's a callback\n            if (_.isFunction(_config)) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    _config.call(self, null, docId);\n                });\n            }\n\n            dispatchInsert(\n                config.optimistic,\n                this._name,\n                config._channels,\n                docId\n            );\n\n            return docId;\n        } catch (e) {\n            if (_.isFunction(_config)) {\n                Meteor.defer(() => {\n                    return _config.call(this, e);\n                });\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * @param Originals\n     * @param selector\n     * @param modifier\n     * @param _config\n     * @param callback\n     * @returns {*}\n     */\n    static update(Originals, selector, modifier, _config, callback) {\n        if (_.isString(selector)) {\n            selector = { _id: selector };\n        }\n\n        if (_.isFunction(_config)) {\n            callback = _config;\n            _config = {};\n        }\n\n        const config = getMutationConfig(this, _config, {\n            event: Events.UPDATE,\n            selector,\n            modifier,\n        });\n\n        if (canUseOriginalMethod(config)) {\n            return Originals.update.call(this, selector, modifier, config);\n        }\n\n        // searching the elements that will get updated by id\n        const findOptions = { fields: { _id: 1 }, transform: null };\n        if (!config.multi) {\n            findOptions.limit = 1;\n        }\n\n        let docIds = this.find(selector, findOptions)\n            .fetch()\n            .map(doc => doc._id);\n\n        if (config && config.upsert) {\n            return Mutator._handleUpsert.call(\n                this,\n                Originals,\n                selector,\n                modifier,\n                config,\n                callback,\n                docIds\n            );\n        }\n\n        // we do this because when we send to redis\n        // we need the exact _ids\n        // and we extend the selector, because if between finding the docIds and updating\n        // another matching insert sneaked in, it's update will not be pushed\n        const updateSelector = _.extend({}, selector, {\n            _id: { $in: docIds },\n        });\n\n        try {\n            const result = Originals.update.call(\n                this,\n                updateSelector,\n                modifier,\n                config\n            );\n\n            // phony callback emulation\n            if (callback) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    callback.call(self, null, result);\n                });\n            }\n\n            const { fields } = getFields(modifier);\n\n            dispatchUpdate(\n                config.optimistic,\n                this._name,\n                config._channels,\n                docIds,\n                fields\n            );\n\n            return result;\n        } catch (e) {\n            if (callback) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    callback.call(self, e);\n                });\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * @param Originals\n     * @param selector\n     * @param modifier\n     * @param config\n     * @param callback\n     * @param docIds\n     */\n    static _handleUpsert(\n        Originals,\n        selector,\n        modifier,\n        config,\n        callback,\n        docIds\n    ) {\n        try {\n            const data = Originals.update.call(\n                this,\n                selector,\n                modifier,\n                _.extend({}, config, { _returnObject: true })\n            );\n            let { insertedId, numberAffected } = data;\n\n            if (callback) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    callback.call(this, null, { insertedId, numberAffected });\n                });\n            }\n\n            if (config.pushToRedis) {\n                if (insertedId) {\n                    dispatchInsert(\n                        config.optimistic,\n                        this._name,\n                        config._channels,\n                        insertedId\n                    );\n                } else {\n                    // it means that we ran an upsert thinking there will be no docs\n                    if (\n                        docIds.length === 0 ||\n                        numberAffected !== docIds.length\n                    ) {\n                        // there were no docs initially found matching the selector\n                        // however a document sneeked in, resulting in a race-condition\n                        // and if we look again for that document, we cannot retrieve it.\n\n                        // or a new document was added/modified to match selector before the actual update\n                        console.warn(\n                            'RedisOplog - Warning - A race condition occurred when running upsert.'\n                        );\n                    } else {\n                        const { fields } = getFields(modifier);\n                        dispatchUpdate(\n                            config.optimistic,\n                            this._name,\n                            config._channels,\n                            docIds,\n                            fields\n                        );\n                    }\n                }\n            }\n\n            return { insertedId, numberAffected };\n        } catch (e) {\n            if (callback) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    callback.call(self, e);\n                });\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * @param Originals\n     * @param selector\n     * @param _config\n     * @returns {*}\n     */\n    static remove(Originals, selector, _config) {\n        if (_.isString(selector)) {\n            selector = { _id: selector };\n        }\n\n        const config = getMutationConfig(this, _config, {\n            selector,\n            event: Events.REMOVE,\n        });\n\n        if (canUseOriginalMethod(config)) {\n            return Originals.remove.call(this, selector);\n        }\n\n        const removeSelector = _.extend({}, selector);\n\n        // TODO: optimization check if it has _id or _id with {$in} so we don't have to redo this.\n        let docIds = this.find(selector, {\n            fields: { _id: 1 },\n            transform: null,\n        })\n            .fetch()\n            .map(doc => doc._id);\n\n        if (!selector._id) {\n            removeSelector._id = { $in: docIds };\n        }\n\n        try {\n            const result = Originals.remove.call(this, removeSelector);\n\n            if (_.isFunction(_config)) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    _config.call(self, null);\n                });\n            }\n\n            dispatchRemove(\n                config.optimistic,\n                this._name,\n                config._channels,\n                docIds\n            );\n\n            return result;\n        } catch (e) {\n            if (_.isFunction(_config)) {\n                const self = this;\n                runCallbackInBackground(function() {\n                    _config.call(self, e);\n                });\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n\nfunction canUseOriginalMethod(mutationConfig) {\n    // There are two cases where we can use the original mutators rather than\n    // our overriden ones:\n    //\n    // 1) The user set pushToRedis: false, indicating they don't need realtime\n    //    updates at all.\n    //\n    // 2) The user is using an external redis publisher, so we don't need to\n    //    figure out what to publish to redis, and this update doesn't need\n    //    optimistic-ui processing, so we don't need to synchronously run\n    //    observers.\n    return !mutationConfig.pushToRedis || (Config.externalRedisPublisher && !mutationConfig.optimistic);\n}\n"]},"sourceType":"script","hash":"ed84c81d0d5a2480b42a9741f90fdd4c40c65a23"}
