{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties",["flow",{}],"dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"imports/core/utils/Calculator/SolvencyCalculator.js","filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","inputSourceMap":{"version":3,"sources":["imports/core/utils/Calculator/SolvencyCalculator.js"],"names":["OWN_FUNDS_ROUNDING_AMOUNT","OWN_FUNDS_TYPES","RESIDENCE_TYPE","OWN_FUNDS_USAGE_TYPES","arrayify","NotaryFeesCalculator","roundValue","INITIAL_MIN_BOUND","INITIAL_MAX_BOUND","INITIAL_ABSOLUTE_MAX_BOUND","MAX_ITERATIONS","ACCURACY","ROUNDING_DIGITS","Math","log10","MAX_BOUND_MULTIPLICATION_FACTOR","OWN_FUNDS_ROUNDING_ALGO","INITIAL_BORROW_RATIO_STEP_SIZE","withSolvencyCalculator","SuperClass","getAllowedOwnFundsTypes","residenceType","MAIN_RESIDENCE","THIRD_PARTY_FORTUNE","BANK_FORTUNE","INSURANCE_3A","BANK_3A","INSURANCE_3B","INSURANCE_2","ownFundTypeRequiresUsageType","type","includes","makeOwnFunds","borrowers","usageType","max","map","borrower","ownFundsObject","value","ceil","min","getFunds","borrowerId","_id","WITHDRAW","filter","suggestStructure","propertyValue","maxBorrowRatio","loanValue","canton","notaryFees","forcedNotaryFees","finalLoanValue","round","notaryCalc","getNotaryFeesWithoutLoan","mortgageNoteIncrease","total","requiredOwnFunds","ownFunds","allowedOwnFundsTypes","forEach","newOwnFunds","reduce","tot","createLoanObject","wantedLoan","loanTranches","rest","structure","property","suggestedStructureIsValid","loanObject","lenderRules","initialize","loan","isMissingOwnFunds","hasEnoughCash","structureIsValid","getMaxPropertyValue","foundValue","minBound","maxBound","absoluteMax","iterations","ownFundsRoundingAmount","nextPropertyValue","getNextStepSize","currentMax","currentBorrowRatio","stepSize","direction","cache","newStepSize","foundBetterValue","nextValue","getMaxPropertyValueWithoutBorrowRatio","borrowRatio","deltaX","maxPropertyValue","optimalBorrowRatio","setMax","ratio","center","yLeft","yRight","slope","finalBorrowRatio","finalPropertyValue","getMaxPropertyValueForLoan","loanResidenceType","suggestStructureForLoan","structureId","getPropAndWork","selectLoanValue","getFees"],"mappings":"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","sourcesContent":["// @flow\nimport { OWN_FUNDS_ROUNDING_AMOUNT } from '../../config/financeConstants';\nimport {\n  OWN_FUNDS_TYPES,\n  RESIDENCE_TYPE,\n  OWN_FUNDS_USAGE_TYPES,\n} from '../../api/constants';\nimport { arrayify } from '../general';\nimport { NotaryFeesCalculator } from '../notaryFees/index';\nimport { roundValue } from '../conversionFunctions';\n\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nexport const withSolvencyCalculator = (SuperClass = class {}) =>\n  class extends SuperClass {\n    getAllowedOwnFundsTypes({ residenceType }) {\n      return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE\n        ? [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3A,\n          OWN_FUNDS_TYPES.BANK_3A,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n          OWN_FUNDS_TYPES.INSURANCE_2,\n        ]\n        : [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n        ];\n    }\n\n    ownFundTypeRequiresUsageType({ type }) {\n      return [\n        OWN_FUNDS_TYPES.INSURANCE_2,\n        OWN_FUNDS_TYPES.INSURANCE_3A,\n        OWN_FUNDS_TYPES.INSURANCE_3B,\n      ].includes(type);\n    }\n\n    makeOwnFunds({ borrowers, type, usageType, max }) {\n      return arrayify(borrowers)\n        .map((borrower) => {\n          const ownFundsObject = {\n            type,\n            value: Math.ceil(Math.min(max, this.getFunds({ borrowers: borrower, type }))),\n            borrowerId: borrower._id,\n          };\n\n          if (!usageType && this.ownFundTypeRequiresUsageType({ type })) {\n            return {\n              ...ownFundsObject,\n              usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW,\n            };\n          }\n\n          if (usageType) {\n            return { ...ownFundsObject, usageType };\n          }\n\n          return ownFundsObject;\n        })\n        .filter(({ value }) => value > 0);\n    }\n\n    suggestStructure({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      notaryFees: forcedNotaryFees,\n    }) {\n      let notaryFees;\n\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n      if (forcedNotaryFees) {\n        notaryFees = forcedNotaryFees;\n      } else {\n        const notaryCalc = new NotaryFeesCalculator({ canton });\n        notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n          propertyValue,\n          mortgageNoteIncrease: finalLoanValue,\n          residenceType,\n        }).total;\n      }\n\n      let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n      let ownFunds = [];\n\n      // Get all possible OWN_FUNDS_TYPES\n      const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n        residenceType,\n      });\n\n      allowedOwnFundsTypes.forEach((type) => {\n        borrowers.forEach((borrower) => {\n          const newOwnFunds = this.makeOwnFunds({\n            borrowers: borrower,\n            type,\n            max: requiredOwnFunds,\n          });\n\n          requiredOwnFunds -= newOwnFunds.reduce(\n            (tot, { value }) => tot + value,\n            0,\n          );\n\n          ownFunds = [...ownFunds, ...newOwnFunds];\n        });\n      });\n\n      return ownFunds;\n    }\n\n    createLoanObject({\n      residenceType,\n      borrowers,\n      wantedLoan,\n      propertyValue,\n      canton,\n      ownFunds = [],\n      loanTranches = [],\n      ...rest\n    }) {\n      return {\n        residenceType,\n        borrowers,\n        structure: {\n          wantedLoan,\n          propertyValue,\n          property: { canton },\n          ownFunds,\n          loanTranches,\n        },\n        ...rest,\n      };\n    }\n\n    suggestedStructureIsValid({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      ownFunds,\n    }) {\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n      const loanObject = this.createLoanObject({\n        residenceType,\n        borrowers,\n        wantedLoan: finalLoanValue,\n        propertyValue,\n        canton,\n        ownFunds,\n      });\n\n      // If the calculator has been initialized, reinitialize it according to this new potential loan\n      if (this.lenderRules) {\n        this.initialize({ loan: loanObject, lenderRules: this.lenderRules });\n      }\n\n      if (this.isMissingOwnFunds({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.hasEnoughCash({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.structureIsValid({ loan: loanObject })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    getMaxPropertyValue({ borrowers, maxBorrowRatio, canton, residenceType }) {\n      // Immediately stop iterating if maxBorrowRatio is above what is allowed\n      if (this.maxBorrowRatio < maxBorrowRatio) {\n        return 0;\n      }\n\n      let foundValue = false;\n      let minBound = INITIAL_MIN_BOUND;\n      let maxBound = INITIAL_MAX_BOUND;\n      let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n      let iterations = 0;\n\n      // The rounding amount of 1000 is helpful when the user tries to\n      // fit his own funds into a structure without being overly accurate\n      // which is annoying.\n      // However for this calculation we don't need to round own funds as loosely\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n      while (!foundValue) {\n        iterations += 1;\n        const nextPropertyValue = roundValue(\n          (minBound + maxBound) / 2,\n          ROUNDING_DIGITS,\n        );\n\n        const ownFunds = this.suggestStructure({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue,\n        });\n\n        if (\n          this.suggestedStructureIsValid({\n            borrowers,\n            maxBorrowRatio,\n            canton,\n            residenceType,\n            propertyValue: nextPropertyValue,\n            ownFunds,\n          })\n        ) {\n          minBound = nextPropertyValue;\n          maxBound = Math.min(\n            maxBound * MAX_BOUND_MULTIPLICATION_FACTOR,\n            absoluteMax,\n          );\n        } else {\n          maxBound = nextPropertyValue;\n          absoluteMax = maxBound;\n        }\n\n        if (maxBound - minBound <= ACCURACY) {\n          foundValue = true;\n        }\n\n        if (iterations > MAX_ITERATIONS) {\n          foundValue = true;\n        }\n      }\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n\n      return minBound;\n    }\n\n    getNextStepSize({\n      currentMax,\n      currentBorrowRatio,\n      stepSize,\n      borrowers,\n      residenceType,\n      canton,\n      direction,\n      cache,\n    }) {\n      let newStepSize = stepSize;\n      let foundBetterValue;\n\n      while (!foundBetterValue) {\n        let nextValue;\n        if (direction === 'upwards') {\n          nextValue = cache[currentBorrowRatio + stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio + stepSize,\n              canton,\n            });\n        } else {\n          nextValue = cache[currentBorrowRatio - stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio - stepSize,\n              canton,\n            });\n        }\n\n        if (nextValue > currentMax) {\n          foundBetterValue = true;\n        } else {\n          newStepSize /= 2;\n        }\n\n        if (newStepSize < 0.05) {\n          foundBetterValue = true;\n        }\n      }\n\n      return newStepSize;\n    }\n\n    getMaxPropertyValueWithoutBorrowRatio({\n      borrowers,\n      residenceType,\n      canton,\n    }) {\n      let borrowRatio = 0.7;\n      let foundValue = false;\n      let iterations = 0;\n      let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n      const deltaX = 0.01;\n      let maxPropertyValue = 0;\n      let optimalBorrowRatio;\n      const cache = {};\n\n      const setMax = (ratio, propertyValue) => {\n        // Cache each result to avoid recalculating it later\n        if (!cache[`${ratio}`]) {\n          cache[`${ratio}`] = propertyValue;\n        }\n\n        // Always store the highest encountered value, in case the loop\n        // stops prematurely, or if the stopping conditions would've skipped\n        // a value that we already calculated\n        if (propertyValue > maxPropertyValue) {\n          maxPropertyValue = propertyValue;\n          optimalBorrowRatio = ratio;\n        }\n      };\n\n      while (!foundValue) {\n        iterations += 1;\n\n        const center = cache[borrowRatio]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio,\n            canton,\n          });\n        setMax(borrowRatio, center);\n\n        const yLeft = cache[borrowRatio - deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio - deltaX,\n            canton,\n          });\n        setMax(borrowRatio - deltaX, yLeft);\n        const yRight = cache[borrowRatio + deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio + deltaX,\n            canton,\n          });\n        setMax(borrowRatio + deltaX, yRight);\n\n        const slope = yRight - yLeft;\n\n        if (yRight === 0 && yLeft === 0) {\n          // If the algorithm is at 0 on both sides, it means the borrowRatio\n          // is way too high, so start him over again at 0, but with a large\n          // step size to allow it to recover quickly\n          borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n          stepSize = 0.2;\n        } else if (slope > 0) {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'upwards',\n            cache,\n          });\n          borrowRatio += stepSize;\n        } else {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'downwards',\n            cache,\n          });\n          borrowRatio -= stepSize;\n        }\n\n        if (stepSize < deltaX / 2) {\n          foundValue = true;\n        }\n\n        if (iterations > 50) {\n          foundValue = true;\n        }\n      }\n\n      // Round the borrowRatio, and recompute the exact property value\n      const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n      const finalPropertyValue = cache[finalBorrowRatio]\n        || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: finalBorrowRatio,\n          canton,\n        });\n\n      return {\n        borrowRatio: finalBorrowRatio,\n        propertyValue: finalPropertyValue,\n      };\n    }\n\n    getMaxPropertyValueForLoan({\n      loan,\n      maxBorrowRatio,\n      canton,\n      residenceType,\n    }) {\n      const { borrowers, residenceType: loanResidenceType } = loan;\n      return this.getMaxPropertyValue({\n        borrowers,\n        residenceType: residenceType || loanResidenceType,\n        maxBorrowRatio,\n        canton,\n      });\n    }\n\n    suggestStructureForLoan({ loan, structureId }) {\n      const propertyValue = this.getPropAndWork({ loan, structureId });\n      const loanValue = this.selectLoanValue({ loan, structureId });\n      const notaryFees = this.getFees({ loan, structureId }).total;\n\n      return this.suggestStructure({\n        borrowers: loan.borrowers,\n        propertyValue,\n        loanValue,\n        residenceType: loan.residenceType,\n        notaryFees,\n      });\n    }\n  };\n"]},"passPerPreset":false,"envName":"development","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/core/utils/Calculator/SolvencyCalculator.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nmodule.export({\n  withSolvencyCalculator: () => withSolvencyCalculator\n});\nlet OWN_FUNDS_ROUNDING_AMOUNT;\nmodule.link(\"../../config/financeConstants\", {\n  OWN_FUNDS_ROUNDING_AMOUNT(v) {\n    OWN_FUNDS_ROUNDING_AMOUNT = v;\n  }\n\n}, 0);\nlet OWN_FUNDS_TYPES, RESIDENCE_TYPE, OWN_FUNDS_USAGE_TYPES;\nmodule.link(\"../../api/constants\", {\n  OWN_FUNDS_TYPES(v) {\n    OWN_FUNDS_TYPES = v;\n  },\n\n  RESIDENCE_TYPE(v) {\n    RESIDENCE_TYPE = v;\n  },\n\n  OWN_FUNDS_USAGE_TYPES(v) {\n    OWN_FUNDS_USAGE_TYPES = v;\n  }\n\n}, 1);\nlet arrayify;\nmodule.link(\"../general\", {\n  arrayify(v) {\n    arrayify = v;\n  }\n\n}, 2);\nlet NotaryFeesCalculator;\nmodule.link(\"../notaryFees/index\", {\n  NotaryFeesCalculator(v) {\n    NotaryFeesCalculator = v;\n  }\n\n}, 3);\nlet roundValue;\nmodule.link(\"../conversionFunctions\", {\n  roundValue(v) {\n    roundValue = v;\n  }\n\n}, 4);\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nconst withSolvencyCalculator = function () {\n  let SuperClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : class {};\n  return class extends SuperClass {\n    getAllowedOwnFundsTypes(_ref) {\n      let {\n        residenceType\n      } = _ref;\n      return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE ? [OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE, OWN_FUNDS_TYPES.BANK_FORTUNE, OWN_FUNDS_TYPES.INSURANCE_3A, OWN_FUNDS_TYPES.BANK_3A, OWN_FUNDS_TYPES.INSURANCE_3B, OWN_FUNDS_TYPES.INSURANCE_2] : [OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE, OWN_FUNDS_TYPES.BANK_FORTUNE, OWN_FUNDS_TYPES.INSURANCE_3B];\n    }\n\n    ownFundTypeRequiresUsageType(_ref2) {\n      let {\n        type\n      } = _ref2;\n      return [OWN_FUNDS_TYPES.INSURANCE_2, OWN_FUNDS_TYPES.INSURANCE_3A, OWN_FUNDS_TYPES.INSURANCE_3B].includes(type);\n    }\n\n    makeOwnFunds(_ref3) {\n      let {\n        borrowers,\n        type,\n        usageType,\n        max\n      } = _ref3;\n      return arrayify(borrowers).map(borrower => {\n        const ownFundsObject = {\n          type,\n          value: Math.ceil(Math.min(max, this.getFunds({\n            borrowers: borrower,\n            type\n          }))),\n          borrowerId: borrower._id\n        };\n\n        if (!usageType && this.ownFundTypeRequiresUsageType({\n          type\n        })) {\n          return (0, _objectSpread2.default)({}, ownFundsObject, {\n            usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW\n          });\n        }\n\n        if (usageType) {\n          return (0, _objectSpread2.default)({}, ownFundsObject, {\n            usageType\n          });\n        }\n\n        return ownFundsObject;\n      }).filter((_ref4) => {\n        let {\n          value\n        } = _ref4;\n        return value > 0;\n      });\n    }\n\n    suggestStructure(_ref5) {\n      let {\n        borrowers,\n        propertyValue,\n        maxBorrowRatio = this.maxBorrowRatio,\n        loanValue,\n        canton,\n        residenceType,\n        notaryFees: forcedNotaryFees\n      } = _ref5;\n      let notaryFees;\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n      if (forcedNotaryFees) {\n        notaryFees = forcedNotaryFees;\n      } else {\n        const notaryCalc = new NotaryFeesCalculator({\n          canton\n        });\n        notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n          propertyValue,\n          mortgageNoteIncrease: finalLoanValue,\n          residenceType\n        }).total;\n      }\n\n      let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n      let ownFunds = []; // Get all possible OWN_FUNDS_TYPES\n\n      const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n        residenceType\n      });\n      allowedOwnFundsTypes.forEach(type => {\n        borrowers.forEach(borrower => {\n          const newOwnFunds = this.makeOwnFunds({\n            borrowers: borrower,\n            type,\n            max: requiredOwnFunds\n          });\n          requiredOwnFunds -= newOwnFunds.reduce((tot, _ref6) => {\n            let {\n              value\n            } = _ref6;\n            return tot + value;\n          }, 0);\n          ownFunds = [...ownFunds, ...newOwnFunds];\n        });\n      });\n      return ownFunds;\n    }\n\n    createLoanObject(_ref7) {\n      let {\n        residenceType,\n        borrowers,\n        wantedLoan,\n        propertyValue,\n        canton,\n        ownFunds = [],\n        loanTranches = []\n      } = _ref7,\n          rest = (0, _objectWithoutProperties2.default)(_ref7, [\"residenceType\", \"borrowers\", \"wantedLoan\", \"propertyValue\", \"canton\", \"ownFunds\", \"loanTranches\"]);\n      return (0, _objectSpread2.default)({\n        residenceType,\n        borrowers,\n        structure: {\n          wantedLoan,\n          propertyValue,\n          property: {\n            canton\n          },\n          ownFunds,\n          loanTranches\n        }\n      }, rest);\n    }\n\n    suggestedStructureIsValid(_ref8) {\n      let {\n        borrowers,\n        propertyValue,\n        maxBorrowRatio = this.maxBorrowRatio,\n        loanValue,\n        canton,\n        residenceType,\n        ownFunds\n      } = _ref8;\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n      const loanObject = this.createLoanObject({\n        residenceType,\n        borrowers,\n        wantedLoan: finalLoanValue,\n        propertyValue,\n        canton,\n        ownFunds\n      }); // If the calculator has been initialized, reinitialize it according to this new potential loan\n\n      if (this.lenderRules) {\n        this.initialize({\n          loan: loanObject,\n          lenderRules: this.lenderRules\n        });\n      }\n\n      if (this.isMissingOwnFunds({\n        loan: loanObject\n      })) {\n        return false;\n      }\n\n      if (!this.hasEnoughCash({\n        loan: loanObject\n      })) {\n        return false;\n      }\n\n      if (!this.structureIsValid({\n        loan: loanObject\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    getMaxPropertyValue(_ref9) {\n      let {\n        borrowers,\n        maxBorrowRatio,\n        canton,\n        residenceType\n      } = _ref9;\n\n      // Immediately stop iterating if maxBorrowRatio is above what is allowed\n      if (this.maxBorrowRatio < maxBorrowRatio) {\n        return 0;\n      }\n\n      let foundValue = false;\n      let minBound = INITIAL_MIN_BOUND;\n      let maxBound = INITIAL_MAX_BOUND;\n      let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n      let iterations = 0; // The rounding amount of 1000 is helpful when the user tries to\n      // fit his own funds into a structure without being overly accurate\n      // which is annoying.\n      // However for this calculation we don't need to round own funds as loosely\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n      while (!foundValue) {\n        iterations += 1;\n        const nextPropertyValue = roundValue((minBound + maxBound) / 2, ROUNDING_DIGITS);\n        const ownFunds = this.suggestStructure({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue\n        });\n\n        if (this.suggestedStructureIsValid({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue,\n          ownFunds\n        })) {\n          minBound = nextPropertyValue;\n          maxBound = Math.min(maxBound * MAX_BOUND_MULTIPLICATION_FACTOR, absoluteMax);\n        } else {\n          maxBound = nextPropertyValue;\n          absoluteMax = maxBound;\n        }\n\n        if (maxBound - minBound <= ACCURACY) {\n          foundValue = true;\n        }\n\n        if (iterations > MAX_ITERATIONS) {\n          foundValue = true;\n        }\n      }\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n      return minBound;\n    }\n\n    getNextStepSize(_ref10) {\n      let {\n        currentMax,\n        currentBorrowRatio,\n        stepSize,\n        borrowers,\n        residenceType,\n        canton,\n        direction,\n        cache\n      } = _ref10;\n      let newStepSize = stepSize;\n      let foundBetterValue;\n\n      while (!foundBetterValue) {\n        let nextValue;\n\n        if (direction === 'upwards') {\n          nextValue = cache[currentBorrowRatio + stepSize] || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: currentBorrowRatio + stepSize,\n            canton\n          });\n        } else {\n          nextValue = cache[currentBorrowRatio - stepSize] || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: currentBorrowRatio - stepSize,\n            canton\n          });\n        }\n\n        if (nextValue > currentMax) {\n          foundBetterValue = true;\n        } else {\n          newStepSize /= 2;\n        }\n\n        if (newStepSize < 0.05) {\n          foundBetterValue = true;\n        }\n      }\n\n      return newStepSize;\n    }\n\n    getMaxPropertyValueWithoutBorrowRatio(_ref11) {\n      let {\n        borrowers,\n        residenceType,\n        canton\n      } = _ref11;\n      let borrowRatio = 0.7;\n      let foundValue = false;\n      let iterations = 0;\n      let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n      const deltaX = 0.01;\n      let maxPropertyValue = 0;\n      let optimalBorrowRatio;\n      const cache = {};\n\n      const setMax = (ratio, propertyValue) => {\n        // Cache each result to avoid recalculating it later\n        if (!cache[\"\".concat(ratio)]) {\n          cache[\"\".concat(ratio)] = propertyValue;\n        } // Always store the highest encountered value, in case the loop\n        // stops prematurely, or if the stopping conditions would've skipped\n        // a value that we already calculated\n\n\n        if (propertyValue > maxPropertyValue) {\n          maxPropertyValue = propertyValue;\n          optimalBorrowRatio = ratio;\n        }\n      };\n\n      while (!foundValue) {\n        iterations += 1;\n        const center = cache[borrowRatio] || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: borrowRatio,\n          canton\n        });\n        setMax(borrowRatio, center);\n        const yLeft = cache[borrowRatio - deltaX] || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: borrowRatio - deltaX,\n          canton\n        });\n        setMax(borrowRatio - deltaX, yLeft);\n        const yRight = cache[borrowRatio + deltaX] || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: borrowRatio + deltaX,\n          canton\n        });\n        setMax(borrowRatio + deltaX, yRight);\n        const slope = yRight - yLeft;\n\n        if (yRight === 0 && yLeft === 0) {\n          // If the algorithm is at 0 on both sides, it means the borrowRatio\n          // is way too high, so start him over again at 0, but with a large\n          // step size to allow it to recover quickly\n          borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n          stepSize = 0.2;\n        } else if (slope > 0) {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'upwards',\n            cache\n          });\n          borrowRatio += stepSize;\n        } else {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'downwards',\n            cache\n          });\n          borrowRatio -= stepSize;\n        }\n\n        if (stepSize < deltaX / 2) {\n          foundValue = true;\n        }\n\n        if (iterations > 50) {\n          foundValue = true;\n        }\n      } // Round the borrowRatio, and recompute the exact property value\n\n\n      const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n      const finalPropertyValue = cache[finalBorrowRatio] || this.getMaxPropertyValue({\n        borrowers,\n        residenceType,\n        maxBorrowRatio: finalBorrowRatio,\n        canton\n      });\n      return {\n        borrowRatio: finalBorrowRatio,\n        propertyValue: finalPropertyValue\n      };\n    }\n\n    getMaxPropertyValueForLoan(_ref12) {\n      let {\n        loan,\n        maxBorrowRatio,\n        canton,\n        residenceType\n      } = _ref12;\n      const {\n        borrowers,\n        residenceType: loanResidenceType\n      } = loan;\n      return this.getMaxPropertyValue({\n        borrowers,\n        residenceType: residenceType || loanResidenceType,\n        maxBorrowRatio,\n        canton\n      });\n    }\n\n    suggestStructureForLoan(_ref13) {\n      let {\n        loan,\n        structureId\n      } = _ref13;\n      const propertyValue = this.getPropAndWork({\n        loan,\n        structureId\n      });\n      const loanValue = this.selectLoanValue({\n        loan,\n        structureId\n      });\n      const notaryFees = this.getFees({\n        loan,\n        structureId\n      }).total;\n      return this.suggestStructure({\n        borrowers: loan.borrowers,\n        propertyValue,\n        loanValue,\n        residenceType: loan.residenceType,\n        notaryFees\n      });\n    }\n\n  };\n};","map":{"version":3,"sources":["imports/core/utils/Calculator/SolvencyCalculator.js"],"names":["INITIAL_MIN_BOUND","INITIAL_MAX_BOUND","INITIAL_ABSOLUTE_MAX_BOUND","MAX_ITERATIONS","ACCURACY","ROUNDING_DIGITS","Math","MAX_BOUND_MULTIPLICATION_FACTOR","OWN_FUNDS_ROUNDING_ALGO","INITIAL_BORROW_RATIO_STEP_SIZE","withSolvencyCalculator","SuperClass","getAllowedOwnFundsTypes","residenceType","RESIDENCE_TYPE","OWN_FUNDS_TYPES","ownFundTypeRequiresUsageType","type","makeOwnFunds","max","borrower","ownFundsObject","value","borrowers","borrowerId","_id","usageType","OWN_FUNDS_USAGE_TYPES","WITHDRAW","suggestStructure","maxBorrowRatio","notaryFees","forcedNotaryFees","finalLoanValue","loanValue","propertyValue","notaryCalc","canton","mortgageNoteIncrease","requiredOwnFunds","ownFunds","allowedOwnFundsTypes","newOwnFunds","tot","createLoanObject","loanTranches","rest","structure","property","suggestedStructureIsValid","loanObject","wantedLoan","loan","lenderRules","getMaxPropertyValue","foundValue","minBound","maxBound","absoluteMax","iterations","nextPropertyValue","roundValue","getNextStepSize","cache","newStepSize","direction","nextValue","currentBorrowRatio","foundBetterValue","getMaxPropertyValueWithoutBorrowRatio","borrowRatio","stepSize","deltaX","maxPropertyValue","setMax","optimalBorrowRatio","center","yLeft","yRight","slope","currentMax","finalBorrowRatio","finalPropertyValue","getMaxPropertyValueForLoan","loanResidenceType","suggestStructureForLoan","structureId"],"mappings":"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","sourcesContent":["// @flow\nimport { OWN_FUNDS_ROUNDING_AMOUNT } from '../../config/financeConstants';\nimport {\n  OWN_FUNDS_TYPES,\n  RESIDENCE_TYPE,\n  OWN_FUNDS_USAGE_TYPES,\n} from '../../api/constants';\nimport { arrayify } from '../general';\nimport { NotaryFeesCalculator } from '../notaryFees/index';\nimport { roundValue } from '../conversionFunctions';\n\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nexport const withSolvencyCalculator = (SuperClass = class {}) =>\n  class extends SuperClass {\n    getAllowedOwnFundsTypes({ residenceType }) {\n      return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE\n        ? [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3A,\n          OWN_FUNDS_TYPES.BANK_3A,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n          OWN_FUNDS_TYPES.INSURANCE_2,\n        ]\n        : [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n        ];\n    }\n\n    ownFundTypeRequiresUsageType({ type }) {\n      return [\n        OWN_FUNDS_TYPES.INSURANCE_2,\n        OWN_FUNDS_TYPES.INSURANCE_3A,\n        OWN_FUNDS_TYPES.INSURANCE_3B,\n      ].includes(type);\n    }\n\n    makeOwnFunds({ borrowers, type, usageType, max }) {\n      return arrayify(borrowers)\n        .map((borrower) => {\n          const ownFundsObject = {\n            type,\n            value: Math.ceil(Math.min(max, this.getFunds({ borrowers: borrower, type }))),\n            borrowerId: borrower._id,\n          };\n\n          if (!usageType && this.ownFundTypeRequiresUsageType({ type })) {\n            return {\n              ...ownFundsObject,\n              usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW,\n            };\n          }\n\n          if (usageType) {\n            return { ...ownFundsObject, usageType };\n          }\n\n          return ownFundsObject;\n        })\n        .filter(({ value }) => value > 0);\n    }\n\n    suggestStructure({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      notaryFees: forcedNotaryFees,\n    }) {\n      let notaryFees;\n\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n      if (forcedNotaryFees) {\n        notaryFees = forcedNotaryFees;\n      } else {\n        const notaryCalc = new NotaryFeesCalculator({ canton });\n        notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n          propertyValue,\n          mortgageNoteIncrease: finalLoanValue,\n          residenceType,\n        }).total;\n      }\n\n      let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n      let ownFunds = [];\n\n      // Get all possible OWN_FUNDS_TYPES\n      const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n        residenceType,\n      });\n\n      allowedOwnFundsTypes.forEach((type) => {\n        borrowers.forEach((borrower) => {\n          const newOwnFunds = this.makeOwnFunds({\n            borrowers: borrower,\n            type,\n            max: requiredOwnFunds,\n          });\n\n          requiredOwnFunds -= newOwnFunds.reduce(\n            (tot, { value }) => tot + value,\n            0,\n          );\n\n          ownFunds = [...ownFunds, ...newOwnFunds];\n        });\n      });\n\n      return ownFunds;\n    }\n\n    createLoanObject({\n      residenceType,\n      borrowers,\n      wantedLoan,\n      propertyValue,\n      canton,\n      ownFunds = [],\n      loanTranches = [],\n      ...rest\n    }) {\n      return {\n        residenceType,\n        borrowers,\n        structure: {\n          wantedLoan,\n          propertyValue,\n          property: { canton },\n          ownFunds,\n          loanTranches,\n        },\n        ...rest,\n      };\n    }\n\n    suggestedStructureIsValid({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      ownFunds,\n    }) {\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n      const loanObject = this.createLoanObject({\n        residenceType,\n        borrowers,\n        wantedLoan: finalLoanValue,\n        propertyValue,\n        canton,\n        ownFunds,\n      });\n\n      // If the calculator has been initialized, reinitialize it according to this new potential loan\n      if (this.lenderRules) {\n        this.initialize({ loan: loanObject, lenderRules: this.lenderRules });\n      }\n\n      if (this.isMissingOwnFunds({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.hasEnoughCash({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.structureIsValid({ loan: loanObject })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    getMaxPropertyValue({ borrowers, maxBorrowRatio, canton, residenceType }) {\n      // Immediately stop iterating if maxBorrowRatio is above what is allowed\n      if (this.maxBorrowRatio < maxBorrowRatio) {\n        return 0;\n      }\n\n      let foundValue = false;\n      let minBound = INITIAL_MIN_BOUND;\n      let maxBound = INITIAL_MAX_BOUND;\n      let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n      let iterations = 0;\n\n      // The rounding amount of 1000 is helpful when the user tries to\n      // fit his own funds into a structure without being overly accurate\n      // which is annoying.\n      // However for this calculation we don't need to round own funds as loosely\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n      while (!foundValue) {\n        iterations += 1;\n        const nextPropertyValue = roundValue(\n          (minBound + maxBound) / 2,\n          ROUNDING_DIGITS,\n        );\n\n        const ownFunds = this.suggestStructure({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue,\n        });\n\n        if (\n          this.suggestedStructureIsValid({\n            borrowers,\n            maxBorrowRatio,\n            canton,\n            residenceType,\n            propertyValue: nextPropertyValue,\n            ownFunds,\n          })\n        ) {\n          minBound = nextPropertyValue;\n          maxBound = Math.min(\n            maxBound * MAX_BOUND_MULTIPLICATION_FACTOR,\n            absoluteMax,\n          );\n        } else {\n          maxBound = nextPropertyValue;\n          absoluteMax = maxBound;\n        }\n\n        if (maxBound - minBound <= ACCURACY) {\n          foundValue = true;\n        }\n\n        if (iterations > MAX_ITERATIONS) {\n          foundValue = true;\n        }\n      }\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n\n      return minBound;\n    }\n\n    getNextStepSize({\n      currentMax,\n      currentBorrowRatio,\n      stepSize,\n      borrowers,\n      residenceType,\n      canton,\n      direction,\n      cache,\n    }) {\n      let newStepSize = stepSize;\n      let foundBetterValue;\n\n      while (!foundBetterValue) {\n        let nextValue;\n        if (direction === 'upwards') {\n          nextValue = cache[currentBorrowRatio + stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio + stepSize,\n              canton,\n            });\n        } else {\n          nextValue = cache[currentBorrowRatio - stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio - stepSize,\n              canton,\n            });\n        }\n\n        if (nextValue > currentMax) {\n          foundBetterValue = true;\n        } else {\n          newStepSize /= 2;\n        }\n\n        if (newStepSize < 0.05) {\n          foundBetterValue = true;\n        }\n      }\n\n      return newStepSize;\n    }\n\n    getMaxPropertyValueWithoutBorrowRatio({\n      borrowers,\n      residenceType,\n      canton,\n    }) {\n      let borrowRatio = 0.7;\n      let foundValue = false;\n      let iterations = 0;\n      let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n      const deltaX = 0.01;\n      let maxPropertyValue = 0;\n      let optimalBorrowRatio;\n      const cache = {};\n\n      const setMax = (ratio, propertyValue) => {\n        // Cache each result to avoid recalculating it later\n        if (!cache[`${ratio}`]) {\n          cache[`${ratio}`] = propertyValue;\n        }\n\n        // Always store the highest encountered value, in case the loop\n        // stops prematurely, or if the stopping conditions would've skipped\n        // a value that we already calculated\n        if (propertyValue > maxPropertyValue) {\n          maxPropertyValue = propertyValue;\n          optimalBorrowRatio = ratio;\n        }\n      };\n\n      while (!foundValue) {\n        iterations += 1;\n\n        const center = cache[borrowRatio]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio,\n            canton,\n          });\n        setMax(borrowRatio, center);\n\n        const yLeft = cache[borrowRatio - deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio - deltaX,\n            canton,\n          });\n        setMax(borrowRatio - deltaX, yLeft);\n        const yRight = cache[borrowRatio + deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio + deltaX,\n            canton,\n          });\n        setMax(borrowRatio + deltaX, yRight);\n\n        const slope = yRight - yLeft;\n\n        if (yRight === 0 && yLeft === 0) {\n          // If the algorithm is at 0 on both sides, it means the borrowRatio\n          // is way too high, so start him over again at 0, but with a large\n          // step size to allow it to recover quickly\n          borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n          stepSize = 0.2;\n        } else if (slope > 0) {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'upwards',\n            cache,\n          });\n          borrowRatio += stepSize;\n        } else {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'downwards',\n            cache,\n          });\n          borrowRatio -= stepSize;\n        }\n\n        if (stepSize < deltaX / 2) {\n          foundValue = true;\n        }\n\n        if (iterations > 50) {\n          foundValue = true;\n        }\n      }\n\n      // Round the borrowRatio, and recompute the exact property value\n      const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n      const finalPropertyValue = cache[finalBorrowRatio]\n        || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: finalBorrowRatio,\n          canton,\n        });\n\n      return {\n        borrowRatio: finalBorrowRatio,\n        propertyValue: finalPropertyValue,\n      };\n    }\n\n    getMaxPropertyValueForLoan({\n      loan,\n      maxBorrowRatio,\n      canton,\n      residenceType,\n    }) {\n      const { borrowers, residenceType: loanResidenceType } = loan;\n      return this.getMaxPropertyValue({\n        borrowers,\n        residenceType: residenceType || loanResidenceType,\n        maxBorrowRatio,\n        canton,\n      });\n    }\n\n    suggestStructureForLoan({ loan, structureId }) {\n      const propertyValue = this.getPropAndWork({ loan, structureId });\n      const loanValue = this.selectLoanValue({ loan, structureId });\n      const notaryFees = this.getFees({ loan, structureId }).total;\n\n      return this.suggestStructure({\n        borrowers: loan.borrowers,\n        propertyValue,\n        loanValue,\n        residenceType: loan.residenceType,\n        notaryFees,\n      });\n    }\n  };\n"]},"sourceType":"script","hash":"fa2f5fe8e3fd97c55e1257ab446a6d1c7542cecd"}
