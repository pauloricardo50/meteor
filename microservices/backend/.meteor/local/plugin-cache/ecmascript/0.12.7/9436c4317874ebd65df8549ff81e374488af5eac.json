{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js","passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js"}},"code":"module.export({\n  default: () => ObservableCollection\n});\nlet DiffSequence;\nmodule.link(\"meteor/diff-sequence\", {\n  DiffSequence(v) {\n    DiffSequence = v;\n  }\n\n}, 0);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 1);\nlet LocalCollection, Minimongo;\nmodule.link(\"meteor/minimongo\", {\n  LocalCollection(v) {\n    LocalCollection = v;\n  },\n\n  Minimongo(v) {\n    Minimongo = v;\n  }\n\n}, 2);\nlet cloneDeep;\nmodule.link(\"lodash.clonedeep\", {\n  default(v) {\n    cloneDeep = v;\n  }\n\n}, 3);\nlet fieldProjectionIsExclusion;\nmodule.link(\"./lib/fieldProjectionIsExclusion\", {\n  default(v) {\n    fieldProjectionIsExclusion = v;\n  }\n\n}, 4);\nlet getChannels;\nmodule.link(\"./lib/getChannels\", {\n  default(v) {\n    getChannels = v;\n  }\n\n}, 5);\nlet extractFieldsFromFilters;\nmodule.link(\"./lib/extractFieldsFromFilters\", {\n  default(v) {\n    extractFieldsFromFilters = v;\n  }\n\n}, 6);\nlet MongoIDMap;\nmodule.link(\"./mongoIdMap\", {\n  MongoIDMap(v) {\n    MongoIDMap = v;\n  }\n\n}, 7);\nconst allowedOptions = ['limit', 'skip', 'sort', 'fields', 'channels', 'channel', 'namespace', 'namespaces'];\nconst {\n  Matcher\n} = Minimongo;\n\nclass ObservableCollection {\n  /**\n   * @param observer\n   * @param cursor\n   * @param config\n   */\n  constructor(observer, cursor, config = {}) {\n    this.observer = observer;\n    this.cursor = cursor;\n    this.config = config;\n    this.store = new MongoIDMap();\n    const cursorDescription = cursor._cursorDescription;\n\n    if (cursorDescription) {\n      this.collectionName = cursorDescription.collectionName;\n      this.collection = Mongo.Collection.__getCollectionByName(this.collectionName);\n      this.selector = cursorDescription.selector || {};\n\n      if (_.isString(this.selector)) {\n        this.selector = {\n          _id: this.selector\n        };\n      }\n\n      if (cursorDescription.options) {\n        this.options = _.pick(cursorDescription.options, ...allowedOptions);\n      } else {\n        this.options = {};\n      }\n    } else {\n      this.collectionName = cursor.collection.name;\n      this.collection = Mongo.Collection.__getCollectionByName(this.collectionName);\n      this.selector = {};\n      this.options = {};\n    }\n\n    if (!this.collection) {\n      throw new Meteor.Error('We could not properly identify the collection by its name: ' + this.collectionName + '. Make sure you added redis-oplog package before any package that instantiates a collection.');\n    } // check for empty projector object and delete.\n\n\n    if (this.options.fields && _.isEmpty(this.options.fields)) {\n      delete this.options.fields;\n    }\n\n    if (this.options.fields) {\n      this.fieldsArray = _.keys(this.options.fields);\n\n      if (!_.isArray(this.fieldsArray)) {\n        throw new Meteor.Error('We could not properly extract any fields. \"fields\" must be an object. This was provided: ' + JSON.stringify(this.options.fields));\n      }\n\n      this.projectFieldsOnDoc = LocalCollection._compileProjection(this.options.fields);\n      this.isFieldsProjectionByExclusion = fieldProjectionIsExclusion(this.options.fields);\n    }\n\n    this.channels = getChannels(this.collectionName, this.options);\n    this.testDocEligibility = this._createTestDocEligibility();\n    this.fieldsOfInterest = this._getFieldsOfInterest();\n    this.__isInitialized = false;\n  }\n  /**\n   * Function that checks whether or not the doc matches our filters\n   *\n   * @param doc\n   * @returns {*}\n   */\n\n\n  isEligible(doc) {\n    if (this.testDocEligibility) {\n      return this.testDocEligibility(doc);\n    }\n\n    return true;\n  }\n  /**\n   * @param _id\n   * @returns {boolean}\n   */\n\n\n  isEligibleByDB(_id) {\n    if (this.testDocEligibility) {\n      return !!this.collection.findOne(_.extend({}, this.selector, {\n        _id\n      }), {\n        fields: {\n          _id: 1\n        }\n      });\n    }\n\n    return true;\n  }\n  /**\n   * Performs the initial search then puts them into the store.\n   */\n\n\n  init() {\n    if (this.__isInitialized) {\n      return; // silently do nothing.\n    }\n\n    this.__isInitialized = true;\n    let data = this.cursor.fetch();\n    data.forEach(doc => {\n      this.store.set(doc._id, doc);\n    });\n  }\n  /**\n   * @param docId\n   * @returns {boolean}\n   */\n\n\n  contains(docId) {\n    return this.store.has(docId);\n  }\n  /**\n   * Sends the data through DDP\n   *\n   * @param event\n   * @param args\n   */\n\n\n  send(event, ...args) {\n    this.observer.send(event, this.collectionName, ...args);\n  }\n  /**\n   * @param doc {Object}\n   * @param safe {Boolean} If this is set to true, it assumes that the object is cleaned\n   */\n\n\n  add(doc, safe = false) {\n    doc = cloneDeep(doc);\n\n    if (!safe) {\n      if (this.fieldsArray) {\n        doc = this.projectFieldsOnDoc(doc);\n      }\n    }\n\n    this.store.set(doc._id, doc);\n    this.send('added', doc._id, doc);\n  }\n  /**\n   * We use this method when we receive updates for a document that is not yet in the observable collection store\n   * @param docId\n   */\n\n\n  addById(docId) {\n    const doc = this.collection.findOne({\n      _id: docId\n    }, this.options);\n    this.store.set(docId, doc);\n\n    if (doc) {\n      this.send('added', doc._id, doc);\n    }\n  }\n  /**\n   * Sends over the wire only the top fields of changes, because DDP client doesnt do deep merge.\n   *\n   * @param {object} doc\n   * @param {array} modifiedFields\n   */\n\n\n  change(doc, modifiedFields) {\n    const docId = doc._id;\n    const oldDoc = this.store.get(docId);\n\n    if (oldDoc == null) {\n      return;\n    }\n\n    let newDoc = cloneDeep(doc);\n\n    if (this.fieldsArray) {\n      newDoc = this.projectFieldsOnDoc(newDoc);\n    }\n\n    if (this.options.transform) {\n      newDoc = this.options.transform(newDoc);\n    }\n\n    this.store.set(docId, newDoc);\n    const changedTopLevelFields = DiffSequence.makeChangedFields(newDoc, oldDoc);\n\n    if (!_.isEmpty(changedTopLevelFields)) {\n      this.send('changed', docId, changedTopLevelFields, newDoc, oldDoc);\n    }\n  }\n  /**\n   * @param docId string\n   * @param modifier object\n   * @param topLevelFields array\n   * @private\n   */\n\n\n  changeSynthetic(docId, modifier, topLevelFields) {\n    if (!this.store.has(docId)) {\n      return;\n    }\n\n    let storedDoc = this.store.get(docId);\n    let oldDoc = cloneDeep(storedDoc);\n\n    LocalCollection._modify(storedDoc, modifier);\n\n    let changedTopLevelFields = {};\n    topLevelFields.forEach(topLevelField => {\n      changedTopLevelFields[topLevelField] = storedDoc[topLevelField];\n    });\n    this.send('changed', docId, changedTopLevelFields, storedDoc, oldDoc);\n  }\n  /**\n   * @param docId\n   */\n\n\n  remove(docId) {\n    const doc = this.store.pop(docId);\n\n    if (doc != null) {\n      this.send('removed', docId, doc);\n    }\n  }\n  /**\n   * Clears the store\n   */\n\n\n  clearStore() {\n    this.store.clear();\n  }\n  /**\n   * Returns whether the limit of allowed documents is reached\n   * based on the selector options\n   */\n\n\n  isLimitReached() {\n    if (this.options.limit) {\n      const size = this.store.size();\n      return size >= this.options.limit;\n    }\n\n    return false;\n  }\n  /**\n   * Used at initialization\n   *\n   * Creates the function that checks if the document is valid\n   *\n   * @returns {null}\n   * @private\n   */\n\n\n  _createTestDocEligibility() {\n    const self = this;\n\n    if (_.keys(this.selector).length) {\n      try {\n        const matcher = new Matcher(this.selector);\n        return function (object) {\n          return matcher.documentMatches(object).result;\n        };\n      } catch (e) {\n        // The logic here is that if our matcher is too complex for minimongo\n        // We put our matching function to query db\n        if (e.toString().indexOf('Unrecognized logical operator') >= 0) {\n          return function (object) {\n            return self.isEligibleByDB(object._id);\n          };\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Used at initialization\n   *\n   * Creates and stores the fields specified in fields & filters\n   * If by any chance there are no fields specified, we return true\n   *\n   * @private\n   * @return {true|object}\n   */\n\n\n  _getFieldsOfInterest() {\n    if (!this.options.fields) {\n      return true;\n    } // if you have some fields excluded (high chances you don't, but we query for all fields either way)\n    // because it can get very tricky with future subscribers that may need some fields\n\n\n    if (this.isFieldsProjectionByExclusion) {\n      return true;\n    } // if we have options, we surely have fields array\n\n\n    let fieldsArray = this.fieldsArray.slice();\n\n    if (_.keys(this.selector).length > 0) {\n      fieldsArray = _.union(fieldsArray, extractFieldsFromFilters(this.selector));\n    }\n\n    return fieldsArray;\n  }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:redis-oplog/lib/cache/ObservableCollection.js"],"names":["module","export","default","ObservableCollection","DiffSequence","link","v","_","LocalCollection","Minimongo","cloneDeep","fieldProjectionIsExclusion","getChannels","extractFieldsFromFilters","MongoIDMap","allowedOptions","Matcher","constructor","observer","cursor","config","store","cursorDescription","_cursorDescription","collectionName","collection","Mongo","Collection","__getCollectionByName","selector","isString","_id","options","pick","name","Meteor","Error","fields","isEmpty","fieldsArray","keys","isArray","JSON","stringify","projectFieldsOnDoc","_compileProjection","isFieldsProjectionByExclusion","channels","testDocEligibility","_createTestDocEligibility","fieldsOfInterest","_getFieldsOfInterest","__isInitialized","isEligible","doc","isEligibleByDB","findOne","extend","init","data","fetch","forEach","set","contains","docId","has","send","event","args","add","safe","addById","change","modifiedFields","oldDoc","get","newDoc","transform","changedTopLevelFields","makeChangedFields","changeSynthetic","modifier","topLevelFields","storedDoc","_modify","topLevelField","remove","pop","clearStore","clear","isLimitReached","limit","size","self","length","matcher","object","documentMatches","result","e","toString","indexOf","slice","union"],"mappings":"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","sourcesContent":["import { DiffSequence } from 'meteor/diff-sequence';\nimport { _ } from 'meteor/underscore';\nimport { LocalCollection, Minimongo } from 'meteor/minimongo';\nimport cloneDeep from 'lodash.clonedeep';\nimport fieldProjectionIsExclusion from './lib/fieldProjectionIsExclusion';\nimport getChannels from './lib/getChannels';\nimport extractFieldsFromFilters from './lib/extractFieldsFromFilters';\nimport { MongoIDMap } from './mongoIdMap';\n\nconst allowedOptions = [\n    'limit',\n    'skip',\n    'sort',\n    'fields',\n    'channels',\n    'channel',\n    'namespace',\n    'namespaces',\n];\n\nconst { Matcher } = Minimongo;\n\nexport default class ObservableCollection {\n    /**\n     * @param observer\n     * @param cursor\n     * @param config\n     */\n    constructor(observer, cursor, config = {}) {\n        this.observer = observer;\n        this.cursor = cursor;\n        this.config = config;\n        this.store = new MongoIDMap();\n\n        const cursorDescription = cursor._cursorDescription;\n\n        if (cursorDescription) {\n            this.collectionName = cursorDescription.collectionName;\n            this.collection = Mongo.Collection.__getCollectionByName(\n                this.collectionName\n            );\n\n            this.selector = cursorDescription.selector || {};\n\n            if (_.isString(this.selector)) {\n                this.selector = { _id: this.selector };\n            }\n\n            if (cursorDescription.options) {\n                this.options = _.pick(\n                    cursorDescription.options,\n                    ...allowedOptions\n                );\n            } else {\n                this.options = {};\n            }\n        } else {\n            this.collectionName = cursor.collection.name;\n            this.collection = Mongo.Collection.__getCollectionByName(\n                this.collectionName\n            );\n            this.selector = {};\n            this.options = {};\n        }\n\n        if (!this.collection) {\n            throw new Meteor.Error(\n                'We could not properly identify the collection by its name: ' +\n                    this.collectionName +\n                    '. Make sure you added redis-oplog package before any package that instantiates a collection.'\n            );\n        }\n\n        // check for empty projector object and delete.\n        if (this.options.fields && _.isEmpty(this.options.fields)) {\n            delete this.options.fields;\n        }\n\n        if (this.options.fields) {\n            this.fieldsArray = _.keys(this.options.fields);\n\n            if (!_.isArray(this.fieldsArray)) {\n                throw new Meteor.Error(\n                    'We could not properly extract any fields. \"fields\" must be an object. This was provided: ' +\n                        JSON.stringify(this.options.fields)\n                );\n            }\n\n            this.projectFieldsOnDoc = LocalCollection._compileProjection(\n                this.options.fields\n            );\n            this.isFieldsProjectionByExclusion = fieldProjectionIsExclusion(\n                this.options.fields\n            );\n        }\n\n        this.channels = getChannels(this.collectionName, this.options);\n        this.testDocEligibility = this._createTestDocEligibility();\n        this.fieldsOfInterest = this._getFieldsOfInterest();\n        this.__isInitialized = false;\n    }\n\n    /**\n     * Function that checks whether or not the doc matches our filters\n     *\n     * @param doc\n     * @returns {*}\n     */\n    isEligible(doc) {\n        if (this.testDocEligibility) {\n            return this.testDocEligibility(doc);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param _id\n     * @returns {boolean}\n     */\n    isEligibleByDB(_id) {\n        if (this.testDocEligibility) {\n            return !!this.collection.findOne(\n                _.extend({}, this.selector, { _id }),\n                { fields: { _id: 1 } }\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Performs the initial search then puts them into the store.\n     */\n    init() {\n        if (this.__isInitialized) {\n            return; // silently do nothing.\n        }\n\n        this.__isInitialized = true;\n        let data = this.cursor.fetch();\n\n        data.forEach(doc => {\n            this.store.set(doc._id, doc);\n        });\n    }\n\n    /**\n     * @param docId\n     * @returns {boolean}\n     */\n    contains(docId) {\n        return this.store.has(docId);\n    }\n\n    /**\n     * Sends the data through DDP\n     *\n     * @param event\n     * @param args\n     */\n    send(event, ...args) {\n        this.observer.send(event, this.collectionName, ...args);\n    }\n\n    /**\n     * @param doc {Object}\n     * @param safe {Boolean} If this is set to true, it assumes that the object is cleaned\n     */\n    add(doc, safe = false) {\n        doc = cloneDeep(doc);\n\n        if (!safe) {\n            if (this.fieldsArray) {\n                doc = this.projectFieldsOnDoc(doc);\n            }\n        }\n\n        this.store.set(doc._id, doc);\n        this.send('added', doc._id, doc);\n    }\n\n    /**\n     * We use this method when we receive updates for a document that is not yet in the observable collection store\n     * @param docId\n     */\n    addById(docId) {\n        const doc = this.collection.findOne({ _id: docId }, this.options);\n\n        this.store.set(docId, doc);\n\n        if (doc) {\n            this.send('added', doc._id, doc);\n        }\n    }\n\n    /**\n     * Sends over the wire only the top fields of changes, because DDP client doesnt do deep merge.\n     *\n     * @param {object} doc\n     * @param {array} modifiedFields\n     */\n    change(doc, modifiedFields) {\n        const docId = doc._id;\n        const oldDoc = this.store.get(docId);\n        if (oldDoc == null) {\n            return;\n        }\n        let newDoc = cloneDeep(doc);\n        if (this.fieldsArray) {\n            newDoc = this.projectFieldsOnDoc(newDoc);\n        }\n        if (this.options.transform) {\n            newDoc = this.options.transform(newDoc);\n        }\n        this.store.set(docId, newDoc);\n        const changedTopLevelFields = DiffSequence.makeChangedFields(newDoc, oldDoc);\n        if (!_.isEmpty(changedTopLevelFields)) {\n            this.send('changed', docId, changedTopLevelFields, newDoc, oldDoc)\n        }\n    }\n\n    /**\n     * @param docId string\n     * @param modifier object\n     * @param topLevelFields array\n     * @private\n     */\n    changeSynthetic(docId, modifier, topLevelFields) {\n        if (!this.store.has(docId)) {\n            return;\n        }\n\n        let storedDoc = this.store.get(docId);\n        let oldDoc = cloneDeep(storedDoc);\n\n        LocalCollection._modify(storedDoc, modifier);\n        let changedTopLevelFields = {};\n\n        topLevelFields.forEach(topLevelField => {\n            changedTopLevelFields[topLevelField] = storedDoc[topLevelField];\n        });\n\n        this.send('changed', docId, changedTopLevelFields, storedDoc, oldDoc);\n    }\n\n    /**\n     * @param docId\n     */\n    remove(docId) {\n        const doc = this.store.pop(docId);\n        if (doc != null) {\n            this.send('removed', docId, doc);\n        }\n    }\n\n    /**\n     * Clears the store\n     */\n    clearStore() {\n        this.store.clear();\n    }\n\n    /**\n     * Returns whether the limit of allowed documents is reached\n     * based on the selector options\n     */\n    isLimitReached() {\n        if (this.options.limit) {\n            const size = this.store.size();\n            return size >= this.options.limit;\n        }\n\n        return false;\n    }\n\n    /**\n     * Used at initialization\n     *\n     * Creates the function that checks if the document is valid\n     *\n     * @returns {null}\n     * @private\n     */\n    _createTestDocEligibility() {\n        const self = this;\n\n        if (_.keys(this.selector).length) {\n            try {\n                const matcher = new Matcher(this.selector);\n\n                return function (object) {\n                    return matcher.documentMatches(object).result;\n                };\n            } catch (e) {\n                // The logic here is that if our matcher is too complex for minimongo\n                // We put our matching function to query db\n                if (\n                    e.toString().indexOf('Unrecognized logical operator') >= 0\n                ) {\n                    return function (object) {\n                        return self.isEligibleByDB(object._id);\n                    };\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Used at initialization\n     *\n     * Creates and stores the fields specified in fields & filters\n     * If by any chance there are no fields specified, we return true\n     *\n     * @private\n     * @return {true|object}\n     */\n    _getFieldsOfInterest() {\n        if (!this.options.fields) {\n            return true;\n        }\n\n        // if you have some fields excluded (high chances you don't, but we query for all fields either way)\n        // because it can get very tricky with future subscribers that may need some fields\n        if (this.isFieldsProjectionByExclusion) {\n            return true;\n        }\n\n        // if we have options, we surely have fields array\n        let fieldsArray = this.fieldsArray.slice();\n        if (_.keys(this.selector).length > 0) {\n            fieldsArray = _.union(\n                fieldsArray,\n                extractFieldsFromFilters(this.selector)\n            );\n        }\n\n        return fieldsArray;\n    }\n}\n"]},"sourceType":"script","hash":"9436c4317874ebd65df8549ff81e374488af5eac"}
