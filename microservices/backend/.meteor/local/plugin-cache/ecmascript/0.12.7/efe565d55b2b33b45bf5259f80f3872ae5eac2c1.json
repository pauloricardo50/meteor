{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties",["flow",{}],"jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"imports/core/utils/Calculator/SolvencyCalculator.js","filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","inputSourceMap":{"version":3,"sources":["imports/core/utils/Calculator/SolvencyCalculator.js"],"names":["OWN_FUNDS_ROUNDING_AMOUNT","OWN_FUNDS_TYPES","RESIDENCE_TYPE","OWN_FUNDS_USAGE_TYPES","arrayify","NotaryFeesCalculator","roundValue","INITIAL_MIN_BOUND","INITIAL_MAX_BOUND","INITIAL_ABSOLUTE_MAX_BOUND","MAX_ITERATIONS","ACCURACY","ROUNDING_DIGITS","Math","log10","MAX_BOUND_MULTIPLICATION_FACTOR","OWN_FUNDS_ROUNDING_ALGO","INITIAL_BORROW_RATIO_STEP_SIZE","withSolvencyCalculator","SuperClass","getAllowedOwnFundsTypes","residenceType","MAIN_RESIDENCE","THIRD_PARTY_FORTUNE","BANK_FORTUNE","INSURANCE_3A","BANK_3A","INSURANCE_3B","INSURANCE_2","ownFundTypeRequiresUsageType","type","includes","makeOwnFunds","borrowers","usageType","max","map","borrower","ownFundsObject","value","ceil","min","getFunds","borrowerId","_id","WITHDRAW","filter","suggestStructure","propertyValue","maxBorrowRatio","loanValue","canton","notaryFees","forcedNotaryFees","finalLoanValue","round","notaryCalc","getNotaryFeesWithoutLoan","mortgageNoteIncrease","total","requiredOwnFunds","ownFunds","allowedOwnFundsTypes","forEach","newOwnFunds","reduce","tot","createLoanObject","wantedLoan","loanTranches","rest","structure","property","suggestedStructureIsValid","loanObject","lenderRules","initialize","loan","isMissingOwnFunds","hasEnoughCash","structureIsValid","getMaxPropertyValue","foundValue","minBound","maxBound","absoluteMax","iterations","ownFundsRoundingAmount","nextPropertyValue","getNextStepSize","currentMax","currentBorrowRatio","stepSize","direction","cache","newStepSize","foundBetterValue","nextValue","getMaxPropertyValueWithoutBorrowRatio","borrowRatio","deltaX","maxPropertyValue","optimalBorrowRatio","setMax","ratio","center","yLeft","yRight","slope","finalBorrowRatio","finalPropertyValue","getMaxPropertyValueForLoan","loanResidenceType","suggestStructureForLoan","structureId","getPropAndWork","selectLoanValue","getFees"],"mappings":"AAAA;AACA,SAASA,yBAAT;AACA,SACEC,eADF,EAEEC,cAFF,EAGEC,qBAHF;AAKA,SAASC,QAAT;AACA,SAASC,oBAAT;AACA,SAASC,UAAT;AAEA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,iBAAiB,GAAG,OAA1B;AACA,MAAMC,0BAA0B,GAAG,SAAnC;AACA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAMC,QAAQ,GAAG,IAAjB;AACA,MAAMC,eAAe,GAAGC,IAAI,CAACC,KAAL,CAAWH,QAAX,CAAxB;AACA,MAAMI,+BAA+B,GAAG,CAAxC;AACA,MAAMC,uBAAuB,GAAG,GAAhC;AACA,MAAMC,8BAA8B,GAAG,IAAvC;AAEA,OAAO,MAAMC,sBAAsB,GAAG,CAACC,UAAU,GAAG,MAAM,EAApB,KACpC,cAAcA,UAAd,CAAyB;AACvBC,EAAAA,uBAAuB,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAoB;AACzC,WAAOA,aAAa,KAAKnB,cAAc,CAACoB,cAAjC,GACH,CACArB,eAAe,CAACsB,mBADhB,EAEAtB,eAAe,CAACuB,YAFhB,EAGAvB,eAAe,CAACwB,YAHhB,EAIAxB,eAAe,CAACyB,OAJhB,EAKAzB,eAAe,CAAC0B,YALhB,EAMA1B,eAAe,CAAC2B,WANhB,CADG,GASH,CACA3B,eAAe,CAACsB,mBADhB,EAEAtB,eAAe,CAACuB,YAFhB,EAGAvB,eAAe,CAAC0B,YAHhB,CATJ;AAcD;;AAEDE,EAAAA,4BAA4B,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAW;AACrC,WAAO,CACL7B,eAAe,CAAC2B,WADX,EAEL3B,eAAe,CAACwB,YAFX,EAGLxB,eAAe,CAAC0B,YAHX,EAILI,QAJK,CAIID,IAJJ,CAAP;AAKD;;AAEDE,EAAAA,YAAY,CAAC;AAAEC,IAAAA,SAAF;AAAaH,IAAAA,IAAb;AAAmBI,IAAAA,SAAnB;AAA8BC,IAAAA;AAA9B,GAAD,EAAsC;AAChD,WAAO/B,QAAQ,CAAC6B,SAAD,CAAR,CACJG,GADI,CACCC,QAAD,IAAc;AACjB,YAAMC,cAAc,GAAG;AACrBR,QAAAA,IADqB;AAErBS,QAAAA,KAAK,EAAE1B,IAAI,CAAC2B,IAAL,CAAU3B,IAAI,CAAC4B,GAAL,CAASN,GAAT,EAAc,KAAKO,QAAL,CAAc;AAAET,UAAAA,SAAS,EAAEI,QAAb;AAAuBP,UAAAA;AAAvB,SAAd,CAAd,CAAV,CAFc;AAGrBa,QAAAA,UAAU,EAAEN,QAAQ,CAACO;AAHA,OAAvB;;AAMA,UAAI,CAACV,SAAD,IAAc,KAAKL,4BAAL,CAAkC;AAAEC,QAAAA;AAAF,OAAlC,CAAlB,EAA+D;AAC7D,eAAO,EACL,GAAGQ,cADE;AAELJ,UAAAA,SAAS,EAAE/B,qBAAqB,CAAC0C;AAF5B,SAAP;AAID;;AAED,UAAIX,SAAJ,EAAe;AACb,eAAO,EAAE,GAAGI,cAAL;AAAqBJ,UAAAA;AAArB,SAAP;AACD;;AAED,aAAOI,cAAP;AACD,KApBI,EAqBJQ,MArBI,CAqBG,CAAC;AAAEP,MAAAA;AAAF,KAAD,KAAeA,KAAK,GAAG,CArB1B,CAAP;AAsBD;;AAEDQ,EAAAA,gBAAgB,CAAC;AACfd,IAAAA,SADe;AAEfe,IAAAA,aAFe;AAGfC,IAAAA,cAAc,GAAG,KAAKA,cAHP;AAIfC,IAAAA,SAJe;AAKfC,IAAAA,MALe;AAMf9B,IAAAA,aANe;AAOf+B,IAAAA,UAAU,EAAEC;AAPG,GAAD,EAQb;AACD,QAAID,UAAJ;AAEA,UAAME,cAAc,GAAGJ,SAAS,IAAIrC,IAAI,CAAC0C,KAAL,CAAWP,aAAa,GAAGC,cAA3B,CAApC;;AAEA,QAAII,gBAAJ,EAAsB;AACpBD,MAAAA,UAAU,GAAGC,gBAAb;AACD,KAFD,MAEO;AACL,YAAMG,UAAU,GAAG,IAAInD,oBAAJ,CAAyB;AAAE8C,QAAAA;AAAF,OAAzB,CAAnB;AACAC,MAAAA,UAAU,GAAGI,UAAU,CAACC,wBAAX,CAAoC;AAC/CT,QAAAA,aAD+C;AAE/CU,QAAAA,oBAAoB,EAAEJ,cAFyB;AAG/CjC,QAAAA;AAH+C,OAApC,EAIVsC,KAJH;AAKD;;AAED,QAAIC,gBAAgB,GAAG/C,IAAI,CAAC0C,KAAL,CAAWP,aAAa,GAAGI,UAAhB,GAA6BE,cAAxC,CAAvB;AACA,QAAIO,QAAQ,GAAG,EAAf,CAjBC,CAmBD;;AACA,UAAMC,oBAAoB,GAAG,KAAK1C,uBAAL,CAA6B;AACxDC,MAAAA;AADwD,KAA7B,CAA7B;AAIAyC,IAAAA,oBAAoB,CAACC,OAArB,CAA8BjC,IAAD,IAAU;AACrCG,MAAAA,SAAS,CAAC8B,OAAV,CAAmB1B,QAAD,IAAc;AAC9B,cAAM2B,WAAW,GAAG,KAAKhC,YAAL,CAAkB;AACpCC,UAAAA,SAAS,EAAEI,QADyB;AAEpCP,UAAAA,IAFoC;AAGpCK,UAAAA,GAAG,EAAEyB;AAH+B,SAAlB,CAApB;AAMAA,QAAAA,gBAAgB,IAAII,WAAW,CAACC,MAAZ,CAClB,CAACC,GAAD,EAAM;AAAE3B,UAAAA;AAAF,SAAN,KAAoB2B,GAAG,GAAG3B,KADR,EAElB,CAFkB,CAApB;AAKAsB,QAAAA,QAAQ,GAAG,CAAC,GAAGA,QAAJ,EAAc,GAAGG,WAAjB,CAAX;AACD,OAbD;AAcD,KAfD;AAiBA,WAAOH,QAAP;AACD;;AAEDM,EAAAA,gBAAgB,CAAC;AACf9C,IAAAA,aADe;AAEfY,IAAAA,SAFe;AAGfmC,IAAAA,UAHe;AAIfpB,IAAAA,aAJe;AAKfG,IAAAA,MALe;AAMfU,IAAAA,QAAQ,GAAG,EANI;AAOfQ,IAAAA,YAAY,GAAG,EAPA;AAQf,OAAGC;AARY,GAAD,EASb;AACD,WAAO;AACLjD,MAAAA,aADK;AAELY,MAAAA,SAFK;AAGLsC,MAAAA,SAAS,EAAE;AACTH,QAAAA,UADS;AAETpB,QAAAA,aAFS;AAGTwB,QAAAA,QAAQ,EAAE;AAAErB,UAAAA;AAAF,SAHD;AAITU,QAAAA,QAJS;AAKTQ,QAAAA;AALS,OAHN;AAUL,SAAGC;AAVE,KAAP;AAYD;;AAEDG,EAAAA,yBAAyB,CAAC;AACxBxC,IAAAA,SADwB;AAExBe,IAAAA,aAFwB;AAGxBC,IAAAA,cAAc,GAAG,KAAKA,cAHE;AAIxBC,IAAAA,SAJwB;AAKxBC,IAAAA,MALwB;AAMxB9B,IAAAA,aANwB;AAOxBwC,IAAAA;AAPwB,GAAD,EAQtB;AACD,UAAMP,cAAc,GAAGJ,SAAS,IAAIrC,IAAI,CAAC0C,KAAL,CAAWP,aAAa,GAAGC,cAA3B,CAApC;AACA,UAAMyB,UAAU,GAAG,KAAKP,gBAAL,CAAsB;AACvC9C,MAAAA,aADuC;AAEvCY,MAAAA,SAFuC;AAGvCmC,MAAAA,UAAU,EAAEd,cAH2B;AAIvCN,MAAAA,aAJuC;AAKvCG,MAAAA,MALuC;AAMvCU,MAAAA;AANuC,KAAtB,CAAnB,CAFC,CAWD;;AACA,QAAI,KAAKc,WAAT,EAAsB;AACpB,WAAKC,UAAL,CAAgB;AAAEC,QAAAA,IAAI,EAAEH,UAAR;AAAoBC,QAAAA,WAAW,EAAE,KAAKA;AAAtC,OAAhB;AACD;;AAED,QAAI,KAAKG,iBAAL,CAAuB;AAAED,MAAAA,IAAI,EAAEH;AAAR,KAAvB,CAAJ,EAAkD;AAChD,aAAO,KAAP;AACD;;AAED,QAAI,CAAC,KAAKK,aAAL,CAAmB;AAAEF,MAAAA,IAAI,EAAEH;AAAR,KAAnB,CAAL,EAA+C;AAC7C,aAAO,KAAP;AACD;;AAED,QAAI,CAAC,KAAKM,gBAAL,CAAsB;AAAEH,MAAAA,IAAI,EAAEH;AAAR,KAAtB,CAAL,EAAkD;AAChD,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;;AAEDO,EAAAA,mBAAmB,CAAC;AAAEhD,IAAAA,SAAF;AAAagB,IAAAA,cAAb;AAA6BE,IAAAA,MAA7B;AAAqC9B,IAAAA;AAArC,GAAD,EAAuD;AACxE;AACA,QAAI,KAAK4B,cAAL,GAAsBA,cAA1B,EAA0C;AACxC,aAAO,CAAP;AACD;;AAED,QAAIiC,UAAU,GAAG,KAAjB;AACA,QAAIC,QAAQ,GAAG5E,iBAAf;AACA,QAAI6E,QAAQ,GAAG5E,iBAAf;AACA,QAAI6E,WAAW,GAAG5E,0BAAlB;AACA,QAAI6E,UAAU,GAAG,CAAjB,CAVwE,CAYxE;AACA;AACA;AACA;;AACA,SAAKC,sBAAL,GAA8BvE,uBAA9B;;AAEA,WAAO,CAACkE,UAAR,EAAoB;AAClBI,MAAAA,UAAU,IAAI,CAAd;AACA,YAAME,iBAAiB,GAAGlF,UAAU,CAClC,CAAC6E,QAAQ,GAAGC,QAAZ,IAAwB,CADU,EAElCxE,eAFkC,CAApC;AAKA,YAAMiD,QAAQ,GAAG,KAAKd,gBAAL,CAAsB;AACrCd,QAAAA,SADqC;AAErCgB,QAAAA,cAFqC;AAGrCE,QAAAA,MAHqC;AAIrC9B,QAAAA,aAJqC;AAKrC2B,QAAAA,aAAa,EAAEwC;AALsB,OAAtB,CAAjB;;AAQA,UACE,KAAKf,yBAAL,CAA+B;AAC7BxC,QAAAA,SAD6B;AAE7BgB,QAAAA,cAF6B;AAG7BE,QAAAA,MAH6B;AAI7B9B,QAAAA,aAJ6B;AAK7B2B,QAAAA,aAAa,EAAEwC,iBALc;AAM7B3B,QAAAA;AAN6B,OAA/B,CADF,EASE;AACAsB,QAAAA,QAAQ,GAAGK,iBAAX;AACAJ,QAAAA,QAAQ,GAAGvE,IAAI,CAAC4B,GAAL,CACT2C,QAAQ,GAAGrE,+BADF,EAETsE,WAFS,CAAX;AAID,OAfD,MAeO;AACLD,QAAAA,QAAQ,GAAGI,iBAAX;AACAH,QAAAA,WAAW,GAAGD,QAAd;AACD;;AAED,UAAIA,QAAQ,GAAGD,QAAX,IAAuBxE,QAA3B,EAAqC;AACnCuE,QAAAA,UAAU,GAAG,IAAb;AACD;;AAED,UAAII,UAAU,GAAG5E,cAAjB,EAAiC;AAC/BwE,QAAAA,UAAU,GAAG,IAAb;AACD;AACF;;AAED,SAAKK,sBAAL,GAA8BvF,yBAA9B;AAEA,WAAOmF,QAAP;AACD;;AAEDM,EAAAA,eAAe,CAAC;AACdC,IAAAA,UADc;AAEdC,IAAAA,kBAFc;AAGdC,IAAAA,QAHc;AAId3D,IAAAA,SAJc;AAKdZ,IAAAA,aALc;AAMd8B,IAAAA,MANc;AAOd0C,IAAAA,SAPc;AAQdC,IAAAA;AARc,GAAD,EASZ;AACD,QAAIC,WAAW,GAAGH,QAAlB;AACA,QAAII,gBAAJ;;AAEA,WAAO,CAACA,gBAAR,EAA0B;AACxB,UAAIC,SAAJ;;AACA,UAAIJ,SAAS,KAAK,SAAlB,EAA6B;AAC3BI,QAAAA,SAAS,GAAGH,KAAK,CAACH,kBAAkB,GAAGC,QAAtB,CAAL,IACP,KAAKX,mBAAL,CAAyB;AAC1BhD,UAAAA,SAD0B;AAE1BZ,UAAAA,aAF0B;AAG1B4B,UAAAA,cAAc,EAAE0C,kBAAkB,GAAGC,QAHX;AAI1BzC,UAAAA;AAJ0B,SAAzB,CADL;AAOD,OARD,MAQO;AACL8C,QAAAA,SAAS,GAAGH,KAAK,CAACH,kBAAkB,GAAGC,QAAtB,CAAL,IACP,KAAKX,mBAAL,CAAyB;AAC1BhD,UAAAA,SAD0B;AAE1BZ,UAAAA,aAF0B;AAG1B4B,UAAAA,cAAc,EAAE0C,kBAAkB,GAAGC,QAHX;AAI1BzC,UAAAA;AAJ0B,SAAzB,CADL;AAOD;;AAED,UAAI8C,SAAS,GAAGP,UAAhB,EAA4B;AAC1BM,QAAAA,gBAAgB,GAAG,IAAnB;AACD,OAFD,MAEO;AACLD,QAAAA,WAAW,IAAI,CAAf;AACD;;AAED,UAAIA,WAAW,GAAG,IAAlB,EAAwB;AACtBC,QAAAA,gBAAgB,GAAG,IAAnB;AACD;AACF;;AAED,WAAOD,WAAP;AACD;;AAEDG,EAAAA,qCAAqC,CAAC;AACpCjE,IAAAA,SADoC;AAEpCZ,IAAAA,aAFoC;AAGpC8B,IAAAA;AAHoC,GAAD,EAIlC;AACD,QAAIgD,WAAW,GAAG,GAAlB;AACA,QAAIjB,UAAU,GAAG,KAAjB;AACA,QAAII,UAAU,GAAG,CAAjB;AACA,QAAIM,QAAQ,GAAG3E,8BAAf;AACA,UAAMmF,MAAM,GAAG,IAAf;AACA,QAAIC,gBAAgB,GAAG,CAAvB;AACA,QAAIC,kBAAJ;AACA,UAAMR,KAAK,GAAG,EAAd;;AAEA,UAAMS,MAAM,GAAG,CAACC,KAAD,EAAQxD,aAAR,KAA0B;AACvC;AACA,UAAI,CAAC8C,KAAK,CAAE,GAAEU,KAAM,EAAV,CAAV,EAAwB;AACtBV,QAAAA,KAAK,CAAE,GAAEU,KAAM,EAAV,CAAL,GAAoBxD,aAApB;AACD,OAJsC,CAMvC;AACA;AACA;;;AACA,UAAIA,aAAa,GAAGqD,gBAApB,EAAsC;AACpCA,QAAAA,gBAAgB,GAAGrD,aAAnB;AACAsD,QAAAA,kBAAkB,GAAGE,KAArB;AACD;AACF,KAbD;;AAeA,WAAO,CAACtB,UAAR,EAAoB;AAClBI,MAAAA,UAAU,IAAI,CAAd;AAEA,YAAMmB,MAAM,GAAGX,KAAK,CAACK,WAAD,CAAL,IACV,KAAKlB,mBAAL,CAAyB;AAC1BhD,QAAAA,SAD0B;AAE1BZ,QAAAA,aAF0B;AAG1B4B,QAAAA,cAAc,EAAEkD,WAHU;AAI1BhD,QAAAA;AAJ0B,OAAzB,CADL;AAOAoD,MAAAA,MAAM,CAACJ,WAAD,EAAcM,MAAd,CAAN;AAEA,YAAMC,KAAK,GAAGZ,KAAK,CAACK,WAAW,GAAGC,MAAf,CAAL,IACT,KAAKnB,mBAAL,CAAyB;AAC1BhD,QAAAA,SAD0B;AAE1BZ,QAAAA,aAF0B;AAG1B4B,QAAAA,cAAc,EAAEkD,WAAW,GAAGC,MAHJ;AAI1BjD,QAAAA;AAJ0B,OAAzB,CADL;AAOAoD,MAAAA,MAAM,CAACJ,WAAW,GAAGC,MAAf,EAAuBM,KAAvB,CAAN;AACA,YAAMC,MAAM,GAAGb,KAAK,CAACK,WAAW,GAAGC,MAAf,CAAL,IACV,KAAKnB,mBAAL,CAAyB;AAC1BhD,QAAAA,SAD0B;AAE1BZ,QAAAA,aAF0B;AAG1B4B,QAAAA,cAAc,EAAEkD,WAAW,GAAGC,MAHJ;AAI1BjD,QAAAA;AAJ0B,OAAzB,CADL;AAOAoD,MAAAA,MAAM,CAACJ,WAAW,GAAGC,MAAf,EAAuBO,MAAvB,CAAN;AAEA,YAAMC,KAAK,GAAGD,MAAM,GAAGD,KAAvB;;AAEA,UAAIC,MAAM,KAAK,CAAX,IAAgBD,KAAK,KAAK,CAA9B,EAAiC;AAC/B;AACA;AACA;AACAP,QAAAA,WAAW,GAAGlF,8BAAd;AACA2E,QAAAA,QAAQ,GAAG,GAAX;AACD,OAND,MAMO,IAAIgB,KAAK,GAAG,CAAZ,EAAe;AACpBhB,QAAAA,QAAQ,GAAG,KAAKH,eAAL,CAAqB;AAC9BC,UAAAA,UAAU,EAAEe,MADkB;AAE9Bd,UAAAA,kBAAkB,EAAEQ,WAFU;AAG9BP,UAAAA,QAH8B;AAI9B3D,UAAAA,SAJ8B;AAK9BZ,UAAAA,aAL8B;AAM9B8B,UAAAA,MAN8B;AAO9B0C,UAAAA,SAAS,EAAE,SAPmB;AAQ9BC,UAAAA;AAR8B,SAArB,CAAX;AAUAK,QAAAA,WAAW,IAAIP,QAAf;AACD,OAZM,MAYA;AACLA,QAAAA,QAAQ,GAAG,KAAKH,eAAL,CAAqB;AAC9BC,UAAAA,UAAU,EAAEe,MADkB;AAE9Bd,UAAAA,kBAAkB,EAAEQ,WAFU;AAG9BP,UAAAA,QAH8B;AAI9B3D,UAAAA,SAJ8B;AAK9BZ,UAAAA,aAL8B;AAM9B8B,UAAAA,MAN8B;AAO9B0C,UAAAA,SAAS,EAAE,WAPmB;AAQ9BC,UAAAA;AAR8B,SAArB,CAAX;AAUAK,QAAAA,WAAW,IAAIP,QAAf;AACD;;AAED,UAAIA,QAAQ,GAAGQ,MAAM,GAAG,CAAxB,EAA2B;AACzBlB,QAAAA,UAAU,GAAG,IAAb;AACD;;AAED,UAAII,UAAU,GAAG,EAAjB,EAAqB;AACnBJ,QAAAA,UAAU,GAAG,IAAb;AACD;AACF,KA/FA,CAiGD;;;AACA,UAAM2B,gBAAgB,GAAGhG,IAAI,CAAC0C,KAAL,CAAW+C,kBAAkB,GAAG,KAAhC,IAAyC,KAAlE;AACA,UAAMQ,kBAAkB,GAAGhB,KAAK,CAACe,gBAAD,CAAL,IACtB,KAAK5B,mBAAL,CAAyB;AAC1BhD,MAAAA,SAD0B;AAE1BZ,MAAAA,aAF0B;AAG1B4B,MAAAA,cAAc,EAAE4D,gBAHU;AAI1B1D,MAAAA;AAJ0B,KAAzB,CADL;AAQA,WAAO;AACLgD,MAAAA,WAAW,EAAEU,gBADR;AAEL7D,MAAAA,aAAa,EAAE8D;AAFV,KAAP;AAID;;AAEDC,EAAAA,0BAA0B,CAAC;AACzBlC,IAAAA,IADyB;AAEzB5B,IAAAA,cAFyB;AAGzBE,IAAAA,MAHyB;AAIzB9B,IAAAA;AAJyB,GAAD,EAKvB;AACD,UAAM;AAAEY,MAAAA,SAAF;AAAaZ,MAAAA,aAAa,EAAE2F;AAA5B,QAAkDnC,IAAxD;AACA,WAAO,KAAKI,mBAAL,CAAyB;AAC9BhD,MAAAA,SAD8B;AAE9BZ,MAAAA,aAAa,EAAEA,aAAa,IAAI2F,iBAFF;AAG9B/D,MAAAA,cAH8B;AAI9BE,MAAAA;AAJ8B,KAAzB,CAAP;AAMD;;AAED8D,EAAAA,uBAAuB,CAAC;AAAEpC,IAAAA,IAAF;AAAQqC,IAAAA;AAAR,GAAD,EAAwB;AAC7C,UAAMlE,aAAa,GAAG,KAAKmE,cAAL,CAAoB;AAAEtC,MAAAA,IAAF;AAAQqC,MAAAA;AAAR,KAApB,CAAtB;AACA,UAAMhE,SAAS,GAAG,KAAKkE,eAAL,CAAqB;AAAEvC,MAAAA,IAAF;AAAQqC,MAAAA;AAAR,KAArB,CAAlB;AACA,UAAM9D,UAAU,GAAG,KAAKiE,OAAL,CAAa;AAAExC,MAAAA,IAAF;AAAQqC,MAAAA;AAAR,KAAb,EAAoCvD,KAAvD;AAEA,WAAO,KAAKZ,gBAAL,CAAsB;AAC3Bd,MAAAA,SAAS,EAAE4C,IAAI,CAAC5C,SADW;AAE3Be,MAAAA,aAF2B;AAG3BE,MAAAA,SAH2B;AAI3B7B,MAAAA,aAAa,EAAEwD,IAAI,CAACxD,aAJO;AAK3B+B,MAAAA;AAL2B,KAAtB,CAAP;AAOD;;AAxasB,CADpB","sourcesContent":["// @flow\nimport { OWN_FUNDS_ROUNDING_AMOUNT } from '../../config/financeConstants';\nimport {\n  OWN_FUNDS_TYPES,\n  RESIDENCE_TYPE,\n  OWN_FUNDS_USAGE_TYPES,\n} from '../../api/constants';\nimport { arrayify } from '../general';\nimport { NotaryFeesCalculator } from '../notaryFees/index';\nimport { roundValue } from '../conversionFunctions';\n\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nexport const withSolvencyCalculator = (SuperClass = class {}) =>\n  class extends SuperClass {\n    getAllowedOwnFundsTypes({ residenceType }) {\n      return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE\n        ? [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3A,\n          OWN_FUNDS_TYPES.BANK_3A,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n          OWN_FUNDS_TYPES.INSURANCE_2,\n        ]\n        : [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n        ];\n    }\n\n    ownFundTypeRequiresUsageType({ type }) {\n      return [\n        OWN_FUNDS_TYPES.INSURANCE_2,\n        OWN_FUNDS_TYPES.INSURANCE_3A,\n        OWN_FUNDS_TYPES.INSURANCE_3B,\n      ].includes(type);\n    }\n\n    makeOwnFunds({ borrowers, type, usageType, max }) {\n      return arrayify(borrowers)\n        .map((borrower) => {\n          const ownFundsObject = {\n            type,\n            value: Math.ceil(Math.min(max, this.getFunds({ borrowers: borrower, type }))),\n            borrowerId: borrower._id,\n          };\n\n          if (!usageType && this.ownFundTypeRequiresUsageType({ type })) {\n            return {\n              ...ownFundsObject,\n              usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW,\n            };\n          }\n\n          if (usageType) {\n            return { ...ownFundsObject, usageType };\n          }\n\n          return ownFundsObject;\n        })\n        .filter(({ value }) => value > 0);\n    }\n\n    suggestStructure({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      notaryFees: forcedNotaryFees,\n    }) {\n      let notaryFees;\n\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n      if (forcedNotaryFees) {\n        notaryFees = forcedNotaryFees;\n      } else {\n        const notaryCalc = new NotaryFeesCalculator({ canton });\n        notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n          propertyValue,\n          mortgageNoteIncrease: finalLoanValue,\n          residenceType,\n        }).total;\n      }\n\n      let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n      let ownFunds = [];\n\n      // Get all possible OWN_FUNDS_TYPES\n      const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n        residenceType,\n      });\n\n      allowedOwnFundsTypes.forEach((type) => {\n        borrowers.forEach((borrower) => {\n          const newOwnFunds = this.makeOwnFunds({\n            borrowers: borrower,\n            type,\n            max: requiredOwnFunds,\n          });\n\n          requiredOwnFunds -= newOwnFunds.reduce(\n            (tot, { value }) => tot + value,\n            0,\n          );\n\n          ownFunds = [...ownFunds, ...newOwnFunds];\n        });\n      });\n\n      return ownFunds;\n    }\n\n    createLoanObject({\n      residenceType,\n      borrowers,\n      wantedLoan,\n      propertyValue,\n      canton,\n      ownFunds = [],\n      loanTranches = [],\n      ...rest\n    }) {\n      return {\n        residenceType,\n        borrowers,\n        structure: {\n          wantedLoan,\n          propertyValue,\n          property: { canton },\n          ownFunds,\n          loanTranches,\n        },\n        ...rest,\n      };\n    }\n\n    suggestedStructureIsValid({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      ownFunds,\n    }) {\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n      const loanObject = this.createLoanObject({\n        residenceType,\n        borrowers,\n        wantedLoan: finalLoanValue,\n        propertyValue,\n        canton,\n        ownFunds,\n      });\n\n      // If the calculator has been initialized, reinitialize it according to this new potential loan\n      if (this.lenderRules) {\n        this.initialize({ loan: loanObject, lenderRules: this.lenderRules });\n      }\n\n      if (this.isMissingOwnFunds({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.hasEnoughCash({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.structureIsValid({ loan: loanObject })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    getMaxPropertyValue({ borrowers, maxBorrowRatio, canton, residenceType }) {\n      // Immediately stop iterating if maxBorrowRatio is above what is allowed\n      if (this.maxBorrowRatio < maxBorrowRatio) {\n        return 0;\n      }\n\n      let foundValue = false;\n      let minBound = INITIAL_MIN_BOUND;\n      let maxBound = INITIAL_MAX_BOUND;\n      let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n      let iterations = 0;\n\n      // The rounding amount of 1000 is helpful when the user tries to\n      // fit his own funds into a structure without being overly accurate\n      // which is annoying.\n      // However for this calculation we don't need to round own funds as loosely\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n      while (!foundValue) {\n        iterations += 1;\n        const nextPropertyValue = roundValue(\n          (minBound + maxBound) / 2,\n          ROUNDING_DIGITS,\n        );\n\n        const ownFunds = this.suggestStructure({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue,\n        });\n\n        if (\n          this.suggestedStructureIsValid({\n            borrowers,\n            maxBorrowRatio,\n            canton,\n            residenceType,\n            propertyValue: nextPropertyValue,\n            ownFunds,\n          })\n        ) {\n          minBound = nextPropertyValue;\n          maxBound = Math.min(\n            maxBound * MAX_BOUND_MULTIPLICATION_FACTOR,\n            absoluteMax,\n          );\n        } else {\n          maxBound = nextPropertyValue;\n          absoluteMax = maxBound;\n        }\n\n        if (maxBound - minBound <= ACCURACY) {\n          foundValue = true;\n        }\n\n        if (iterations > MAX_ITERATIONS) {\n          foundValue = true;\n        }\n      }\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n\n      return minBound;\n    }\n\n    getNextStepSize({\n      currentMax,\n      currentBorrowRatio,\n      stepSize,\n      borrowers,\n      residenceType,\n      canton,\n      direction,\n      cache,\n    }) {\n      let newStepSize = stepSize;\n      let foundBetterValue;\n\n      while (!foundBetterValue) {\n        let nextValue;\n        if (direction === 'upwards') {\n          nextValue = cache[currentBorrowRatio + stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio + stepSize,\n              canton,\n            });\n        } else {\n          nextValue = cache[currentBorrowRatio - stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio - stepSize,\n              canton,\n            });\n        }\n\n        if (nextValue > currentMax) {\n          foundBetterValue = true;\n        } else {\n          newStepSize /= 2;\n        }\n\n        if (newStepSize < 0.05) {\n          foundBetterValue = true;\n        }\n      }\n\n      return newStepSize;\n    }\n\n    getMaxPropertyValueWithoutBorrowRatio({\n      borrowers,\n      residenceType,\n      canton,\n    }) {\n      let borrowRatio = 0.7;\n      let foundValue = false;\n      let iterations = 0;\n      let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n      const deltaX = 0.01;\n      let maxPropertyValue = 0;\n      let optimalBorrowRatio;\n      const cache = {};\n\n      const setMax = (ratio, propertyValue) => {\n        // Cache each result to avoid recalculating it later\n        if (!cache[`${ratio}`]) {\n          cache[`${ratio}`] = propertyValue;\n        }\n\n        // Always store the highest encountered value, in case the loop\n        // stops prematurely, or if the stopping conditions would've skipped\n        // a value that we already calculated\n        if (propertyValue > maxPropertyValue) {\n          maxPropertyValue = propertyValue;\n          optimalBorrowRatio = ratio;\n        }\n      };\n\n      while (!foundValue) {\n        iterations += 1;\n\n        const center = cache[borrowRatio]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio,\n            canton,\n          });\n        setMax(borrowRatio, center);\n\n        const yLeft = cache[borrowRatio - deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio - deltaX,\n            canton,\n          });\n        setMax(borrowRatio - deltaX, yLeft);\n        const yRight = cache[borrowRatio + deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio + deltaX,\n            canton,\n          });\n        setMax(borrowRatio + deltaX, yRight);\n\n        const slope = yRight - yLeft;\n\n        if (yRight === 0 && yLeft === 0) {\n          // If the algorithm is at 0 on both sides, it means the borrowRatio\n          // is way too high, so start him over again at 0, but with a large\n          // step size to allow it to recover quickly\n          borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n          stepSize = 0.2;\n        } else if (slope > 0) {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'upwards',\n            cache,\n          });\n          borrowRatio += stepSize;\n        } else {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'downwards',\n            cache,\n          });\n          borrowRatio -= stepSize;\n        }\n\n        if (stepSize < deltaX / 2) {\n          foundValue = true;\n        }\n\n        if (iterations > 50) {\n          foundValue = true;\n        }\n      }\n\n      // Round the borrowRatio, and recompute the exact property value\n      const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n      const finalPropertyValue = cache[finalBorrowRatio]\n        || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: finalBorrowRatio,\n          canton,\n        });\n\n      return {\n        borrowRatio: finalBorrowRatio,\n        propertyValue: finalPropertyValue,\n      };\n    }\n\n    getMaxPropertyValueForLoan({\n      loan,\n      maxBorrowRatio,\n      canton,\n      residenceType,\n    }) {\n      const { borrowers, residenceType: loanResidenceType } = loan;\n      return this.getMaxPropertyValue({\n        borrowers,\n        residenceType: residenceType || loanResidenceType,\n        maxBorrowRatio,\n        canton,\n      });\n    }\n\n    suggestStructureForLoan({ loan, structureId }) {\n      const propertyValue = this.getPropAndWork({ loan, structureId });\n      const loanValue = this.selectLoanValue({ loan, structureId });\n      const notaryFees = this.getFees({ loan, structureId }).total;\n\n      return this.suggestStructure({\n        borrowers: loan.borrowers,\n        propertyValue,\n        loanValue,\n        residenceType: loan.residenceType,\n        notaryFees,\n      });\n    }\n  };\n"]},"passPerPreset":false,"envName":"development","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/imports/core/utils/Calculator/SolvencyCalculator.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/core/utils/Calculator/SolvencyCalculator.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nmodule.export({\n  withSolvencyCalculator: () => withSolvencyCalculator\n});\nlet OWN_FUNDS_ROUNDING_AMOUNT;\nmodule.link(\"../../config/financeConstants\", {\n  OWN_FUNDS_ROUNDING_AMOUNT(v) {\n    OWN_FUNDS_ROUNDING_AMOUNT = v;\n  }\n\n}, 0);\nlet OWN_FUNDS_TYPES, RESIDENCE_TYPE, OWN_FUNDS_USAGE_TYPES;\nmodule.link(\"../../api/constants\", {\n  OWN_FUNDS_TYPES(v) {\n    OWN_FUNDS_TYPES = v;\n  },\n\n  RESIDENCE_TYPE(v) {\n    RESIDENCE_TYPE = v;\n  },\n\n  OWN_FUNDS_USAGE_TYPES(v) {\n    OWN_FUNDS_USAGE_TYPES = v;\n  }\n\n}, 1);\nlet arrayify;\nmodule.link(\"../general\", {\n  arrayify(v) {\n    arrayify = v;\n  }\n\n}, 2);\nlet NotaryFeesCalculator;\nmodule.link(\"../notaryFees/index\", {\n  NotaryFeesCalculator(v) {\n    NotaryFeesCalculator = v;\n  }\n\n}, 3);\nlet roundValue;\nmodule.link(\"../conversionFunctions\", {\n  roundValue(v) {\n    roundValue = v;\n  }\n\n}, 4);\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nconst withSolvencyCalculator = (SuperClass = class {}) => class extends SuperClass {\n  getAllowedOwnFundsTypes({\n    residenceType\n  }) {\n    return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE ? [OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE, OWN_FUNDS_TYPES.BANK_FORTUNE, OWN_FUNDS_TYPES.INSURANCE_3A, OWN_FUNDS_TYPES.BANK_3A, OWN_FUNDS_TYPES.INSURANCE_3B, OWN_FUNDS_TYPES.INSURANCE_2] : [OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE, OWN_FUNDS_TYPES.BANK_FORTUNE, OWN_FUNDS_TYPES.INSURANCE_3B];\n  }\n\n  ownFundTypeRequiresUsageType({\n    type\n  }) {\n    return [OWN_FUNDS_TYPES.INSURANCE_2, OWN_FUNDS_TYPES.INSURANCE_3A, OWN_FUNDS_TYPES.INSURANCE_3B].includes(type);\n  }\n\n  makeOwnFunds({\n    borrowers,\n    type,\n    usageType,\n    max\n  }) {\n    return arrayify(borrowers).map(borrower => {\n      const ownFundsObject = {\n        type,\n        value: Math.ceil(Math.min(max, this.getFunds({\n          borrowers: borrower,\n          type\n        }))),\n        borrowerId: borrower._id\n      };\n\n      if (!usageType && this.ownFundTypeRequiresUsageType({\n        type\n      })) {\n        return (0, _objectSpread2.default)({}, ownFundsObject, {\n          usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW\n        });\n      }\n\n      if (usageType) {\n        return (0, _objectSpread2.default)({}, ownFundsObject, {\n          usageType\n        });\n      }\n\n      return ownFundsObject;\n    }).filter(({\n      value\n    }) => value > 0);\n  }\n\n  suggestStructure({\n    borrowers,\n    propertyValue,\n    maxBorrowRatio = this.maxBorrowRatio,\n    loanValue,\n    canton,\n    residenceType,\n    notaryFees: forcedNotaryFees\n  }) {\n    let notaryFees;\n    const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n    if (forcedNotaryFees) {\n      notaryFees = forcedNotaryFees;\n    } else {\n      const notaryCalc = new NotaryFeesCalculator({\n        canton\n      });\n      notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n        propertyValue,\n        mortgageNoteIncrease: finalLoanValue,\n        residenceType\n      }).total;\n    }\n\n    let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n    let ownFunds = []; // Get all possible OWN_FUNDS_TYPES\n\n    const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n      residenceType\n    });\n    allowedOwnFundsTypes.forEach(type => {\n      borrowers.forEach(borrower => {\n        const newOwnFunds = this.makeOwnFunds({\n          borrowers: borrower,\n          type,\n          max: requiredOwnFunds\n        });\n        requiredOwnFunds -= newOwnFunds.reduce((tot, {\n          value\n        }) => tot + value, 0);\n        ownFunds = [...ownFunds, ...newOwnFunds];\n      });\n    });\n    return ownFunds;\n  }\n\n  createLoanObject(_ref) {\n    let {\n      residenceType,\n      borrowers,\n      wantedLoan,\n      propertyValue,\n      canton,\n      ownFunds = [],\n      loanTranches = []\n    } = _ref,\n        rest = (0, _objectWithoutProperties2.default)(_ref, [\"residenceType\", \"borrowers\", \"wantedLoan\", \"propertyValue\", \"canton\", \"ownFunds\", \"loanTranches\"]);\n    return (0, _objectSpread2.default)({\n      residenceType,\n      borrowers,\n      structure: {\n        wantedLoan,\n        propertyValue,\n        property: {\n          canton\n        },\n        ownFunds,\n        loanTranches\n      }\n    }, rest);\n  }\n\n  suggestedStructureIsValid({\n    borrowers,\n    propertyValue,\n    maxBorrowRatio = this.maxBorrowRatio,\n    loanValue,\n    canton,\n    residenceType,\n    ownFunds\n  }) {\n    const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n    const loanObject = this.createLoanObject({\n      residenceType,\n      borrowers,\n      wantedLoan: finalLoanValue,\n      propertyValue,\n      canton,\n      ownFunds\n    }); // If the calculator has been initialized, reinitialize it according to this new potential loan\n\n    if (this.lenderRules) {\n      this.initialize({\n        loan: loanObject,\n        lenderRules: this.lenderRules\n      });\n    }\n\n    if (this.isMissingOwnFunds({\n      loan: loanObject\n    })) {\n      return false;\n    }\n\n    if (!this.hasEnoughCash({\n      loan: loanObject\n    })) {\n      return false;\n    }\n\n    if (!this.structureIsValid({\n      loan: loanObject\n    })) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getMaxPropertyValue({\n    borrowers,\n    maxBorrowRatio,\n    canton,\n    residenceType\n  }) {\n    // Immediately stop iterating if maxBorrowRatio is above what is allowed\n    if (this.maxBorrowRatio < maxBorrowRatio) {\n      return 0;\n    }\n\n    let foundValue = false;\n    let minBound = INITIAL_MIN_BOUND;\n    let maxBound = INITIAL_MAX_BOUND;\n    let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n    let iterations = 0; // The rounding amount of 1000 is helpful when the user tries to\n    // fit his own funds into a structure without being overly accurate\n    // which is annoying.\n    // However for this calculation we don't need to round own funds as loosely\n\n    this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n    while (!foundValue) {\n      iterations += 1;\n      const nextPropertyValue = roundValue((minBound + maxBound) / 2, ROUNDING_DIGITS);\n      const ownFunds = this.suggestStructure({\n        borrowers,\n        maxBorrowRatio,\n        canton,\n        residenceType,\n        propertyValue: nextPropertyValue\n      });\n\n      if (this.suggestedStructureIsValid({\n        borrowers,\n        maxBorrowRatio,\n        canton,\n        residenceType,\n        propertyValue: nextPropertyValue,\n        ownFunds\n      })) {\n        minBound = nextPropertyValue;\n        maxBound = Math.min(maxBound * MAX_BOUND_MULTIPLICATION_FACTOR, absoluteMax);\n      } else {\n        maxBound = nextPropertyValue;\n        absoluteMax = maxBound;\n      }\n\n      if (maxBound - minBound <= ACCURACY) {\n        foundValue = true;\n      }\n\n      if (iterations > MAX_ITERATIONS) {\n        foundValue = true;\n      }\n    }\n\n    this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n    return minBound;\n  }\n\n  getNextStepSize({\n    currentMax,\n    currentBorrowRatio,\n    stepSize,\n    borrowers,\n    residenceType,\n    canton,\n    direction,\n    cache\n  }) {\n    let newStepSize = stepSize;\n    let foundBetterValue;\n\n    while (!foundBetterValue) {\n      let nextValue;\n\n      if (direction === 'upwards') {\n        nextValue = cache[currentBorrowRatio + stepSize] || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: currentBorrowRatio + stepSize,\n          canton\n        });\n      } else {\n        nextValue = cache[currentBorrowRatio - stepSize] || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: currentBorrowRatio - stepSize,\n          canton\n        });\n      }\n\n      if (nextValue > currentMax) {\n        foundBetterValue = true;\n      } else {\n        newStepSize /= 2;\n      }\n\n      if (newStepSize < 0.05) {\n        foundBetterValue = true;\n      }\n    }\n\n    return newStepSize;\n  }\n\n  getMaxPropertyValueWithoutBorrowRatio({\n    borrowers,\n    residenceType,\n    canton\n  }) {\n    let borrowRatio = 0.7;\n    let foundValue = false;\n    let iterations = 0;\n    let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n    const deltaX = 0.01;\n    let maxPropertyValue = 0;\n    let optimalBorrowRatio;\n    const cache = {};\n\n    const setMax = (ratio, propertyValue) => {\n      // Cache each result to avoid recalculating it later\n      if (!cache[`${ratio}`]) {\n        cache[`${ratio}`] = propertyValue;\n      } // Always store the highest encountered value, in case the loop\n      // stops prematurely, or if the stopping conditions would've skipped\n      // a value that we already calculated\n\n\n      if (propertyValue > maxPropertyValue) {\n        maxPropertyValue = propertyValue;\n        optimalBorrowRatio = ratio;\n      }\n    };\n\n    while (!foundValue) {\n      iterations += 1;\n      const center = cache[borrowRatio] || this.getMaxPropertyValue({\n        borrowers,\n        residenceType,\n        maxBorrowRatio: borrowRatio,\n        canton\n      });\n      setMax(borrowRatio, center);\n      const yLeft = cache[borrowRatio - deltaX] || this.getMaxPropertyValue({\n        borrowers,\n        residenceType,\n        maxBorrowRatio: borrowRatio - deltaX,\n        canton\n      });\n      setMax(borrowRatio - deltaX, yLeft);\n      const yRight = cache[borrowRatio + deltaX] || this.getMaxPropertyValue({\n        borrowers,\n        residenceType,\n        maxBorrowRatio: borrowRatio + deltaX,\n        canton\n      });\n      setMax(borrowRatio + deltaX, yRight);\n      const slope = yRight - yLeft;\n\n      if (yRight === 0 && yLeft === 0) {\n        // If the algorithm is at 0 on both sides, it means the borrowRatio\n        // is way too high, so start him over again at 0, but with a large\n        // step size to allow it to recover quickly\n        borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n        stepSize = 0.2;\n      } else if (slope > 0) {\n        stepSize = this.getNextStepSize({\n          currentMax: center,\n          currentBorrowRatio: borrowRatio,\n          stepSize,\n          borrowers,\n          residenceType,\n          canton,\n          direction: 'upwards',\n          cache\n        });\n        borrowRatio += stepSize;\n      } else {\n        stepSize = this.getNextStepSize({\n          currentMax: center,\n          currentBorrowRatio: borrowRatio,\n          stepSize,\n          borrowers,\n          residenceType,\n          canton,\n          direction: 'downwards',\n          cache\n        });\n        borrowRatio -= stepSize;\n      }\n\n      if (stepSize < deltaX / 2) {\n        foundValue = true;\n      }\n\n      if (iterations > 50) {\n        foundValue = true;\n      }\n    } // Round the borrowRatio, and recompute the exact property value\n\n\n    const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n    const finalPropertyValue = cache[finalBorrowRatio] || this.getMaxPropertyValue({\n      borrowers,\n      residenceType,\n      maxBorrowRatio: finalBorrowRatio,\n      canton\n    });\n    return {\n      borrowRatio: finalBorrowRatio,\n      propertyValue: finalPropertyValue\n    };\n  }\n\n  getMaxPropertyValueForLoan({\n    loan,\n    maxBorrowRatio,\n    canton,\n    residenceType\n  }) {\n    const {\n      borrowers,\n      residenceType: loanResidenceType\n    } = loan;\n    return this.getMaxPropertyValue({\n      borrowers,\n      residenceType: residenceType || loanResidenceType,\n      maxBorrowRatio,\n      canton\n    });\n  }\n\n  suggestStructureForLoan({\n    loan,\n    structureId\n  }) {\n    const propertyValue = this.getPropAndWork({\n      loan,\n      structureId\n    });\n    const loanValue = this.selectLoanValue({\n      loan,\n      structureId\n    });\n    const notaryFees = this.getFees({\n      loan,\n      structureId\n    }).total;\n    return this.suggestStructure({\n      borrowers: loan.borrowers,\n      propertyValue,\n      loanValue,\n      residenceType: loan.residenceType,\n      notaryFees\n    });\n  }\n\n};","map":{"version":3,"sources":["imports/core/utils/Calculator/SolvencyCalculator.js"],"names":["INITIAL_MIN_BOUND","INITIAL_MAX_BOUND","INITIAL_ABSOLUTE_MAX_BOUND","MAX_ITERATIONS","ACCURACY","ROUNDING_DIGITS","Math","MAX_BOUND_MULTIPLICATION_FACTOR","OWN_FUNDS_ROUNDING_ALGO","INITIAL_BORROW_RATIO_STEP_SIZE","withSolvencyCalculator","SuperClass","getAllowedOwnFundsTypes","residenceType","RESIDENCE_TYPE","OWN_FUNDS_TYPES","ownFundTypeRequiresUsageType","type","makeOwnFunds","max","borrower","ownFundsObject","value","borrowers","borrowerId","_id","usageType","OWN_FUNDS_USAGE_TYPES","WITHDRAW","suggestStructure","maxBorrowRatio","notaryFees","forcedNotaryFees","finalLoanValue","loanValue","propertyValue","notaryCalc","canton","mortgageNoteIncrease","requiredOwnFunds","ownFunds","allowedOwnFundsTypes","newOwnFunds","tot","createLoanObject","loanTranches","rest","structure","property","suggestedStructureIsValid","loanObject","wantedLoan","loan","lenderRules","getMaxPropertyValue","foundValue","minBound","maxBound","absoluteMax","iterations","nextPropertyValue","roundValue","getNextStepSize","cache","newStepSize","direction","nextValue","currentBorrowRatio","foundBetterValue","getMaxPropertyValueWithoutBorrowRatio","borrowRatio","stepSize","deltaX","maxPropertyValue","setMax","ratio","optimalBorrowRatio","center","yLeft","yRight","slope","currentMax","finalBorrowRatio","finalPropertyValue","getMaxPropertyValueForLoan","loanResidenceType","suggestStructureForLoan","structureId"],"mappings":"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","sourcesContent":["// @flow\nimport { OWN_FUNDS_ROUNDING_AMOUNT } from '../../config/financeConstants';\nimport {\n  OWN_FUNDS_TYPES,\n  RESIDENCE_TYPE,\n  OWN_FUNDS_USAGE_TYPES,\n} from '../../api/constants';\nimport { arrayify } from '../general';\nimport { NotaryFeesCalculator } from '../notaryFees/index';\nimport { roundValue } from '../conversionFunctions';\n\nconst INITIAL_MIN_BOUND = 0;\nconst INITIAL_MAX_BOUND = 1000000;\nconst INITIAL_ABSOLUTE_MAX_BOUND = 100000000;\nconst MAX_ITERATIONS = 50;\nconst ACCURACY = 1000;\nconst ROUNDING_DIGITS = Math.log10(ACCURACY);\nconst MAX_BOUND_MULTIPLICATION_FACTOR = 2;\nconst OWN_FUNDS_ROUNDING_ALGO = 100;\nconst INITIAL_BORROW_RATIO_STEP_SIZE = 0.05;\n\nexport const withSolvencyCalculator = (SuperClass = class {}) =>\n  class extends SuperClass {\n    getAllowedOwnFundsTypes({ residenceType }) {\n      return residenceType === RESIDENCE_TYPE.MAIN_RESIDENCE\n        ? [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3A,\n          OWN_FUNDS_TYPES.BANK_3A,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n          OWN_FUNDS_TYPES.INSURANCE_2,\n        ]\n        : [\n          OWN_FUNDS_TYPES.THIRD_PARTY_FORTUNE,\n          OWN_FUNDS_TYPES.BANK_FORTUNE,\n          OWN_FUNDS_TYPES.INSURANCE_3B,\n        ];\n    }\n\n    ownFundTypeRequiresUsageType({ type }) {\n      return [\n        OWN_FUNDS_TYPES.INSURANCE_2,\n        OWN_FUNDS_TYPES.INSURANCE_3A,\n        OWN_FUNDS_TYPES.INSURANCE_3B,\n      ].includes(type);\n    }\n\n    makeOwnFunds({ borrowers, type, usageType, max }) {\n      return arrayify(borrowers)\n        .map((borrower) => {\n          const ownFundsObject = {\n            type,\n            value: Math.ceil(Math.min(max, this.getFunds({ borrowers: borrower, type }))),\n            borrowerId: borrower._id,\n          };\n\n          if (!usageType && this.ownFundTypeRequiresUsageType({ type })) {\n            return {\n              ...ownFundsObject,\n              usageType: OWN_FUNDS_USAGE_TYPES.WITHDRAW,\n            };\n          }\n\n          if (usageType) {\n            return { ...ownFundsObject, usageType };\n          }\n\n          return ownFundsObject;\n        })\n        .filter(({ value }) => value > 0);\n    }\n\n    suggestStructure({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      notaryFees: forcedNotaryFees,\n    }) {\n      let notaryFees;\n\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n\n      if (forcedNotaryFees) {\n        notaryFees = forcedNotaryFees;\n      } else {\n        const notaryCalc = new NotaryFeesCalculator({ canton });\n        notaryFees = notaryCalc.getNotaryFeesWithoutLoan({\n          propertyValue,\n          mortgageNoteIncrease: finalLoanValue,\n          residenceType,\n        }).total;\n      }\n\n      let requiredOwnFunds = Math.round(propertyValue + notaryFees - finalLoanValue);\n      let ownFunds = [];\n\n      // Get all possible OWN_FUNDS_TYPES\n      const allowedOwnFundsTypes = this.getAllowedOwnFundsTypes({\n        residenceType,\n      });\n\n      allowedOwnFundsTypes.forEach((type) => {\n        borrowers.forEach((borrower) => {\n          const newOwnFunds = this.makeOwnFunds({\n            borrowers: borrower,\n            type,\n            max: requiredOwnFunds,\n          });\n\n          requiredOwnFunds -= newOwnFunds.reduce(\n            (tot, { value }) => tot + value,\n            0,\n          );\n\n          ownFunds = [...ownFunds, ...newOwnFunds];\n        });\n      });\n\n      return ownFunds;\n    }\n\n    createLoanObject({\n      residenceType,\n      borrowers,\n      wantedLoan,\n      propertyValue,\n      canton,\n      ownFunds = [],\n      loanTranches = [],\n      ...rest\n    }) {\n      return {\n        residenceType,\n        borrowers,\n        structure: {\n          wantedLoan,\n          propertyValue,\n          property: { canton },\n          ownFunds,\n          loanTranches,\n        },\n        ...rest,\n      };\n    }\n\n    suggestedStructureIsValid({\n      borrowers,\n      propertyValue,\n      maxBorrowRatio = this.maxBorrowRatio,\n      loanValue,\n      canton,\n      residenceType,\n      ownFunds,\n    }) {\n      const finalLoanValue = loanValue || Math.round(propertyValue * maxBorrowRatio);\n      const loanObject = this.createLoanObject({\n        residenceType,\n        borrowers,\n        wantedLoan: finalLoanValue,\n        propertyValue,\n        canton,\n        ownFunds,\n      });\n\n      // If the calculator has been initialized, reinitialize it according to this new potential loan\n      if (this.lenderRules) {\n        this.initialize({ loan: loanObject, lenderRules: this.lenderRules });\n      }\n\n      if (this.isMissingOwnFunds({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.hasEnoughCash({ loan: loanObject })) {\n        return false;\n      }\n\n      if (!this.structureIsValid({ loan: loanObject })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    getMaxPropertyValue({ borrowers, maxBorrowRatio, canton, residenceType }) {\n      // Immediately stop iterating if maxBorrowRatio is above what is allowed\n      if (this.maxBorrowRatio < maxBorrowRatio) {\n        return 0;\n      }\n\n      let foundValue = false;\n      let minBound = INITIAL_MIN_BOUND;\n      let maxBound = INITIAL_MAX_BOUND;\n      let absoluteMax = INITIAL_ABSOLUTE_MAX_BOUND;\n      let iterations = 0;\n\n      // The rounding amount of 1000 is helpful when the user tries to\n      // fit his own funds into a structure without being overly accurate\n      // which is annoying.\n      // However for this calculation we don't need to round own funds as loosely\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_ALGO;\n\n      while (!foundValue) {\n        iterations += 1;\n        const nextPropertyValue = roundValue(\n          (minBound + maxBound) / 2,\n          ROUNDING_DIGITS,\n        );\n\n        const ownFunds = this.suggestStructure({\n          borrowers,\n          maxBorrowRatio,\n          canton,\n          residenceType,\n          propertyValue: nextPropertyValue,\n        });\n\n        if (\n          this.suggestedStructureIsValid({\n            borrowers,\n            maxBorrowRatio,\n            canton,\n            residenceType,\n            propertyValue: nextPropertyValue,\n            ownFunds,\n          })\n        ) {\n          minBound = nextPropertyValue;\n          maxBound = Math.min(\n            maxBound * MAX_BOUND_MULTIPLICATION_FACTOR,\n            absoluteMax,\n          );\n        } else {\n          maxBound = nextPropertyValue;\n          absoluteMax = maxBound;\n        }\n\n        if (maxBound - minBound <= ACCURACY) {\n          foundValue = true;\n        }\n\n        if (iterations > MAX_ITERATIONS) {\n          foundValue = true;\n        }\n      }\n\n      this.ownFundsRoundingAmount = OWN_FUNDS_ROUNDING_AMOUNT;\n\n      return minBound;\n    }\n\n    getNextStepSize({\n      currentMax,\n      currentBorrowRatio,\n      stepSize,\n      borrowers,\n      residenceType,\n      canton,\n      direction,\n      cache,\n    }) {\n      let newStepSize = stepSize;\n      let foundBetterValue;\n\n      while (!foundBetterValue) {\n        let nextValue;\n        if (direction === 'upwards') {\n          nextValue = cache[currentBorrowRatio + stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio + stepSize,\n              canton,\n            });\n        } else {\n          nextValue = cache[currentBorrowRatio - stepSize]\n            || this.getMaxPropertyValue({\n              borrowers,\n              residenceType,\n              maxBorrowRatio: currentBorrowRatio - stepSize,\n              canton,\n            });\n        }\n\n        if (nextValue > currentMax) {\n          foundBetterValue = true;\n        } else {\n          newStepSize /= 2;\n        }\n\n        if (newStepSize < 0.05) {\n          foundBetterValue = true;\n        }\n      }\n\n      return newStepSize;\n    }\n\n    getMaxPropertyValueWithoutBorrowRatio({\n      borrowers,\n      residenceType,\n      canton,\n    }) {\n      let borrowRatio = 0.7;\n      let foundValue = false;\n      let iterations = 0;\n      let stepSize = INITIAL_BORROW_RATIO_STEP_SIZE;\n      const deltaX = 0.01;\n      let maxPropertyValue = 0;\n      let optimalBorrowRatio;\n      const cache = {};\n\n      const setMax = (ratio, propertyValue) => {\n        // Cache each result to avoid recalculating it later\n        if (!cache[`${ratio}`]) {\n          cache[`${ratio}`] = propertyValue;\n        }\n\n        // Always store the highest encountered value, in case the loop\n        // stops prematurely, or if the stopping conditions would've skipped\n        // a value that we already calculated\n        if (propertyValue > maxPropertyValue) {\n          maxPropertyValue = propertyValue;\n          optimalBorrowRatio = ratio;\n        }\n      };\n\n      while (!foundValue) {\n        iterations += 1;\n\n        const center = cache[borrowRatio]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio,\n            canton,\n          });\n        setMax(borrowRatio, center);\n\n        const yLeft = cache[borrowRatio - deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio - deltaX,\n            canton,\n          });\n        setMax(borrowRatio - deltaX, yLeft);\n        const yRight = cache[borrowRatio + deltaX]\n          || this.getMaxPropertyValue({\n            borrowers,\n            residenceType,\n            maxBorrowRatio: borrowRatio + deltaX,\n            canton,\n          });\n        setMax(borrowRatio + deltaX, yRight);\n\n        const slope = yRight - yLeft;\n\n        if (yRight === 0 && yLeft === 0) {\n          // If the algorithm is at 0 on both sides, it means the borrowRatio\n          // is way too high, so start him over again at 0, but with a large\n          // step size to allow it to recover quickly\n          borrowRatio = INITIAL_BORROW_RATIO_STEP_SIZE;\n          stepSize = 0.2;\n        } else if (slope > 0) {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'upwards',\n            cache,\n          });\n          borrowRatio += stepSize;\n        } else {\n          stepSize = this.getNextStepSize({\n            currentMax: center,\n            currentBorrowRatio: borrowRatio,\n            stepSize,\n            borrowers,\n            residenceType,\n            canton,\n            direction: 'downwards',\n            cache,\n          });\n          borrowRatio -= stepSize;\n        }\n\n        if (stepSize < deltaX / 2) {\n          foundValue = true;\n        }\n\n        if (iterations > 50) {\n          foundValue = true;\n        }\n      }\n\n      // Round the borrowRatio, and recompute the exact property value\n      const finalBorrowRatio = Math.round(optimalBorrowRatio * 10000) / 10000;\n      const finalPropertyValue = cache[finalBorrowRatio]\n        || this.getMaxPropertyValue({\n          borrowers,\n          residenceType,\n          maxBorrowRatio: finalBorrowRatio,\n          canton,\n        });\n\n      return {\n        borrowRatio: finalBorrowRatio,\n        propertyValue: finalPropertyValue,\n      };\n    }\n\n    getMaxPropertyValueForLoan({\n      loan,\n      maxBorrowRatio,\n      canton,\n      residenceType,\n    }) {\n      const { borrowers, residenceType: loanResidenceType } = loan;\n      return this.getMaxPropertyValue({\n        borrowers,\n        residenceType: residenceType || loanResidenceType,\n        maxBorrowRatio,\n        canton,\n      });\n    }\n\n    suggestStructureForLoan({ loan, structureId }) {\n      const propertyValue = this.getPropAndWork({ loan, structureId });\n      const loanValue = this.selectLoanValue({ loan, structureId });\n      const notaryFees = this.getFees({ loan, structureId }).total;\n\n      return this.suggestStructure({\n        borrowers: loan.borrowers,\n        propertyValue,\n        loanValue,\n        residenceType: loan.residenceType,\n        notaryFees,\n      });\n    }\n  };\n"]},"sourceType":"script","hash":"efe565d55b2b33b45bf5259f80f3872ae5eac2c1"}
