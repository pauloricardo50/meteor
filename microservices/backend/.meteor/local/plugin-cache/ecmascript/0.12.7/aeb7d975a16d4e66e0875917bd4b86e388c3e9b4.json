{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","passPerPreset":false,"envName":"development","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"}},"code":"module.export({\n  applyPostFilters: () => applyPostFilters,\n  applyPostOptions: () => applyPostOptions,\n  getResultsArray: () => getResultsArray,\n  removeLinkStorages: () => removeLinkStorages,\n  storeOneResults: () => storeOneResults,\n  assembleMetadata: () => assembleMetadata\n});\nlet applyReducers;\nmodule.link(\"../reducers/lib/applyReducers\", {\n  default(v) {\n    applyReducers = v;\n  }\n\n}, 0);\nlet cleanReducerLeftovers;\nmodule.link(\"../reducers/lib/cleanReducerLeftovers\", {\n  default(v) {\n    cleanReducerLeftovers = v;\n  }\n\n}, 1);\nlet sift;\nmodule.link(\"sift\", {\n  default(v) {\n    sift = v;\n  }\n\n}, 2);\nlet dot;\nmodule.link(\"dot-object\", {\n  default(v) {\n    dot = v;\n  }\n\n}, 3);\nlet Minimongo;\nmodule.link(\"meteor/minimongo\", {\n  Minimongo(v) {\n    Minimongo = v;\n  }\n\n}, 4);\nmodule.exportDefault((node, params) => {\n  snapBackCaches(node);\n  storeOneResults(node, node.results);\n  applyReducers(node, params);\n\n  _.each(node.collectionNodes, collectionNode => {\n    cloneMetaChildren(collectionNode, node.results);\n  });\n\n  _.each(node.collectionNodes, collectionNode => {\n    assembleMetadata(collectionNode, node.results);\n  });\n\n  cleanReducerLeftovers(node, node.results);\n  removeLinkStorages(node, node.results);\n  applyPostFilters(node);\n  applyPostOptions(node);\n  applyPostFilter(node, params);\n});\n\nfunction applyPostFilters(node) {\n  const postFilters = node.props.$postFilters;\n\n  if (postFilters) {\n    node.results = sift(postFilters, node.results);\n  }\n}\n\nfunction applyPostOptions(node) {\n  const options = node.props.$postOptions;\n\n  if (options) {\n    if (options.sort) {\n      const sorter = new Minimongo.Sorter(options.sort);\n      node.results.sort(sorter.getComparator());\n    }\n\n    if (options.limit || options.skip) {\n      const start = options.skip || 0;\n      const end = options.limit ? options.limit + start : node.results.length;\n      node.results = node.results.slice(start, end);\n    }\n  }\n}\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n  if (node.props.$postFilter) {\n    const filter = node.props.$postFilter;\n\n    if (_.isArray(filter)) {\n      filter.forEach(f => {\n        node.results = f(node.results, params);\n      });\n    } else {\n      node.results = filter(node.results, params);\n    }\n  }\n}\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\n\n\nfunction getResultsArray(results) {\n  if (_.isArray(results)) {\n    return results;\n  } else if (_.isUndefined(results)) {\n    return [];\n  }\n\n  return [results];\n}\n\nfunction removeLinkStorages(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  sameLevelResults = getResultsArray(sameLevelResults);\n\n  _.each(node.collectionNodes, collectionNode => {\n    const removeStorageField = collectionNode.shouldCleanStorage;\n\n    _.each(sameLevelResults, result => {\n      if (removeStorageField) {\n        const isSingle = collectionNode.linker.isSingle();\n        const [root, ...nested] = collectionNode.linkStorageField.split('.');\n\n        const removeFromResult = (result, removeEmptyRoot = false) => {\n          if (isSingle) {\n            dot.pick(collectionNode.linkStorageField, result, true);\n\n            if (removeEmptyRoot && nested.length > 0 && _.isEmpty(result[root])) {\n              delete result[root];\n            }\n          } else {\n            if (nested.length > 0) {\n              const arr = result[root] || [];\n\n              if (_.isArray(arr)) {\n                arr.forEach(obj => dot.pick(nested.join('.'), obj, true));\n\n                if (removeEmptyRoot && nested.length > 0 && arr.every(obj => _.isEmpty(obj))) {\n                  delete result[root];\n                }\n              }\n            } else {\n              delete result[collectionNode.linkStorageField];\n            }\n          }\n        };\n\n        if (collectionNode.isVirtual) {\n          const childResults = getResultsArray(result[collectionNode.linkName]);\n\n          _.each(childResults, childResult => {\n            removeFromResult(childResult);\n          });\n        } else {\n          removeFromResult(result);\n        }\n      }\n\n      removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n    });\n  });\n}\n\nfunction storeOneResults(node, sameLevelResults) {\n  if (!sameLevelResults) {\n    return;\n  }\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(sameLevelResults, result => {\n      // The reason we are doing this is that if the requested link does not exist\n      // It will fail when we try to get undefined[something] below\n      if (result === undefined) {\n        return;\n      }\n\n      storeOneResults(collectionNode, result[collectionNode.linkName]);\n    });\n\n    if (collectionNode.isOneResult) {\n      _.each(sameLevelResults, result => {\n        if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n          result[collectionNode.linkName] = result[collectionNode.linkName] ? _.first(result[collectionNode.linkName]) : undefined;\n        }\n      });\n    }\n  });\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n  if (!parentResults) {\n    return;\n  }\n\n  const linkName = node.linkName;\n  const isMeta = node.isMeta; // parentResults might be an object (for type==one links)\n\n  parentResults = getResultsArray(parentResults);\n  parentResults.forEach(parentResult => {\n    if (isMeta && parentResult[linkName]) {\n      if (node.isOneResult) {\n        parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n      } else {\n        parentResult[linkName] = parentResult[linkName].map(object => {\n          return Object.assign({}, object);\n        });\n      }\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n      cloneMetaChildren(collectionNode, parentResult[linkName]);\n    });\n  });\n}\n\nfunction assembleMetadata(node, parentResults) {\n  parentResults = getResultsArray(parentResults); // assembling metadata is depth first\n\n  node.collectionNodes.forEach(collectionNode => {\n    _.each(parentResults, result => {\n      assembleMetadata(collectionNode, result[node.linkName]);\n    });\n  });\n\n  if (node.isMeta) {\n    if (node.isVirtual) {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n\n        if (node.isOneResult) {\n          if (_.isObject(childResult)) {\n            const storage = childResult[node.linkStorageField];\n            storeMetadata(childResult, parentResult, storage, true);\n          }\n        } else {\n          _.each(childResult, object => {\n            const storage = object[node.linkStorageField];\n            storeMetadata(object, parentResult, storage, true);\n          });\n        }\n      });\n    } else {\n      _.each(parentResults, parentResult => {\n        const childResult = parentResult[node.linkName];\n        const storage = parentResult[node.linkStorageField];\n\n        if (node.isOneResult) {\n          if (childResult) {\n            storeMetadata(childResult, parentResult, storage, false);\n          }\n        } else {\n          _.each(childResult, object => {\n            storeMetadata(object, parentResult, storage, false);\n          });\n        }\n      });\n    }\n  }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n  if (isVirtual) {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  } else {\n    let $metadata;\n\n    if (_.isArray(storage)) {\n      $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n    } else {\n      $metadata = storage;\n    }\n\n    element.$metadata = _.omit($metadata, '_id');\n  }\n}\n\nfunction snapBackCaches(node) {\n  node.collectionNodes.forEach(collectionNode => {\n    snapBackCaches(collectionNode);\n  });\n\n  if (!_.isEmpty(node.snapCaches)) {\n    // process stuff\n    _.each(node.snapCaches, (linkName, cacheField) => {\n      const isSingle = _.contains(node.snapCachesSingles, cacheField);\n\n      const linker = node.collection.getLinker(linkName); // we do this because for one direct and one meta direct, id is not stored\n\n      const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n      node.results.forEach(result => {\n        if (result[cacheField]) {\n          if (shoudStoreLinkStorage) {\n            Object.assign(result[cacheField], {\n              _id: linker.isMeta() ? result[linker.linkStorageField]._id : result[linker.linkStorageField]\n            });\n          }\n\n          if (isSingle && _.isArray(result[cacheField])) {\n            result[linkName] = _.first(result[cacheField]);\n          } else {\n            result[linkName] = result[cacheField];\n          }\n\n          delete result[cacheField];\n        }\n      });\n    });\n  }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"],"names":["module","export","applyPostFilters","applyPostOptions","getResultsArray","removeLinkStorages","storeOneResults","assembleMetadata","applyReducers","link","default","v","cleanReducerLeftovers","sift","dot","Minimongo","exportDefault","node","params","snapBackCaches","results","_","each","collectionNodes","collectionNode","cloneMetaChildren","applyPostFilter","postFilters","props","$postFilters","options","$postOptions","sort","sorter","Sorter","getComparator","limit","skip","start","end","length","slice","$postFilter","filter","isArray","forEach","f","isUndefined","sameLevelResults","removeStorageField","shouldCleanStorage","result","isSingle","linker","root","nested","linkStorageField","split","removeFromResult","removeEmptyRoot","pick","isEmpty","arr","obj","join","every","isVirtual","childResults","linkName","childResult","undefined","isOneResult","first","parentResults","isMeta","parentResult","Object","assign","map","object","isObject","storage","storeMetadata","element","parentElement","$metadata","find","storageItem","_id","omit","snapCaches","cacheField","contains","snapCachesSingles","collection","getLinker","shoudStoreLinkStorage","isMany"],"mappings":"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","sourcesContent":["// 1. Clone children with meta relationships\n// 2. Apply $metadata to children\n// 3. Removes link storage (if not specified)\n// 4. Stores oneResult links as a single object instead of array\nimport applyReducers from '../reducers/lib/applyReducers';\nimport cleanReducerLeftovers from '../reducers/lib/cleanReducerLeftovers';\nimport sift from 'sift';\nimport dot from 'dot-object';\nimport {Minimongo} from 'meteor/minimongo';\n\nexport default (node, params) => {\n    snapBackCaches(node);\n    storeOneResults(node, node.results);\n\n    applyReducers(node, params);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results)\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results)\n    });\n\n    cleanReducerLeftovers(node, node.results);\n\n    removeLinkStorages(node, node.results);\n\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n}\n\nexport function applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nexport function applyPostOptions(node) {\n    const options = node.props.$postOptions;\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            })\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\n/**\n *\n * Helper function which transforms results into the array.\n * Results are an object for 'one' links.\n *\n * @param results\n * @return array\n */\nexport function getResultsArray(results) {\n    if (_.isArray(results)) {\n        return results;\n    }\n    else if (_.isUndefined(results)) {\n        return [];\n    }\n    return [results];\n}\n\nexport function removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    sameLevelResults = getResultsArray(sameLevelResults);\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                const isSingle = collectionNode.linker.isSingle();\n                const [root, ...nested] = collectionNode.linkStorageField.split('.');\n\n                const removeFromResult = (result, removeEmptyRoot = false) => {\n                    if (isSingle) {\n                        dot.pick(collectionNode.linkStorageField, result, true);\n                        if (removeEmptyRoot && nested.length > 0 && _.isEmpty(result[root])) {\n                            delete result[root];\n                        }\n                    }\n                    else {\n                        if (nested.length > 0) {\n                            const arr = result[root] || [];\n                            if (_.isArray(arr)) {\n                                arr.forEach(obj => dot.pick(nested.join('.'), obj, true));\n                                if (removeEmptyRoot && nested.length > 0 && arr.every(obj => _.isEmpty(obj))) {\n                                    delete result[root];\n                                }\n                            }\n                        }\n                        else {\n                            delete result[collectionNode.linkStorageField];\n                        }\n                    }\n                };\n\n                if (collectionNode.isVirtual) {\n                    const childResults = getResultsArray(result[collectionNode.linkName]);\n                    _.each(childResults, childResult => {\n                        removeFromResult(childResult);\n                    });\n                } else {\n                    removeFromResult(result);\n                }\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        })\n    })\n}\n\nexport function storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            // The reason we are doing this is that if the requested link does not exist\n            // It will fail when we try to get undefined[something] below\n            if (result === undefined) {\n                return;\n            }\n\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            _.each(sameLevelResults, result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName]\n                        ? _.first(result[collectionNode.linkName])\n                        : undefined;\n                }\n            })\n        }\n    })\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n\n    // parentResults might be an object (for type==one links)\n    parentResults = getResultsArray(parentResults);\n\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            if (node.isOneResult) {\n                parentResult[linkName] = Object.assign({}, parentResult[linkName]);\n            }\n            else {\n                parentResult[linkName] = parentResult[linkName].map(object => {\n                    return Object.assign({}, object);\n                });\n            }\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nexport function assembleMetadata(node, parentResults) {\n    parentResults = getResultsArray(parentResults);\n\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName])\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                if (node.isOneResult) {\n                    if (_.isObject(childResult)) {\n                        const storage = childResult[node.linkStorageField];\n                        storeMetadata(childResult, parentResult, storage, true);\n                    }\n                } else {\n                    _.each(childResult, object => {\n                        const storage = object[node.linkStorageField];\n                        storeMetadata(object, parentResult, storage, true);\n                    });\n                }\n            })\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                if (node.isOneResult) {\n                    if (childResult) {\n                        storeMetadata(childResult, parentResult, storage, false);\n                    }\n                } else {\n                    _.each(childResult, object => {\n                        storeMetadata(object, parentResult, storage, false);\n                    });\n                }\n            })\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id')\n    } else {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n            const linker = node.collection.getLinker(linkName);\n            // we do this because for one direct and one meta direct, id is not stored\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta()\n                                ? result[linker.linkStorageField]._id\n                                : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            })\n        })\n    }\n}\n"]},"sourceType":"script","hash":"aeb7d975a16d4e66e0875917bd4b86e388c3e9b4"}
