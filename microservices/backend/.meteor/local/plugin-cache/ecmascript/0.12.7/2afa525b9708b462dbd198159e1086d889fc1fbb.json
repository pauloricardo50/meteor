{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js","filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js","passPerPreset":false,"envName":"production","cwd":"/Users/Florian/dev/epotek/microservices/backend","root":"/Users/Florian/dev/epotek/microservices/backend","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/Users/Florian/dev/epotek/microservices/backend/packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js"}},"code":"let Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Random;\nmodule.link(\"meteor/random\", {\n  Random(v) {\n    Random = v;\n  }\n\n}, 1);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 2);\nlet debug;\nmodule.link(\"../debug\", {\n  default(v) {\n    debug = v;\n  }\n\n}, 3);\nlet RedisPipe, Events;\nmodule.link(\"../constants\", {\n  RedisPipe(v) {\n    RedisPipe = v;\n  },\n\n  Events(v) {\n    Events = v;\n  }\n\n}, 4);\nlet getFieldsOfInterestFromAll;\nmodule.link(\"./lib/getFieldsOfInterestFromAll\", {\n  default(v) {\n    getFieldsOfInterestFromAll = v;\n  }\n\n}, 5);\nlet Config;\nmodule.link(\"../config\", {\n  default(v) {\n    Config = v;\n  }\n\n}, 6);\n\nclass RedisSubscriptionManager {\n  init() {\n    if (this.isInitialized) {\n      return;\n    }\n\n    this.uid = Random.id();\n    this.queue = new Meteor._SynchronousQueue();\n    this.store = {}; // {channel: [RedisSubscribers]}\n\n    this.channelHandlers = {}; // {channel: handler}\n\n    this.isInitialized = true;\n  }\n  /**\n   * @param redisSubscriber\n   */\n\n\n  attach(redisSubscriber) {\n    this.queue.queueTask(() => {\n      _.each(redisSubscriber.channels, channel => {\n        if (!this.store[channel]) {\n          this.initializeChannel(channel);\n        }\n\n        this.store[channel].push(redisSubscriber);\n      });\n    });\n  }\n  /**\n   * @param redisSubscriber\n   */\n\n\n  detach(redisSubscriber) {\n    this.queue.queueTask(() => {\n      _.each(redisSubscriber.channels, channel => {\n        if (!this.store[channel]) {\n          return debug('[RedisSubscriptionManager] Trying to detach a subscriber on a non existent channels.');\n        } else {\n          this.store[channel] = _.without(this.store[channel], redisSubscriber);\n\n          if (this.store[channel].length === 0) {\n            this.destroyChannel(channel);\n          }\n        }\n      });\n    });\n  }\n  /**\n   * @param channel\n   */\n\n\n  initializeChannel(channel) {\n    debug(`[RedisSubscriptionManager] Subscribing to channel: ${channel}`); // create the handler for this channel\n\n    const self = this;\n\n    const handler = function (message) {\n      self.queue.queueTask(() => {\n        self.process(channel, message, true);\n      });\n    };\n\n    this.channelHandlers[channel] = handler;\n    this.store[channel] = [];\n    const {\n      pubSubManager\n    } = Config;\n    pubSubManager.subscribe(channel, handler);\n  }\n  /**\n   * @param channel\n   */\n\n\n  destroyChannel(channel) {\n    debug(`[RedisSubscriptionManager] Unsubscribing from channel: ${channel}`);\n    const {\n      pubSubManager\n    } = Config;\n    pubSubManager.unsubscribe(channel, this.channelHandlers[channel]);\n    delete this.store[channel];\n    delete this.channelHandlers[channel];\n  }\n  /**\n   * @param channel\n   * @param data\n   * @param [fromRedis=false]\n   */\n\n\n  process(channel, data, fromRedis) {\n    // messages from redis that contain our uid were handled\n    //  optimistically, so we can drop them.\n    if (fromRedis && data[RedisPipe.UID] === this.uid) {\n      return;\n    }\n\n    const subscribers = this.store[channel];\n\n    if (!subscribers) {\n      return;\n    }\n\n    let isSynthetic = data[RedisPipe.SYNTHETIC];\n    debug(`[RedisSubscriptionManager] Received ${isSynthetic ? 'synthetic ' : ''}event: \"${data[RedisPipe.EVENT]}\" to \"${channel}\"`);\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    if (!isSynthetic) {\n      const collection = subscribers[0].observableCollection.collection;\n      let doc;\n\n      if (data[RedisPipe.EVENT] === Events.REMOVE) {\n        doc = data[RedisPipe.DOC];\n      } else {\n        doc = this.getDoc(collection, subscribers, data);\n      } // if by any chance it was deleted after it got dispatched\n      // doc will be undefined\n\n\n      if (!doc) {\n        return;\n      }\n\n      subscribers.forEach(redisSubscriber => {\n        redisSubscriber.process(data[RedisPipe.EVENT], doc, data[RedisPipe.FIELDS]);\n      });\n    } else {\n      subscribers.forEach(redisSubscriber => {\n        redisSubscriber.processSynthetic(data[RedisPipe.EVENT], data[RedisPipe.DOC], data[RedisPipe.MODIFIER], data[RedisPipe.MODIFIED_TOP_LEVEL_FIELDS]);\n      });\n    }\n  }\n  /**\n   * @param collection\n   * @param subscribers\n   * @param data\n   */\n\n\n  getDoc(collection, subscribers, data) {\n    const event = data[RedisPipe.EVENT];\n    let doc = data[RedisPipe.DOC];\n    const fieldsOfInterest = getFieldsOfInterestFromAll(subscribers);\n\n    if (fieldsOfInterest === true) {\n      doc = collection.findOne(doc._id);\n    } else {\n      doc = collection.findOne(doc._id, {\n        fields: fieldsOfInterest\n      });\n    }\n\n    return doc;\n  }\n\n}\n\nmodule.exportDefault(new RedisSubscriptionManager());","map":{"version":3,"sources":["packages/cultofcoders:redis-oplog/lib/redis/RedisSubscriptionManager.js"],"names":["Meteor","module","link","v","Random","_","debug","default","RedisPipe","Events","getFieldsOfInterestFromAll","Config","RedisSubscriptionManager","init","isInitialized","uid","id","queue","_SynchronousQueue","store","channelHandlers","attach","redisSubscriber","queueTask","each","channels","channel","initializeChannel","push","detach","without","length","destroyChannel","self","handler","message","process","pubSubManager","subscribe","unsubscribe","data","fromRedis","UID","subscribers","isSynthetic","SYNTHETIC","EVENT","collection","observableCollection","doc","REMOVE","DOC","getDoc","forEach","FIELDS","processSynthetic","MODIFIER","MODIFIED_TOP_LEVEL_FIELDS","event","fieldsOfInterest","findOne","_id","fields","exportDefault"],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Random } from 'meteor/random';\nimport { _ } from 'meteor/underscore';\nimport debug from '../debug';\nimport { RedisPipe, Events } from '../constants';\nimport getFieldsOfInterestFromAll from './lib/getFieldsOfInterestFromAll';\nimport Config from '../config';\n\nclass RedisSubscriptionManager {\n    init() {\n        if (this.isInitialized) {\n            return;\n        }\n        this.uid = Random.id();\n        this.queue = new Meteor._SynchronousQueue();\n        this.store = {}; // {channel: [RedisSubscribers]}\n        this.channelHandlers = {}; // {channel: handler}\n\n        this.isInitialized = true;\n    }\n\n    /**\n     * @param redisSubscriber\n     */\n    attach(redisSubscriber) {\n        this.queue.queueTask(() => {\n            _.each(redisSubscriber.channels, channel => {\n                if (!this.store[channel]) {\n                    this.initializeChannel(channel);\n                }\n\n                this.store[channel].push(redisSubscriber);\n            });\n        });\n    }\n\n    /**\n     * @param redisSubscriber\n     */\n    detach(redisSubscriber) {\n        this.queue.queueTask(() => {\n            _.each(redisSubscriber.channels, channel => {\n                if (!this.store[channel]) {\n                    return debug(\n                        '[RedisSubscriptionManager] Trying to detach a subscriber on a non existent channels.'\n                    );\n                } else {\n                    this.store[channel] = _.without(\n                        this.store[channel],\n                        redisSubscriber\n                    );\n\n                    if (this.store[channel].length === 0) {\n                        this.destroyChannel(channel);\n                    }\n                }\n            });\n        });\n    }\n\n    /**\n     * @param channel\n     */\n    initializeChannel(channel) {\n        debug(`[RedisSubscriptionManager] Subscribing to channel: ${channel}`);\n\n        // create the handler for this channel\n        const self = this;\n        const handler = function(message) {\n            self.queue.queueTask(() => {\n                self.process(channel, message, true);\n            });\n        };\n\n        this.channelHandlers[channel] = handler;\n        this.store[channel] = [];\n\n        const { pubSubManager } = Config;\n        pubSubManager.subscribe(channel, handler);\n    }\n\n    /**\n     * @param channel\n     */\n    destroyChannel(channel) {\n        debug(\n            `[RedisSubscriptionManager] Unsubscribing from channel: ${channel}`\n        );\n\n        const { pubSubManager } = Config;\n        pubSubManager.unsubscribe(channel, this.channelHandlers[channel]);\n\n        delete this.store[channel];\n        delete this.channelHandlers[channel];\n    }\n\n    /**\n     * @param channel\n     * @param data\n     * @param [fromRedis=false]\n     */\n    process(channel, data, fromRedis) {\n        // messages from redis that contain our uid were handled\n        //  optimistically, so we can drop them.\n        if (fromRedis && data[RedisPipe.UID] === this.uid){\n            return;\n        }\n\n        const subscribers = this.store[channel];\n        if (!subscribers) {\n            return;\n        }\n\n        let isSynthetic = data[RedisPipe.SYNTHETIC];\n\n        debug(\n            `[RedisSubscriptionManager] Received ${\n                isSynthetic ? 'synthetic ' : ''\n            }event: \"${data[RedisPipe.EVENT]}\" to \"${channel}\"`\n        );\n\n        if (subscribers.length === 0) {\n            return;\n        }\n\n        if (!isSynthetic) {\n            const collection = subscribers[0].observableCollection.collection;\n\n            let doc;\n            if (data[RedisPipe.EVENT] === Events.REMOVE) {\n                doc = data[RedisPipe.DOC];\n            } else {\n                doc = this.getDoc(collection, subscribers, data);\n            }\n\n            // if by any chance it was deleted after it got dispatched\n            // doc will be undefined\n            if (!doc) {\n                return;\n            }\n\n            subscribers.forEach(redisSubscriber => {\n                redisSubscriber.process(\n                    data[RedisPipe.EVENT],\n                    doc,\n                    data[RedisPipe.FIELDS]\n                );\n            });\n        } else {\n            subscribers.forEach(redisSubscriber => {\n                redisSubscriber.processSynthetic(\n                    data[RedisPipe.EVENT],\n                    data[RedisPipe.DOC],\n                    data[RedisPipe.MODIFIER],\n                    data[RedisPipe.MODIFIED_TOP_LEVEL_FIELDS]\n                );\n            });\n        }\n    }\n\n    /**\n     * @param collection\n     * @param subscribers\n     * @param data\n     */\n    getDoc(collection, subscribers, data) {\n        const event = data[RedisPipe.EVENT];\n        let doc = data[RedisPipe.DOC];\n\n        const fieldsOfInterest = getFieldsOfInterestFromAll(subscribers);\n\n        if (fieldsOfInterest === true) {\n            doc = collection.findOne(doc._id);\n        } else {\n            doc = collection.findOne(doc._id, { fields: fieldsOfInterest });\n        }\n\n        return doc;\n    }\n}\n\nexport default new RedisSubscriptionManager();\n"]},"sourceType":"script","hash":"2afa525b9708b462dbd198159e1086d889fc1fbb"}
