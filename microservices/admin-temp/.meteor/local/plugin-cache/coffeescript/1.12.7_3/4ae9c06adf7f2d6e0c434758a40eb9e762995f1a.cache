{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar JobQueue,\n    _clearInterval,\n    _setImmediate,\n    _setInterval,\n    concatReduce,\n    isBoolean,\n    isFunction,\n    isInteger,\n    isNonEmptyString,\n    isNonEmptyStringOrArrayOfNonEmptyStrings,\n    methodCall,\n    optionsHelp,\n    reduceCallbacks,\n    splitLongArray,\n    slice = [].slice,\n    indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\nmethodCall = function (root, method, params, cb, after) {\n  var apply, name, ref, ref1, ref2, ref3;\n\n  if (after == null) {\n    after = function (ret) {\n      return ret;\n    };\n  }\n\n  apply = (ref = (ref1 = Job._ddp_apply) != null ? ref1[(ref2 = root.root) != null ? ref2 : root] : void 0) != null ? ref : Job._ddp_apply;\n\n  if (typeof apply !== 'function') {\n    throw new Error(\"Job remote method call error, no valid invocation method found.\");\n  }\n\n  name = ((ref3 = root.root) != null ? ref3 : root) + \"_\" + method;\n\n  if (cb && typeof cb === 'function') {\n    return apply(name, params, function (_this) {\n      return function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        return cb(null, after(res));\n      };\n    }(this));\n  } else {\n    return after(apply(name, params));\n  }\n};\n\noptionsHelp = function (options, cb) {\n  var ref;\n\n  if (cb != null && typeof cb !== 'function') {\n    options = cb;\n    cb = void 0;\n  } else {\n    if (!((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === 'object' && options instanceof Array && options.length < 2)) {\n      throw new Error('options... in optionsHelp must be an Array with zero or one elements');\n    }\n\n    options = (ref = options != null ? options[0] : void 0) != null ? ref : {};\n  }\n\n  if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== 'object') {\n    throw new Error('in optionsHelp options not an object or bad callback');\n  }\n\n  return [options, cb];\n};\n\nsplitLongArray = function (arr, max) {\n  var i, k, ref, results;\n\n  if (!(arr instanceof Array && max > 0)) {\n    throw new Error('splitLongArray: bad params');\n  }\n\n  results = [];\n\n  for (i = k = 0, ref = Math.ceil(arr.length / max); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n    results.push(arr.slice(i * max, (i + 1) * max));\n  }\n\n  return results;\n};\n\nreduceCallbacks = function (cb, num, reduce, init) {\n  var cbCount, cbErr, cbRetVal;\n\n  if (reduce == null) {\n    reduce = function (a, b) {\n      return a || b;\n    };\n  }\n\n  if (init == null) {\n    init = false;\n  }\n\n  if (cb == null) {\n    return void 0;\n  }\n\n  if (!(typeof cb === 'function' && num > 0 && typeof reduce === 'function')) {\n    throw new Error('Bad params given to reduceCallbacks');\n  }\n\n  cbRetVal = init;\n  cbCount = 0;\n  cbErr = null;\n  return function (err, res) {\n    if (!cbErr) {\n      if (err) {\n        cbErr = err;\n        return cb(err);\n      } else {\n        cbCount++;\n        cbRetVal = reduce(cbRetVal, res);\n\n        if (cbCount === num) {\n          return cb(null, cbRetVal);\n        } else if (cbCount > num) {\n          throw new Error(\"reduceCallbacks callback invoked more than requested \" + num + \" times\");\n        }\n      }\n    }\n  };\n};\n\nconcatReduce = function (a, b) {\n  if (!(a instanceof Array)) {\n    a = [a];\n  }\n\n  return a.concat(b);\n};\n\nisInteger = function (i) {\n  return typeof i === 'number' && Math.floor(i) === i;\n};\n\nisBoolean = function (b) {\n  return typeof b === 'boolean';\n};\n\nisFunction = function (f) {\n  return typeof f === 'function';\n};\n\nisNonEmptyString = function (s) {\n  return typeof s === 'string' && s.length > 0;\n};\n\nisNonEmptyStringOrArrayOfNonEmptyStrings = function (sa) {\n  var s;\n  return isNonEmptyString(sa) || sa instanceof Array && sa.length !== 0 && function () {\n    var k, len, results;\n    results = [];\n\n    for (k = 0, len = sa.length; k < len; k++) {\n      s = sa[k];\n\n      if (isNonEmptyString(s)) {\n        results.push(s);\n      }\n    }\n\n    return results;\n  }().length === sa.length;\n};\n\n_setImmediate = function () {\n  var args, func;\n  func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.setTimeout : void 0) != null) {\n    return Meteor.setTimeout.apply(Meteor, [func, 0].concat(slice.call(args)));\n  } else if (typeof setImmediate !== \"undefined\" && setImmediate !== null) {\n    return setImmediate.apply(null, [func].concat(slice.call(args)));\n  } else {\n    return setTimeout.apply(null, [func, 0].concat(slice.call(args)));\n  }\n};\n\n_setInterval = function () {\n  var args, func, timeOut;\n  func = arguments[0], timeOut = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.setInterval : void 0) != null) {\n    return Meteor.setInterval.apply(Meteor, [func, timeOut].concat(slice.call(args)));\n  } else {\n    return setInterval.apply(null, [func, timeOut].concat(slice.call(args)));\n  }\n};\n\n_clearInterval = function (id) {\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.clearInterval : void 0) != null) {\n    return Meteor.clearInterval(id);\n  } else {\n    return clearInterval(id);\n  }\n};\n\nJobQueue = function () {\n  function JobQueue() {\n    var k, options, ref, ref1, ref2, ref3, ref4, root1, type1, worker;\n    root1 = arguments[0], type1 = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), worker = arguments[k++];\n    this.root = root1;\n    this.type = type1;\n    this.worker = worker;\n\n    if (!(this instanceof JobQueue)) {\n      return function (func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor(),\n            result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      }(JobQueue, [this.root, this.type].concat(slice.call(options), [this.worker]), function () {});\n    }\n\n    ref = optionsHelp(options, this.worker), options = ref[0], this.worker = ref[1];\n\n    if (!isNonEmptyString(this.root)) {\n      throw new Error(\"JobQueue: Invalid root, must be nonempty string\");\n    }\n\n    if (!isNonEmptyStringOrArrayOfNonEmptyStrings(this.type)) {\n      throw new Error(\"JobQueue: Invalid type, must be nonempty string or array of nonempty strings\");\n    }\n\n    if (!isFunction(this.worker)) {\n      throw new Error(\"JobQueue: Invalid worker, must be a function\");\n    }\n\n    this.errorCallback = (ref1 = options.errorCallback) != null ? ref1 : function (e) {\n      return console.error(\"JobQueue: \", e);\n    };\n\n    if (!isFunction(this.errorCallback)) {\n      throw new Error(\"JobQueue: Invalid errorCallback, must be a function\");\n    }\n\n    this.pollInterval = options.pollInterval != null && !options.pollInterval ? Job.forever : !(options.pollInterval != null && isInteger(options.pollInterval)) ? 5000 : options.pollInterval;\n\n    if (!(isInteger(this.pollInterval) && this.pollInterval >= 0)) {\n      throw new Error(\"JobQueue: Invalid pollInterval, must be a positive integer\");\n    }\n\n    this.concurrency = (ref2 = options.concurrency) != null ? ref2 : 1;\n\n    if (!(isInteger(this.concurrency) && this.concurrency >= 0)) {\n      throw new Error(\"JobQueue: Invalid concurrency, must be a positive integer\");\n    }\n\n    this.payload = (ref3 = options.payload) != null ? ref3 : 1;\n\n    if (!(isInteger(this.payload) && this.payload >= 0)) {\n      throw new Error(\"JobQueue: Invalid payload, must be a positive integer\");\n    }\n\n    this.prefetch = (ref4 = options.prefetch) != null ? ref4 : 0;\n\n    if (!(isInteger(this.prefetch) && this.prefetch >= 0)) {\n      throw new Error(\"JobQueue: Invalid prefetch, must be a positive integer\");\n    }\n\n    this.workTimeout = options.workTimeout;\n\n    if (this.workTimeout != null && !(isInteger(this.workTimeout) && this.workTimeout >= 0)) {\n      throw new Error(\"JobQueue: Invalid workTimeout, must be a positive integer\");\n    }\n\n    this.callbackStrict = options.callbackStrict;\n\n    if (this.callbackStrict != null && !isBoolean(this.callbackStrict)) {\n      throw new Error(\"JobQueue: Invalid callbackStrict, must be a boolean\");\n    }\n\n    this._workers = {};\n    this._tasks = [];\n    this._taskNumber = 0;\n    this._stoppingGetWork = void 0;\n    this._stoppingTasks = void 0;\n    this._interval = null;\n    this._getWorkOutstanding = false;\n    this.paused = true;\n    this.resume();\n  }\n\n  JobQueue.prototype._getWork = function () {\n    var numJobsToGet, options;\n\n    if (!(this._getWorkOutstanding || this.paused)) {\n      numJobsToGet = this.prefetch + this.payload * (this.concurrency - this.running()) - this.length();\n\n      if (numJobsToGet > 0) {\n        this._getWorkOutstanding = true;\n        options = {\n          maxJobs: numJobsToGet\n        };\n\n        if (this.workTimeout != null) {\n          options.workTimeout = this.workTimeout;\n        }\n\n        return Job.getWork(this.root, this.type, options, function (_this) {\n          return function (err, jobs) {\n            var j, k, len;\n            _this._getWorkOutstanding = false;\n\n            if (err) {\n              return _this.errorCallback(new Error(\"Received error from getWork(): \" + err));\n            } else if (jobs != null && jobs instanceof Array) {\n              if (jobs.length > numJobsToGet) {\n                _this.errorCallback(new Error(\"getWork() returned jobs (\" + jobs.length + \") in excess of maxJobs (\" + numJobsToGet + \")\"));\n              }\n\n              for (k = 0, len = jobs.length; k < len; k++) {\n                j = jobs[k];\n\n                _this._tasks.push(j);\n\n                if (_this._stoppingGetWork == null) {\n                  _setImmediate(_this._process.bind(_this));\n                }\n              }\n\n              if (_this._stoppingGetWork != null) {\n                return _this._stoppingGetWork();\n              }\n            } else {\n              return _this.errorCallback(new Error(\"Nonarray response from server from getWork()\"));\n            }\n          };\n        }(this));\n      }\n    }\n  };\n\n  JobQueue.prototype._only_once = function (fn) {\n    var called;\n    called = false;\n    return function (_this) {\n      return function () {\n        if (called) {\n          _this.errorCallback(new Error(\"Worker callback called multiple times\"));\n\n          if (_this.callbackStrict) {\n            throw new Error(\"JobQueue: worker callback was invoked multiple times\");\n          }\n        }\n\n        called = true;\n        return fn.apply(_this, arguments);\n      };\n    }(this);\n  };\n\n  JobQueue.prototype._process = function () {\n    var cb, job, next;\n\n    if (!this.paused && this.running() < this.concurrency && this.length()) {\n      if (this.payload > 1) {\n        job = this._tasks.splice(0, this.payload);\n      } else {\n        job = this._tasks.shift();\n      }\n\n      job._taskId = \"Task_\" + this._taskNumber++;\n      this._workers[job._taskId] = job;\n\n      next = function (_this) {\n        return function () {\n          delete _this._workers[job._taskId];\n\n          if (_this._stoppingTasks != null && _this.running() === 0 && _this.length() === 0) {\n            return _this._stoppingTasks();\n          } else {\n            _setImmediate(_this._process.bind(_this));\n\n            return _setImmediate(_this._getWork.bind(_this));\n          }\n        };\n      }(this);\n\n      cb = this._only_once(next);\n      return this.worker(job, cb);\n    }\n  };\n\n  JobQueue.prototype._stopGetWork = function (callback) {\n    _clearInterval(this._interval);\n\n    this._interval = null;\n\n    if (this._getWorkOutstanding) {\n      return this._stoppingGetWork = callback;\n    } else {\n      return _setImmediate(callback);\n    }\n  };\n\n  JobQueue.prototype._waitForTasks = function (callback) {\n    if (this.running() !== 0) {\n      return this._stoppingTasks = callback;\n    } else {\n      return _setImmediate(callback);\n    }\n  };\n\n  JobQueue.prototype._failJobs = function (tasks, callback) {\n    var count, job, k, len, results;\n\n    if (tasks.length === 0) {\n      _setImmediate(callback);\n    }\n\n    count = 0;\n    results = [];\n\n    for (k = 0, len = tasks.length; k < len; k++) {\n      job = tasks[k];\n      results.push(job.fail(\"Worker shutdown\", function (_this) {\n        return function (err, res) {\n          count++;\n\n          if (count === tasks.length) {\n            return callback();\n          }\n        };\n      }(this)));\n    }\n\n    return results;\n  };\n\n  JobQueue.prototype._hard = function (callback) {\n    this.paused = true;\n    return this._stopGetWork(function (_this) {\n      return function () {\n        var i, r, ref, tasks;\n        tasks = _this._tasks;\n        _this._tasks = [];\n        ref = _this._workers;\n\n        for (i in meteorBabelHelpers.sanitizeForInObject(ref)) {\n          r = ref[i];\n          tasks = tasks.concat(r);\n        }\n\n        return _this._failJobs(tasks, callback);\n      };\n    }(this));\n  };\n\n  JobQueue.prototype._stop = function (callback) {\n    this.paused = true;\n    return this._stopGetWork(function (_this) {\n      return function () {\n        var tasks;\n        tasks = _this._tasks;\n        _this._tasks = [];\n        return _this._waitForTasks(function () {\n          return _this._failJobs(tasks, callback);\n        });\n      };\n    }(this));\n  };\n\n  JobQueue.prototype._soft = function (callback) {\n    return this._stopGetWork(function (_this) {\n      return function () {\n        return _this._waitForTasks(callback);\n      };\n    }(this));\n  };\n\n  JobQueue.prototype.length = function () {\n    return this._tasks.length;\n  };\n\n  JobQueue.prototype.running = function () {\n    return Object.keys(this._workers).length;\n  };\n\n  JobQueue.prototype.idle = function () {\n    return this.length() + this.running() === 0;\n  };\n\n  JobQueue.prototype.full = function () {\n    return this.running() === this.concurrency;\n  };\n\n  JobQueue.prototype.pause = function () {\n    if (this.paused) {\n      return;\n    }\n\n    if (!(this.pollInterval >= Job.forever)) {\n      _clearInterval(this._interval);\n\n      this._interval = null;\n    }\n\n    this.paused = true;\n    return this;\n  };\n\n  JobQueue.prototype.resume = function () {\n    var k, ref, w;\n\n    if (!this.paused) {\n      return;\n    }\n\n    this.paused = false;\n\n    _setImmediate(this._getWork.bind(this));\n\n    if (!(this.pollInterval >= Job.forever)) {\n      this._interval = _setInterval(this._getWork.bind(this), this.pollInterval);\n    }\n\n    for (w = k = 1, ref = this.concurrency; 1 <= ref ? k <= ref : k >= ref; w = 1 <= ref ? ++k : --k) {\n      _setImmediate(this._process.bind(this));\n    }\n\n    return this;\n  };\n\n  JobQueue.prototype.trigger = function () {\n    if (this.paused) {\n      return;\n    }\n\n    _setImmediate(this._getWork.bind(this));\n\n    return this;\n  };\n\n  JobQueue.prototype.shutdown = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.level == null) {\n      options.level = 'normal';\n    }\n\n    if (options.quiet == null) {\n      options.quiet = false;\n    }\n\n    if (cb == null) {\n      if (!options.quiet) {\n        console.warn(\"using default shutdown callback!\");\n      }\n\n      cb = function (_this) {\n        return function () {\n          return console.warn(\"Shutdown complete\");\n        };\n      }(this);\n    }\n\n    switch (options.level) {\n      case 'hard':\n        if (!options.quiet) {\n          console.warn(\"Shutting down hard\");\n        }\n\n        return this._hard(cb);\n\n      case 'soft':\n        if (!options.quiet) {\n          console.warn(\"Shutting down soft\");\n        }\n\n        return this._soft(cb);\n\n      default:\n        if (!options.quiet) {\n          console.warn(\"Shutting down normally\");\n        }\n\n        return this._stop(cb);\n    }\n  };\n\n  return JobQueue;\n}();\n\nJob = function () {\n  Job.forever = 9007199254740992;\n  Job.foreverDate = new Date(8640000000000000);\n  Job.jobPriorities = {\n    low: 10,\n    normal: 0,\n    medium: -5,\n    high: -10,\n    critical: -15\n  };\n  Job.jobRetryBackoffMethods = ['constant', 'exponential'];\n  Job.jobStatuses = ['waiting', 'paused', 'ready', 'running', 'failed', 'cancelled', 'completed'];\n  Job.jobLogLevels = ['info', 'success', 'warning', 'danger'];\n  Job.jobStatusCancellable = ['running', 'ready', 'waiting', 'paused'];\n  Job.jobStatusPausable = ['ready', 'waiting'];\n  Job.jobStatusRemovable = ['cancelled', 'completed', 'failed'];\n  Job.jobStatusRestartable = ['cancelled', 'failed'];\n  Job.ddpMethods = ['startJobs', 'stopJobs', 'startJobServer', 'shutdownJobServer', 'jobRemove', 'jobPause', 'jobResume', 'jobReady', 'jobCancel', 'jobRestart', 'jobSave', 'jobRerun', 'getWork', 'getJob', 'jobLog', 'jobProgress', 'jobDone', 'jobFail'];\n  Job.ddpPermissionLevels = ['admin', 'manager', 'creator', 'worker'];\n  Job.ddpMethodPermissions = {\n    'startJobs': ['startJobs', 'admin'],\n    'stopJobs': ['stopJobs', 'admin'],\n    'startJobServer': ['startJobServer', 'admin'],\n    'shutdownJobServer': ['shutdownJobServer', 'admin'],\n    'jobRemove': ['jobRemove', 'admin', 'manager'],\n    'jobPause': ['jobPause', 'admin', 'manager'],\n    'jobResume': ['jobResume', 'admin', 'manager'],\n    'jobCancel': ['jobCancel', 'admin', 'manager'],\n    'jobReady': ['jobReady', 'admin', 'manager'],\n    'jobRestart': ['jobRestart', 'admin', 'manager'],\n    'jobSave': ['jobSave', 'admin', 'creator'],\n    'jobRerun': ['jobRerun', 'admin', 'creator'],\n    'getWork': ['getWork', 'admin', 'worker'],\n    'getJob': ['getJob', 'admin', 'worker'],\n    'jobLog': ['jobLog', 'admin', 'worker'],\n    'jobProgress': ['jobProgress', 'admin', 'worker'],\n    'jobDone': ['jobDone', 'admin', 'worker'],\n    'jobFail': ['jobFail', 'admin', 'worker']\n  };\n  Job._ddp_apply = void 0;\n\n  Job._setDDPApply = function (apply, collectionName) {\n    if (typeof apply === 'function') {\n      if (typeof collectionName === 'string') {\n        if (this._ddp_apply == null) {\n          this._ddp_apply = {};\n        }\n\n        if (typeof this._ddp_apply === 'function') {\n          throw new Error(\"Job.setDDP must specify a collection name each time if called more than once.\");\n        }\n\n        return this._ddp_apply[collectionName] = apply;\n      } else if (!this._ddp_apply) {\n        return this._ddp_apply = apply;\n      } else {\n        throw new Error(\"Job.setDDP must specify a collection name each time if called more than once.\");\n      }\n    } else {\n      throw new Error(\"Bad function in Job.setDDPApply()\");\n    }\n  };\n\n  Job.setDDP = function (ddp, collectionNames, Fiber) {\n    var collName, k, len, results;\n\n    if (ddp == null) {\n      ddp = null;\n    }\n\n    if (collectionNames == null) {\n      collectionNames = null;\n    }\n\n    if (Fiber == null) {\n      Fiber = null;\n    }\n\n    if (!(typeof collectionNames === 'string' || collectionNames instanceof Array)) {\n      Fiber = collectionNames;\n      collectionNames = [void 0];\n    } else if (typeof collectionNames === 'string') {\n      collectionNames = [collectionNames];\n    }\n\n    results = [];\n\n    for (k = 0, len = collectionNames.length; k < len; k++) {\n      collName = collectionNames[k];\n\n      if (!(ddp != null && ddp.close != null && ddp.subscribe != null)) {\n        if (ddp === null && (typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.apply : void 0) != null) {\n          results.push(this._setDDPApply(Meteor.apply, collName));\n        } else {\n          throw new Error(\"Bad ddp object in Job.setDDP()\");\n        }\n      } else if (ddp.observe == null) {\n        results.push(this._setDDPApply(ddp.apply.bind(ddp), collName));\n      } else {\n        if (Fiber == null) {\n          results.push(this._setDDPApply(ddp.call.bind(ddp), collName));\n        } else {\n          results.push(this._setDDPApply(function (name, params, cb) {\n            var fib;\n            fib = Fiber.current;\n            ddp.call(name, params, function (err, res) {\n              if (cb != null && typeof cb === 'function') {\n                return cb(err, res);\n              } else {\n                if (err) {\n                  return fib.throwInto(err);\n                } else {\n                  return fib.run(res);\n                }\n              }\n            });\n\n            if (cb != null && typeof cb === 'function') {} else {\n              return Fiber[\"yield\"]();\n            }\n          }, collName));\n        }\n      }\n    }\n\n    return results;\n  };\n\n  Job.getWork = function () {\n    var cb, k, options, ref, root, type;\n    root = arguments[0], type = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (typeof type === 'string') {\n      type = [type];\n    }\n\n    if (options.workTimeout != null) {\n      if (!(isInteger(options.workTimeout) && options.workTimeout > 0)) {\n        throw new Error('getWork: workTimeout must be a positive integer');\n      }\n    }\n\n    return methodCall(root, \"getWork\", [type, options], cb, function (_this) {\n      return function (res) {\n        var doc, jobs;\n\n        jobs = function () {\n          var l, len, results;\n          results = [];\n\n          for (l = 0, len = res.length; l < len; l++) {\n            doc = res[l];\n            results.push(new Job(root, doc));\n          }\n\n          return results;\n        }() || [];\n\n        if (options.maxJobs != null) {\n          return jobs;\n        } else {\n          return jobs[0];\n        }\n      };\n    }(this));\n  };\n\n  Job.processJobs = JobQueue;\n\n  Job.makeJob = function () {\n    var depFlag;\n    depFlag = false;\n    return function (root, doc) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Job.makeJob(root, jobDoc) has been deprecated and will be removed in a future release, use 'new Job(root, jobDoc)' instead.\");\n      }\n\n      return new Job(root, doc);\n    };\n  }();\n\n  Job.getJob = function () {\n    var cb, id, k, options, ref, root;\n    root = arguments[0], id = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n\n    return methodCall(root, \"getJob\", [id, options], cb, function (_this) {\n      return function (doc) {\n        if (doc) {\n          return new Job(root, doc);\n        } else {\n          return void 0;\n        }\n      };\n    }(this));\n  };\n\n  Job.getJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n\n    retVal = [];\n    chunksOfIds = splitLongArray(ids, 32);\n    myCb = reduceCallbacks(cb, chunksOfIds.length, concatReduce, []);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = retVal.concat(methodCall(root, \"getJob\", [chunkOfIds, options], myCb, function (_this) {\n        return function (doc) {\n          var d, len1, m, results;\n\n          if (doc) {\n            results = [];\n\n            for (m = 0, len1 = doc.length; m < len1; m++) {\n              d = doc[m];\n              results.push(new Job(root, d.type, d.data, d));\n            }\n\n            return results;\n          } else {\n            return null;\n          }\n        };\n      }(this)));\n    }\n\n    return retVal;\n  };\n\n  Job.pauseJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobPause\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.resumeJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobResume\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.readyJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n\n    if (ids == null) {\n      ids = [];\n    }\n\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.force == null) {\n      options.force = false;\n    }\n\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n\n    if (!(chunksOfIds.length > 0)) {\n      chunksOfIds = [[]];\n    }\n\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobReady\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.cancelJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobCancel\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.restartJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobRestart\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.removeJobs = function () {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobRemove\", [chunkOfIds, options], myCb) || retVal;\n    }\n\n    return retVal;\n  };\n\n  Job.startJobs = function () {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(root, \"startJobs\", [options], cb);\n  };\n\n  Job.stopJobs = function () {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n\n    return methodCall(root, \"stopJobs\", [options], cb);\n  };\n\n  Job.startJobServer = function () {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(root, \"startJobServer\", [options], cb);\n  };\n\n  Job.shutdownJobServer = function () {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n\n    return methodCall(root, \"shutdownJobServer\", [options], cb);\n  };\n\n  function Job(rootVal, type, data) {\n    var doc, ref, time;\n\n    if (!(this instanceof Job)) {\n      return new Job(rootVal, type, data);\n    }\n\n    this.root = rootVal;\n    this._root = rootVal;\n\n    if (((ref = this.root) != null ? ref.root : void 0) != null && typeof this.root.root === 'string') {\n      this.root = this._root.root;\n    }\n\n    if (data == null && (type != null ? type.data : void 0) != null && (type != null ? type.type : void 0) != null) {\n      if (type instanceof Job) {\n        return type;\n      }\n\n      doc = type;\n      data = doc.data;\n      type = doc.type;\n    } else {\n      doc = {};\n    }\n\n    if (!((typeof doc === \"undefined\" ? \"undefined\" : _typeof(doc)) === 'object' && (typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) === 'object' && typeof type === 'string' && typeof this.root === 'string')) {\n      throw new Error(\"new Job: bad parameter(s), \" + this.root + \" (\" + _typeof(this.root) + \"), \" + type + \" (\" + (typeof type === \"undefined\" ? \"undefined\" : _typeof(type)) + \"), \" + data + \" (\" + (typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) + \"), \" + doc + \" (\" + (typeof doc === \"undefined\" ? \"undefined\" : _typeof(doc)) + \")\");\n    } else if (doc.type != null && doc.data != null) {\n      this._doc = doc;\n    } else {\n      time = new Date();\n      this._doc = {\n        runId: null,\n        type: type,\n        data: data,\n        status: 'waiting',\n        updated: time,\n        created: time\n      };\n      this.priority().retry().repeat().after().progress().depends().log(\"Constructed\");\n    }\n\n    return this;\n  }\n\n  Job.prototype._echo = function (message, level) {\n    if (level == null) {\n      level = null;\n    }\n\n    switch (level) {\n      case 'danger':\n        console.error(message);\n        break;\n\n      case 'warning':\n        console.warn(message);\n        break;\n\n      case 'success':\n        console.log(message);\n        break;\n\n      default:\n        console.info(message);\n    }\n  };\n\n  Job.prototype.depends = function (jobs) {\n    var depends, j, k, len;\n\n    if (jobs) {\n      if (jobs instanceof Job) {\n        jobs = [jobs];\n      }\n\n      if (jobs instanceof Array) {\n        depends = this._doc.depends;\n\n        for (k = 0, len = jobs.length; k < len; k++) {\n          j = jobs[k];\n\n          if (!(j instanceof Job && j._doc._id != null)) {\n            throw new Error('Each provided object must be a saved Job instance (with an _id)');\n          }\n\n          depends.push(j._doc._id);\n        }\n      } else {\n        throw new Error('Bad input parameter: depends() accepts a falsy value, or Job or array of Jobs');\n      }\n    } else {\n      depends = [];\n    }\n\n    this._doc.depends = depends;\n    this._doc.resolved = [];\n    return this;\n  };\n\n  Job.prototype.priority = function (level) {\n    var priority;\n\n    if (level == null) {\n      level = 0;\n    }\n\n    if (typeof level === 'string') {\n      priority = Job.jobPriorities[level];\n\n      if (priority == null) {\n        throw new Error('Invalid string priority level provided');\n      }\n    } else if (isInteger(level)) {\n      priority = level;\n    } else {\n      throw new Error('priority must be an integer or valid priority level');\n      priority = 0;\n    }\n\n    this._doc.priority = priority;\n    return this;\n  };\n\n  Job.prototype.retry = function (options) {\n    var base, ref;\n\n    if (options == null) {\n      options = 0;\n    }\n\n    if (isInteger(options) && options >= 0) {\n      options = {\n        retries: options\n      };\n    }\n\n    if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== 'object') {\n      throw new Error('bad parameter: accepts either an integer >= 0 or an options object');\n    }\n\n    if (options.retries != null) {\n      if (!(isInteger(options.retries) && options.retries >= 0)) {\n        throw new Error('bad option: retries must be an integer >= 0');\n      }\n\n      options.retries++;\n    } else {\n      options.retries = Job.forever;\n    }\n\n    if (options.until != null) {\n      if (!(options.until instanceof Date)) {\n        throw new Error('bad option: until must be a Date object');\n      }\n    } else {\n      options.until = Job.foreverDate;\n    }\n\n    if (options.wait != null) {\n      if (!(isInteger(options.wait) && options.wait >= 0)) {\n        throw new Error('bad option: wait must be an integer >= 0');\n      }\n    } else {\n      options.wait = 5 * 60 * 1000;\n    }\n\n    if (options.backoff != null) {\n      if (ref = options.backoff, indexOf.call(Job.jobRetryBackoffMethods, ref) < 0) {\n        throw new Error('bad option: invalid retry backoff method');\n      }\n    } else {\n      options.backoff = 'constant';\n    }\n\n    this._doc.retries = options.retries;\n    this._doc.repeatRetries = options.retries;\n    this._doc.retryWait = options.wait;\n\n    if ((base = this._doc).retried == null) {\n      base.retried = 0;\n    }\n\n    this._doc.retryBackoff = options.backoff;\n    this._doc.retryUntil = options.until;\n    return this;\n  };\n\n  Job.prototype.repeat = function (options) {\n    var base, ref;\n\n    if (options == null) {\n      options = 0;\n    }\n\n    if (isInteger(options) && options >= 0) {\n      options = {\n        repeats: options\n      };\n    }\n\n    if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== 'object') {\n      throw new Error('bad parameter: accepts either an integer >= 0 or an options object');\n    }\n\n    if (options.wait != null && options.schedule != null) {\n      throw new Error('bad options: wait and schedule options are mutually exclusive');\n    }\n\n    if (options.repeats != null) {\n      if (!(isInteger(options.repeats) && options.repeats >= 0)) {\n        throw new Error('bad option: repeats must be an integer >= 0');\n      }\n    } else {\n      options.repeats = Job.forever;\n    }\n\n    if (options.until != null) {\n      if (!(options.until instanceof Date)) {\n        throw new Error('bad option: until must be a Date object');\n      }\n    } else {\n      options.until = Job.foreverDate;\n    }\n\n    if (options.wait != null) {\n      if (!(isInteger(options.wait) && options.wait >= 0)) {\n        throw new Error('bad option: wait must be an integer >= 0');\n      }\n    } else {\n      options.wait = 5 * 60 * 1000;\n    }\n\n    if (options.schedule != null) {\n      if (_typeof(options.schedule) !== 'object') {\n        throw new Error('bad option, schedule option must be an object');\n      }\n\n      if (!(((ref = options.schedule) != null ? ref.schedules : void 0) != null && options.schedule.schedules instanceof Array)) {\n        throw new Error('bad option, schedule object requires a schedules attribute of type Array.');\n      }\n\n      if (options.schedule.exceptions != null && !(options.schedule.exceptions instanceof Array)) {\n        throw new Error('bad option, schedule object exceptions attribute must be an Array');\n      }\n\n      options.wait = {\n        schedules: options.schedule.schedules,\n        exceptions: options.schedule.exceptions\n      };\n    }\n\n    this._doc.repeats = options.repeats;\n    this._doc.repeatWait = options.wait;\n\n    if ((base = this._doc).repeated == null) {\n      base.repeated = 0;\n    }\n\n    this._doc.repeatUntil = options.until;\n    return this;\n  };\n\n  Job.prototype.delay = function (wait) {\n    if (wait == null) {\n      wait = 0;\n    }\n\n    if (!(isInteger(wait) && wait >= 0)) {\n      throw new Error('Bad parameter, delay requires a non-negative integer.');\n    }\n\n    return this.after(new Date(new Date().valueOf() + wait));\n  };\n\n  Job.prototype.after = function (time) {\n    var after;\n\n    if (time == null) {\n      time = new Date(0);\n    }\n\n    if ((typeof time === \"undefined\" ? \"undefined\" : _typeof(time)) === 'object' && time instanceof Date) {\n      after = time;\n    } else {\n      throw new Error('Bad parameter, after requires a valid Date object');\n    }\n\n    this._doc.after = after;\n    return this;\n  };\n\n  Job.prototype.log = function () {\n    var base, cb, k, message, options, ref, ref1;\n    message = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.level == null) {\n      options.level = 'info';\n    }\n\n    if (typeof message !== 'string') {\n      throw new Error('Log message must be a string');\n    }\n\n    if (!(typeof options.level === 'string' && (ref1 = options.level, indexOf.call(Job.jobLogLevels, ref1) >= 0))) {\n      throw new Error('Log level options must be one of Job.jobLogLevels');\n    }\n\n    if (options.echo != null) {\n      if (options.echo && Job.jobLogLevels.indexOf(options.level) >= Job.jobLogLevels.indexOf(options.echo)) {\n        this._echo(\"LOG: \" + options.level + \", \" + this._doc._id + \" \" + this._doc.runId + \": \" + message, options.level);\n      }\n\n      delete options.echo;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobLog\", [this._doc._id, this._doc.runId, message, options], cb);\n    } else {\n      if ((base = this._doc).log == null) {\n        base.log = [];\n      }\n\n      this._doc.log.push({\n        time: new Date(),\n        runId: null,\n        level: options.level,\n        message: message\n      });\n\n      if (cb != null && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n\n      return this;\n    }\n  };\n\n  Job.prototype.progress = function () {\n    var cb, completed, k, options, progress, ref, total;\n    completed = arguments[0], total = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n\n    if (completed == null) {\n      completed = 0;\n    }\n\n    if (total == null) {\n      total = 1;\n    }\n\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (typeof completed === 'number' && typeof total === 'number' && completed >= 0 && total > 0 && total >= completed) {\n      progress = {\n        completed: completed,\n        total: total,\n        percent: 100 * completed / total\n      };\n\n      if (options.echo) {\n        delete options.echo;\n\n        this._echo(\"PROGRESS: \" + this._doc._id + \" \" + this._doc.runId + \": \" + progress.completed + \" out of \" + progress.total + \" (\" + progress.percent + \"%)\");\n      }\n\n      if (this._doc._id != null && this._doc.runId != null) {\n        return methodCall(this._root, \"jobProgress\", [this._doc._id, this._doc.runId, completed, total, options], cb, function (_this) {\n          return function (res) {\n            if (res) {\n              _this._doc.progress = progress;\n            }\n\n            return res;\n          };\n        }(this));\n      } else if (this._doc._id == null) {\n        this._doc.progress = progress;\n\n        if (cb != null && typeof cb === 'function') {\n          _setImmediate(cb, null, true);\n        }\n\n        return this;\n      }\n    } else {\n      throw new Error(\"job.progress: something is wrong with progress params: \" + this.id + \", \" + completed + \" out of \" + total);\n    }\n\n    return null;\n  };\n\n  Job.prototype.save = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(this._root, \"jobSave\", [this._doc, options], cb, function (_this) {\n      return function (id) {\n        if (id) {\n          _this._doc._id = id;\n        }\n\n        return id;\n      };\n    }(this));\n  };\n\n  Job.prototype.refresh = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"getJob\", [this._doc._id, options], cb, function (_this) {\n        return function (doc) {\n          if (doc != null) {\n            _this._doc = doc;\n            return _this;\n          } else {\n            return false;\n          }\n        };\n      }(this));\n    } else {\n      throw new Error(\"Can't call .refresh() on an unsaved job\");\n    }\n  };\n\n  Job.prototype.done = function () {\n    var cb, k, options, ref, result;\n    result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n\n    if (result == null) {\n      result = {};\n    }\n\n    if (typeof result === 'function') {\n      cb = result;\n      result = {};\n    }\n\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (!(result != null && (typeof result === \"undefined\" ? \"undefined\" : _typeof(result)) === 'object')) {\n      result = {\n        value: result\n      };\n    }\n\n    if (this._doc._id != null && this._doc.runId != null) {\n      return methodCall(this._root, \"jobDone\", [this._doc._id, this._doc.runId, result, options], cb);\n    } else {\n      throw new Error(\"Can't call .done() on an unsaved or non-running job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.fail = function () {\n    var cb, k, options, ref, result;\n    result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n\n    if (result == null) {\n      result = \"No error information provided\";\n    }\n\n    if (typeof result === 'function') {\n      cb = result;\n      result = \"No error information provided\";\n    }\n\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (!(result != null && (typeof result === \"undefined\" ? \"undefined\" : _typeof(result)) === 'object')) {\n      result = {\n        value: result\n      };\n    }\n\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n\n    if (this._doc._id != null && this._doc.runId != null) {\n      return methodCall(this._root, \"jobFail\", [this._doc._id, this._doc.runId, result, options], cb);\n    } else {\n      throw new Error(\"Can't call .fail() on an unsaved or non-running job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.pause = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobPause\", [this._doc._id, options], cb);\n    } else {\n      this._doc.status = 'paused';\n\n      if (cb != null && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n\n      return this;\n    }\n\n    return null;\n  };\n\n  Job.prototype.resume = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobResume\", [this._doc._id, options], cb);\n    } else {\n      this._doc.status = 'waiting';\n\n      if (cb != null && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n\n      return this;\n    }\n\n    return null;\n  };\n\n  Job.prototype.ready = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.force == null) {\n      options.force = false;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobReady\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .ready() on an unsaved job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.cancel = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobCancel\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .cancel() on an unsaved job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.restart = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRestart\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .restart() on an unsaved job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.rerun = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (options.repeats == null) {\n      options.repeats = 0;\n    }\n\n    if (options.wait == null) {\n      options.wait = this._doc.repeatWait;\n    }\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRerun\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .rerun() on an unsaved job\");\n    }\n\n    return null;\n  };\n\n  Job.prototype.remove = function () {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRemove\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .remove() on an unsaved job\");\n    }\n\n    return null;\n  };\n\n  Object.defineProperties(Job.prototype, {\n    doc: {\n      get: function () {\n        return this._doc;\n      },\n      set: function () {\n        return console.warn(\"Job.doc cannot be directly assigned.\");\n      }\n    },\n    type: {\n      get: function () {\n        return this._doc.type;\n      },\n      set: function () {\n        return console.warn(\"Job.type cannot be directly assigned.\");\n      }\n    },\n    data: {\n      get: function () {\n        return this._doc.data;\n      },\n      set: function () {\n        return console.warn(\"Job.data cannot be directly assigned.\");\n      }\n    }\n  });\n  return Job;\n}();\n\nif ((typeof module !== \"undefined\" && module !== null ? module.exports : void 0) != null) {\n  module.exports = Job;\n}","sourceMap":{"version":3,"sources":["/packages/vsivsi_job-collection/job/src/job_class.coffee","/job/src/job_class.coffee"],"names":["JobQueue","_clearInterval","_setImmediate","_setInterval","concatReduce","isBoolean","isFunction","isInteger","isNonEmptyString","isNonEmptyStringOrArrayOfNonEmptyStrings","methodCall","optionsHelp","reduceCallbacks","splitLongArray","slice","indexOf","item","i","l","length","root","method","params","cb","after","apply","name","ref","ref1","ref2","ref3","ret","Job","_ddp_apply","Error","_this","err","res","options","Array","arr","max","k","results","Math","ceil","push","num","reduce","init","cbCount","cbErr","cbRetVal","a","b","concat","floor","f","s","sa","len","args","func","arguments","call","Meteor","setTimeout","setImmediate","timeOut","setInterval","id","clearInterval","ref4","root1","type1","worker","type","ctor","prototype","child","result","Object","errorCallback","e","console","error","pollInterval","forever","concurrency","payload","prefetch","workTimeout","callbackStrict","_workers","_tasks","_taskNumber","_stoppingGetWork","_stoppingTasks","_interval","_getWorkOutstanding","paused","resume","_getWork","numJobsToGet","running","maxJobs","getWork","jobs","j","_process","bind","_only_once","fn","called","job","next","splice","shift","_taskId","_stopGetWork","callback","_waitForTasks","_failJobs","tasks","count","fail","_hard","r","_stop","_soft","keys","idle","full","pause","w","trigger","shutdown","level","quiet","warn","foreverDate","Date","jobPriorities","low","normal","medium","high","critical","jobRetryBackoffMethods","jobStatuses","jobLogLevels","jobStatusCancellable","jobStatusPausable","jobStatusRemovable","jobStatusRestartable","ddpMethods","ddpPermissionLevels","ddpMethodPermissions","_setDDPApply","collectionName","setDDP","ddp","collectionNames","Fiber","collName","close","subscribe","observe","fib","current","throwInto","run","doc","processJobs","makeJob","depFlag","getJob","getLog","getJobs","chunkOfIds","chunksOfIds","ids","myCb","retVal","d","len1","m","data","pauseJobs","resumeJobs","readyJobs","force","cancelJobs","antecedents","restartJobs","retries","dependents","removeJobs","startJobs","stopJobs","timeout","startJobServer","shutdownJobServer","rootVal","time","_root","_doc","runId","status","updated","created","priority","retry","repeat","progress","depends","log","_echo","message","info","_id","resolved","base","until","wait","backoff","repeatRetries","retryWait","retried","retryBackoff","retryUntil","repeats","schedule","schedules","exceptions","repeatWait","repeated","repeatUntil","delay","valueOf","echo","completed","total","percent","save","refresh","done","value","fatal","ready","cancel","restart","rerun","remove","defineProperties","get","set","module","exports"],"mappings":"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","file":"packages/vsivsi:job-collection/job/src/job_class.coffee.map","sourcesContent":["############################################################################\n#     Copyright (C) 2014-2017 by Vaughn Iverson\n#     meteor-job-class is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\n# Exports Job object\n\nmethodCall = (root, method, params, cb, after = ((ret) -> ret)) ->\n  apply = Job._ddp_apply?[root.root ? root] ? Job._ddp_apply\n  unless typeof apply is 'function'\n     throw new Error \"Job remote method call error, no valid invocation method found.\"\n  name = \"#{root.root ? root}_#{method}\"\n  if cb and typeof cb is 'function'\n    apply name, params, (err, res) =>\n      return cb err if err\n      cb null, after(res)\n  else\n    return after(apply name, params)\n\noptionsHelp = (options, cb) ->\n  # If cb isn't a function, it's assumed to be options...\n  if cb? and typeof cb isnt 'function'\n    options = cb\n    cb = undefined\n  else\n    unless (typeof options is 'object' and\n            options instanceof Array and\n            options.length < 2)\n      throw new Error 'options... in optionsHelp must be an Array with zero or one elements'\n    options = options?[0] ? {}\n  unless typeof options is 'object'\n    throw new Error 'in optionsHelp options not an object or bad callback'\n  return [options, cb]\n\nsplitLongArray = (arr, max) ->\n  throw new Error 'splitLongArray: bad params' unless arr instanceof Array and max > 0\n  arr[(i*max)...((i+1)*max)] for i in [0...Math.ceil(arr.length/max)]\n\n# This function soaks up num callbacks, by default returning the disjunction of Boolean results\n# or returning on first error.... Reduce function causes different reduce behavior, such as concatenation\nreduceCallbacks = (cb, num, reduce = ((a , b) -> (a or b)), init = false) ->\n  return undefined unless cb?\n  unless typeof cb is 'function' and num > 0 and typeof reduce is 'function'\n    throw new Error 'Bad params given to reduceCallbacks'\n  cbRetVal = init\n  cbCount = 0\n  cbErr = null\n  return (err, res) ->\n    unless cbErr\n      if err\n        cbErr = err\n        cb err\n      else\n        cbCount++\n        cbRetVal = reduce cbRetVal, res\n        if cbCount is num\n          cb null, cbRetVal\n        else if cbCount > num\n          throw new Error \"reduceCallbacks callback invoked more than requested #{num} times\"\n\nconcatReduce = (a, b) ->\n  a = [a] unless a instanceof Array\n  a.concat b\n\nisInteger = (i) -> typeof i is 'number' and Math.floor(i) is i\n\nisBoolean = (b) -> typeof b is 'boolean'\n\nisFunction = (f) -> typeof f is 'function'\n\nisNonEmptyString = (s) -> typeof s is 'string' and s.length > 0\n\nisNonEmptyStringOrArrayOfNonEmptyStrings = (sa) ->\n   isNonEmptyString(sa) or\n      sa instanceof Array and\n      sa.length isnt 0 and\n      (s for s in sa when isNonEmptyString(s)).length is sa.length\n\n# This smooths over the various different implementations...\n_setImmediate = (func, args...) ->\n  if Meteor?.setTimeout?\n    return Meteor.setTimeout func, 0, args...\n  else if setImmediate?\n    return setImmediate func, args...\n  else\n    # Browser fallback\n    return setTimeout func, 0, args...\n\n_setInterval = (func, timeOut, args...) ->\n  if Meteor?.setInterval?\n    return Meteor.setInterval func, timeOut, args...\n  else\n    # Browser / node.js fallback\n    return setInterval func, timeOut, args...\n\n_clearInterval = (id) ->\n  if Meteor?.clearInterval?\n    return Meteor.clearInterval id\n  else\n    # Browser / node.js fallback\n    return clearInterval id\n\n###################################################################\n\nclass JobQueue\n\n  constructor: (@root, @type, options..., @worker) ->\n    unless @ instanceof JobQueue\n      return new JobQueue @root, @type, options..., @worker\n    [options, @worker] = optionsHelp options, @worker\n\n    unless isNonEmptyString(@root)\n      throw new Error(\"JobQueue: Invalid root, must be nonempty string\")\n\n    unless isNonEmptyStringOrArrayOfNonEmptyStrings(@type)\n      throw new Error(\"JobQueue: Invalid type, must be nonempty string or array of nonempty strings\")\n\n    unless isFunction(@worker)\n      throw new Error(\"JobQueue: Invalid worker, must be a function\")\n\n    @errorCallback = options.errorCallback ? (e) ->\n      console.error \"JobQueue: \", e\n    unless isFunction(@errorCallback)\n      throw new Error(\"JobQueue: Invalid errorCallback, must be a function\")\n\n    @pollInterval =\n      if options.pollInterval? and not options.pollInterval\n        Job.forever\n      else if not (options.pollInterval? and isInteger(options.pollInterval))\n        5000  # ms\n      else\n        options.pollInterval\n    unless isInteger(@pollInterval) and @pollInterval >= 0\n      throw new Error \"JobQueue: Invalid pollInterval, must be a positive integer\"\n\n    @concurrency = options.concurrency ? 1\n    unless isInteger(@concurrency) and @concurrency >= 0\n      throw new Error \"JobQueue: Invalid concurrency, must be a positive integer\"\n\n    @payload = options.payload ? 1\n    unless isInteger(@payload) and @payload >= 0\n      throw new Error \"JobQueue: Invalid payload, must be a positive integer\"\n\n    @prefetch = options.prefetch ? 0\n    unless isInteger(@prefetch) and @prefetch >= 0\n      throw new Error \"JobQueue: Invalid prefetch, must be a positive integer\"\n\n    @workTimeout = options.workTimeout  # No default\n    if @workTimeout? and not (isInteger(@workTimeout) and @workTimeout >= 0)\n      throw new Error \"JobQueue: Invalid workTimeout, must be a positive integer\"\n\n    @callbackStrict = options.callbackStrict\n    if @callbackStrict? and not isBoolean(@callbackStrict)\n      throw new Error \"JobQueue: Invalid callbackStrict, must be a boolean\"\n\n    @_workers = {}\n    @_tasks = []\n    @_taskNumber = 0\n    @_stoppingGetWork = undefined\n    @_stoppingTasks = undefined\n    @_interval = null\n    @_getWorkOutstanding = false\n    @paused = true\n    @resume()\n\n  _getWork: () ->\n    # Don't reenter, or run when paused or stopping\n    unless @_getWorkOutstanding or @paused\n      numJobsToGet = @prefetch + @payload*(@concurrency - @running()) - @length()\n      if numJobsToGet > 0\n        @_getWorkOutstanding = true\n        options = { maxJobs: numJobsToGet }\n        options.workTimeout = @workTimeout if @workTimeout?\n        Job.getWork @root, @type, options, (err, jobs) =>\n          @_getWorkOutstanding = false\n          if err\n            @errorCallback new Error \"Received error from getWork(): #{err}\"\n          else if jobs? and jobs instanceof Array\n            if jobs.length > numJobsToGet\n              @errorCallback new Error \"getWork() returned jobs (#{jobs.length}) in excess of maxJobs (#{numJobsToGet})\"\n            for j in jobs\n              @_tasks.push j\n              _setImmediate @_process.bind(@) unless @_stoppingGetWork?\n            @_stoppingGetWork() if @_stoppingGetWork?\n          else\n            @errorCallback new Error \"Nonarray response from server from getWork()\"\n\n  _only_once: (fn) ->\n    called = false\n    return () =>\n      if called\n        @errorCallback new Error \"Worker callback called multiple times\"\n        if @callbackStrict\n          throw new Error \"JobQueue: worker callback was invoked multiple times\"\n      called = true\n      fn.apply @, arguments\n\n  _process: () ->\n    if not @paused and @running() < @concurrency and @length()\n      if @payload > 1\n        job = @_tasks.splice 0, @payload\n      else\n        job = @_tasks.shift()\n      job._taskId = \"Task_#{@_taskNumber++}\"\n      @_workers[job._taskId] = job\n      next = () =>\n        delete @_workers[job._taskId]\n        if @_stoppingTasks? and @running() is 0 and @length() is 0\n          @_stoppingTasks()\n        else\n          _setImmediate @_process.bind(@)\n          _setImmediate @_getWork.bind(@)\n      cb = @_only_once next\n      @worker job, cb\n\n  _stopGetWork: (callback) ->\n    _clearInterval @_interval\n    @_interval = null\n    if @_getWorkOutstanding\n      @_stoppingGetWork = callback\n    else\n      _setImmediate callback  # No Zalgo, thanks\n\n  _waitForTasks: (callback) ->\n    unless @running() is 0\n      @_stoppingTasks = callback\n    else\n      _setImmediate callback  # No Zalgo, thanks\n\n  _failJobs: (tasks, callback) ->\n    _setImmediate callback if tasks.length is 0  # No Zalgo, thanks\n    count = 0\n    for job in tasks\n      job.fail \"Worker shutdown\", (err, res) =>\n        count++\n        if count is tasks.length\n          callback()\n\n  _hard: (callback) ->\n    @paused = true\n    @_stopGetWork () =>\n      tasks = @_tasks\n      @_tasks = []\n      for i, r of @_workers\n        tasks = tasks.concat r\n      @_failJobs tasks, callback\n\n  _stop: (callback) ->\n    @paused = true\n    @_stopGetWork () =>\n      tasks = @_tasks\n      @_tasks = []\n      @_waitForTasks () =>\n        @_failJobs tasks, callback\n\n  _soft: (callback) ->\n    @_stopGetWork () =>\n      @_waitForTasks callback\n\n  length: () -> @_tasks.length\n\n  running: () -> Object.keys(@_workers).length\n\n  idle: () -> @length() + @running() is 0\n\n  full: () -> @running() is @concurrency\n\n  pause: () ->\n    return if @paused\n    unless @pollInterval >= Job.forever\n      _clearInterval @_interval\n      @_interval = null\n    @paused = true\n    @\n\n  resume: () ->\n    return unless @paused\n    @paused = false\n    _setImmediate @_getWork.bind(@)\n    unless @pollInterval >= Job.forever\n      @_interval = _setInterval @_getWork.bind(@), @pollInterval\n    for w in [1..@concurrency]\n      _setImmediate @_process.bind(@)\n    @\n\n  trigger: () ->\n    return if @paused\n    _setImmediate @_getWork.bind(@)\n    @\n\n  shutdown: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.level ?= 'normal'\n    options.quiet ?= false\n    unless cb?\n      console.warn \"using default shutdown callback!\" unless options.quiet\n      cb = () =>\n        console.warn \"Shutdown complete\"\n    switch options.level\n      when 'hard'\n        console.warn \"Shutting down hard\" unless options.quiet\n        @_hard cb\n      when 'soft'\n        console.warn \"Shutting down soft\" unless options.quiet\n        @_soft cb\n      else\n        console.warn \"Shutting down normally\" unless options.quiet\n        @_stop cb\n\n###################################################################\n\nclass Job\n\n  # This is the JS max int value = 2^53\n  @forever = 9007199254740992\n\n  # This is the maximum date value in JS\n  @foreverDate = new Date 8640000000000000\n\n  @jobPriorities:\n    low: 10\n    normal: 0\n    medium: -5\n    high: -10\n    critical: -15\n\n  @jobRetryBackoffMethods: [ 'constant', 'exponential' ]\n\n  @jobStatuses: [ 'waiting', 'paused', 'ready', 'running'\n                  'failed', 'cancelled', 'completed' ]\n\n  @jobLogLevels: [ 'info', 'success', 'warning', 'danger' ]\n\n  @jobStatusCancellable: [ 'running', 'ready', 'waiting', 'paused' ]\n  @jobStatusPausable: [ 'ready', 'waiting' ]\n  @jobStatusRemovable:   [ 'cancelled', 'completed', 'failed' ]\n  @jobStatusRestartable: [ 'cancelled', 'failed' ]\n\n  @ddpMethods = [ 'startJobs', 'stopJobs',  # Deprecated!\n                  'startJobServer', 'shutdownJobServer',\n                  'jobRemove', 'jobPause', 'jobResume', 'jobReady'\n                  'jobCancel', 'jobRestart', 'jobSave', 'jobRerun', 'getWork'\n                  'getJob', 'jobLog', 'jobProgress', 'jobDone', 'jobFail' ]\n\n  @ddpPermissionLevels = [ 'admin', 'manager', 'creator', 'worker' ]\n\n  # These are the four levels of the allow/deny permission heirarchy\n  @ddpMethodPermissions =\n    'startJobs': ['startJobs', 'admin']  # Deprecated!\n    'stopJobs': ['stopJobs', 'admin']    # Deprecated!\n    'startJobServer': ['startJobServer', 'admin']\n    'shutdownJobServer': ['shutdownJobServer', 'admin']\n    'jobRemove': ['jobRemove', 'admin', 'manager']\n    'jobPause': ['jobPause', 'admin', 'manager']\n    'jobResume': ['jobResume', 'admin', 'manager']\n    'jobCancel': ['jobCancel', 'admin', 'manager']\n    'jobReady': ['jobReady', 'admin', 'manager']\n    'jobRestart': ['jobRestart', 'admin', 'manager']\n    'jobSave': ['jobSave', 'admin', 'creator']\n    'jobRerun': ['jobRerun', 'admin', 'creator']\n    'getWork': ['getWork', 'admin', 'worker']\n    'getJob': ['getJob', 'admin', 'worker']\n    'jobLog': [ 'jobLog', 'admin', 'worker']\n    'jobProgress': ['jobProgress', 'admin', 'worker']\n    'jobDone': ['jobDone', 'admin', 'worker']\n    'jobFail': ['jobFail', 'admin', 'worker']\n\n  # Automatically work within Meteor, otherwise see @setDDP below\n  @_ddp_apply: undefined\n\n  # Class methods\n\n  @_setDDPApply: (apply, collectionName) ->\n    if typeof apply is 'function'\n      if typeof collectionName is 'string'\n         @_ddp_apply ?= {}\n         if typeof @_ddp_apply is 'function'\n            throw new Error \"Job.setDDP must specify a collection name each time if called more than once.\"\n         @_ddp_apply[collectionName] = apply\n      else unless @_ddp_apply\n         @_ddp_apply = apply\n      else\n         throw new Error \"Job.setDDP must specify a collection name each time if called more than once.\"\n    else\n      throw new Error \"Bad function in Job.setDDPApply()\"\n\n  # This needs to be called when not running in Meteor to use the local DDP connection.\n  @setDDP: (ddp = null, collectionNames = null, Fiber = null) ->\n    unless (typeof collectionNames is 'string') or (collectionNames instanceof Array)\n      # Handle optional collection string with Fiber present\n      Fiber = collectionNames\n      collectionNames = [ undefined ]\n    else if typeof collectionNames is 'string'\n      # If string, convert to array of strings\n      collectionNames = [ collectionNames ]\n    for collName in collectionNames\n      unless ddp? and ddp.close? and ddp.subscribe?\n        # Not the DDP npm package\n        if ddp is null and Meteor?.apply?\n          # Meteor local server/client\n          @_setDDPApply Meteor.apply, collName\n        else\n          # No other possibilities...\n          throw new Error \"Bad ddp object in Job.setDDP()\"\n      else unless ddp.observe?  # This is a Meteor DDP connection object\n        @_setDDPApply ddp.apply.bind(ddp), collName\n      else # This is the npm DDP package\n        unless Fiber?\n          @_setDDPApply ddp.call.bind(ddp), collName\n        else\n          # If Fibers in use under pure node.js,\n          # make sure to yield and throw errors when no callback\n          @_setDDPApply(((name, params, cb) ->\n            fib = Fiber.current\n            ddp.call name, params, (err, res) ->\n              if cb? and typeof cb is 'function'\n                cb err, res\n              else\n                if err\n                  fib.throwInto err\n                else\n                  fib.run res\n            if cb? and typeof cb is 'function'\n              return\n            else\n              return Fiber.yield()\n          ), collName)\n\n  # Creates a job object by reserving the next available job of\n  # the specified 'type' from the server queue root\n  # returns null if no such job exists\n  @getWork: (root, type, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    type = [type] if typeof type is 'string'\n    if options.workTimeout?\n      unless isInteger(options.workTimeout) and options.workTimeout > 0\n        throw new Error 'getWork: workTimeout must be a positive integer'\n    methodCall root, \"getWork\", [type, options], cb, (res) =>\n      jobs = (new Job(root, doc) for doc in res) or []\n      if options.maxJobs?\n        return jobs\n      else\n        return jobs[0]\n\n  # This is defined above\n  @processJobs: JobQueue\n\n  # Makes a job object from a job document\n  # This method is deprecated and will be removed\n  @makeJob: do () ->\n    depFlag = false\n    (root, doc) ->\n      unless depFlag\n        depFlag = true\n        console.warn \"Job.makeJob(root, jobDoc) has been deprecated and will be removed in a future release, use 'new Job(root, jobDoc)' instead.\"\n      new Job root, doc\n\n  # Creates a job object by id from the server queue root\n  # returns null if no such job exists\n  @getJob: (root, id, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.getLog ?= false\n    methodCall root, \"getJob\", [id, options], cb, (doc) =>\n      if doc\n        new Job root, doc\n      else\n        undefined\n\n  # Like the above, but takes an array of ids, returns array of jobs\n  @getJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.getLog ?= false\n    retVal = []\n    chunksOfIds = splitLongArray ids, 32\n    myCb = reduceCallbacks(cb, chunksOfIds.length, concatReduce, [])\n    for chunkOfIds in chunksOfIds\n      retVal = retVal.concat(methodCall root, \"getJob\", [chunkOfIds, options], myCb, (doc) =>\n        if doc\n          (new Job(root, d.type, d.data, d) for d in doc)\n        else\n          null)\n    return retVal\n\n  # Pause this job, only Ready and Waiting jobs can be paused\n  # Calling this toggles the paused state. Unpaused jobs go to waiting\n  @pauseJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobPause\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Resume this job, only Paused jobs can be resumed\n  # Calling this toggles the paused state. Unpaused jobs go to waiting\n  @resumeJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobResume\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Move waiting jobs to the ready state, jobs with dependencies will not\n  # be made ready unless force is used.\n  @readyJobs: (root, ids = [], options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.force ?= false\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    chunksOfIds = [[]] unless chunksOfIds.length > 0\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobReady\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Cancel this job if it is running or able to run (waiting, ready)\n  @cancelJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.antecedents ?= true\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobCancel\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Restart a failed or cancelled job\n  @restartJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.retries ?= 1\n    options.dependents ?= true\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobRestart\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Remove a job that is not able to run (completed, cancelled, failed) from the queue\n  @removeJobs: (root, ids, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    retVal = false\n    chunksOfIds = splitLongArray ids, 256\n    myCb = reduceCallbacks(cb, chunksOfIds.length)\n    for chunkOfIds in chunksOfIds\n      retVal = methodCall(root, \"jobRemove\", [chunkOfIds, options], myCb) || retVal\n    return retVal\n\n  # Start the job queue\n  # Deprecated!\n  @startJobs: (root, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    methodCall root, \"startJobs\", [options], cb\n\n  # Stop the job queue, stop all running jobs\n  # Deprecated!\n  @stopJobs: (root, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.timeout ?= 60*1000\n    methodCall root, \"stopJobs\", [options], cb\n\n  # Start the job queue\n  @startJobServer: (root, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    methodCall root, \"startJobServer\", [options], cb\n\n  # Shutdown the job queue, stop all running jobs\n  @shutdownJobServer: (root, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.timeout ?= 60*1000\n    methodCall root, \"shutdownJobServer\", [options], cb\n\n  # Job class instance constructor. When \"new Job(...)\" is run\n  constructor: (rootVal, type, data) ->\n    unless @ instanceof Job\n      return new Job rootVal, type, data\n\n    # Set the root value\n    @root = rootVal\n    # Keep a copy of the original root value, whatever type that is\n    @_root = rootVal\n\n    # Handle root as object with obj.root attribute\n    if @root?.root? and typeof @root.root is 'string'\n      @root = @_root.root\n\n    # Handle (root, doc) signature\n    if not data? and type?.data? and type?.type?\n      if type instanceof Job\n        return type\n\n      doc = type\n      data = doc.data\n      type = doc.type\n    else\n      doc = {}\n\n    unless typeof doc is 'object' and\n           typeof data is 'object' and\n           typeof type is 'string' and\n           typeof @root is 'string'\n      throw new Error \"new Job: bad parameter(s), #{@root} (#{typeof @root}), #{type} (#{typeof type}), #{data} (#{typeof data}), #{doc} (#{typeof doc})\"\n\n    else if doc.type? and doc.data? # This case is used to create local Job objects from DDP calls\n      @_doc = doc\n\n    else  # This is the normal \"create a new object\" case\n      time = new Date()\n      @_doc =\n        runId: null\n        type : type\n        data: data\n        status: 'waiting'\n        updated: time\n        created: time\n      @priority().retry().repeat().after().progress().depends().log(\"Constructed\")\n\n    return @\n\n  # Override point for methods that have an echo option\n  _echo: (message, level = null) ->\n    switch level\n      when 'danger' then console.error message\n      when 'warning' then console.warn message\n      when 'success' then console.log message\n      else console.info message\n    return\n\n  # Adds a run dependancy on one or more existing jobs to this job\n  # Calling with a falsy value resets the dependencies to []\n  depends: (jobs) ->\n    if jobs\n      if jobs instanceof Job\n        jobs = [ jobs ]\n      if jobs instanceof Array\n        depends = @_doc.depends\n        for j in jobs\n          unless j instanceof Job and j._doc._id?\n            throw new Error 'Each provided object must be a saved Job instance (with an _id)'\n          depends.push j._doc._id\n      else\n        throw new Error 'Bad input parameter: depends() accepts a falsy value, or Job or array of Jobs'\n    else\n      depends = []\n    @_doc.depends = depends\n    @_doc.resolved = []  # This is where prior depends go as they are satisfied\n    return @\n\n  # Set the run priority of this job\n  priority: (level = 0) ->\n    if typeof level is 'string'\n      priority = Job.jobPriorities[level]\n      unless priority?\n        throw new Error 'Invalid string priority level provided'\n    else if isInteger(level)\n      priority = level\n    else\n      throw new Error 'priority must be an integer or valid priority level'\n      priority = 0\n    @_doc.priority = priority\n    return @\n\n  # Sets the number of attempted runs of this job and\n  # the time to wait between successive attempts\n  # Default, do not retry\n  retry: (options = 0) ->\n    if isInteger(options) and options >= 0\n      options = { retries: options }\n    if typeof options isnt 'object'\n      throw new Error 'bad parameter: accepts either an integer >= 0 or an options object'\n    if options.retries?\n      unless isInteger(options.retries) and options.retries >= 0\n        throw new Error 'bad option: retries must be an integer >= 0'\n      options.retries++\n    else\n      options.retries = Job.forever\n    if options.until?\n      unless options.until instanceof Date\n        throw new Error 'bad option: until must be a Date object'\n    else\n      options.until = Job.foreverDate\n    if options.wait?\n      unless isInteger(options.wait) and options.wait >= 0\n        throw new Error 'bad option: wait must be an integer >= 0'\n    else\n      options.wait = 5*60*1000\n    if options.backoff?\n      unless options.backoff in Job.jobRetryBackoffMethods\n        throw new Error 'bad option: invalid retry backoff method'\n    else\n      options.backoff = 'constant'\n\n    @_doc.retries = options.retries\n    @_doc.repeatRetries = options.retries\n    @_doc.retryWait = options.wait\n    @_doc.retried ?= 0\n    @_doc.retryBackoff = options.backoff\n    @_doc.retryUntil = options.until\n    return @\n\n  # Sets the number of times to repeatedly run this job\n  # and the time to wait between successive runs\n  # Default: repeat every 5 minutes, forever...\n  repeat: (options = 0) ->\n    if isInteger(options) and options >= 0\n      options = { repeats: options }\n    if typeof options isnt 'object'\n      throw new Error 'bad parameter: accepts either an integer >= 0 or an options object'\n    if options.wait? and options.schedule?\n      throw new Error 'bad options: wait and schedule options are mutually exclusive'\n    if options.repeats?\n      unless isInteger(options.repeats) and options.repeats >= 0\n        throw new Error 'bad option: repeats must be an integer >= 0'\n    else\n      options.repeats = Job.forever\n    if options.until?\n      unless options.until instanceof Date\n        throw new Error 'bad option: until must be a Date object'\n    else\n      options.until = Job.foreverDate\n    if options.wait?\n      unless isInteger(options.wait) and options.wait >= 0\n        throw new Error 'bad option: wait must be an integer >= 0'\n    else\n      options.wait = 5*60*1000\n    if options.schedule?\n      unless typeof options.schedule is 'object'\n        throw new Error 'bad option, schedule option must be an object'\n      unless options.schedule?.schedules? and options.schedule.schedules instanceof Array\n        throw new Error 'bad option, schedule object requires a schedules attribute of type Array.'\n      if options.schedule.exceptions? and not (options.schedule.exceptions instanceof Array)\n        throw new Error 'bad option, schedule object exceptions attribute must be an Array'\n      options.wait =\n        schedules: options.schedule.schedules\n        exceptions: options.schedule.exceptions\n\n    @_doc.repeats = options.repeats\n    @_doc.repeatWait = options.wait\n    @_doc.repeated ?= 0\n    @_doc.repeatUntil = options.until\n    return @\n\n  # Sets the delay before this job can run after it is saved\n  delay: (wait = 0) ->\n    unless isInteger(wait) and wait >= 0\n      throw new Error 'Bad parameter, delay requires a non-negative integer.'\n    return @after new Date(new Date().valueOf() + wait)\n\n  # Sets a time after which this job can run once it is saved\n  after: (time = new Date(0)) ->\n    if typeof time is 'object' and time instanceof Date\n      after = time\n    else\n      throw new Error 'Bad parameter, after requires a valid Date object'\n    @_doc.after = after\n    return @\n\n  # Write a message to this job's log.\n  log: (message, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.level ?= 'info'\n    unless typeof message is 'string'\n      throw new Error 'Log message must be a string'\n    unless typeof options.level is 'string' and options.level in Job.jobLogLevels\n      throw new Error 'Log level options must be one of Job.jobLogLevels'\n    if options.echo?\n      if options.echo and Job.jobLogLevels.indexOf(options.level) >= Job.jobLogLevels.indexOf(options.echo)\n        @_echo \"LOG: #{options.level}, #{@_doc._id} #{@_doc.runId}: #{message}\", options.level\n      delete options.echo\n    if @_doc._id?\n      return methodCall @_root, \"jobLog\", [@_doc._id, @_doc.runId, message, options], cb\n    else  # Log can be called on an unsaved job\n      @_doc.log ?= []\n      @_doc.log.push { time: new Date(), runId: null, level: options.level, message: message }\n      if cb? and typeof cb is 'function'\n        _setImmediate cb, null, true   # DO NOT release Zalgo\n      return @  # Allow call chaining in this case\n\n  # Indicate progress made for a running job. This is important for\n  # long running jobs so the scheduler doesn't assume they are dead\n  progress: (completed = 0, total = 1, options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    if (typeof completed is 'number' and\n        typeof total is 'number' and\n        completed >= 0 and\n        total > 0 and\n        total >= completed)\n      progress =\n        completed: completed\n        total: total\n        percent: 100*completed/total\n      if options.echo\n        delete options.echo\n        @_echo \"PROGRESS: #{@_doc._id} #{@_doc.runId}: #{progress.completed} out of #{progress.total} (#{progress.percent}%)\"\n      if @_doc._id? and @_doc.runId?\n        return methodCall @_root, \"jobProgress\", [@_doc._id, @_doc.runId, completed, total, options], cb, (res) =>\n          if res\n            @_doc.progress = progress\n          res\n      else unless @_doc._id?\n        @_doc.progress = progress\n        if cb? and typeof cb is 'function'\n          _setImmediate cb, null, true   # DO NOT release Zalgo\n        return @\n    else\n      throw new Error \"job.progress: something is wrong with progress params: #{@id}, #{completed} out of #{total}\"\n    return null\n\n  # Save this job to the server job queue Collection it will also resave a modified job if the\n  # job is not running and hasn't completed.\n  save: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    return methodCall @_root, \"jobSave\", [@_doc, options], cb, (id) =>\n      if id\n        @_doc._id = id\n      id\n\n  # Refresh the local job state with the server job queue's version\n  refresh: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.getLog ?= false\n    if @_doc._id?\n      return methodCall @_root, \"getJob\", [@_doc._id, options], cb, (doc) =>\n        if doc?\n          @_doc = doc\n          @\n        else\n          false\n    else\n      throw new Error \"Can't call .refresh() on an unsaved job\"\n\n  # Indicate to the server that this run has successfully finished.\n  done: (result = {}, options..., cb) ->\n    if typeof result is 'function'\n      cb = result\n      result = {}\n    [options, cb] = optionsHelp options, cb\n    unless result? and typeof result is 'object'\n      result = { value: result }\n    if @_doc._id? and @_doc.runId?\n      return methodCall @_root, \"jobDone\", [@_doc._id, @_doc.runId, result, options], cb\n    else\n      throw new Error \"Can't call .done() on an unsaved or non-running job\"\n    return null\n\n  # Indicate to the server that this run has failed and provide an error message.\n  fail: (result = \"No error information provided\", options..., cb) ->\n    if typeof result is 'function'\n      cb = result\n      result = \"No error information provided\"\n    [options, cb] = optionsHelp options, cb\n    unless result? and typeof result is 'object'\n      result = { value: result }\n    options.fatal ?= false\n    if @_doc._id? and @_doc.runId?\n      return methodCall @_root, \"jobFail\", [@_doc._id, @_doc.runId, result, options], cb\n    else\n      throw new Error \"Can't call .fail() on an unsaved or non-running job\"\n    return null\n\n  # Pause this job, only Ready and Waiting jobs can be paused\n  pause: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    if @_doc._id?\n      return methodCall @_root, \"jobPause\", [@_doc._id, options], cb\n    else\n      @_doc.status = 'paused'\n      if cb? and typeof cb is 'function'\n        _setImmediate cb, null, true  # DO NOT release Zalgo\n      return @\n    return null\n\n  # Resume this job, only Paused jobs can be resumed\n  # Resumed jobs go to waiting\n  resume: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    if @_doc._id?\n      return methodCall @_root, \"jobResume\", [@_doc._id, options], cb\n    else\n      @_doc.status = 'waiting'\n      if cb? and typeof cb is 'function'\n        _setImmediate cb, null, true  # DO NOT release Zalgo\n      return @\n    return null\n\n  # Make a waiting job ready to run. Jobs with dependencies only when forced\n  ready: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.force ?= false\n    if @_doc._id?\n      return methodCall @_root, \"jobReady\", [@_doc._id, options], cb\n    else\n      throw new Error \"Can't call .ready() on an unsaved job\"\n    return null\n\n  # Cancel this job if it is running or able to run (waiting, ready)\n  cancel: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.antecedents ?= true\n    if @_doc._id?\n      return methodCall @_root, \"jobCancel\", [@_doc._id, options], cb\n    else\n      throw new Error \"Can't call .cancel() on an unsaved job\"\n    return null\n\n  # Restart a failed or cancelled job\n  restart: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.retries ?= 1\n    options.dependents ?= true\n    if @_doc._id?\n      return methodCall @_root, \"jobRestart\", [@_doc._id, options], cb\n    else\n      throw new Error \"Can't call .restart() on an unsaved job\"\n    return null\n\n  # Run a completed job again as a new job, essentially a manual repeat\n  rerun: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    options.repeats ?= 0\n    options.wait ?= @_doc.repeatWait\n    if @_doc._id?\n      return methodCall @_root, \"jobRerun\", [@_doc._id, options], cb\n    else\n      throw new Error \"Can't call .rerun() on an unsaved job\"\n    return null\n\n  # Remove a job that is not able to run (completed, cancelled, failed) from the queue\n  remove: (options..., cb) ->\n    [options, cb] = optionsHelp options, cb\n    if @_doc._id?\n      return methodCall @_root, \"jobRemove\", [@_doc._id, options], cb\n    else\n      throw new Error \"Can't call .remove() on an unsaved job\"\n    return null\n\n    # Define convenience getters for some document properties\n  Object.defineProperties @prototype,\n    doc:\n      get: () -> @_doc\n      set: () -> console.warn \"Job.doc cannot be directly assigned.\"\n    type:\n      get: () -> @_doc.type\n      set: () -> console.warn \"Job.type cannot be directly assigned.\"\n    data:\n      get: () -> @_doc.data\n      set: () -> console.warn \"Job.data cannot be directly assigned.\"\n\n# Export Job in a npm package\nif module?.exports?\n  module.exports = Job\n","var JobQueue, _clearInterval, _setImmediate, _setInterval, concatReduce, isBoolean, isFunction, isInteger, isNonEmptyString, isNonEmptyStringOrArrayOfNonEmptyStrings, methodCall, optionsHelp, reduceCallbacks, splitLongArray,     \n  slice = [].slice,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nmethodCall = function(root, method, params, cb, after) {\n  var apply, name, ref, ref1, ref2, ref3;\n  if (after == null) {\n    after = (function(ret) {\n      return ret;\n    });\n  }\n  apply = (ref = (ref1 = Job._ddp_apply) != null ? ref1[(ref2 = root.root) != null ? ref2 : root] : void 0) != null ? ref : Job._ddp_apply;\n  if (typeof apply !== 'function') {\n    throw new Error(\"Job remote method call error, no valid invocation method found.\");\n  }\n  name = ((ref3 = root.root) != null ? ref3 : root) + \"_\" + method;\n  if (cb && typeof cb === 'function') {\n    return apply(name, params, (function(_this) {\n      return function(err, res) {\n        if (err) {\n          return cb(err);\n        }\n        return cb(null, after(res));\n      };\n    })(this));\n  } else {\n    return after(apply(name, params));\n  }\n};\n\noptionsHelp = function(options, cb) {\n  var ref;\n  if ((cb != null) && typeof cb !== 'function') {\n    options = cb;\n    cb = void 0;\n  } else {\n    if (!(typeof options === 'object' && options instanceof Array && options.length < 2)) {\n      throw new Error('options... in optionsHelp must be an Array with zero or one elements');\n    }\n    options = (ref = options != null ? options[0] : void 0) != null ? ref : {};\n  }\n  if (typeof options !== 'object') {\n    throw new Error('in optionsHelp options not an object or bad callback');\n  }\n  return [options, cb];\n};\n\nsplitLongArray = function(arr, max) {\n  var i, k, ref, results;\n  if (!(arr instanceof Array && max > 0)) {\n    throw new Error('splitLongArray: bad params');\n  }\n  results = [];\n  for (i = k = 0, ref = Math.ceil(arr.length / max); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n    results.push(arr.slice(i * max, (i + 1) * max));\n  }\n  return results;\n};\n\nreduceCallbacks = function(cb, num, reduce, init) {\n  var cbCount, cbErr, cbRetVal;\n  if (reduce == null) {\n    reduce = (function(a, b) {\n      return a || b;\n    });\n  }\n  if (init == null) {\n    init = false;\n  }\n  if (cb == null) {\n    return void 0;\n  }\n  if (!(typeof cb === 'function' && num > 0 && typeof reduce === 'function')) {\n    throw new Error('Bad params given to reduceCallbacks');\n  }\n  cbRetVal = init;\n  cbCount = 0;\n  cbErr = null;\n  return function(err, res) {\n    if (!cbErr) {\n      if (err) {\n        cbErr = err;\n        return cb(err);\n      } else {\n        cbCount++;\n        cbRetVal = reduce(cbRetVal, res);\n        if (cbCount === num) {\n          return cb(null, cbRetVal);\n        } else if (cbCount > num) {\n          throw new Error(\"reduceCallbacks callback invoked more than requested \" + num + \" times\");\n        }\n      }\n    }\n  };\n};\n\nconcatReduce = function(a, b) {\n  if (!(a instanceof Array)) {\n    a = [a];\n  }\n  return a.concat(b);\n};\n\nisInteger = function(i) {\n  return typeof i === 'number' && Math.floor(i) === i;\n};\n\nisBoolean = function(b) {\n  return typeof b === 'boolean';\n};\n\nisFunction = function(f) {\n  return typeof f === 'function';\n};\n\nisNonEmptyString = function(s) {\n  return typeof s === 'string' && s.length > 0;\n};\n\nisNonEmptyStringOrArrayOfNonEmptyStrings = function(sa) {\n  var s;\n  return isNonEmptyString(sa) || sa instanceof Array && sa.length !== 0 && ((function() {\n    var k, len, results;\n    results = [];\n    for (k = 0, len = sa.length; k < len; k++) {\n      s = sa[k];\n      if (isNonEmptyString(s)) {\n        results.push(s);\n      }\n    }\n    return results;\n  })()).length === sa.length;\n};\n\n_setImmediate = function() {\n  var args, func;\n  func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.setTimeout : void 0) != null) {\n    return Meteor.setTimeout.apply(Meteor, [func, 0].concat(slice.call(args)));\n  } else if (typeof setImmediate !== \"undefined\" && setImmediate !== null) {\n    return setImmediate.apply(null, [func].concat(slice.call(args)));\n  } else {\n    return setTimeout.apply(null, [func, 0].concat(slice.call(args)));\n  }\n};\n\n_setInterval = function() {\n  var args, func, timeOut;\n  func = arguments[0], timeOut = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.setInterval : void 0) != null) {\n    return Meteor.setInterval.apply(Meteor, [func, timeOut].concat(slice.call(args)));\n  } else {\n    return setInterval.apply(null, [func, timeOut].concat(slice.call(args)));\n  }\n};\n\n_clearInterval = function(id) {\n  if ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.clearInterval : void 0) != null) {\n    return Meteor.clearInterval(id);\n  } else {\n    return clearInterval(id);\n  }\n};\n\nJobQueue = (function() {\n  function JobQueue() {\n    var k, options, ref, ref1, ref2, ref3, ref4, root1, type1, worker;\n    root1 = arguments[0], type1 = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), worker = arguments[k++];\n    this.root = root1;\n    this.type = type1;\n    this.worker = worker;\n    if (!(this instanceof JobQueue)) {\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(JobQueue, [this.root, this.type].concat(slice.call(options), [this.worker]), function(){});\n    }\n    ref = optionsHelp(options, this.worker), options = ref[0], this.worker = ref[1];\n    if (!isNonEmptyString(this.root)) {\n      throw new Error(\"JobQueue: Invalid root, must be nonempty string\");\n    }\n    if (!isNonEmptyStringOrArrayOfNonEmptyStrings(this.type)) {\n      throw new Error(\"JobQueue: Invalid type, must be nonempty string or array of nonempty strings\");\n    }\n    if (!isFunction(this.worker)) {\n      throw new Error(\"JobQueue: Invalid worker, must be a function\");\n    }\n    this.errorCallback = (ref1 = options.errorCallback) != null ? ref1 : function(e) {\n      return console.error(\"JobQueue: \", e);\n    };\n    if (!isFunction(this.errorCallback)) {\n      throw new Error(\"JobQueue: Invalid errorCallback, must be a function\");\n    }\n    this.pollInterval = (options.pollInterval != null) && !options.pollInterval ? Job.forever : !((options.pollInterval != null) && isInteger(options.pollInterval)) ? 5000 : options.pollInterval;\n    if (!(isInteger(this.pollInterval) && this.pollInterval >= 0)) {\n      throw new Error(\"JobQueue: Invalid pollInterval, must be a positive integer\");\n    }\n    this.concurrency = (ref2 = options.concurrency) != null ? ref2 : 1;\n    if (!(isInteger(this.concurrency) && this.concurrency >= 0)) {\n      throw new Error(\"JobQueue: Invalid concurrency, must be a positive integer\");\n    }\n    this.payload = (ref3 = options.payload) != null ? ref3 : 1;\n    if (!(isInteger(this.payload) && this.payload >= 0)) {\n      throw new Error(\"JobQueue: Invalid payload, must be a positive integer\");\n    }\n    this.prefetch = (ref4 = options.prefetch) != null ? ref4 : 0;\n    if (!(isInteger(this.prefetch) && this.prefetch >= 0)) {\n      throw new Error(\"JobQueue: Invalid prefetch, must be a positive integer\");\n    }\n    this.workTimeout = options.workTimeout;\n    if ((this.workTimeout != null) && !(isInteger(this.workTimeout) && this.workTimeout >= 0)) {\n      throw new Error(\"JobQueue: Invalid workTimeout, must be a positive integer\");\n    }\n    this.callbackStrict = options.callbackStrict;\n    if ((this.callbackStrict != null) && !isBoolean(this.callbackStrict)) {\n      throw new Error(\"JobQueue: Invalid callbackStrict, must be a boolean\");\n    }\n    this._workers = {};\n    this._tasks = [];\n    this._taskNumber = 0;\n    this._stoppingGetWork = void 0;\n    this._stoppingTasks = void 0;\n    this._interval = null;\n    this._getWorkOutstanding = false;\n    this.paused = true;\n    this.resume();\n  }\n\n  JobQueue.prototype._getWork = function() {\n    var numJobsToGet, options;\n    if (!(this._getWorkOutstanding || this.paused)) {\n      numJobsToGet = this.prefetch + this.payload * (this.concurrency - this.running()) - this.length();\n      if (numJobsToGet > 0) {\n        this._getWorkOutstanding = true;\n        options = {\n          maxJobs: numJobsToGet\n        };\n        if (this.workTimeout != null) {\n          options.workTimeout = this.workTimeout;\n        }\n        return Job.getWork(this.root, this.type, options, (function(_this) {\n          return function(err, jobs) {\n            var j, k, len;\n            _this._getWorkOutstanding = false;\n            if (err) {\n              return _this.errorCallback(new Error(\"Received error from getWork(): \" + err));\n            } else if ((jobs != null) && jobs instanceof Array) {\n              if (jobs.length > numJobsToGet) {\n                _this.errorCallback(new Error(\"getWork() returned jobs (\" + jobs.length + \") in excess of maxJobs (\" + numJobsToGet + \")\"));\n              }\n              for (k = 0, len = jobs.length; k < len; k++) {\n                j = jobs[k];\n                _this._tasks.push(j);\n                if (_this._stoppingGetWork == null) {\n                  _setImmediate(_this._process.bind(_this));\n                }\n              }\n              if (_this._stoppingGetWork != null) {\n                return _this._stoppingGetWork();\n              }\n            } else {\n              return _this.errorCallback(new Error(\"Nonarray response from server from getWork()\"));\n            }\n          };\n        })(this));\n      }\n    }\n  };\n\n  JobQueue.prototype._only_once = function(fn) {\n    var called;\n    called = false;\n    return (function(_this) {\n      return function() {\n        if (called) {\n          _this.errorCallback(new Error(\"Worker callback called multiple times\"));\n          if (_this.callbackStrict) {\n            throw new Error(\"JobQueue: worker callback was invoked multiple times\");\n          }\n        }\n        called = true;\n        return fn.apply(_this, arguments);\n      };\n    })(this);\n  };\n\n  JobQueue.prototype._process = function() {\n    var cb, job, next;\n    if (!this.paused && this.running() < this.concurrency && this.length()) {\n      if (this.payload > 1) {\n        job = this._tasks.splice(0, this.payload);\n      } else {\n        job = this._tasks.shift();\n      }\n      job._taskId = \"Task_\" + (this._taskNumber++);\n      this._workers[job._taskId] = job;\n      next = (function(_this) {\n        return function() {\n          delete _this._workers[job._taskId];\n          if ((_this._stoppingTasks != null) && _this.running() === 0 && _this.length() === 0) {\n            return _this._stoppingTasks();\n          } else {\n            _setImmediate(_this._process.bind(_this));\n            return _setImmediate(_this._getWork.bind(_this));\n          }\n        };\n      })(this);\n      cb = this._only_once(next);\n      return this.worker(job, cb);\n    }\n  };\n\n  JobQueue.prototype._stopGetWork = function(callback) {\n    _clearInterval(this._interval);\n    this._interval = null;\n    if (this._getWorkOutstanding) {\n      return this._stoppingGetWork = callback;\n    } else {\n      return _setImmediate(callback);\n    }\n  };\n\n  JobQueue.prototype._waitForTasks = function(callback) {\n    if (this.running() !== 0) {\n      return this._stoppingTasks = callback;\n    } else {\n      return _setImmediate(callback);\n    }\n  };\n\n  JobQueue.prototype._failJobs = function(tasks, callback) {\n    var count, job, k, len, results;\n    if (tasks.length === 0) {\n      _setImmediate(callback);\n    }\n    count = 0;\n    results = [];\n    for (k = 0, len = tasks.length; k < len; k++) {\n      job = tasks[k];\n      results.push(job.fail(\"Worker shutdown\", (function(_this) {\n        return function(err, res) {\n          count++;\n          if (count === tasks.length) {\n            return callback();\n          }\n        };\n      })(this)));\n    }\n    return results;\n  };\n\n  JobQueue.prototype._hard = function(callback) {\n    this.paused = true;\n    return this._stopGetWork((function(_this) {\n      return function() {\n        var i, r, ref, tasks;\n        tasks = _this._tasks;\n        _this._tasks = [];\n        ref = _this._workers;\n        for (i in ref) {\n          r = ref[i];\n          tasks = tasks.concat(r);\n        }\n        return _this._failJobs(tasks, callback);\n      };\n    })(this));\n  };\n\n  JobQueue.prototype._stop = function(callback) {\n    this.paused = true;\n    return this._stopGetWork((function(_this) {\n      return function() {\n        var tasks;\n        tasks = _this._tasks;\n        _this._tasks = [];\n        return _this._waitForTasks(function() {\n          return _this._failJobs(tasks, callback);\n        });\n      };\n    })(this));\n  };\n\n  JobQueue.prototype._soft = function(callback) {\n    return this._stopGetWork((function(_this) {\n      return function() {\n        return _this._waitForTasks(callback);\n      };\n    })(this));\n  };\n\n  JobQueue.prototype.length = function() {\n    return this._tasks.length;\n  };\n\n  JobQueue.prototype.running = function() {\n    return Object.keys(this._workers).length;\n  };\n\n  JobQueue.prototype.idle = function() {\n    return this.length() + this.running() === 0;\n  };\n\n  JobQueue.prototype.full = function() {\n    return this.running() === this.concurrency;\n  };\n\n  JobQueue.prototype.pause = function() {\n    if (this.paused) {\n      return;\n    }\n    if (!(this.pollInterval >= Job.forever)) {\n      _clearInterval(this._interval);\n      this._interval = null;\n    }\n    this.paused = true;\n    return this;\n  };\n\n  JobQueue.prototype.resume = function() {\n    var k, ref, w;\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n    _setImmediate(this._getWork.bind(this));\n    if (!(this.pollInterval >= Job.forever)) {\n      this._interval = _setInterval(this._getWork.bind(this), this.pollInterval);\n    }\n    for (w = k = 1, ref = this.concurrency; 1 <= ref ? k <= ref : k >= ref; w = 1 <= ref ? ++k : --k) {\n      _setImmediate(this._process.bind(this));\n    }\n    return this;\n  };\n\n  JobQueue.prototype.trigger = function() {\n    if (this.paused) {\n      return;\n    }\n    _setImmediate(this._getWork.bind(this));\n    return this;\n  };\n\n  JobQueue.prototype.shutdown = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.level == null) {\n      options.level = 'normal';\n    }\n    if (options.quiet == null) {\n      options.quiet = false;\n    }\n    if (cb == null) {\n      if (!options.quiet) {\n        console.warn(\"using default shutdown callback!\");\n      }\n      cb = (function(_this) {\n        return function() {\n          return console.warn(\"Shutdown complete\");\n        };\n      })(this);\n    }\n    switch (options.level) {\n      case 'hard':\n        if (!options.quiet) {\n          console.warn(\"Shutting down hard\");\n        }\n        return this._hard(cb);\n      case 'soft':\n        if (!options.quiet) {\n          console.warn(\"Shutting down soft\");\n        }\n        return this._soft(cb);\n      default:\n        if (!options.quiet) {\n          console.warn(\"Shutting down normally\");\n        }\n        return this._stop(cb);\n    }\n  };\n\n  return JobQueue;\n\n})();\n\nJob = (function() {\n  Job.forever = 9007199254740992;\n\n  Job.foreverDate = new Date(8640000000000000);\n\n  Job.jobPriorities = {\n    low: 10,\n    normal: 0,\n    medium: -5,\n    high: -10,\n    critical: -15\n  };\n\n  Job.jobRetryBackoffMethods = ['constant', 'exponential'];\n\n  Job.jobStatuses = ['waiting', 'paused', 'ready', 'running', 'failed', 'cancelled', 'completed'];\n\n  Job.jobLogLevels = ['info', 'success', 'warning', 'danger'];\n\n  Job.jobStatusCancellable = ['running', 'ready', 'waiting', 'paused'];\n\n  Job.jobStatusPausable = ['ready', 'waiting'];\n\n  Job.jobStatusRemovable = ['cancelled', 'completed', 'failed'];\n\n  Job.jobStatusRestartable = ['cancelled', 'failed'];\n\n  Job.ddpMethods = ['startJobs', 'stopJobs', 'startJobServer', 'shutdownJobServer', 'jobRemove', 'jobPause', 'jobResume', 'jobReady', 'jobCancel', 'jobRestart', 'jobSave', 'jobRerun', 'getWork', 'getJob', 'jobLog', 'jobProgress', 'jobDone', 'jobFail'];\n\n  Job.ddpPermissionLevels = ['admin', 'manager', 'creator', 'worker'];\n\n  Job.ddpMethodPermissions = {\n    'startJobs': ['startJobs', 'admin'],\n    'stopJobs': ['stopJobs', 'admin'],\n    'startJobServer': ['startJobServer', 'admin'],\n    'shutdownJobServer': ['shutdownJobServer', 'admin'],\n    'jobRemove': ['jobRemove', 'admin', 'manager'],\n    'jobPause': ['jobPause', 'admin', 'manager'],\n    'jobResume': ['jobResume', 'admin', 'manager'],\n    'jobCancel': ['jobCancel', 'admin', 'manager'],\n    'jobReady': ['jobReady', 'admin', 'manager'],\n    'jobRestart': ['jobRestart', 'admin', 'manager'],\n    'jobSave': ['jobSave', 'admin', 'creator'],\n    'jobRerun': ['jobRerun', 'admin', 'creator'],\n    'getWork': ['getWork', 'admin', 'worker'],\n    'getJob': ['getJob', 'admin', 'worker'],\n    'jobLog': ['jobLog', 'admin', 'worker'],\n    'jobProgress': ['jobProgress', 'admin', 'worker'],\n    'jobDone': ['jobDone', 'admin', 'worker'],\n    'jobFail': ['jobFail', 'admin', 'worker']\n  };\n\n  Job._ddp_apply = void 0;\n\n  Job._setDDPApply = function(apply, collectionName) {\n    if (typeof apply === 'function') {\n      if (typeof collectionName === 'string') {\n        if (this._ddp_apply == null) {\n          this._ddp_apply = {};\n        }\n        if (typeof this._ddp_apply === 'function') {\n          throw new Error(\"Job.setDDP must specify a collection name each time if called more than once.\");\n        }\n        return this._ddp_apply[collectionName] = apply;\n      } else if (!this._ddp_apply) {\n        return this._ddp_apply = apply;\n      } else {\n        throw new Error(\"Job.setDDP must specify a collection name each time if called more than once.\");\n      }\n    } else {\n      throw new Error(\"Bad function in Job.setDDPApply()\");\n    }\n  };\n\n  Job.setDDP = function(ddp, collectionNames, Fiber) {\n    var collName, k, len, results;\n    if (ddp == null) {\n      ddp = null;\n    }\n    if (collectionNames == null) {\n      collectionNames = null;\n    }\n    if (Fiber == null) {\n      Fiber = null;\n    }\n    if (!((typeof collectionNames === 'string') || (collectionNames instanceof Array))) {\n      Fiber = collectionNames;\n      collectionNames = [void 0];\n    } else if (typeof collectionNames === 'string') {\n      collectionNames = [collectionNames];\n    }\n    results = [];\n    for (k = 0, len = collectionNames.length; k < len; k++) {\n      collName = collectionNames[k];\n      if (!((ddp != null) && (ddp.close != null) && (ddp.subscribe != null))) {\n        if (ddp === null && ((typeof Meteor !== \"undefined\" && Meteor !== null ? Meteor.apply : void 0) != null)) {\n          results.push(this._setDDPApply(Meteor.apply, collName));\n        } else {\n          throw new Error(\"Bad ddp object in Job.setDDP()\");\n        }\n      } else if (ddp.observe == null) {\n        results.push(this._setDDPApply(ddp.apply.bind(ddp), collName));\n      } else {\n        if (Fiber == null) {\n          results.push(this._setDDPApply(ddp.call.bind(ddp), collName));\n        } else {\n          results.push(this._setDDPApply((function(name, params, cb) {\n            var fib;\n            fib = Fiber.current;\n            ddp.call(name, params, function(err, res) {\n              if ((cb != null) && typeof cb === 'function') {\n                return cb(err, res);\n              } else {\n                if (err) {\n                  return fib.throwInto(err);\n                } else {\n                  return fib.run(res);\n                }\n              }\n            });\n            if ((cb != null) && typeof cb === 'function') {\n\n            } else {\n              return Fiber[\"yield\"]();\n            }\n          }), collName));\n        }\n      }\n    }\n    return results;\n  };\n\n  Job.getWork = function() {\n    var cb, k, options, ref, root, type;\n    root = arguments[0], type = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (typeof type === 'string') {\n      type = [type];\n    }\n    if (options.workTimeout != null) {\n      if (!(isInteger(options.workTimeout) && options.workTimeout > 0)) {\n        throw new Error('getWork: workTimeout must be a positive integer');\n      }\n    }\n    return methodCall(root, \"getWork\", [type, options], cb, (function(_this) {\n      return function(res) {\n        var doc, jobs;\n        jobs = ((function() {\n          var l, len, results;\n          results = [];\n          for (l = 0, len = res.length; l < len; l++) {\n            doc = res[l];\n            results.push(new Job(root, doc));\n          }\n          return results;\n        })()) || [];\n        if (options.maxJobs != null) {\n          return jobs;\n        } else {\n          return jobs[0];\n        }\n      };\n    })(this));\n  };\n\n  Job.processJobs = JobQueue;\n\n  Job.makeJob = (function() {\n    var depFlag;\n    depFlag = false;\n    return function(root, doc) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Job.makeJob(root, jobDoc) has been deprecated and will be removed in a future release, use 'new Job(root, jobDoc)' instead.\");\n      }\n      return new Job(root, doc);\n    };\n  })();\n\n  Job.getJob = function() {\n    var cb, id, k, options, ref, root;\n    root = arguments[0], id = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n    return methodCall(root, \"getJob\", [id, options], cb, (function(_this) {\n      return function(doc) {\n        if (doc) {\n          return new Job(root, doc);\n        } else {\n          return void 0;\n        }\n      };\n    })(this));\n  };\n\n  Job.getJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n    retVal = [];\n    chunksOfIds = splitLongArray(ids, 32);\n    myCb = reduceCallbacks(cb, chunksOfIds.length, concatReduce, []);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = retVal.concat(methodCall(root, \"getJob\", [chunkOfIds, options], myCb, (function(_this) {\n        return function(doc) {\n          var d, len1, m, results;\n          if (doc) {\n            results = [];\n            for (m = 0, len1 = doc.length; m < len1; m++) {\n              d = doc[m];\n              results.push(new Job(root, d.type, d.data, d));\n            }\n            return results;\n          } else {\n            return null;\n          }\n        };\n      })(this)));\n    }\n    return retVal;\n  };\n\n  Job.pauseJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobPause\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.resumeJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobResume\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.readyJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    if (ids == null) {\n      ids = [];\n    }\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.force == null) {\n      options.force = false;\n    }\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    if (!(chunksOfIds.length > 0)) {\n      chunksOfIds = [[]];\n    }\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobReady\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.cancelJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobCancel\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.restartJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobRestart\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.removeJobs = function() {\n    var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;\n    root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    retVal = false;\n    chunksOfIds = splitLongArray(ids, 256);\n    myCb = reduceCallbacks(cb, chunksOfIds.length);\n    for (l = 0, len = chunksOfIds.length; l < len; l++) {\n      chunkOfIds = chunksOfIds[l];\n      retVal = methodCall(root, \"jobRemove\", [chunkOfIds, options], myCb) || retVal;\n    }\n    return retVal;\n  };\n\n  Job.startJobs = function() {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(root, \"startJobs\", [options], cb);\n  };\n\n  Job.stopJobs = function() {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n    return methodCall(root, \"stopJobs\", [options], cb);\n  };\n\n  Job.startJobServer = function() {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(root, \"startJobServer\", [options], cb);\n  };\n\n  Job.shutdownJobServer = function() {\n    var cb, k, options, ref, root;\n    root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n    return methodCall(root, \"shutdownJobServer\", [options], cb);\n  };\n\n  function Job(rootVal, type, data) {\n    var doc, ref, time;\n    if (!(this instanceof Job)) {\n      return new Job(rootVal, type, data);\n    }\n    this.root = rootVal;\n    this._root = rootVal;\n    if ((((ref = this.root) != null ? ref.root : void 0) != null) && typeof this.root.root === 'string') {\n      this.root = this._root.root;\n    }\n    if ((data == null) && ((type != null ? type.data : void 0) != null) && ((type != null ? type.type : void 0) != null)) {\n      if (type instanceof Job) {\n        return type;\n      }\n      doc = type;\n      data = doc.data;\n      type = doc.type;\n    } else {\n      doc = {};\n    }\n    if (!(typeof doc === 'object' && typeof data === 'object' && typeof type === 'string' && typeof this.root === 'string')) {\n      throw new Error(\"new Job: bad parameter(s), \" + this.root + \" (\" + (typeof this.root) + \"), \" + type + \" (\" + (typeof type) + \"), \" + data + \" (\" + (typeof data) + \"), \" + doc + \" (\" + (typeof doc) + \")\");\n    } else if ((doc.type != null) && (doc.data != null)) {\n      this._doc = doc;\n    } else {\n      time = new Date();\n      this._doc = {\n        runId: null,\n        type: type,\n        data: data,\n        status: 'waiting',\n        updated: time,\n        created: time\n      };\n      this.priority().retry().repeat().after().progress().depends().log(\"Constructed\");\n    }\n    return this;\n  }\n\n  Job.prototype._echo = function(message, level) {\n    if (level == null) {\n      level = null;\n    }\n    switch (level) {\n      case 'danger':\n        console.error(message);\n        break;\n      case 'warning':\n        console.warn(message);\n        break;\n      case 'success':\n        console.log(message);\n        break;\n      default:\n        console.info(message);\n    }\n  };\n\n  Job.prototype.depends = function(jobs) {\n    var depends, j, k, len;\n    if (jobs) {\n      if (jobs instanceof Job) {\n        jobs = [jobs];\n      }\n      if (jobs instanceof Array) {\n        depends = this._doc.depends;\n        for (k = 0, len = jobs.length; k < len; k++) {\n          j = jobs[k];\n          if (!(j instanceof Job && (j._doc._id != null))) {\n            throw new Error('Each provided object must be a saved Job instance (with an _id)');\n          }\n          depends.push(j._doc._id);\n        }\n      } else {\n        throw new Error('Bad input parameter: depends() accepts a falsy value, or Job or array of Jobs');\n      }\n    } else {\n      depends = [];\n    }\n    this._doc.depends = depends;\n    this._doc.resolved = [];\n    return this;\n  };\n\n  Job.prototype.priority = function(level) {\n    var priority;\n    if (level == null) {\n      level = 0;\n    }\n    if (typeof level === 'string') {\n      priority = Job.jobPriorities[level];\n      if (priority == null) {\n        throw new Error('Invalid string priority level provided');\n      }\n    } else if (isInteger(level)) {\n      priority = level;\n    } else {\n      throw new Error('priority must be an integer or valid priority level');\n      priority = 0;\n    }\n    this._doc.priority = priority;\n    return this;\n  };\n\n  Job.prototype.retry = function(options) {\n    var base, ref;\n    if (options == null) {\n      options = 0;\n    }\n    if (isInteger(options) && options >= 0) {\n      options = {\n        retries: options\n      };\n    }\n    if (typeof options !== 'object') {\n      throw new Error('bad parameter: accepts either an integer >= 0 or an options object');\n    }\n    if (options.retries != null) {\n      if (!(isInteger(options.retries) && options.retries >= 0)) {\n        throw new Error('bad option: retries must be an integer >= 0');\n      }\n      options.retries++;\n    } else {\n      options.retries = Job.forever;\n    }\n    if (options.until != null) {\n      if (!(options.until instanceof Date)) {\n        throw new Error('bad option: until must be a Date object');\n      }\n    } else {\n      options.until = Job.foreverDate;\n    }\n    if (options.wait != null) {\n      if (!(isInteger(options.wait) && options.wait >= 0)) {\n        throw new Error('bad option: wait must be an integer >= 0');\n      }\n    } else {\n      options.wait = 5 * 60 * 1000;\n    }\n    if (options.backoff != null) {\n      if (ref = options.backoff, indexOf.call(Job.jobRetryBackoffMethods, ref) < 0) {\n        throw new Error('bad option: invalid retry backoff method');\n      }\n    } else {\n      options.backoff = 'constant';\n    }\n    this._doc.retries = options.retries;\n    this._doc.repeatRetries = options.retries;\n    this._doc.retryWait = options.wait;\n    if ((base = this._doc).retried == null) {\n      base.retried = 0;\n    }\n    this._doc.retryBackoff = options.backoff;\n    this._doc.retryUntil = options.until;\n    return this;\n  };\n\n  Job.prototype.repeat = function(options) {\n    var base, ref;\n    if (options == null) {\n      options = 0;\n    }\n    if (isInteger(options) && options >= 0) {\n      options = {\n        repeats: options\n      };\n    }\n    if (typeof options !== 'object') {\n      throw new Error('bad parameter: accepts either an integer >= 0 or an options object');\n    }\n    if ((options.wait != null) && (options.schedule != null)) {\n      throw new Error('bad options: wait and schedule options are mutually exclusive');\n    }\n    if (options.repeats != null) {\n      if (!(isInteger(options.repeats) && options.repeats >= 0)) {\n        throw new Error('bad option: repeats must be an integer >= 0');\n      }\n    } else {\n      options.repeats = Job.forever;\n    }\n    if (options.until != null) {\n      if (!(options.until instanceof Date)) {\n        throw new Error('bad option: until must be a Date object');\n      }\n    } else {\n      options.until = Job.foreverDate;\n    }\n    if (options.wait != null) {\n      if (!(isInteger(options.wait) && options.wait >= 0)) {\n        throw new Error('bad option: wait must be an integer >= 0');\n      }\n    } else {\n      options.wait = 5 * 60 * 1000;\n    }\n    if (options.schedule != null) {\n      if (typeof options.schedule !== 'object') {\n        throw new Error('bad option, schedule option must be an object');\n      }\n      if (!((((ref = options.schedule) != null ? ref.schedules : void 0) != null) && options.schedule.schedules instanceof Array)) {\n        throw new Error('bad option, schedule object requires a schedules attribute of type Array.');\n      }\n      if ((options.schedule.exceptions != null) && !(options.schedule.exceptions instanceof Array)) {\n        throw new Error('bad option, schedule object exceptions attribute must be an Array');\n      }\n      options.wait = {\n        schedules: options.schedule.schedules,\n        exceptions: options.schedule.exceptions\n      };\n    }\n    this._doc.repeats = options.repeats;\n    this._doc.repeatWait = options.wait;\n    if ((base = this._doc).repeated == null) {\n      base.repeated = 0;\n    }\n    this._doc.repeatUntil = options.until;\n    return this;\n  };\n\n  Job.prototype.delay = function(wait) {\n    if (wait == null) {\n      wait = 0;\n    }\n    if (!(isInteger(wait) && wait >= 0)) {\n      throw new Error('Bad parameter, delay requires a non-negative integer.');\n    }\n    return this.after(new Date(new Date().valueOf() + wait));\n  };\n\n  Job.prototype.after = function(time) {\n    var after;\n    if (time == null) {\n      time = new Date(0);\n    }\n    if (typeof time === 'object' && time instanceof Date) {\n      after = time;\n    } else {\n      throw new Error('Bad parameter, after requires a valid Date object');\n    }\n    this._doc.after = after;\n    return this;\n  };\n\n  Job.prototype.log = function() {\n    var base, cb, k, message, options, ref, ref1;\n    message = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.level == null) {\n      options.level = 'info';\n    }\n    if (typeof message !== 'string') {\n      throw new Error('Log message must be a string');\n    }\n    if (!(typeof options.level === 'string' && (ref1 = options.level, indexOf.call(Job.jobLogLevels, ref1) >= 0))) {\n      throw new Error('Log level options must be one of Job.jobLogLevels');\n    }\n    if (options.echo != null) {\n      if (options.echo && Job.jobLogLevels.indexOf(options.level) >= Job.jobLogLevels.indexOf(options.echo)) {\n        this._echo(\"LOG: \" + options.level + \", \" + this._doc._id + \" \" + this._doc.runId + \": \" + message, options.level);\n      }\n      delete options.echo;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobLog\", [this._doc._id, this._doc.runId, message, options], cb);\n    } else {\n      if ((base = this._doc).log == null) {\n        base.log = [];\n      }\n      this._doc.log.push({\n        time: new Date(),\n        runId: null,\n        level: options.level,\n        message: message\n      });\n      if ((cb != null) && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n      return this;\n    }\n  };\n\n  Job.prototype.progress = function() {\n    var cb, completed, k, options, progress, ref, total;\n    completed = arguments[0], total = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];\n    if (completed == null) {\n      completed = 0;\n    }\n    if (total == null) {\n      total = 1;\n    }\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (typeof completed === 'number' && typeof total === 'number' && completed >= 0 && total > 0 && total >= completed) {\n      progress = {\n        completed: completed,\n        total: total,\n        percent: 100 * completed / total\n      };\n      if (options.echo) {\n        delete options.echo;\n        this._echo(\"PROGRESS: \" + this._doc._id + \" \" + this._doc.runId + \": \" + progress.completed + \" out of \" + progress.total + \" (\" + progress.percent + \"%)\");\n      }\n      if ((this._doc._id != null) && (this._doc.runId != null)) {\n        return methodCall(this._root, \"jobProgress\", [this._doc._id, this._doc.runId, completed, total, options], cb, (function(_this) {\n          return function(res) {\n            if (res) {\n              _this._doc.progress = progress;\n            }\n            return res;\n          };\n        })(this));\n      } else if (this._doc._id == null) {\n        this._doc.progress = progress;\n        if ((cb != null) && typeof cb === 'function') {\n          _setImmediate(cb, null, true);\n        }\n        return this;\n      }\n    } else {\n      throw new Error(\"job.progress: something is wrong with progress params: \" + this.id + \", \" + completed + \" out of \" + total);\n    }\n    return null;\n  };\n\n  Job.prototype.save = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    return methodCall(this._root, \"jobSave\", [this._doc, options], cb, (function(_this) {\n      return function(id) {\n        if (id) {\n          _this._doc._id = id;\n        }\n        return id;\n      };\n    })(this));\n  };\n\n  Job.prototype.refresh = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"getJob\", [this._doc._id, options], cb, (function(_this) {\n        return function(doc) {\n          if (doc != null) {\n            _this._doc = doc;\n            return _this;\n          } else {\n            return false;\n          }\n        };\n      })(this));\n    } else {\n      throw new Error(\"Can't call .refresh() on an unsaved job\");\n    }\n  };\n\n  Job.prototype.done = function() {\n    var cb, k, options, ref, result;\n    result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    if (result == null) {\n      result = {};\n    }\n    if (typeof result === 'function') {\n      cb = result;\n      result = {};\n    }\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (!((result != null) && typeof result === 'object')) {\n      result = {\n        value: result\n      };\n    }\n    if ((this._doc._id != null) && (this._doc.runId != null)) {\n      return methodCall(this._root, \"jobDone\", [this._doc._id, this._doc.runId, result, options], cb);\n    } else {\n      throw new Error(\"Can't call .done() on an unsaved or non-running job\");\n    }\n    return null;\n  };\n\n  Job.prototype.fail = function() {\n    var cb, k, options, ref, result;\n    result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];\n    if (result == null) {\n      result = \"No error information provided\";\n    }\n    if (typeof result === 'function') {\n      cb = result;\n      result = \"No error information provided\";\n    }\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (!((result != null) && typeof result === 'object')) {\n      result = {\n        value: result\n      };\n    }\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n    if ((this._doc._id != null) && (this._doc.runId != null)) {\n      return methodCall(this._root, \"jobFail\", [this._doc._id, this._doc.runId, result, options], cb);\n    } else {\n      throw new Error(\"Can't call .fail() on an unsaved or non-running job\");\n    }\n    return null;\n  };\n\n  Job.prototype.pause = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobPause\", [this._doc._id, options], cb);\n    } else {\n      this._doc.status = 'paused';\n      if ((cb != null) && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n      return this;\n    }\n    return null;\n  };\n\n  Job.prototype.resume = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobResume\", [this._doc._id, options], cb);\n    } else {\n      this._doc.status = 'waiting';\n      if ((cb != null) && typeof cb === 'function') {\n        _setImmediate(cb, null, true);\n      }\n      return this;\n    }\n    return null;\n  };\n\n  Job.prototype.ready = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.force == null) {\n      options.force = false;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobReady\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .ready() on an unsaved job\");\n    }\n    return null;\n  };\n\n  Job.prototype.cancel = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobCancel\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .cancel() on an unsaved job\");\n    }\n    return null;\n  };\n\n  Job.prototype.restart = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRestart\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .restart() on an unsaved job\");\n    }\n    return null;\n  };\n\n  Job.prototype.rerun = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (options.repeats == null) {\n      options.repeats = 0;\n    }\n    if (options.wait == null) {\n      options.wait = this._doc.repeatWait;\n    }\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRerun\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .rerun() on an unsaved job\");\n    }\n    return null;\n  };\n\n  Job.prototype.remove = function() {\n    var cb, k, options, ref;\n    options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];\n    ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];\n    if (this._doc._id != null) {\n      return methodCall(this._root, \"jobRemove\", [this._doc._id, options], cb);\n    } else {\n      throw new Error(\"Can't call .remove() on an unsaved job\");\n    }\n    return null;\n  };\n\n  Object.defineProperties(Job.prototype, {\n    doc: {\n      get: function() {\n        return this._doc;\n      },\n      set: function() {\n        return console.warn(\"Job.doc cannot be directly assigned.\");\n      }\n    },\n    type: {\n      get: function() {\n        return this._doc.type;\n      },\n      set: function() {\n        return console.warn(\"Job.type cannot be directly assigned.\");\n      }\n    },\n    data: {\n      get: function() {\n        return this._doc.data;\n      },\n      set: function() {\n        return console.warn(\"Job.data cannot be directly assigned.\");\n      }\n    }\n  });\n\n  return Job;\n\n})();\n\nif ((typeof module !== \"undefined\" && module !== null ? module.exports : void 0) != null) {\n  module.exports = Job;\n}\n"]}}