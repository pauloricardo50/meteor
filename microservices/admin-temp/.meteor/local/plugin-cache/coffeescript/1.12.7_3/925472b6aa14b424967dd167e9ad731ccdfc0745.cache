{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar JobCollectionBase,\n    _validId,\n    _validIntGTEOne,\n    _validIntGTEZero,\n    _validJobDoc,\n    _validLaterJSObj,\n    _validLog,\n    _validLogLevel,\n    _validNumGTEOne,\n    _validNumGTEZero,\n    _validNumGTZero,\n    _validProgress,\n    _validRetryBackoff,\n    _validStatus,\n    indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n},\n    extend = function (child, parent) {\n  for (var key in meteorBabelHelpers.sanitizeForInObject(parent)) {\n    if (hasProp.call(parent, key)) child[key] = parent[key];\n  }\n\n  function ctor() {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n},\n    hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n_validNumGTEZero = function (v) {\n  return Match.test(v, Number) && v >= 0.0;\n};\n\n_validNumGTZero = function (v) {\n  return Match.test(v, Number) && v > 0.0;\n};\n\n_validNumGTEOne = function (v) {\n  return Match.test(v, Number) && v >= 1.0;\n};\n\n_validIntGTEZero = function (v) {\n  return _validNumGTEZero(v) && Math.floor(v) === v;\n};\n\n_validIntGTEOne = function (v) {\n  return _validNumGTEOne(v) && Math.floor(v) === v;\n};\n\n_validStatus = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobStatuses, v) >= 0;\n};\n\n_validLogLevel = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobLogLevels, v) >= 0;\n};\n\n_validRetryBackoff = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobRetryBackoffMethods, v) >= 0;\n};\n\n_validId = function (v) {\n  return Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID));\n};\n\n_validLog = function () {\n  return [{\n    time: Date,\n    runId: Match.OneOf(Match.Where(_validId), null),\n    level: Match.Where(_validLogLevel),\n    message: String,\n    data: Match.Optional(Object)\n  }];\n};\n\n_validProgress = function () {\n  return {\n    completed: Match.Where(_validNumGTEZero),\n    total: Match.Where(_validNumGTEZero),\n    percent: Match.Where(_validNumGTEZero)\n  };\n};\n\n_validLaterJSObj = function () {\n  return {\n    schedules: [Object],\n    exceptions: Match.Optional([Object])\n  };\n};\n\n_validJobDoc = function () {\n  return {\n    _id: Match.Optional(Match.OneOf(Match.Where(_validId), null)),\n    runId: Match.OneOf(Match.Where(_validId), null),\n    type: String,\n    status: Match.Where(_validStatus),\n    data: Object,\n    result: Match.Optional(Object),\n    failures: Match.Optional([Object]),\n    priority: Match.Integer,\n    depends: [Match.Where(_validId)],\n    resolved: [Match.Where(_validId)],\n    after: Date,\n    updated: Date,\n    workTimeout: Match.Optional(Match.Where(_validIntGTEOne)),\n    expiresAfter: Match.Optional(Date),\n    log: Match.Optional(_validLog()),\n    progress: _validProgress(),\n    retries: Match.Where(_validIntGTEZero),\n    retried: Match.Where(_validIntGTEZero),\n    repeatRetries: Match.Optional(Match.Where(_validIntGTEZero)),\n    retryUntil: Date,\n    retryWait: Match.Where(_validIntGTEZero),\n    retryBackoff: Match.Where(_validRetryBackoff),\n    repeats: Match.Where(_validIntGTEZero),\n    repeated: Match.Where(_validIntGTEZero),\n    repeatUntil: Date,\n    repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj)),\n    created: Date\n  };\n};\n\nJobCollectionBase = function (superClass) {\n  extend(JobCollectionBase, superClass);\n\n  function JobCollectionBase(root, options) {\n    var collectionName;\n    this.root = root != null ? root : 'queue';\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (!(this instanceof JobCollectionBase)) {\n      return new JobCollectionBase(this.root, options);\n    }\n\n    if (!(this instanceof Mongo.Collection)) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.');\n    }\n\n    if (Mongo.Collection !== Mongo.Collection.prototype.constructor) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592');\n    }\n\n    this.later = later;\n\n    if (options.noCollectionSuffix == null) {\n      options.noCollectionSuffix = false;\n    }\n\n    collectionName = this.root;\n\n    if (!options.noCollectionSuffix) {\n      collectionName += '.jobs';\n    }\n\n    delete options.noCollectionSuffix;\n    Job.setDDP(options.connection, this.root);\n\n    this._createLogEntry = function (message, runId, level, time, data) {\n      var l;\n\n      if (message == null) {\n        message = '';\n      }\n\n      if (runId == null) {\n        runId = null;\n      }\n\n      if (level == null) {\n        level = 'info';\n      }\n\n      if (time == null) {\n        time = new Date();\n      }\n\n      if (data == null) {\n        data = null;\n      }\n\n      l = {\n        time: time,\n        runId: runId,\n        message: message,\n        level: level\n      };\n      return l;\n    };\n\n    this._logMessage = {\n      'readied': function () {\n        return this._createLogEntry(\"Promoted to ready\");\n      }.bind(this),\n      'forced': function (id) {\n        return this._createLogEntry(\"Dependencies force resolved\", null, 'warning');\n      }.bind(this),\n      'rerun': function (id, runId) {\n        return this._createLogEntry(\"Rerunning job\", null, 'info', new Date(), {\n          previousJob: {\n            id: id,\n            runId: runId\n          }\n        });\n      }.bind(this),\n      'running': function (runId) {\n        return this._createLogEntry(\"Job Running\", runId);\n      }.bind(this),\n      'paused': function () {\n        return this._createLogEntry(\"Job Paused\");\n      }.bind(this),\n      'resumed': function () {\n        return this._createLogEntry(\"Job Resumed\");\n      }.bind(this),\n      'cancelled': function () {\n        return this._createLogEntry(\"Job Cancelled\", null, 'warning');\n      }.bind(this),\n      'restarted': function () {\n        return this._createLogEntry(\"Job Restarted\");\n      }.bind(this),\n      'resubmitted': function () {\n        return this._createLogEntry(\"Job Resubmitted\");\n      }.bind(this),\n      'submitted': function () {\n        return this._createLogEntry(\"Job Submitted\");\n      }.bind(this),\n      'completed': function (runId) {\n        return this._createLogEntry(\"Job Completed\", runId, 'success');\n      }.bind(this),\n      'resolved': function (id, runId) {\n        return this._createLogEntry(\"Dependency resolved\", null, 'info', new Date(), {\n          dependency: {\n            id: id,\n            runId: runId\n          }\n        });\n      }.bind(this),\n      'failed': function (runId, fatal, err) {\n        var level, msg, value;\n        value = err.value;\n        msg = \"Job Failed with\" + (fatal ? ' Fatal' : '') + \" Error\" + (value != null && typeof value === 'string' ? ': ' + value : '') + \".\";\n        level = fatal ? 'danger' : 'warning';\n        return this._createLogEntry(msg, runId, level);\n      }.bind(this)\n    };\n\n    JobCollectionBase.__super__.constructor.call(this, collectionName, options);\n  }\n\n  JobCollectionBase.prototype._validNumGTEZero = _validNumGTEZero;\n  JobCollectionBase.prototype._validNumGTZero = _validNumGTZero;\n  JobCollectionBase.prototype._validNumGTEOne = _validNumGTEOne;\n  JobCollectionBase.prototype._validIntGTEZero = _validIntGTEZero;\n  JobCollectionBase.prototype._validIntGTEOne = _validIntGTEOne;\n  JobCollectionBase.prototype._validStatus = _validStatus;\n  JobCollectionBase.prototype._validLogLevel = _validLogLevel;\n  JobCollectionBase.prototype._validRetryBackoff = _validRetryBackoff;\n  JobCollectionBase.prototype._validId = _validId;\n  JobCollectionBase.prototype._validLog = _validLog;\n  JobCollectionBase.prototype._validProgress = _validProgress;\n  JobCollectionBase.prototype._validJobDoc = _validJobDoc;\n  JobCollectionBase.prototype.jobLogLevels = Job.jobLogLevels;\n  JobCollectionBase.prototype.jobPriorities = Job.jobPriorities;\n  JobCollectionBase.prototype.jobStatuses = Job.jobStatuses;\n  JobCollectionBase.prototype.jobStatusCancellable = Job.jobStatusCancellable;\n  JobCollectionBase.prototype.jobStatusPausable = Job.jobStatusPausable;\n  JobCollectionBase.prototype.jobStatusRemovable = Job.jobStatusRemovable;\n  JobCollectionBase.prototype.jobStatusRestartable = Job.jobStatusRestartable;\n  JobCollectionBase.prototype.forever = Job.forever;\n  JobCollectionBase.prototype.foreverDate = Job.foreverDate;\n  JobCollectionBase.prototype.ddpMethods = Job.ddpMethods;\n  JobCollectionBase.prototype.ddpPermissionLevels = Job.ddpPermissionLevels;\n  JobCollectionBase.prototype.ddpMethodPermissions = Job.ddpMethodPermissions;\n\n  JobCollectionBase.prototype.processJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor(),\n          result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    }(Job.processJobs, [this.root].concat(slice.call(params)), function () {});\n  };\n\n  JobCollectionBase.prototype.getJob = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJob.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getWork = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getWork.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.readyJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.readyJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.cancelJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.cancelJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.pauseJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.pauseJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.resumeJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.resumeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.restartJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.restartJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.removeJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.removeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.setDDP = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.setDDP.apply(Job, params);\n  };\n\n  JobCollectionBase.prototype.startJobServer = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.shutdownJobServer = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.shutdownJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.startJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.stopJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.stopJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.jobDocPattern = _validJobDoc();\n\n  JobCollectionBase.prototype.allow = function () {\n    throw new Error(\"Server-only function jc.allow() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.deny = function () {\n    throw new Error(\"Server-only function jc.deny() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.promote = function () {\n    throw new Error(\"Server-only function jc.promote() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.setLogStream = function () {\n    throw new Error(\"Server-only function jc.setLogStream() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.logConsole = function () {\n    throw new Error(\"Client-only function jc.logConsole() invoked on server.\");\n  };\n\n  JobCollectionBase.prototype.makeJob = function () {\n    var dep;\n    dep = false;\n    return function () {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\");\n      }\n\n      return function (func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor(),\n            result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      }(Job, [this.root].concat(slice.call(params)), function () {});\n    };\n  }();\n\n  JobCollectionBase.prototype.createJob = function () {\n    var dep;\n    dep = false;\n    return function () {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\");\n      }\n\n      return function (func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor(),\n            result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      }(Job, [this.root].concat(slice.call(params)), function () {});\n    };\n  }();\n\n  JobCollectionBase.prototype._methodWrapper = function (method, func) {\n    var ref, toLog, unblockDDPMethods;\n    toLog = this._toLog;\n    unblockDDPMethods = (ref = this._unblockDDPMethods) != null ? ref : false;\n    return function () {\n      var params, ref1, retval, user;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      user = (ref1 = this.userId) != null ? ref1 : \"[UNAUTHENTICATED]\";\n      toLog(user, method, \"params: \" + JSON.stringify(params));\n\n      if (unblockDDPMethods) {\n        this.unblock();\n      }\n\n      retval = func.apply(null, params);\n      toLog(user, method, \"returned: \" + JSON.stringify(retval));\n      return retval;\n    };\n  };\n\n  JobCollectionBase.prototype._generateMethods = function () {\n    var baseMethodName, methodFunc, methodName, methodPrefix, methodsOut, ref;\n    methodsOut = {};\n    methodPrefix = '_DDPMethod_';\n    ref = this;\n\n    for (methodName in meteorBabelHelpers.sanitizeForInObject(ref)) {\n      methodFunc = ref[methodName];\n\n      if (!(methodName.slice(0, methodPrefix.length) === methodPrefix)) {\n        continue;\n      }\n\n      baseMethodName = methodName.slice(methodPrefix.length);\n      methodsOut[this.root + \"_\" + baseMethodName] = this._methodWrapper(baseMethodName, methodFunc.bind(this));\n    }\n\n    return methodsOut;\n  };\n\n  JobCollectionBase.prototype._idsOfDeps = function (ids, antecedents, dependents, jobStatuses) {\n    var antsArray, dependsIds, dependsQuery;\n    dependsQuery = [];\n    dependsIds = [];\n\n    if (dependents) {\n      dependsQuery.push({\n        depends: {\n          $elemMatch: {\n            $in: ids\n          }\n        }\n      });\n    }\n\n    if (antecedents) {\n      antsArray = [];\n      this.find({\n        _id: {\n          $in: ids\n        }\n      }, {\n        fields: {\n          depends: 1\n        },\n        transform: null\n      }).forEach(function (d) {\n        var i, k, len, ref, results;\n\n        if (indexOf.call(antsArray, i) < 0) {\n          ref = d.depends;\n          results = [];\n\n          for (k = 0, len = ref.length; k < len; k++) {\n            i = ref[k];\n            results.push(antsArray.push(i));\n          }\n\n          return results;\n        }\n      });\n\n      if (antsArray.length > 0) {\n        dependsQuery.push({\n          _id: {\n            $in: antsArray\n          }\n        });\n      }\n    }\n\n    if (dependsQuery.length > 0) {\n      this.find({\n        status: {\n          $in: jobStatuses\n        },\n        $or: dependsQuery\n      }, {\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).forEach(function (d) {\n        var ref;\n\n        if (ref = d._id, indexOf.call(dependsIds, ref) < 0) {\n          return dependsIds.push(d._id);\n        }\n      });\n    }\n\n    return dependsIds;\n  };\n\n  JobCollectionBase.prototype._rerun_job = function (doc, repeats, wait, repeatUntil) {\n    var id, jobId, logObj, runId, time;\n\n    if (repeats == null) {\n      repeats = doc.repeats - 1;\n    }\n\n    if (wait == null) {\n      wait = doc.repeatWait;\n    }\n\n    if (repeatUntil == null) {\n      repeatUntil = doc.repeatUntil;\n    }\n\n    id = doc._id;\n    runId = doc.runId;\n    time = new Date();\n    delete doc._id;\n    delete doc.result;\n    delete doc.failures;\n    delete doc.expiresAfter;\n    delete doc.workTimeout;\n    doc.runId = null;\n    doc.status = \"waiting\";\n    doc.repeatRetries = doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried;\n    doc.retries = doc.repeatRetries;\n\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n\n    doc.retryUntil = repeatUntil;\n    doc.retried = 0;\n    doc.repeats = repeats;\n\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n\n    doc.repeatUntil = repeatUntil;\n    doc.repeated = doc.repeated + 1;\n    doc.updated = time;\n    doc.created = time;\n    doc.progress = {\n      completed: 0,\n      total: 1,\n      percent: 0\n    };\n\n    if (logObj = this._logMessage.rerun(id, runId)) {\n      doc.log = [logObj];\n    } else {\n      doc.log = [];\n    }\n\n    doc.after = new Date(time.valueOf() + wait);\n\n    if (jobId = this.insert(doc)) {\n      this._DDPMethod_jobReady(jobId);\n\n      return jobId;\n    } else {\n      console.warn(\"Job rerun/repeat failed to reschedule!\", id, runId);\n    }\n\n    return null;\n  };\n\n  JobCollectionBase.prototype._checkDeps = function (job, dryRun) {\n    var cancel, cancelled, depJob, deps, failed, foundIds, j, k, len, len1, log, m, mods, n, ref, ref1, removed, resolved;\n\n    if (dryRun == null) {\n      dryRun = true;\n    }\n\n    cancel = false;\n    resolved = [];\n    failed = [];\n    cancelled = [];\n    removed = [];\n    log = [];\n\n    if (job.depends.length > 0) {\n      deps = this.find({\n        _id: {\n          $in: job.depends\n        }\n      }, {\n        fields: {\n          _id: 1,\n          runId: 1,\n          status: 1\n        }\n      }).fetch();\n\n      if (deps.length !== job.depends.length) {\n        foundIds = deps.map(function (d) {\n          return d._id;\n        });\n        ref = job.depends;\n\n        for (k = 0, len = ref.length; k < len; k++) {\n          j = ref[k];\n\n          if (!!(indexOf.call(foundIds, j) >= 0)) {\n            continue;\n          }\n\n          if (!dryRun) {\n            this._DDPMethod_jobLog(job._id, null, \"Antecedent job \" + j + \" missing at save\");\n          }\n\n          removed.push(j);\n        }\n\n        cancel = true;\n      }\n\n      for (m = 0, len1 = deps.length; m < len1; m++) {\n        depJob = deps[m];\n\n        if (ref1 = depJob.status, indexOf.call(this.jobStatusCancellable, ref1) < 0) {\n          switch (depJob.status) {\n            case \"completed\":\n              resolved.push(depJob._id);\n              log.push(this._logMessage.resolved(depJob._id, depJob.runId));\n              break;\n\n            case \"failed\":\n              cancel = true;\n              failed.push(depJob._id);\n\n              if (!dryRun) {\n                this._DDPMethod_jobLog(job._id, null, \"Antecedent job failed before save\");\n              }\n\n              break;\n\n            case \"cancelled\":\n              cancel = true;\n              cancelled.push(depJob._id);\n\n              if (!dryRun) {\n                this._DDPMethod_jobLog(job._id, null, \"Antecedent job cancelled before save\");\n              }\n\n              break;\n\n            default:\n              throw new Meteor.Error(\"Unknown status in jobSave Dependency check\");\n          }\n        }\n      }\n\n      if (!(resolved.length === 0 || dryRun)) {\n        mods = {\n          $pull: {\n            depends: {\n              $in: resolved\n            }\n          },\n          $push: {\n            resolved: {\n              $each: resolved\n            },\n            log: {\n              $each: log\n            }\n          }\n        };\n        n = this.update({\n          _id: job._id,\n          status: 'waiting'\n        }, mods);\n\n        if (!n) {\n          console.warn(\"Update for job \" + job._id + \" during dependency check failed.\");\n        }\n      }\n\n      if (cancel && !dryRun) {\n        this._DDPMethod_jobCancel(job._id);\n\n        return false;\n      }\n    }\n\n    if (dryRun) {\n      if (cancel || resolved.length > 0) {\n        return {\n          jobId: job._id,\n          resolved: resolved,\n          failed: failed,\n          cancelled: cancelled,\n          removed: removed\n        };\n      } else {\n        return false;\n      }\n    } else {\n      return true;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobServer = function (options) {\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n\n      this.stopped = false;\n    }\n\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobs = function () {\n    var depFlag;\n    depFlag = false;\n    return function (options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\");\n      }\n\n      return this._DDPMethod_startJobServer(options);\n    };\n  }();\n\n  JobCollectionBase.prototype._DDPMethod_shutdownJobServer = function (options) {\n    check(options, Match.Optional({\n      timeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n\n      this.stopped = Meteor.setTimeout(function (_this) {\n        return function () {\n          var cursor, failedJobs;\n          cursor = _this.find({\n            status: 'running'\n          }, {\n            transform: null\n          });\n          failedJobs = cursor.count();\n\n          if (failedJobs !== 0) {\n            console.warn(\"Failing \" + failedJobs + \" jobs on queue stop.\");\n          }\n\n          cursor.forEach(function (d) {\n            return _this._DDPMethod_jobFail(d._id, d.runId, \"Running at Job Server shutdown.\");\n          });\n\n          if (_this.logStream != null) {\n            _this.logStream.end();\n\n            return _this.logStream = null;\n          }\n        };\n      }(this), options.timeout);\n    }\n\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_stopJobs = function () {\n    var depFlag;\n    depFlag = false;\n    return function (options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\");\n      }\n\n      return this._DDPMethod_shutdownJobServer(options);\n    };\n  }();\n\n  JobCollectionBase.prototype._DDPMethod_getJob = function (ids, options) {\n    var d, docs, fields, single;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      getLog: Match.Optional(Boolean),\n      getFailures: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n\n    if (options.getFailures == null) {\n      options.getFailures = false;\n    }\n\n    single = false;\n\n    if (_validId(ids)) {\n      ids = [ids];\n      single = true;\n    }\n\n    if (ids.length === 0) {\n      return null;\n    }\n\n    fields = {\n      _private: 0\n    };\n\n    if (!options.getLog) {\n      fields.log = 0;\n    }\n\n    if (!options.getFailures) {\n      fields.failures = 0;\n    }\n\n    docs = this.find({\n      _id: {\n        $in: ids\n      }\n    }, {\n      fields: fields,\n      transform: null\n    }).fetch();\n\n    if (docs != null ? docs.length : void 0) {\n      if (this.scrub != null) {\n        docs = function () {\n          var k, len, results;\n          results = [];\n\n          for (k = 0, len = docs.length; k < len; k++) {\n            d = docs[k];\n            results.push(this.scrub(d));\n          }\n\n          return results;\n        }.call(this);\n      }\n\n      check(docs, [_validJobDoc()]);\n\n      if (single) {\n        return docs[0];\n      } else {\n        return docs;\n      }\n    }\n\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_getWork = function (type, options) {\n    var d, docs, foundDocs, ids, logObj, mods, num, runId, time;\n    check(type, Match.OneOf(String, [String]));\n    check(options, Match.Optional({\n      maxJobs: Match.Optional(Match.Where(_validIntGTEOne)),\n      workTimeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n\n    if (this.isSimulation) {\n      return;\n    }\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.maxJobs == null) {\n      options.maxJobs = 1;\n    }\n\n    if (this.stopped) {\n      return [];\n    }\n\n    if (typeof type === 'string') {\n      type = [type];\n    }\n\n    time = new Date();\n    docs = [];\n    runId = this._makeNewID();\n\n    while (docs.length < options.maxJobs) {\n      ids = this.find({\n        type: {\n          $in: type\n        },\n        status: 'ready',\n        runId: null\n      }, {\n        sort: {\n          priority: 1,\n          retryUntil: 1,\n          after: 1\n        },\n        limit: options.maxJobs - docs.length,\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).map(function (d) {\n        return d._id;\n      });\n\n      if (!((ids != null ? ids.length : void 0) > 0)) {\n        break;\n      }\n\n      mods = {\n        $set: {\n          status: 'running',\n          runId: runId,\n          updated: time\n        },\n        $inc: {\n          retries: -1,\n          retried: 1\n        }\n      };\n\n      if (logObj = this._logMessage.running(runId)) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n\n      if (options.workTimeout != null) {\n        mods.$set.workTimeout = options.workTimeout;\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout);\n      } else {\n        if (mods.$unset == null) {\n          mods.$unset = {};\n        }\n\n        mods.$unset.workTimeout = \"\";\n        mods.$unset.expiresAfter = \"\";\n      }\n\n      num = this.update({\n        _id: {\n          $in: ids\n        },\n        status: 'ready',\n        runId: null\n      }, mods, {\n        multi: true\n      });\n\n      if (num > 0) {\n        foundDocs = this.find({\n          _id: {\n            $in: ids\n          },\n          runId: runId\n        }, {\n          fields: {\n            log: 0,\n            failures: 0,\n            _private: 0\n          },\n          transform: null\n        }).fetch();\n\n        if ((foundDocs != null ? foundDocs.length : void 0) > 0) {\n          if (this.scrub != null) {\n            foundDocs = function () {\n              var k, len, results;\n              results = [];\n\n              for (k = 0, len = foundDocs.length; k < len; k++) {\n                d = foundDocs[k];\n                results.push(this.scrub(d));\n              }\n\n              return results;\n            }.call(this);\n          }\n\n          check(docs, [_validJobDoc()]);\n          docs = docs.concat(foundDocs);\n        }\n      }\n    }\n\n    return docs;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRemove = function (ids, options) {\n    var num;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    num = this.remove({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRemovable\n      }\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobRemove failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobPause = function (ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"paused\",\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.paused()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusPausable\n      }\n    }, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobPause failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobResume = function (ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"waiting\",\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.resumed()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: \"paused\",\n      updated: {\n        $ne: time\n      }\n    }, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      this._DDPMethod_jobReady(ids);\n\n      return true;\n    } else {\n      console.warn(\"jobResume failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobReady = function (ids, options) {\n    var l, logObj, mods, now, num, query;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      force: Match.Optional(Boolean),\n      time: Match.Optional(Date)\n    }));\n\n    if (this.isSimulation) {\n      return;\n    }\n\n    now = new Date();\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.force == null) {\n      options.force = false;\n    }\n\n    if (options.time == null) {\n      options.time = now;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    query = {\n      status: \"waiting\",\n      after: {\n        $lte: options.time\n      }\n    };\n    mods = {\n      $set: {\n        status: \"ready\",\n        updated: now\n      }\n    };\n\n    if (ids.length > 0) {\n      query._id = {\n        $in: ids\n      };\n      mods.$set.after = now;\n    }\n\n    logObj = [];\n\n    if (options.force) {\n      mods.$set.depends = [];\n      l = this._logMessage.forced();\n\n      if (l) {\n        logObj.push(l);\n      }\n    } else {\n      query.depends = {\n        $size: 0\n      };\n    }\n\n    l = this._logMessage.readied();\n\n    if (l) {\n      logObj.push(l);\n    }\n\n    if (logObj.length > 0) {\n      mods.$push = {\n        log: {\n          $each: logObj\n        }\n      };\n    }\n\n    num = this.update(query, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobCancel = function (ids, options) {\n    var cancelIds, depsCancelled, logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.antecedents == null) {\n      options.antecedents = false;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"cancelled\",\n        runId: null,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.cancelled()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusCancellable\n      }\n    }, mods, {\n      multi: true\n    });\n    cancelIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusCancellable);\n    depsCancelled = false;\n\n    if (cancelIds.length > 0) {\n      depsCancelled = this._DDPMethod_jobCancel(cancelIds, options);\n    }\n\n    if (num > 0 || depsCancelled) {\n      return true;\n    } else {\n      console.warn(\"jobCancel failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRestart = function (ids, options) {\n    var depsRestarted, logObj, mods, num, query, restartIds, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      retries: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n\n    if (options.retries > this.forever) {\n      options.retries = this.forever;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = false;\n    }\n\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    query = {\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRestartable\n      }\n    };\n    mods = {\n      $set: {\n        status: \"waiting\",\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $inc: {\n        retries: options.retries\n      }\n    };\n\n    if (logObj = this._logMessage.restarted()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    if (options.until != null) {\n      mods.$set.retryUntil = options.until;\n    }\n\n    num = this.update(query, mods, {\n      multi: true\n    });\n    restartIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusRestartable);\n    depsRestarted = false;\n\n    if (restartIds.length > 0) {\n      depsRestarted = this._DDPMethod_jobRestart(restartIds, options);\n    }\n\n    if (num > 0 || depsRestarted) {\n      this._DDPMethod_jobReady(ids);\n\n      return true;\n    } else {\n      console.warn(\"jobRestart failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobSave = function (doc, options) {\n    var logObj, mods, next, nextDate, num, ref, schedule, time;\n    check(doc, _validJobDoc());\n    check(options, Match.Optional({\n      cancelRepeats: Match.Optional(Boolean)\n    }));\n    check(doc.status, Match.Where(function (v) {\n      return Match.test(v, String) && (v === 'waiting' || v === 'paused');\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.cancelRepeats == null) {\n      options.cancelRepeats = false;\n    }\n\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n\n    time = new Date();\n\n    if (doc.after < time) {\n      doc.after = time;\n    }\n\n    if (doc.retryUntil < time) {\n      doc.retryUntil = time;\n    }\n\n    if (doc.repeatUntil < time) {\n      doc.repeatUntil = time;\n    }\n\n    if (this.later != null && typeof doc.repeatWait !== 'number') {\n      schedule = (ref = this.later) != null ? ref.schedule(doc.repeatWait) : void 0;\n\n      if (!(schedule && (next = schedule.next(2, schedule.prev(1, doc.after))[1]))) {\n        console.warn(\"No valid available later.js times in schedule after \" + doc.after);\n        return null;\n      }\n\n      nextDate = new Date(next);\n\n      if (!(nextDate <= doc.repeatUntil)) {\n        console.warn(\"No valid available later.js times in schedule before \" + doc.repeatUntil);\n        return null;\n      }\n\n      doc.after = nextDate;\n    } else if (this.later == null && doc.repeatWait !== 'number') {\n      console.warn(\"Later.js not loaded...\");\n      return null;\n    }\n\n    if (doc._id) {\n      mods = {\n        $set: {\n          status: 'waiting',\n          data: doc.data,\n          retries: doc.retries,\n          repeatRetries: doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried,\n          retryUntil: doc.retryUntil,\n          retryWait: doc.retryWait,\n          retryBackoff: doc.retryBackoff,\n          repeats: doc.repeats,\n          repeatUntil: doc.repeatUntil,\n          repeatWait: doc.repeatWait,\n          depends: doc.depends,\n          priority: doc.priority,\n          after: doc.after,\n          updated: time\n        }\n      };\n\n      if (logObj = this._logMessage.resubmitted()) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n\n      num = this.update({\n        _id: doc._id,\n        status: 'paused',\n        runId: null\n      }, mods);\n\n      if (num && this._checkDeps(doc, false)) {\n        this._DDPMethod_jobReady(doc._id);\n\n        return doc._id;\n      } else {\n        return null;\n      }\n    } else {\n      if (doc.repeats === this.forever && options.cancelRepeats) {\n        this.find({\n          type: doc.type,\n          status: {\n            $in: this.jobStatusCancellable\n          }\n        }, {\n          transform: null\n        }).forEach(function (_this) {\n          return function (d) {\n            return _this._DDPMethod_jobCancel(d._id, {});\n          };\n        }(this));\n      }\n\n      doc.created = time;\n      doc.log.push(this._logMessage.submitted());\n      doc._id = this.insert(doc);\n\n      if (doc._id && this._checkDeps(doc, false)) {\n        this._DDPMethod_jobReady(doc._id);\n\n        return doc._id;\n      } else {\n        return null;\n      }\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobProgress = function (id, runId, completed, total, options) {\n    var job, mods, num, progress, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(completed, Match.Where(_validNumGTEZero));\n    check(total, Match.Where(_validNumGTZero));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (this.stopped) {\n      return null;\n    }\n\n    progress = {\n      completed: completed,\n      total: total,\n      percent: 100 * completed / total\n    };\n    check(progress, Match.Where(function (v) {\n      var ref;\n      return v.total >= v.completed && 0 <= (ref = v.percent) && ref <= 100;\n    }));\n    time = new Date();\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $set: {\n        progress: progress,\n        updated: time\n      }\n    };\n\n    if ((job != null ? job.workTimeout : void 0) != null) {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobProgress failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobLog = function (id, runId, message, options) {\n    var job, logObj, mods, num, ref, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.OneOf(Match.Where(_validId), null));\n    check(message, String);\n    check(options, Match.Optional({\n      level: Match.Optional(Match.Where(_validLogLevel)),\n      data: Match.Optional(Object)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    time = new Date();\n    logObj = {\n      time: time,\n      runId: runId,\n      level: (ref = options.level) != null ? ref : 'info',\n      message: message\n    };\n\n    if (options.data != null) {\n      logObj.data = options.data;\n    }\n\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        status: 1,\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $push: {\n        log: logObj\n      },\n      $set: {\n        updated: time\n      }\n    };\n\n    if ((job != null ? job.workTimeout : void 0) != null && job.status === 'running') {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n\n    num = this.update({\n      _id: id\n    }, mods);\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobLog failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRerun = function (id, options) {\n    var doc;\n    check(id, Match.Where(_validId));\n    check(options, Match.Optional({\n      repeats: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n    }));\n    doc = this.findOne({\n      _id: id,\n      status: \"completed\"\n    }, {\n      fields: {\n        result: 0,\n        failures: 0,\n        log: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc != null) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (options.repeats == null) {\n        options.repeats = 0;\n      }\n\n      if (options.repeats > this.forever) {\n        options.repeats = this.forever;\n      }\n\n      if (options.until == null) {\n        options.until = doc.repeatUntil;\n      }\n\n      if (options.wait == null) {\n        options.wait = 0;\n      }\n\n      return this._rerun_job(doc, options.repeats, options.wait, options.until);\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobDone = function (id, runId, result, options) {\n    var after, d, doc, ids, jobId, logObj, mods, n, next, num, ref, time, wait;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(result, Object);\n    check(options, Match.Optional({\n      repeatId: Match.Optional(Boolean),\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n    }));\n\n    if (options == null) {\n      options = {\n        repeatId: false\n      };\n    }\n\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n\n      return false;\n    }\n\n    mods = {\n      $set: {\n        status: \"completed\",\n        result: result,\n        progress: {\n          completed: doc.progress.total || 1,\n          total: doc.progress.total || 1,\n          percent: 100\n        },\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.completed(runId)) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (num === 1) {\n      if (doc.repeats > 0) {\n        if (typeof doc.repeatWait === 'number') {\n          if (doc.repeatUntil - doc.repeatWait >= time) {\n            jobId = this._rerun_job(doc);\n          }\n        } else {\n          next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(2) : void 0;\n\n          if (next && next.length > 0) {\n            d = new Date(next[0]);\n\n            if (d - time > 500 || next.length > 1) {\n              if (d - time <= 500) {\n                d = new Date(next[1]);\n              }\n\n              wait = d - time;\n\n              if (doc.repeatUntil - wait >= time) {\n                jobId = this._rerun_job(doc, doc.repeats - 1, wait);\n              }\n            }\n          }\n        }\n      }\n\n      ids = this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null,\n        fields: {\n          _id: 1\n        }\n      }).fetch().map(function (_this) {\n        return function (d) {\n          return d._id;\n        };\n      }(this));\n\n      if (ids.length > 0) {\n        mods = {\n          $pull: {\n            depends: id\n          },\n          $push: {\n            resolved: id\n          }\n        };\n\n        if (options.delayDeps != null) {\n          after = new Date(time.valueOf() + options.delayDeps);\n          mods.$max = {\n            after: after\n          };\n        }\n\n        if (logObj = this._logMessage.resolved(id, runId)) {\n          mods.$push.log = logObj;\n        }\n\n        n = this.update({\n          _id: {\n            $in: ids\n          }\n        }, mods, {\n          multi: true\n        });\n\n        if (n !== ids.length) {\n          console.warn(\"Not all dependent jobs were resolved \" + ids.length + \" > \" + n);\n        }\n\n        this._DDPMethod_jobReady(ids);\n      }\n\n      if (options.repeatId && jobId != null) {\n        return jobId;\n      } else {\n        return true;\n      }\n    } else {\n      console.warn(\"jobDone failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobFail = function (id, runId, err, options) {\n    var after, doc, logObj, mods, newStatus, num, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(err, Object);\n    check(options, Match.Optional({\n      fatal: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        runId: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n\n      return false;\n    }\n\n    after = function () {\n      switch (doc.retryBackoff) {\n        case 'exponential':\n          return new Date(time.valueOf() + doc.retryWait * Math.pow(2, doc.retried - 1));\n\n        default:\n          return new Date(time.valueOf() + doc.retryWait);\n      }\n    }();\n\n    newStatus = !options.fatal && doc.retries > 0 && doc.retryUntil >= after ? \"waiting\" : \"failed\";\n    err.runId = runId;\n    mods = {\n      $set: {\n        status: newStatus,\n        runId: null,\n        after: after,\n        updated: time\n      },\n      $push: {\n        failures: err\n      }\n    };\n\n    if (logObj = this._logMessage.failed(runId, newStatus === 'failed', err)) {\n      mods.$push.log = logObj;\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (newStatus === \"failed\" && num === 1) {\n      this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null\n      }).forEach(function (_this) {\n        return function (d) {\n          return _this._DDPMethod_jobCancel(d._id);\n        };\n      }(this));\n    }\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobFail failed\");\n    }\n\n    return false;\n  };\n\n  return JobCollectionBase;\n}(Mongo.Collection);\n\nshare.JobCollectionBase = JobCollectionBase;","sourceMap":{"version":3,"sources":["/packages/vsivsi_job-collection/src/shared.coffee","/src/shared.coffee"],"names":["JobCollectionBase","_validId","_validIntGTEOne","_validIntGTEZero","_validJobDoc","_validLaterJSObj","_validLog","_validLogLevel","_validNumGTEOne","_validNumGTEZero","_validNumGTZero","_validProgress","_validRetryBackoff","_validStatus","indexOf","item","i","l","length","extend","child","parent","key","hasProp","call","ctor","constructor","prototype","__super__","hasOwnProperty","slice","v","Match","test","Number","Math","floor","String","Job","jobStatuses","jobLogLevels","jobRetryBackoffMethods","OneOf","Mongo","Collection","ObjectID","time","Date","runId","Where","level","message","data","Optional","Object","completed","total","percent","schedules","exceptions","_id","type","status","result","failures","priority","Integer","depends","resolved","after","updated","workTimeout","expiresAfter","log","progress","retries","retried","repeatRetries","retryUntil","retryWait","retryBackoff","repeats","repeated","repeatUntil","repeatWait","created","superClass","root","options","collectionName","Meteor","Error","later","noCollectionSuffix","setDDP","connection","_createLogEntry","_logMessage","bind","id","previousJob","dependency","fatal","err","msg","value","jobPriorities","jobStatusCancellable","jobStatusPausable","jobStatusRemovable","jobStatusRestartable","forever","foreverDate","ddpMethods","ddpPermissionLevels","ddpMethodPermissions","processJobs","params","arguments","func","args","apply","concat","getJob","getWork","getJobs","readyJobs","cancelJobs","pauseJobs","resumeJobs","restartJobs","removeJobs","startJobServer","shutdownJobServer","startJobs","stopJobs","jobDocPattern","allow","deny","promote","setLogStream","logConsole","makeJob","dep","console","warn","createJob","_methodWrapper","method","ref","toLog","unblockDDPMethods","_toLog","_unblockDDPMethods","ref1","retval","user","userId","JSON","stringify","unblock","_generateMethods","baseMethodName","methodFunc","methodName","methodPrefix","methodsOut","_idsOfDeps","ids","antecedents","dependents","antsArray","dependsIds","dependsQuery","push","$elemMatch","$in","find","fields","transform","forEach","d","k","len","results","$or","_rerun_job","doc","wait","jobId","logObj","rerun","valueOf","insert","_DDPMethod_jobReady","_checkDeps","job","dryRun","cancel","cancelled","depJob","deps","failed","foundIds","j","len1","m","mods","n","removed","fetch","map","_DDPMethod_jobLog","$pull","$push","$each","update","_DDPMethod_jobCancel","_DDPMethod_startJobServer","check","isSimulation","stopped","clearTimeout","_DDPMethod_startJobs","depFlag","_DDPMethod_shutdownJobServer","timeout","setTimeout","_this","cursor","failedJobs","count","_DDPMethod_jobFail","logStream","end","_DDPMethod_stopJobs","_DDPMethod_getJob","docs","single","getLog","Boolean","getFailures","_private","scrub","_DDPMethod_getWork","foundDocs","num","maxJobs","_makeNewID","sort","limit","$set","$inc","running","$unset","multi","_DDPMethod_jobRemove","remove","_DDPMethod_jobPause","paused","_DDPMethod_jobResume","resumed","$ne","now","query","force","$lte","forced","$size","readied","cancelIds","depsCancelled","_DDPMethod_jobRestart","depsRestarted","restartIds","until","restarted","_DDPMethod_jobSave","next","nextDate","schedule","cancelRepeats","prev","resubmitted","submitted","_DDPMethod_jobProgress","findOne","_DDPMethod_jobRerun","_DDPMethod_jobDone","repeatId","delayDeps","$all","$max","newStatus","pow","share"],"mappings":"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","file":"packages/vsivsi:job-collection/src/shared.coffee.map","sourcesContent":["############################################################################\n#     Copyright (C) 2014-2017 by Vaughn Iverson\n#     job-collection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\n_validNumGTEZero = (v) ->\n  Match.test(v, Number) and v >= 0.0\n\n_validNumGTZero = (v) ->\n  Match.test(v, Number) and v > 0.0\n\n_validNumGTEOne = (v) ->\n  Match.test(v, Number) and v >= 1.0\n\n_validIntGTEZero = (v) ->\n  _validNumGTEZero(v) and Math.floor(v) is v\n\n_validIntGTEOne = (v) ->\n  _validNumGTEOne(v) and Math.floor(v) is v\n\n_validStatus = (v) ->\n  Match.test(v, String) and v in Job.jobStatuses\n\n_validLogLevel = (v) ->\n  Match.test(v, String) and v in Job.jobLogLevels\n\n_validRetryBackoff = (v) ->\n  Match.test(v, String) and v in Job.jobRetryBackoffMethods\n\n_validId = (v) ->\n  Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID))\n\n_validLog = () ->\n  [{\n      time: Date\n      runId: Match.OneOf(Match.Where(_validId), null)\n      level: Match.Where(_validLogLevel)\n      message: String\n      data: Match.Optional Object\n  }]\n\n_validProgress = () ->\n  completed: Match.Where(_validNumGTEZero)\n  total: Match.Where(_validNumGTEZero)\n  percent: Match.Where(_validNumGTEZero)\n\n_validLaterJSObj = () ->\n  schedules: [ Object ]\n  exceptions: Match.Optional [ Object ]\n\n_validJobDoc = () ->\n  _id: Match.Optional Match.OneOf(Match.Where(_validId), null)\n  runId: Match.OneOf(Match.Where(_validId), null)\n  type: String\n  status: Match.Where _validStatus\n  data: Object\n  result: Match.Optional Object\n  failures: Match.Optional [ Object ]\n  priority: Match.Integer\n  depends: [ Match.Where(_validId) ]\n  resolved: [ Match.Where(_validId) ]\n  after: Date\n  updated: Date\n  workTimeout: Match.Optional Match.Where(_validIntGTEOne)\n  expiresAfter: Match.Optional Date\n  log: Match.Optional _validLog()\n  progress: _validProgress()\n  retries: Match.Where _validIntGTEZero\n  retried: Match.Where _validIntGTEZero\n  repeatRetries: Match.Optional Match.Where _validIntGTEZero\n  retryUntil: Date\n  retryWait: Match.Where _validIntGTEZero\n  retryBackoff: Match.Where _validRetryBackoff\n  repeats: Match.Where _validIntGTEZero\n  repeated: Match.Where _validIntGTEZero\n  repeatUntil: Date\n  repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n  created: Date\n\nclass JobCollectionBase extends Mongo.Collection\n\n  constructor: (@root = 'queue', options = {}) ->\n    unless @ instanceof JobCollectionBase\n      return new JobCollectionBase(@root, options)\n\n    unless @ instanceof Mongo.Collection\n      throw new Meteor.Error 'The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.'\n\n    unless Mongo.Collection is Mongo.Collection.prototype.constructor\n      throw new Meteor.Error 'The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592'\n\n    @later = later  # later object, for convenience\n\n    options.noCollectionSuffix ?= false\n\n    collectionName = @root\n\n    unless options.noCollectionSuffix\n      collectionName += '.jobs'\n\n    # Remove non-standard options before\n    # calling Mongo.Collection constructor\n    delete options.noCollectionSuffix\n\n    Job.setDDP(options.connection, @root)\n\n    @_createLogEntry = (message = '', runId = null, level = 'info', time = new Date(), data = null) ->\n      l = { time: time, runId: runId, message: message, level: level }\n      return l\n\n    @_logMessage =\n      'readied': (() -> @_createLogEntry \"Promoted to ready\").bind(@)\n      'forced': ((id) -> @_createLogEntry \"Dependencies force resolved\", null, 'warning').bind(@)\n      'rerun': ((id, runId) -> @_createLogEntry \"Rerunning job\", null, 'info', new Date(), {previousJob:{id:id,runId:runId}}).bind(@)\n      'running': ((runId) -> @_createLogEntry \"Job Running\", runId).bind(@)\n      'paused': (() -> @_createLogEntry \"Job Paused\").bind(@)\n      'resumed': (() -> @_createLogEntry \"Job Resumed\").bind(@)\n      'cancelled': (() -> @_createLogEntry \"Job Cancelled\", null, 'warning').bind(@)\n      'restarted': (() -> @_createLogEntry \"Job Restarted\").bind(@)\n      'resubmitted': (() -> @_createLogEntry \"Job Resubmitted\").bind(@)\n      'submitted': (() -> @_createLogEntry \"Job Submitted\").bind(@)\n      'completed': ((runId) -> @_createLogEntry \"Job Completed\", runId, 'success').bind(@)\n      'resolved': ((id, runId) -> @_createLogEntry \"Dependency resolved\", null, 'info', new Date(), {dependency:{id:id,runId:runId}}).bind(@)\n      'failed': ((runId, fatal, err) ->\n        value = err.value\n        msg = \"Job Failed with#{if fatal then ' Fatal' else ''} Error#{if value? and typeof value is 'string' then ': ' + value else ''}.\"\n        level = if fatal then 'danger' else 'warning'\n        @_createLogEntry msg, runId, level).bind(@)\n\n    # Call super's constructor\n    super collectionName, options\n\n  _validNumGTEZero: _validNumGTEZero\n  _validNumGTZero: _validNumGTZero\n  _validNumGTEOne: _validNumGTEOne\n  _validIntGTEZero: _validIntGTEZero\n  _validIntGTEOne: _validIntGTEOne\n  _validStatus: _validStatus\n  _validLogLevel: _validLogLevel\n  _validRetryBackoff: _validRetryBackoff\n  _validId: _validId\n  _validLog: _validLog\n  _validProgress: _validProgress\n  _validJobDoc: _validJobDoc\n\n  jobLogLevels: Job.jobLogLevels\n  jobPriorities: Job.jobPriorities\n  jobStatuses: Job.jobStatuses\n  jobStatusCancellable: Job.jobStatusCancellable\n  jobStatusPausable: Job.jobStatusPausable\n  jobStatusRemovable: Job.jobStatusRemovable\n  jobStatusRestartable: Job.jobStatusRestartable\n  forever: Job.forever\n  foreverDate: Job.foreverDate\n\n  ddpMethods: Job.ddpMethods\n  ddpPermissionLevels: Job.ddpPermissionLevels\n  ddpMethodPermissions: Job.ddpMethodPermissions\n\n  processJobs: (params...) -> new Job.processJobs @root, params...\n  getJob: (params...) -> Job.getJob @root, params...\n  getWork: (params...) -> Job.getWork @root, params...\n  getJobs: (params...) -> Job.getJobs @root, params...\n  readyJobs: (params...) -> Job.readyJobs @root, params...\n  cancelJobs: (params...) -> Job.cancelJobs @root, params...\n  pauseJobs: (params...) -> Job.pauseJobs @root, params...\n  resumeJobs: (params...) -> Job.resumeJobs @root, params...\n  restartJobs: (params...) -> Job.restartJobs @root, params...\n  removeJobs: (params...) -> Job.removeJobs @root, params...\n\n  setDDP: (params...) -> Job.setDDP params...\n\n  startJobServer: (params...) -> Job.startJobServer @root, params...\n  shutdownJobServer: (params...) -> Job.shutdownJobServer @root, params...\n\n  # These are deprecated and will be removed\n  startJobs: (params...) -> Job.startJobs @root, params...\n  stopJobs: (params...) -> Job.stopJobs @root, params...\n\n  jobDocPattern: _validJobDoc()\n\n  # Warning Stubs for server-only calls\n  allow: () -> throw new Error \"Server-only function jc.allow() invoked on client.\"\n  deny: () -> throw new Error \"Server-only function jc.deny() invoked on client.\"\n  promote: () -> throw new Error \"Server-only function jc.promote() invoked on client.\"\n  setLogStream: () -> throw new Error \"Server-only function jc.setLogStream() invoked on client.\"\n\n  # Warning Stubs for client-only calls\n  logConsole: () -> throw new Error \"Client-only function jc.logConsole() invoked on server.\"\n\n  # Deprecated. Remove in next major version\n  makeJob: do () ->\n    dep = false\n    (params...) ->\n      unless dep\n        dep = true\n        console.warn \"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\"\n      new Job @root, params...\n\n  # Deprecated. Remove in next major version\n  createJob: do () ->\n    dep = false\n    (params...) ->\n      unless dep\n        dep = true\n        console.warn \"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\"\n      new Job @root, params...\n\n  _methodWrapper: (method, func) ->\n    toLog = @_toLog\n    unblockDDPMethods = @_unblockDDPMethods ? false\n    # Return the wrapper function that the Meteor method will actually invoke\n    return (params...) ->\n      user = this.userId ? \"[UNAUTHENTICATED]\"\n      toLog user, method, \"params: \" + JSON.stringify(params)\n      this.unblock() if unblockDDPMethods\n      retval = func(params...)\n      toLog user, method, \"returned: \" + JSON.stringify(retval)\n      return retval\n\n  _generateMethods: () ->\n    methodsOut = {}\n    methodPrefix = '_DDPMethod_'\n    for methodName, methodFunc of @ when methodName[0...methodPrefix.length] is methodPrefix\n      baseMethodName = methodName[methodPrefix.length..]\n      methodsOut[\"#{@root}_#{baseMethodName}\"] = @_methodWrapper(baseMethodName, methodFunc.bind(@))\n    return methodsOut\n\n  _idsOfDeps: (ids, antecedents, dependents, jobStatuses) ->\n    # Cancel the entire tree of antecedents and/or dependents\n    # Dependents: jobs that list one of the ids in their depends list\n    # Antecedents: jobs with an id listed in the depends list of one of the jobs in ids\n    dependsQuery = []\n    dependsIds = []\n    if dependents\n      dependsQuery.push\n        depends:\n          $elemMatch:\n            $in: ids\n    if antecedents\n      antsArray = []\n      @find(\n        {\n          _id:\n            $in: ids\n        }\n        {\n          fields:\n            depends: 1\n          transform: null\n        }\n      ).forEach (d) -> antsArray.push(i) for i in d.depends unless i in antsArray\n      if antsArray.length > 0\n        dependsQuery.push\n          _id:\n            $in: antsArray\n    if dependsQuery.length > 0\n      @find(\n        {\n          status:\n            $in: jobStatuses\n          $or: dependsQuery\n        }\n        {\n          fields:\n            _id: 1\n          transform: null\n        }\n      ).forEach (d) ->\n        dependsIds.push d._id unless d._id in dependsIds\n    return dependsIds\n\n  _rerun_job: (doc, repeats = doc.repeats - 1, wait = doc.repeatWait, repeatUntil = doc.repeatUntil) ->\n    # Repeat? if so, make a new job from the old one\n    id = doc._id\n    runId = doc.runId\n    time = new Date()\n    delete doc._id\n    delete doc.result\n    delete doc.failures\n    delete doc.expiresAfter\n    delete doc.workTimeout\n    doc.runId = null\n    doc.status = \"waiting\"\n    doc.repeatRetries = if doc.repeatRetries? then doc.repeatRetries else doc.retries + doc.retried\n    doc.retries = doc.repeatRetries\n    doc.retries = @forever if doc.retries > @forever\n    doc.retryUntil = repeatUntil\n    doc.retried = 0\n    doc.repeats = repeats\n    doc.repeats = @forever if doc.repeats > @forever\n    doc.repeatUntil = repeatUntil\n    doc.repeated = doc.repeated + 1\n    doc.updated = time\n    doc.created = time\n    doc.progress =\n      completed: 0\n      total: 1\n      percent: 0\n    if logObj = @_logMessage.rerun id, runId\n      doc.log = [logObj]\n    else\n      doc.log = []\n\n    doc.after = new Date(time.valueOf() + wait)\n    if jobId = @insert doc\n      @_DDPMethod_jobReady jobId\n      return jobId\n    else\n      console.warn \"Job rerun/repeat failed to reschedule!\", id, runId\n    return null\n\n  _checkDeps: (job, dryRun = true) ->\n    cancel = false\n    resolved = []\n    failed = []\n    cancelled = []\n    removed = []\n    log = []\n    if job.depends.length > 0\n      deps = @find({_id: { $in: job.depends }},{ fields: { _id: 1, runId: 1, status: 1 } }).fetch()\n\n      if deps.length isnt job.depends.length\n        foundIds = deps.map (d) -> d._id\n        for j in job.depends when not (j in foundIds)\n          @_DDPMethod_jobLog job._id, null, \"Antecedent job #{j} missing at save\" unless dryRun\n          removed.push j\n        cancel = true\n\n      for depJob in deps\n        unless depJob.status in @jobStatusCancellable\n          switch depJob.status\n            when \"completed\"\n              resolved.push depJob._id\n              log.push @_logMessage.resolved depJob._id, depJob.runId\n            when \"failed\"\n              cancel = true\n              failed.push depJob._id\n              @_DDPMethod_jobLog job._id, null, \"Antecedent job failed before save\" unless dryRun\n            when \"cancelled\"\n              cancel = true\n              cancelled.push depJob._id\n              @_DDPMethod_jobLog job._id, null, \"Antecedent job cancelled before save\" unless dryRun\n            else  # Unknown status\n              throw new Meteor.Error \"Unknown status in jobSave Dependency check\"\n\n      unless resolved.length is 0 or dryRun\n        mods =\n          $pull:\n            depends:\n              $in: resolved\n          $push:\n            resolved:\n              $each: resolved\n            log:\n              $each: log\n\n        n = @update(\n          {\n            _id: job._id\n            status: 'waiting'\n          }\n          mods\n        )\n\n        unless n\n          console.warn \"Update for job #{job._id} during dependency check failed.\"\n\n      if cancel and not dryRun\n        @_DDPMethod_jobCancel job._id\n        return false\n\n    if dryRun\n      if cancel or resolved.length > 0\n        return {\n          jobId: job._id\n          resolved: resolved\n          failed: failed\n          cancelled: cancelled\n          removed: removed\n        }\n      else\n        return false\n    else\n      return true\n\n  _DDPMethod_startJobServer: (options) ->\n    check options, Match.Optional {}\n    options ?= {}\n    # The client can't actually do this, so skip it\n    unless @isSimulation\n      Meteor.clearTimeout(@stopped) if @stopped and @stopped isnt true\n      @stopped = false\n    return true\n\n  _DDPMethod_startJobs: do () =>\n    depFlag = false\n    (options) ->\n      unless depFlag\n        depFlag = true\n        console.warn \"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\"\n      return @_DDPMethod_startJobServer options\n\n  _DDPMethod_shutdownJobServer: (options) ->\n    check options, Match.Optional\n      timeout: Match.Optional(Match.Where _validIntGTEOne)\n    options ?= {}\n    options.timeout ?= 60*1000\n\n    # The client can't actually do any of this, so skip it\n    unless @isSimulation\n      Meteor.clearTimeout(@stopped) if @stopped and @stopped isnt true\n      @stopped = Meteor.setTimeout(\n        () =>\n          cursor = @find(\n            {\n              status: 'running'\n            },\n            {\n              transform: null\n            }\n          )\n          failedJobs = cursor.count()\n          console.warn \"Failing #{failedJobs} jobs on queue stop.\" if failedJobs isnt 0\n          cursor.forEach (d) => @_DDPMethod_jobFail d._id, d.runId, \"Running at Job Server shutdown.\"\n          if @logStream? # Shutting down closes the logStream!\n            @logStream.end()\n            @logStream = null\n        options.timeout\n      )\n    return true\n\n  _DDPMethod_stopJobs: do () =>\n    depFlag = false\n    (options) ->\n      unless depFlag\n        depFlag = true\n        console.warn \"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\"\n      return @_DDPMethod_shutdownJobServer options\n\n  _DDPMethod_getJob: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      getLog: Match.Optional Boolean\n      getFailures: Match.Optional Boolean\n    options ?= {}\n    options.getLog ?= false\n    options.getFailures ?= false\n    single = false\n    if _validId(ids)\n      ids = [ids]\n      single = true\n    return null if ids.length is 0\n    fields = {_private:0}\n    fields.log = 0 if !options.getLog\n    fields.failures = 0 if !options.getFailures\n    docs = @find(\n      {\n        _id:\n          $in: ids\n      }\n      {\n        fields: fields\n        transform: null\n      }\n    ).fetch()\n    if docs?.length\n      if @scrub?\n        docs = (@scrub d for d in docs)\n      check docs, [_validJobDoc()]\n      if single\n        return docs[0]\n      else\n        return docs\n    return null\n\n  _DDPMethod_getWork: (type, options) ->\n    check type, Match.OneOf String, [ String ]\n    check options, Match.Optional\n      maxJobs: Match.Optional(Match.Where _validIntGTEOne)\n      workTimeout: Match.Optional(Match.Where _validIntGTEOne)\n\n    # Don't simulate getWork!\n    if @isSimulation\n      return\n\n    options ?= {}\n    options.maxJobs ?= 1\n    # Don't put out any more jobs while shutting down\n    if @stopped\n      return []\n\n    # Support string types or arrays of string types\n    if typeof type is 'string'\n      type = [ type ]\n    time = new Date()\n    docs = []\n    runId = @_makeNewID() # This is meteor internal, but it will fail hard if it goes away.\n\n    while docs.length < options.maxJobs\n\n      ids = @find(\n        {\n          type:\n            $in: type\n          status: 'ready'\n          runId: null\n        }\n        {\n          sort:\n            priority: 1\n            retryUntil: 1\n            after: 1\n          limit: options.maxJobs - docs.length # never ask for more than is needed\n          fields:\n            _id: 1\n          transform: null\n        }).map (d) -> d._id\n\n      unless ids?.length > 0\n        break  # Don't keep looping when there's no available work\n\n      mods =\n        $set:\n          status: 'running'\n          runId: runId\n          updated: time\n        $inc:\n          retries: -1\n          retried: 1\n\n      if logObj = @_logMessage.running runId\n        mods.$push =\n          log: logObj\n\n      if options.workTimeout?\n        mods.$set.workTimeout = options.workTimeout\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout)\n      else\n        mods.$unset ?= {}\n        mods.$unset.workTimeout = \"\"\n        mods.$unset.expiresAfter = \"\"\n\n      num = @update(\n        {\n          _id:\n            $in: ids\n          status: 'ready'\n          runId: null\n        }\n        mods\n        {\n          multi: true\n        }\n      )\n\n      if num > 0\n        foundDocs = @find(\n          {\n            _id:\n              $in: ids\n            runId: runId\n          }\n          {\n            fields:\n              log: 0\n              failures: 0\n              _private: 0\n            transform: null\n          }\n        ).fetch()\n\n        if foundDocs?.length > 0\n          if @scrub?\n            foundDocs = (@scrub d for d in foundDocs)\n          check docs, [ _validJobDoc() ]\n          docs = docs.concat foundDocs\n        # else\n        #   console.warn \"getWork: find after update failed\"\n    return docs\n\n  _DDPMethod_jobRemove: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    num = @remove(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusRemovable\n      }\n    )\n    if num > 0\n      return true\n    else\n      console.warn \"jobRemove failed\"\n    return false\n\n  _DDPMethod_jobPause: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    mods =\n      $set:\n        status: \"paused\"\n        updated: time\n\n    if logObj = @_logMessage.paused()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusPausable\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    if num > 0\n      return true\n    else\n      console.warn \"jobPause failed\"\n    return false\n\n  _DDPMethod_jobResume: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n    mods =\n      $set:\n        status: \"waiting\"\n        updated: time\n\n    if logObj = @_logMessage.resumed()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status: \"paused\"\n        updated:\n          $ne: time\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    if num > 0\n      @_DDPMethod_jobReady ids\n      return true\n    else\n      console.warn \"jobResume failed\"\n    return false\n\n  _DDPMethod_jobReady: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      force: Match.Optional Boolean\n      time: Match.Optional Date\n\n    # Don't simulate jobReady. It has a strong chance of causing issues with\n    # Meteor on the client, particularly if an observeChanges() is triggering\n    # a processJobs queue (which in turn sets timers.)\n    if @isSimulation\n      return\n\n    now = new Date()\n\n    options ?= {}\n    options.force ?= false\n    options.time ?= now\n\n    if _validId(ids)\n      ids = [ids]\n\n    query =\n      status: \"waiting\"\n      after:\n        $lte: options.time\n\n    mods =\n      $set:\n        status: \"ready\"\n        updated: now\n\n    if ids.length > 0\n      query._id =\n        $in: ids\n      mods.$set.after = now\n\n    logObj = []\n\n    if options.force\n      mods.$set.depends = []  # Don't move to resolved, because they weren't!\n      l = @_logMessage.forced()\n      logObj.push l if l\n    else\n      query.depends =\n        $size: 0\n\n    l = @_logMessage.readied()\n    logObj.push l if l\n\n    if logObj.length > 0\n      mods.$push =\n        log:\n          $each: logObj\n\n    num = @update(\n      query\n      mods\n      {\n        multi: true\n      }\n    )\n\n    if num > 0\n      return true\n    else\n      return false\n\n  _DDPMethod_jobCancel: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      antecedents: Match.Optional Boolean\n      dependents: Match.Optional Boolean\n    options ?= {}\n    options.antecedents ?= false\n    options.dependents ?= true\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    mods =\n      $set:\n        status: \"cancelled\"\n        runId: null\n        progress:\n          completed: 0\n          total: 1\n          percent: 0\n        updated: time\n\n    if logObj = @_logMessage.cancelled()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusCancellable\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    # Cancel the entire tree of dependents\n    cancelIds = @_idsOfDeps ids, options.antecedents, options.dependents, @jobStatusCancellable\n\n    depsCancelled = false\n    if cancelIds.length > 0\n      depsCancelled = @_DDPMethod_jobCancel cancelIds, options\n\n    if num > 0 or depsCancelled\n      return true\n    else\n      console.warn \"jobCancel failed\"\n    return false\n\n  _DDPMethod_jobRestart: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      retries: Match.Optional(Match.Where _validIntGTEZero)\n      until: Match.Optional Date\n      antecedents: Match.Optional Boolean\n      dependents: Match.Optional Boolean\n    options ?= {}\n    options.retries ?= 1\n    options.retries = @forever if options.retries > @forever\n    options.dependents ?= false\n    options.antecedents ?= true\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    query =\n      _id:\n        $in: ids\n      status:\n        $in: @jobStatusRestartable\n\n    mods =\n      $set:\n        status: \"waiting\"\n        progress:\n          completed: 0\n          total: 1\n          percent: 0\n        updated: time\n      $inc:\n        retries: options.retries\n\n    if logObj = @_logMessage.restarted()\n      mods.$push =\n        log: logObj\n\n    if options.until?\n      mods.$set.retryUntil = options.until\n\n    num = @update query, mods, {multi: true}\n\n    # Restart the entire tree of dependents\n    restartIds = @_idsOfDeps ids, options.antecedents, options.dependents, @jobStatusRestartable\n\n    depsRestarted = false\n    if restartIds.length > 0\n      depsRestarted = @_DDPMethod_jobRestart restartIds, options\n\n    if num > 0 or depsRestarted\n      @_DDPMethod_jobReady ids\n      return true\n    else\n      console.warn \"jobRestart failed\"\n    return false\n\n  # Job creator methods\n\n  _DDPMethod_jobSave: (doc, options) ->\n    check doc, _validJobDoc()\n    check options, Match.Optional\n      cancelRepeats: Match.Optional Boolean\n    check doc.status, Match.Where (v) ->\n      Match.test(v, String) and v in [ 'waiting', 'paused' ]\n    options ?= {}\n    options.cancelRepeats ?= false\n    doc.repeats = @forever if doc.repeats > @forever\n    doc.retries = @forever if doc.retries > @forever\n\n    time = new Date()\n\n    # This enables the default case of \"run immediately\" to\n    # not be impacted by a client's clock\n    doc.after = time if doc.after < time\n    doc.retryUntil = time if doc.retryUntil < time\n    doc.repeatUntil = time if doc.repeatUntil < time\n\n    # If doc.repeatWait is a later.js object, then don't run before\n    # the first valid scheduled time that occurs after doc.after\n    if @later? and typeof doc.repeatWait isnt 'number'\n      # Using a workaround to find next time after doc.after.\n      # See: https://github.com/vsivsi/meteor-job-collection/issues/217\n      schedule = @later?.schedule(doc.repeatWait)\n      unless schedule and next = schedule.next(2, schedule.prev(1, doc.after))[1]\n        console.warn \"No valid available later.js times in schedule after #{doc.after}\"\n        return null\n      nextDate = new Date(next)\n      unless nextDate <= doc.repeatUntil\n        console.warn \"No valid available later.js times in schedule before #{doc.repeatUntil}\"\n        return null\n      doc.after = nextDate\n    else if not @later? and doc.repeatWait isnt 'number'\n      console.warn \"Later.js not loaded...\"\n      return null\n\n    if doc._id\n\n      mods =\n        $set:\n          status: 'waiting'\n          data: doc.data\n          retries: doc.retries\n          repeatRetries: if doc.repeatRetries? then doc.repeatRetries else doc.retries + doc.retried\n          retryUntil: doc.retryUntil\n          retryWait: doc.retryWait\n          retryBackoff: doc.retryBackoff\n          repeats: doc.repeats\n          repeatUntil: doc.repeatUntil\n          repeatWait: doc.repeatWait\n          depends: doc.depends\n          priority: doc.priority\n          after: doc.after\n          updated: time\n\n      if logObj = @_logMessage.resubmitted()\n        mods.$push =\n          log: logObj\n\n      num = @update(\n        {\n          _id: doc._id\n          status: 'paused'\n          runId: null\n        }\n        mods\n      )\n\n      if num and @_checkDeps doc, false\n        @_DDPMethod_jobReady doc._id\n        return doc._id\n      else\n        return null\n    else\n      if doc.repeats is @forever and options.cancelRepeats\n        # If this is unlimited repeating job, then cancel any existing jobs of the same type\n        @find(\n          {\n            type: doc.type\n            status:\n              $in: @jobStatusCancellable\n          },\n          {\n            transform: null\n          }\n        ).forEach (d) => @_DDPMethod_jobCancel d._id, {}\n      doc.created = time\n      doc.log.push @_logMessage.submitted()\n      doc._id = @insert doc\n      if doc._id and @_checkDeps doc, false\n        @_DDPMethod_jobReady doc._id\n        return doc._id\n      else\n        return null\n\n  # Worker methods\n\n  _DDPMethod_jobProgress: (id, runId, completed, total, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check completed, Match.Where _validNumGTEZero\n    check total, Match.Where _validNumGTZero\n    check options, Match.Optional {}\n    options ?= {}\n\n    # Notify the worker to stop running if we are shutting down\n    if @stopped\n      return null\n\n    progress =\n      completed: completed\n      total: total\n      percent: 100*completed/total\n\n    check progress, Match.Where (v) ->\n      v.total >= v.completed and 0 <= v.percent <= 100\n\n    time = new Date()\n\n    job = @findOne { _id: id }, { fields: { workTimeout: 1 } }\n\n    mods =\n      $set:\n        progress: progress\n        updated: time\n\n    if job?.workTimeout?\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout)\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n\n    if num is 1\n      return true\n    else\n      console.warn \"jobProgress failed\"\n    return false\n\n  _DDPMethod_jobLog: (id, runId, message, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.OneOf(Match.Where(_validId), null)\n    check message, String\n    check options, Match.Optional\n      level: Match.Optional(Match.Where _validLogLevel)\n      data: Match.Optional Object\n    options ?= {}\n    time = new Date()\n    logObj =\n        time: time\n        runId: runId\n        level: options.level ? 'info'\n        message: message\n    logObj.data = options.data if options.data?\n\n    job = @findOne { _id: id }, { fields: { status: 1, workTimeout: 1 } }\n\n    mods =\n      $push:\n        log: logObj\n      $set:\n        updated: time\n\n    if job?.workTimeout? and job.status is 'running'\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout)\n\n    num = @update(\n      {\n        _id: id\n      }\n      mods\n    )\n    if num is 1\n      return true\n    else\n      console.warn \"jobLog failed\"\n    return false\n\n  _DDPMethod_jobRerun: (id, options) ->\n    check id, Match.Where(_validId)\n    check options, Match.Optional\n      repeats: Match.Optional(Match.Where _validIntGTEZero)\n      until: Match.Optional Date\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n\n    doc = @findOne(\n      {\n        _id: id\n        status: \"completed\"\n      }\n      {\n        fields:\n          result: 0\n          failures: 0\n          log: 0\n          progress: 0\n          updated: 0\n          after: 0\n          status: 0\n        transform: null\n      }\n    )\n\n    if doc?\n      options ?= {}\n      options.repeats ?= 0\n      options.repeats = @forever if options.repeats > @forever\n      options.until ?= doc.repeatUntil\n      options.wait ?= 0\n      return @_rerun_job doc, options.repeats, options.wait, options.until\n\n    return false\n\n  _DDPMethod_jobDone: (id, runId, result, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check result, Object\n    check options, Match.Optional\n      repeatId: Match.Optional Boolean\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n\n    options ?= { repeatId: false }\n    time = new Date()\n    doc = @findOne(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      {\n        fields:\n          log: 0\n          failures: 0\n          updated: 0\n          after: 0\n          status: 0\n        transform: null\n      }\n    )\n    unless doc?\n      unless @isSimulation\n        console.warn \"Running job not found\", id, runId\n      return false\n\n    mods =\n      $set:\n        status: \"completed\"\n        result: result\n        progress:\n          completed: doc.progress.total or 1\n          total: doc.progress.total or 1\n          percent: 100\n        updated: time\n\n    if logObj = @_logMessage.completed runId\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n    if num is 1\n      if doc.repeats > 0\n        if typeof doc.repeatWait is 'number'\n          if doc.repeatUntil - doc.repeatWait >= time\n            jobId = @_rerun_job doc\n        else\n          # This code prevents a job that just ran and finished\n          # instantly from being immediately rerun on the same occurance\n          next = @later?.schedule(doc.repeatWait).next(2)\n          if next and next.length > 0\n            d = new Date(next[0])\n            if (d - time > 500) or (next.length > 1)\n              if d - time <= 500\n                d = new Date(next[1])\n              wait = d - time\n              if doc.repeatUntil - wait >= time\n                jobId = @_rerun_job doc, doc.repeats - 1, wait\n\n      # Resolve depends\n      ids = @find(\n        {\n          depends:\n            $all: [ id ]\n        },\n        {\n          transform: null\n          fields:\n            _id: 1\n        }\n      ).fetch().map (d) => d._id\n\n      if ids.length > 0\n\n        mods =\n          $pull:\n            depends: id\n          $push:\n            resolved: id\n\n        if options.delayDeps?\n          after = new Date(time.valueOf() + options.delayDeps)\n          mods.$max =\n            after: after\n\n        if logObj = @_logMessage.resolved id, runId\n          mods.$push.log = logObj\n\n        n = @update(\n          {\n            _id:\n              $in: ids\n          }\n          mods\n          {\n            multi: true\n          }\n        )\n        if n isnt ids.length\n          console.warn \"Not all dependent jobs were resolved #{ids.length} > #{n}\"\n        # Try to promote any jobs that just had a dependency resolved\n        @_DDPMethod_jobReady ids\n      if options.repeatId and jobId?\n        return jobId\n      else\n        return true\n    else\n      console.warn \"jobDone failed\"\n    return false\n\n  _DDPMethod_jobFail: (id, runId, err, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check err, Object\n    check options, Match.Optional\n      fatal: Match.Optional Boolean\n\n    options ?= {}\n    options.fatal ?= false\n\n    time = new Date()\n    doc = @findOne(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      {\n        fields:\n          log: 0\n          failures: 0\n          progress: 0\n          updated: 0\n          after: 0\n          runId: 0\n          status: 0\n        transform: null\n      }\n    )\n    unless doc?\n      unless @isSimulation\n        console.warn \"Running job not found\", id, runId\n      return false\n\n    after = switch doc.retryBackoff\n      when 'exponential'\n        new Date(time.valueOf() + doc.retryWait*Math.pow(2, doc.retried-1))\n      else\n        new Date(time.valueOf() + doc.retryWait)  # 'constant'\n\n    newStatus = if (not options.fatal and\n                    doc.retries > 0 and\n                    doc.retryUntil >= after) then \"waiting\" else \"failed\"\n\n    err.runId = runId  # Link each failure to the run that generated it.\n\n    mods =\n      $set:\n        status: newStatus\n        runId: null\n        after: after\n        updated: time\n      $push:\n        failures:\n          err\n\n    if logObj = @_logMessage.failed runId, newStatus is 'failed', err\n      mods.$push.log = logObj\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n    if newStatus is \"failed\" and num is 1\n      # Cancel any dependent jobs too\n      @find(\n        {\n          depends:\n            $all: [ id ]\n        },\n        {\n          transform: null\n        }\n      ).forEach (d) => @_DDPMethod_jobCancel d._id\n    if num is 1\n      return true\n    else\n      console.warn \"jobFail failed\"\n    return false\n\n# Share these methods so they'll be available on server and client\n\nshare.JobCollectionBase = JobCollectionBase\n","var JobCollectionBase, _validId, _validIntGTEOne, _validIntGTEZero, _validJobDoc, _validLaterJSObj, _validLog, _validLogLevel, _validNumGTEOne, _validNumGTEZero, _validNumGTZero, _validProgress, _validRetryBackoff, _validStatus,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\n_validNumGTEZero = function(v) {\n  return Match.test(v, Number) && v >= 0.0;\n};\n\n_validNumGTZero = function(v) {\n  return Match.test(v, Number) && v > 0.0;\n};\n\n_validNumGTEOne = function(v) {\n  return Match.test(v, Number) && v >= 1.0;\n};\n\n_validIntGTEZero = function(v) {\n  return _validNumGTEZero(v) && Math.floor(v) === v;\n};\n\n_validIntGTEOne = function(v) {\n  return _validNumGTEOne(v) && Math.floor(v) === v;\n};\n\n_validStatus = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobStatuses, v) >= 0;\n};\n\n_validLogLevel = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobLogLevels, v) >= 0;\n};\n\n_validRetryBackoff = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobRetryBackoffMethods, v) >= 0;\n};\n\n_validId = function(v) {\n  return Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID));\n};\n\n_validLog = function() {\n  return [\n    {\n      time: Date,\n      runId: Match.OneOf(Match.Where(_validId), null),\n      level: Match.Where(_validLogLevel),\n      message: String,\n      data: Match.Optional(Object)\n    }\n  ];\n};\n\n_validProgress = function() {\n  return {\n    completed: Match.Where(_validNumGTEZero),\n    total: Match.Where(_validNumGTEZero),\n    percent: Match.Where(_validNumGTEZero)\n  };\n};\n\n_validLaterJSObj = function() {\n  return {\n    schedules: [Object],\n    exceptions: Match.Optional([Object])\n  };\n};\n\n_validJobDoc = function() {\n  return {\n    _id: Match.Optional(Match.OneOf(Match.Where(_validId), null)),\n    runId: Match.OneOf(Match.Where(_validId), null),\n    type: String,\n    status: Match.Where(_validStatus),\n    data: Object,\n    result: Match.Optional(Object),\n    failures: Match.Optional([Object]),\n    priority: Match.Integer,\n    depends: [Match.Where(_validId)],\n    resolved: [Match.Where(_validId)],\n    after: Date,\n    updated: Date,\n    workTimeout: Match.Optional(Match.Where(_validIntGTEOne)),\n    expiresAfter: Match.Optional(Date),\n    log: Match.Optional(_validLog()),\n    progress: _validProgress(),\n    retries: Match.Where(_validIntGTEZero),\n    retried: Match.Where(_validIntGTEZero),\n    repeatRetries: Match.Optional(Match.Where(_validIntGTEZero)),\n    retryUntil: Date,\n    retryWait: Match.Where(_validIntGTEZero),\n    retryBackoff: Match.Where(_validRetryBackoff),\n    repeats: Match.Where(_validIntGTEZero),\n    repeated: Match.Where(_validIntGTEZero),\n    repeatUntil: Date,\n    repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj)),\n    created: Date\n  };\n};\n\nJobCollectionBase = (function(superClass) {\n  extend(JobCollectionBase, superClass);\n\n  function JobCollectionBase(root, options) {\n    var collectionName;\n    this.root = root != null ? root : 'queue';\n    if (options == null) {\n      options = {};\n    }\n    if (!(this instanceof JobCollectionBase)) {\n      return new JobCollectionBase(this.root, options);\n    }\n    if (!(this instanceof Mongo.Collection)) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.');\n    }\n    if (Mongo.Collection !== Mongo.Collection.prototype.constructor) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592');\n    }\n    this.later = later;\n    if (options.noCollectionSuffix == null) {\n      options.noCollectionSuffix = false;\n    }\n    collectionName = this.root;\n    if (!options.noCollectionSuffix) {\n      collectionName += '.jobs';\n    }\n    delete options.noCollectionSuffix;\n    Job.setDDP(options.connection, this.root);\n    this._createLogEntry = function(message, runId, level, time, data) {\n      var l;\n      if (message == null) {\n        message = '';\n      }\n      if (runId == null) {\n        runId = null;\n      }\n      if (level == null) {\n        level = 'info';\n      }\n      if (time == null) {\n        time = new Date();\n      }\n      if (data == null) {\n        data = null;\n      }\n      l = {\n        time: time,\n        runId: runId,\n        message: message,\n        level: level\n      };\n      return l;\n    };\n    this._logMessage = {\n      'readied': (function() {\n        return this._createLogEntry(\"Promoted to ready\");\n      }).bind(this),\n      'forced': (function(id) {\n        return this._createLogEntry(\"Dependencies force resolved\", null, 'warning');\n      }).bind(this),\n      'rerun': (function(id, runId) {\n        return this._createLogEntry(\"Rerunning job\", null, 'info', new Date(), {\n          previousJob: {\n            id: id,\n            runId: runId\n          }\n        });\n      }).bind(this),\n      'running': (function(runId) {\n        return this._createLogEntry(\"Job Running\", runId);\n      }).bind(this),\n      'paused': (function() {\n        return this._createLogEntry(\"Job Paused\");\n      }).bind(this),\n      'resumed': (function() {\n        return this._createLogEntry(\"Job Resumed\");\n      }).bind(this),\n      'cancelled': (function() {\n        return this._createLogEntry(\"Job Cancelled\", null, 'warning');\n      }).bind(this),\n      'restarted': (function() {\n        return this._createLogEntry(\"Job Restarted\");\n      }).bind(this),\n      'resubmitted': (function() {\n        return this._createLogEntry(\"Job Resubmitted\");\n      }).bind(this),\n      'submitted': (function() {\n        return this._createLogEntry(\"Job Submitted\");\n      }).bind(this),\n      'completed': (function(runId) {\n        return this._createLogEntry(\"Job Completed\", runId, 'success');\n      }).bind(this),\n      'resolved': (function(id, runId) {\n        return this._createLogEntry(\"Dependency resolved\", null, 'info', new Date(), {\n          dependency: {\n            id: id,\n            runId: runId\n          }\n        });\n      }).bind(this),\n      'failed': (function(runId, fatal, err) {\n        var level, msg, value;\n        value = err.value;\n        msg = \"Job Failed with\" + (fatal ? ' Fatal' : '') + \" Error\" + ((value != null) && typeof value === 'string' ? ': ' + value : '') + \".\";\n        level = fatal ? 'danger' : 'warning';\n        return this._createLogEntry(msg, runId, level);\n      }).bind(this)\n    };\n    JobCollectionBase.__super__.constructor.call(this, collectionName, options);\n  }\n\n  JobCollectionBase.prototype._validNumGTEZero = _validNumGTEZero;\n\n  JobCollectionBase.prototype._validNumGTZero = _validNumGTZero;\n\n  JobCollectionBase.prototype._validNumGTEOne = _validNumGTEOne;\n\n  JobCollectionBase.prototype._validIntGTEZero = _validIntGTEZero;\n\n  JobCollectionBase.prototype._validIntGTEOne = _validIntGTEOne;\n\n  JobCollectionBase.prototype._validStatus = _validStatus;\n\n  JobCollectionBase.prototype._validLogLevel = _validLogLevel;\n\n  JobCollectionBase.prototype._validRetryBackoff = _validRetryBackoff;\n\n  JobCollectionBase.prototype._validId = _validId;\n\n  JobCollectionBase.prototype._validLog = _validLog;\n\n  JobCollectionBase.prototype._validProgress = _validProgress;\n\n  JobCollectionBase.prototype._validJobDoc = _validJobDoc;\n\n  JobCollectionBase.prototype.jobLogLevels = Job.jobLogLevels;\n\n  JobCollectionBase.prototype.jobPriorities = Job.jobPriorities;\n\n  JobCollectionBase.prototype.jobStatuses = Job.jobStatuses;\n\n  JobCollectionBase.prototype.jobStatusCancellable = Job.jobStatusCancellable;\n\n  JobCollectionBase.prototype.jobStatusPausable = Job.jobStatusPausable;\n\n  JobCollectionBase.prototype.jobStatusRemovable = Job.jobStatusRemovable;\n\n  JobCollectionBase.prototype.jobStatusRestartable = Job.jobStatusRestartable;\n\n  JobCollectionBase.prototype.forever = Job.forever;\n\n  JobCollectionBase.prototype.foreverDate = Job.foreverDate;\n\n  JobCollectionBase.prototype.ddpMethods = Job.ddpMethods;\n\n  JobCollectionBase.prototype.ddpPermissionLevels = Job.ddpPermissionLevels;\n\n  JobCollectionBase.prototype.ddpMethodPermissions = Job.ddpMethodPermissions;\n\n  JobCollectionBase.prototype.processJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(Job.processJobs, [this.root].concat(slice.call(params)), function(){});\n  };\n\n  JobCollectionBase.prototype.getJob = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJob.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getWork = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getWork.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.readyJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.readyJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.cancelJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.cancelJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.pauseJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.pauseJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.resumeJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.resumeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.restartJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.restartJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.removeJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.removeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.setDDP = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.setDDP.apply(Job, params);\n  };\n\n  JobCollectionBase.prototype.startJobServer = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.shutdownJobServer = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.shutdownJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.startJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.stopJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.stopJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.jobDocPattern = _validJobDoc();\n\n  JobCollectionBase.prototype.allow = function() {\n    throw new Error(\"Server-only function jc.allow() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.deny = function() {\n    throw new Error(\"Server-only function jc.deny() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.promote = function() {\n    throw new Error(\"Server-only function jc.promote() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.setLogStream = function() {\n    throw new Error(\"Server-only function jc.setLogStream() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.logConsole = function() {\n    throw new Error(\"Client-only function jc.logConsole() invoked on server.\");\n  };\n\n  JobCollectionBase.prototype.makeJob = (function() {\n    var dep;\n    dep = false;\n    return function() {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\");\n      }\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Job, [this.root].concat(slice.call(params)), function(){});\n    };\n  })();\n\n  JobCollectionBase.prototype.createJob = (function() {\n    var dep;\n    dep = false;\n    return function() {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\");\n      }\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Job, [this.root].concat(slice.call(params)), function(){});\n    };\n  })();\n\n  JobCollectionBase.prototype._methodWrapper = function(method, func) {\n    var ref, toLog, unblockDDPMethods;\n    toLog = this._toLog;\n    unblockDDPMethods = (ref = this._unblockDDPMethods) != null ? ref : false;\n    return function() {\n      var params, ref1, retval, user;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      user = (ref1 = this.userId) != null ? ref1 : \"[UNAUTHENTICATED]\";\n      toLog(user, method, \"params: \" + JSON.stringify(params));\n      if (unblockDDPMethods) {\n        this.unblock();\n      }\n      retval = func.apply(null, params);\n      toLog(user, method, \"returned: \" + JSON.stringify(retval));\n      return retval;\n    };\n  };\n\n  JobCollectionBase.prototype._generateMethods = function() {\n    var baseMethodName, methodFunc, methodName, methodPrefix, methodsOut, ref;\n    methodsOut = {};\n    methodPrefix = '_DDPMethod_';\n    ref = this;\n    for (methodName in ref) {\n      methodFunc = ref[methodName];\n      if (!(methodName.slice(0, methodPrefix.length) === methodPrefix)) {\n        continue;\n      }\n      baseMethodName = methodName.slice(methodPrefix.length);\n      methodsOut[this.root + \"_\" + baseMethodName] = this._methodWrapper(baseMethodName, methodFunc.bind(this));\n    }\n    return methodsOut;\n  };\n\n  JobCollectionBase.prototype._idsOfDeps = function(ids, antecedents, dependents, jobStatuses) {\n    var antsArray, dependsIds, dependsQuery;\n    dependsQuery = [];\n    dependsIds = [];\n    if (dependents) {\n      dependsQuery.push({\n        depends: {\n          $elemMatch: {\n            $in: ids\n          }\n        }\n      });\n    }\n    if (antecedents) {\n      antsArray = [];\n      this.find({\n        _id: {\n          $in: ids\n        }\n      }, {\n        fields: {\n          depends: 1\n        },\n        transform: null\n      }).forEach(function(d) {\n        var i, k, len, ref, results;\n        if (indexOf.call(antsArray, i) < 0) {\n          ref = d.depends;\n          results = [];\n          for (k = 0, len = ref.length; k < len; k++) {\n            i = ref[k];\n            results.push(antsArray.push(i));\n          }\n          return results;\n        }\n      });\n      if (antsArray.length > 0) {\n        dependsQuery.push({\n          _id: {\n            $in: antsArray\n          }\n        });\n      }\n    }\n    if (dependsQuery.length > 0) {\n      this.find({\n        status: {\n          $in: jobStatuses\n        },\n        $or: dependsQuery\n      }, {\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).forEach(function(d) {\n        var ref;\n        if (ref = d._id, indexOf.call(dependsIds, ref) < 0) {\n          return dependsIds.push(d._id);\n        }\n      });\n    }\n    return dependsIds;\n  };\n\n  JobCollectionBase.prototype._rerun_job = function(doc, repeats, wait, repeatUntil) {\n    var id, jobId, logObj, runId, time;\n    if (repeats == null) {\n      repeats = doc.repeats - 1;\n    }\n    if (wait == null) {\n      wait = doc.repeatWait;\n    }\n    if (repeatUntil == null) {\n      repeatUntil = doc.repeatUntil;\n    }\n    id = doc._id;\n    runId = doc.runId;\n    time = new Date();\n    delete doc._id;\n    delete doc.result;\n    delete doc.failures;\n    delete doc.expiresAfter;\n    delete doc.workTimeout;\n    doc.runId = null;\n    doc.status = \"waiting\";\n    doc.repeatRetries = doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried;\n    doc.retries = doc.repeatRetries;\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n    doc.retryUntil = repeatUntil;\n    doc.retried = 0;\n    doc.repeats = repeats;\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n    doc.repeatUntil = repeatUntil;\n    doc.repeated = doc.repeated + 1;\n    doc.updated = time;\n    doc.created = time;\n    doc.progress = {\n      completed: 0,\n      total: 1,\n      percent: 0\n    };\n    if (logObj = this._logMessage.rerun(id, runId)) {\n      doc.log = [logObj];\n    } else {\n      doc.log = [];\n    }\n    doc.after = new Date(time.valueOf() + wait);\n    if (jobId = this.insert(doc)) {\n      this._DDPMethod_jobReady(jobId);\n      return jobId;\n    } else {\n      console.warn(\"Job rerun/repeat failed to reschedule!\", id, runId);\n    }\n    return null;\n  };\n\n  JobCollectionBase.prototype._checkDeps = function(job, dryRun) {\n    var cancel, cancelled, depJob, deps, failed, foundIds, j, k, len, len1, log, m, mods, n, ref, ref1, removed, resolved;\n    if (dryRun == null) {\n      dryRun = true;\n    }\n    cancel = false;\n    resolved = [];\n    failed = [];\n    cancelled = [];\n    removed = [];\n    log = [];\n    if (job.depends.length > 0) {\n      deps = this.find({\n        _id: {\n          $in: job.depends\n        }\n      }, {\n        fields: {\n          _id: 1,\n          runId: 1,\n          status: 1\n        }\n      }).fetch();\n      if (deps.length !== job.depends.length) {\n        foundIds = deps.map(function(d) {\n          return d._id;\n        });\n        ref = job.depends;\n        for (k = 0, len = ref.length; k < len; k++) {\n          j = ref[k];\n          if (!(!(indexOf.call(foundIds, j) >= 0))) {\n            continue;\n          }\n          if (!dryRun) {\n            this._DDPMethod_jobLog(job._id, null, \"Antecedent job \" + j + \" missing at save\");\n          }\n          removed.push(j);\n        }\n        cancel = true;\n      }\n      for (m = 0, len1 = deps.length; m < len1; m++) {\n        depJob = deps[m];\n        if (ref1 = depJob.status, indexOf.call(this.jobStatusCancellable, ref1) < 0) {\n          switch (depJob.status) {\n            case \"completed\":\n              resolved.push(depJob._id);\n              log.push(this._logMessage.resolved(depJob._id, depJob.runId));\n              break;\n            case \"failed\":\n              cancel = true;\n              failed.push(depJob._id);\n              if (!dryRun) {\n                this._DDPMethod_jobLog(job._id, null, \"Antecedent job failed before save\");\n              }\n              break;\n            case \"cancelled\":\n              cancel = true;\n              cancelled.push(depJob._id);\n              if (!dryRun) {\n                this._DDPMethod_jobLog(job._id, null, \"Antecedent job cancelled before save\");\n              }\n              break;\n            default:\n              throw new Meteor.Error(\"Unknown status in jobSave Dependency check\");\n          }\n        }\n      }\n      if (!(resolved.length === 0 || dryRun)) {\n        mods = {\n          $pull: {\n            depends: {\n              $in: resolved\n            }\n          },\n          $push: {\n            resolved: {\n              $each: resolved\n            },\n            log: {\n              $each: log\n            }\n          }\n        };\n        n = this.update({\n          _id: job._id,\n          status: 'waiting'\n        }, mods);\n        if (!n) {\n          console.warn(\"Update for job \" + job._id + \" during dependency check failed.\");\n        }\n      }\n      if (cancel && !dryRun) {\n        this._DDPMethod_jobCancel(job._id);\n        return false;\n      }\n    }\n    if (dryRun) {\n      if (cancel || resolved.length > 0) {\n        return {\n          jobId: job._id,\n          resolved: resolved,\n          failed: failed,\n          cancelled: cancelled,\n          removed: removed\n        };\n      } else {\n        return false;\n      }\n    } else {\n      return true;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobServer = function(options) {\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n      this.stopped = false;\n    }\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobs = (function() {\n    var depFlag;\n    depFlag = false;\n    return function(options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\");\n      }\n      return this._DDPMethod_startJobServer(options);\n    };\n  })();\n\n  JobCollectionBase.prototype._DDPMethod_shutdownJobServer = function(options) {\n    check(options, Match.Optional({\n      timeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n      this.stopped = Meteor.setTimeout((function(_this) {\n        return function() {\n          var cursor, failedJobs;\n          cursor = _this.find({\n            status: 'running'\n          }, {\n            transform: null\n          });\n          failedJobs = cursor.count();\n          if (failedJobs !== 0) {\n            console.warn(\"Failing \" + failedJobs + \" jobs on queue stop.\");\n          }\n          cursor.forEach(function(d) {\n            return _this._DDPMethod_jobFail(d._id, d.runId, \"Running at Job Server shutdown.\");\n          });\n          if (_this.logStream != null) {\n            _this.logStream.end();\n            return _this.logStream = null;\n          }\n        };\n      })(this), options.timeout);\n    }\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_stopJobs = (function() {\n    var depFlag;\n    depFlag = false;\n    return function(options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\");\n      }\n      return this._DDPMethod_shutdownJobServer(options);\n    };\n  })();\n\n  JobCollectionBase.prototype._DDPMethod_getJob = function(ids, options) {\n    var d, docs, fields, single;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      getLog: Match.Optional(Boolean),\n      getFailures: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n    if (options.getFailures == null) {\n      options.getFailures = false;\n    }\n    single = false;\n    if (_validId(ids)) {\n      ids = [ids];\n      single = true;\n    }\n    if (ids.length === 0) {\n      return null;\n    }\n    fields = {\n      _private: 0\n    };\n    if (!options.getLog) {\n      fields.log = 0;\n    }\n    if (!options.getFailures) {\n      fields.failures = 0;\n    }\n    docs = this.find({\n      _id: {\n        $in: ids\n      }\n    }, {\n      fields: fields,\n      transform: null\n    }).fetch();\n    if (docs != null ? docs.length : void 0) {\n      if (this.scrub != null) {\n        docs = (function() {\n          var k, len, results;\n          results = [];\n          for (k = 0, len = docs.length; k < len; k++) {\n            d = docs[k];\n            results.push(this.scrub(d));\n          }\n          return results;\n        }).call(this);\n      }\n      check(docs, [_validJobDoc()]);\n      if (single) {\n        return docs[0];\n      } else {\n        return docs;\n      }\n    }\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_getWork = function(type, options) {\n    var d, docs, foundDocs, ids, logObj, mods, num, runId, time;\n    check(type, Match.OneOf(String, [String]));\n    check(options, Match.Optional({\n      maxJobs: Match.Optional(Match.Where(_validIntGTEOne)),\n      workTimeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n    if (this.isSimulation) {\n      return;\n    }\n    if (options == null) {\n      options = {};\n    }\n    if (options.maxJobs == null) {\n      options.maxJobs = 1;\n    }\n    if (this.stopped) {\n      return [];\n    }\n    if (typeof type === 'string') {\n      type = [type];\n    }\n    time = new Date();\n    docs = [];\n    runId = this._makeNewID();\n    while (docs.length < options.maxJobs) {\n      ids = this.find({\n        type: {\n          $in: type\n        },\n        status: 'ready',\n        runId: null\n      }, {\n        sort: {\n          priority: 1,\n          retryUntil: 1,\n          after: 1\n        },\n        limit: options.maxJobs - docs.length,\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).map(function(d) {\n        return d._id;\n      });\n      if (!((ids != null ? ids.length : void 0) > 0)) {\n        break;\n      }\n      mods = {\n        $set: {\n          status: 'running',\n          runId: runId,\n          updated: time\n        },\n        $inc: {\n          retries: -1,\n          retried: 1\n        }\n      };\n      if (logObj = this._logMessage.running(runId)) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n      if (options.workTimeout != null) {\n        mods.$set.workTimeout = options.workTimeout;\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout);\n      } else {\n        if (mods.$unset == null) {\n          mods.$unset = {};\n        }\n        mods.$unset.workTimeout = \"\";\n        mods.$unset.expiresAfter = \"\";\n      }\n      num = this.update({\n        _id: {\n          $in: ids\n        },\n        status: 'ready',\n        runId: null\n      }, mods, {\n        multi: true\n      });\n      if (num > 0) {\n        foundDocs = this.find({\n          _id: {\n            $in: ids\n          },\n          runId: runId\n        }, {\n          fields: {\n            log: 0,\n            failures: 0,\n            _private: 0\n          },\n          transform: null\n        }).fetch();\n        if ((foundDocs != null ? foundDocs.length : void 0) > 0) {\n          if (this.scrub != null) {\n            foundDocs = (function() {\n              var k, len, results;\n              results = [];\n              for (k = 0, len = foundDocs.length; k < len; k++) {\n                d = foundDocs[k];\n                results.push(this.scrub(d));\n              }\n              return results;\n            }).call(this);\n          }\n          check(docs, [_validJobDoc()]);\n          docs = docs.concat(foundDocs);\n        }\n      }\n    }\n    return docs;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRemove = function(ids, options) {\n    var num;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    num = this.remove({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRemovable\n      }\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobRemove failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobPause = function(ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"paused\",\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.paused()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusPausable\n      }\n    }, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobPause failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobResume = function(ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"waiting\",\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.resumed()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: \"paused\",\n      updated: {\n        $ne: time\n      }\n    }, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      this._DDPMethod_jobReady(ids);\n      return true;\n    } else {\n      console.warn(\"jobResume failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobReady = function(ids, options) {\n    var l, logObj, mods, now, num, query;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      force: Match.Optional(Boolean),\n      time: Match.Optional(Date)\n    }));\n    if (this.isSimulation) {\n      return;\n    }\n    now = new Date();\n    if (options == null) {\n      options = {};\n    }\n    if (options.force == null) {\n      options.force = false;\n    }\n    if (options.time == null) {\n      options.time = now;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    query = {\n      status: \"waiting\",\n      after: {\n        $lte: options.time\n      }\n    };\n    mods = {\n      $set: {\n        status: \"ready\",\n        updated: now\n      }\n    };\n    if (ids.length > 0) {\n      query._id = {\n        $in: ids\n      };\n      mods.$set.after = now;\n    }\n    logObj = [];\n    if (options.force) {\n      mods.$set.depends = [];\n      l = this._logMessage.forced();\n      if (l) {\n        logObj.push(l);\n      }\n    } else {\n      query.depends = {\n        $size: 0\n      };\n    }\n    l = this._logMessage.readied();\n    if (l) {\n      logObj.push(l);\n    }\n    if (logObj.length > 0) {\n      mods.$push = {\n        log: {\n          $each: logObj\n        }\n      };\n    }\n    num = this.update(query, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobCancel = function(ids, options) {\n    var cancelIds, depsCancelled, logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.antecedents == null) {\n      options.antecedents = false;\n    }\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"cancelled\",\n        runId: null,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.cancelled()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusCancellable\n      }\n    }, mods, {\n      multi: true\n    });\n    cancelIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusCancellable);\n    depsCancelled = false;\n    if (cancelIds.length > 0) {\n      depsCancelled = this._DDPMethod_jobCancel(cancelIds, options);\n    }\n    if (num > 0 || depsCancelled) {\n      return true;\n    } else {\n      console.warn(\"jobCancel failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRestart = function(ids, options) {\n    var depsRestarted, logObj, mods, num, query, restartIds, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      retries: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n    if (options.retries > this.forever) {\n      options.retries = this.forever;\n    }\n    if (options.dependents == null) {\n      options.dependents = false;\n    }\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    query = {\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRestartable\n      }\n    };\n    mods = {\n      $set: {\n        status: \"waiting\",\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $inc: {\n        retries: options.retries\n      }\n    };\n    if (logObj = this._logMessage.restarted()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    if (options.until != null) {\n      mods.$set.retryUntil = options.until;\n    }\n    num = this.update(query, mods, {\n      multi: true\n    });\n    restartIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusRestartable);\n    depsRestarted = false;\n    if (restartIds.length > 0) {\n      depsRestarted = this._DDPMethod_jobRestart(restartIds, options);\n    }\n    if (num > 0 || depsRestarted) {\n      this._DDPMethod_jobReady(ids);\n      return true;\n    } else {\n      console.warn(\"jobRestart failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobSave = function(doc, options) {\n    var logObj, mods, next, nextDate, num, ref, schedule, time;\n    check(doc, _validJobDoc());\n    check(options, Match.Optional({\n      cancelRepeats: Match.Optional(Boolean)\n    }));\n    check(doc.status, Match.Where(function(v) {\n      return Match.test(v, String) && (v === 'waiting' || v === 'paused');\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.cancelRepeats == null) {\n      options.cancelRepeats = false;\n    }\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n    time = new Date();\n    if (doc.after < time) {\n      doc.after = time;\n    }\n    if (doc.retryUntil < time) {\n      doc.retryUntil = time;\n    }\n    if (doc.repeatUntil < time) {\n      doc.repeatUntil = time;\n    }\n    if ((this.later != null) && typeof doc.repeatWait !== 'number') {\n      schedule = (ref = this.later) != null ? ref.schedule(doc.repeatWait) : void 0;\n      if (!(schedule && (next = schedule.next(2, schedule.prev(1, doc.after))[1]))) {\n        console.warn(\"No valid available later.js times in schedule after \" + doc.after);\n        return null;\n      }\n      nextDate = new Date(next);\n      if (!(nextDate <= doc.repeatUntil)) {\n        console.warn(\"No valid available later.js times in schedule before \" + doc.repeatUntil);\n        return null;\n      }\n      doc.after = nextDate;\n    } else if ((this.later == null) && doc.repeatWait !== 'number') {\n      console.warn(\"Later.js not loaded...\");\n      return null;\n    }\n    if (doc._id) {\n      mods = {\n        $set: {\n          status: 'waiting',\n          data: doc.data,\n          retries: doc.retries,\n          repeatRetries: doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried,\n          retryUntil: doc.retryUntil,\n          retryWait: doc.retryWait,\n          retryBackoff: doc.retryBackoff,\n          repeats: doc.repeats,\n          repeatUntil: doc.repeatUntil,\n          repeatWait: doc.repeatWait,\n          depends: doc.depends,\n          priority: doc.priority,\n          after: doc.after,\n          updated: time\n        }\n      };\n      if (logObj = this._logMessage.resubmitted()) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n      num = this.update({\n        _id: doc._id,\n        status: 'paused',\n        runId: null\n      }, mods);\n      if (num && this._checkDeps(doc, false)) {\n        this._DDPMethod_jobReady(doc._id);\n        return doc._id;\n      } else {\n        return null;\n      }\n    } else {\n      if (doc.repeats === this.forever && options.cancelRepeats) {\n        this.find({\n          type: doc.type,\n          status: {\n            $in: this.jobStatusCancellable\n          }\n        }, {\n          transform: null\n        }).forEach((function(_this) {\n          return function(d) {\n            return _this._DDPMethod_jobCancel(d._id, {});\n          };\n        })(this));\n      }\n      doc.created = time;\n      doc.log.push(this._logMessage.submitted());\n      doc._id = this.insert(doc);\n      if (doc._id && this._checkDeps(doc, false)) {\n        this._DDPMethod_jobReady(doc._id);\n        return doc._id;\n      } else {\n        return null;\n      }\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobProgress = function(id, runId, completed, total, options) {\n    var job, mods, num, progress, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(completed, Match.Where(_validNumGTEZero));\n    check(total, Match.Where(_validNumGTZero));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (this.stopped) {\n      return null;\n    }\n    progress = {\n      completed: completed,\n      total: total,\n      percent: 100 * completed / total\n    };\n    check(progress, Match.Where(function(v) {\n      var ref;\n      return v.total >= v.completed && (0 <= (ref = v.percent) && ref <= 100);\n    }));\n    time = new Date();\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $set: {\n        progress: progress,\n        updated: time\n      }\n    };\n    if ((job != null ? job.workTimeout : void 0) != null) {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobProgress failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobLog = function(id, runId, message, options) {\n    var job, logObj, mods, num, ref, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.OneOf(Match.Where(_validId), null));\n    check(message, String);\n    check(options, Match.Optional({\n      level: Match.Optional(Match.Where(_validLogLevel)),\n      data: Match.Optional(Object)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    time = new Date();\n    logObj = {\n      time: time,\n      runId: runId,\n      level: (ref = options.level) != null ? ref : 'info',\n      message: message\n    };\n    if (options.data != null) {\n      logObj.data = options.data;\n    }\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        status: 1,\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $push: {\n        log: logObj\n      },\n      $set: {\n        updated: time\n      }\n    };\n    if (((job != null ? job.workTimeout : void 0) != null) && job.status === 'running') {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n    num = this.update({\n      _id: id\n    }, mods);\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobLog failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRerun = function(id, options) {\n    var doc;\n    check(id, Match.Where(_validId));\n    check(options, Match.Optional({\n      repeats: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n    }));\n    doc = this.findOne({\n      _id: id,\n      status: \"completed\"\n    }, {\n      fields: {\n        result: 0,\n        failures: 0,\n        log: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc != null) {\n      if (options == null) {\n        options = {};\n      }\n      if (options.repeats == null) {\n        options.repeats = 0;\n      }\n      if (options.repeats > this.forever) {\n        options.repeats = this.forever;\n      }\n      if (options.until == null) {\n        options.until = doc.repeatUntil;\n      }\n      if (options.wait == null) {\n        options.wait = 0;\n      }\n      return this._rerun_job(doc, options.repeats, options.wait, options.until);\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobDone = function(id, runId, result, options) {\n    var after, d, doc, ids, jobId, logObj, mods, n, next, num, ref, time, wait;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(result, Object);\n    check(options, Match.Optional({\n      repeatId: Match.Optional(Boolean),\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n    }));\n    if (options == null) {\n      options = {\n        repeatId: false\n      };\n    }\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n      return false;\n    }\n    mods = {\n      $set: {\n        status: \"completed\",\n        result: result,\n        progress: {\n          completed: doc.progress.total || 1,\n          total: doc.progress.total || 1,\n          percent: 100\n        },\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.completed(runId)) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (num === 1) {\n      if (doc.repeats > 0) {\n        if (typeof doc.repeatWait === 'number') {\n          if (doc.repeatUntil - doc.repeatWait >= time) {\n            jobId = this._rerun_job(doc);\n          }\n        } else {\n          next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(2) : void 0;\n          if (next && next.length > 0) {\n            d = new Date(next[0]);\n            if ((d - time > 500) || (next.length > 1)) {\n              if (d - time <= 500) {\n                d = new Date(next[1]);\n              }\n              wait = d - time;\n              if (doc.repeatUntil - wait >= time) {\n                jobId = this._rerun_job(doc, doc.repeats - 1, wait);\n              }\n            }\n          }\n        }\n      }\n      ids = this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null,\n        fields: {\n          _id: 1\n        }\n      }).fetch().map((function(_this) {\n        return function(d) {\n          return d._id;\n        };\n      })(this));\n      if (ids.length > 0) {\n        mods = {\n          $pull: {\n            depends: id\n          },\n          $push: {\n            resolved: id\n          }\n        };\n        if (options.delayDeps != null) {\n          after = new Date(time.valueOf() + options.delayDeps);\n          mods.$max = {\n            after: after\n          };\n        }\n        if (logObj = this._logMessage.resolved(id, runId)) {\n          mods.$push.log = logObj;\n        }\n        n = this.update({\n          _id: {\n            $in: ids\n          }\n        }, mods, {\n          multi: true\n        });\n        if (n !== ids.length) {\n          console.warn(\"Not all dependent jobs were resolved \" + ids.length + \" > \" + n);\n        }\n        this._DDPMethod_jobReady(ids);\n      }\n      if (options.repeatId && (jobId != null)) {\n        return jobId;\n      } else {\n        return true;\n      }\n    } else {\n      console.warn(\"jobDone failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobFail = function(id, runId, err, options) {\n    var after, doc, logObj, mods, newStatus, num, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(err, Object);\n    check(options, Match.Optional({\n      fatal: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        runId: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n      return false;\n    }\n    after = (function() {\n      switch (doc.retryBackoff) {\n        case 'exponential':\n          return new Date(time.valueOf() + doc.retryWait * Math.pow(2, doc.retried - 1));\n        default:\n          return new Date(time.valueOf() + doc.retryWait);\n      }\n    })();\n    newStatus = (!options.fatal && doc.retries > 0 && doc.retryUntil >= after) ? \"waiting\" : \"failed\";\n    err.runId = runId;\n    mods = {\n      $set: {\n        status: newStatus,\n        runId: null,\n        after: after,\n        updated: time\n      },\n      $push: {\n        failures: err\n      }\n    };\n    if (logObj = this._logMessage.failed(runId, newStatus === 'failed', err)) {\n      mods.$push.log = logObj;\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (newStatus === \"failed\" && num === 1) {\n      this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null\n      }).forEach((function(_this) {\n        return function(d) {\n          return _this._DDPMethod_jobCancel(d._id);\n        };\n      })(this));\n    }\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobFail failed\");\n    }\n    return false;\n  };\n\n  return JobCollectionBase;\n\n})(Mongo.Collection);\n\nshare.JobCollectionBase = JobCollectionBase;\n"]}}