{"metadata":{"usedHelpers":["extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"../lib/applyProps.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"applyProps"}]},{"source":"./aggregateSearchFilters.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"AggregateFilters"}]},{"source":"./assembler.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"assemble"}]},{"source":"./assembleAggregateResults.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"assembleAggregateResults"}]},{"source":"./buildAggregatePipeline.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"buildAggregatePipeline"}]},{"source":"./lib/snapBackDottedFields","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"snapBackDottedFields"}]}],"exports":{"exported":["storeHypernovaResults","childCollectionNode","userId"],"specifiers":[{"kind":"local","local":"storeHypernovaResults","exported":"default"},{"kind":"local","local":"childCollectionNode","exported":"default"},{"kind":"local","local":"userId","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"storeHypernovaResults"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n    default: () => storeHypernovaResults\n});\nlet applyProps;\nmodule.watch(require(\"../lib/applyProps.js\"), {\n    default(v) {\n        applyProps = v;\n    }\n\n}, 0);\nlet AggregateFilters;\nmodule.watch(require(\"./aggregateSearchFilters.js\"), {\n    default(v) {\n        AggregateFilters = v;\n    }\n\n}, 1);\nlet assemble;\nmodule.watch(require(\"./assembler.js\"), {\n    default(v) {\n        assemble = v;\n    }\n\n}, 2);\nlet assembleAggregateResults;\nmodule.watch(require(\"./assembleAggregateResults.js\"), {\n    default(v) {\n        assembleAggregateResults = v;\n    }\n\n}, 3);\nlet buildAggregatePipeline;\nmodule.watch(require(\"./buildAggregatePipeline.js\"), {\n    default(v) {\n        buildAggregatePipeline = v;\n    }\n\n}, 4);\nlet snapBackDottedFields;\nmodule.watch(require(\"./lib/snapBackDottedFields\"), {\n    default(v) {\n        snapBackDottedFields = v;\n    }\n\n}, 5);\n\nfunction storeHypernovaResults(childCollectionNode, userId) {\n    if (childCollectionNode.parent.results.length === 0) {\n        return childCollectionNode.results = [];\n    }\n\n    let {\n        filters,\n        options\n    } = applyProps(childCollectionNode);\n    const metaFilters = filters.$meta;\n    const aggregateFilters = new AggregateFilters(childCollectionNode, metaFilters);\n    delete filters.$meta;\n    const linker = childCollectionNode.linker;\n    const isVirtual = linker.isVirtual();\n    const collection = childCollectionNode.collection;\n\n    _.extend(filters, aggregateFilters.create()); // if it's not virtual then we retrieve them and assemble them here.\n\n\n    if (!isVirtual) {\n        const filteredOptions = _.omit(options, 'limit');\n\n        childCollectionNode.results = collection.find(filters, filteredOptions, userId).fetch();\n        assemble(childCollectionNode, (0, _extends3.default)({}, options, {\n            metaFilters\n        }));\n    } else {\n        // virtuals arrive here\n        let {\n            pipeline,\n            containsDottedFields\n        } = buildAggregatePipeline(childCollectionNode, filters, options, userId);\n        let aggregateResults = collection.aggregate(pipeline, {\n            explains: true\n        }); /**\n             * If in aggregation it contains '.', we replace it with a custom string '___'\n             * And then after aggregation is complete we need to snap-it back to how it was.\n             */\n\n        if (containsDottedFields) {\n            snapBackDottedFields(aggregateResults);\n        }\n\n        assembleAggregateResults(childCollectionNode, aggregateResults, metaFilters);\n    }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js"],"names":["module","export","default","storeHypernovaResults","applyProps","watch","require","v","AggregateFilters","assemble","assembleAggregateResults","buildAggregatePipeline","snapBackDottedFields","childCollectionNode","userId","parent","results","length","filters","options","metaFilters","$meta","aggregateFilters","linker","isVirtual","collection","_","extend","create","filteredOptions","omit","find","fetch","pipeline","containsDottedFields","aggregateResults","aggregate","explains"],"mappings":";;;;;;AAAAA,OAAOC,MAAP,CAAc;AAACC,aAAQ,MAAIC;AAAb,CAAd;AAAmD,IAAIC,UAAJ;AAAeJ,OAAOK,KAAP,CAAaC,QAAQ,sBAAR,CAAb,EAA6C;AAACJ,YAAQK,CAAR,EAAU;AAACH,qBAAWG,CAAX;AAAa;;AAAzB,CAA7C,EAAwE,CAAxE;AAA2E,IAAIC,gBAAJ;AAAqBR,OAAOK,KAAP,CAAaC,QAAQ,6BAAR,CAAb,EAAoD;AAACJ,YAAQK,CAAR,EAAU;AAACC,2BAAiBD,CAAjB;AAAmB;;AAA/B,CAApD,EAAqF,CAArF;AAAwF,IAAIE,QAAJ;AAAaT,OAAOK,KAAP,CAAaC,QAAQ,gBAAR,CAAb,EAAuC;AAACJ,YAAQK,CAAR,EAAU;AAACE,mBAASF,CAAT;AAAW;;AAAvB,CAAvC,EAAgE,CAAhE;AAAmE,IAAIG,wBAAJ;AAA6BV,OAAOK,KAAP,CAAaC,QAAQ,+BAAR,CAAb,EAAsD;AAACJ,YAAQK,CAAR,EAAU;AAACG,mCAAyBH,CAAzB;AAA2B;;AAAvC,CAAtD,EAA+F,CAA/F;AAAkG,IAAII,sBAAJ;AAA2BX,OAAOK,KAAP,CAAaC,QAAQ,6BAAR,CAAb,EAAoD;AAACJ,YAAQK,CAAR,EAAU;AAACI,iCAAuBJ,CAAvB;AAAyB;;AAArC,CAApD,EAA2F,CAA3F;AAA8F,IAAIK,oBAAJ;AAAyBZ,OAAOK,KAAP,CAAaC,QAAQ,4BAAR,CAAb,EAAmD;AAACJ,YAAQK,CAAR,EAAU;AAACK,+BAAqBL,CAArB;AAAuB;;AAAnC,CAAnD,EAAwF,CAAxF;;AAO5kB,SAASJ,qBAAT,CAA+BU,mBAA/B,EAAoDC,MAApD,EAA4D;AACvE,QAAID,oBAAoBE,MAApB,CAA2BC,OAA3B,CAAmCC,MAAnC,KAA8C,CAAlD,EAAqD;AACjD,eAAOJ,oBAAoBG,OAApB,GAA8B,EAArC;AACH;;AAED,QAAI;AAACE,eAAD;AAAUC;AAAV,QAAqBf,WAAWS,mBAAX,CAAzB;AAEA,UAAMO,cAAcF,QAAQG,KAA5B;AACA,UAAMC,mBAAmB,IAAId,gBAAJ,CAAqBK,mBAArB,EAA0CO,WAA1C,CAAzB;AACA,WAAOF,QAAQG,KAAf;AAEA,UAAME,SAASV,oBAAoBU,MAAnC;AACA,UAAMC,YAAYD,OAAOC,SAAP,EAAlB;AACA,UAAMC,aAAaZ,oBAAoBY,UAAvC;;AAEAC,MAAEC,MAAF,CAAST,OAAT,EAAkBI,iBAAiBM,MAAjB,EAAlB,EAfuE,CAiBvE;;;AACA,QAAI,CAACJ,SAAL,EAAgB;AACZ,cAAMK,kBAAkBH,EAAEI,IAAF,CAAOX,OAAP,EAAgB,OAAhB,CAAxB;;AAEAN,4BAAoBG,OAApB,GAA8BS,WAAWM,IAAX,CAAgBb,OAAhB,EAAyBW,eAAzB,EAA0Cf,MAA1C,EAAkDkB,KAAlD,EAA9B;AAEAvB,iBAASI,mBAAT,6BACOM,OADP;AAEIC;AAFJ;AAIH,KATD,MASO;AACH;AACA,YAAI;AAACa,oBAAD;AAAWC;AAAX,YAAmCvB,uBAAuBE,mBAAvB,EAA4CK,OAA5C,EAAqDC,OAArD,EAA8DL,MAA9D,CAAvC;AAEA,YAAIqB,mBAAmBV,WAAWW,SAAX,CAAqBH,QAArB,EAA+B;AAACI,sBAAU;AAAX,SAA/B,CAAvB,CAJG,CAMH;;;;;AAIA,YAAIH,oBAAJ,EAA0B;AACtBtB,iCAAqBuB,gBAArB;AACH;;AAEDzB,iCAAyBG,mBAAzB,EAA8CsB,gBAA9C,EAAgEf,WAAhE;AACH;AACJ","file":"packages/cultofcoders:grapher/lib/query/hypernova/storeHypernovaResults.js.map","sourcesContent":["import applyProps from '../lib/applyProps.js';\nimport AggregateFilters from './aggregateSearchFilters.js';\nimport assemble from './assembler.js';\nimport assembleAggregateResults from './assembleAggregateResults.js';\nimport buildAggregatePipeline from './buildAggregatePipeline.js';\nimport snapBackDottedFields from './lib/snapBackDottedFields';\n\nexport default function storeHypernovaResults(childCollectionNode, userId) {\n    if (childCollectionNode.parent.results.length === 0) {\n        return childCollectionNode.results = [];\n    }\n\n    let {filters, options} = applyProps(childCollectionNode);\n\n    const metaFilters = filters.$meta;\n    const aggregateFilters = new AggregateFilters(childCollectionNode, metaFilters);\n    delete filters.$meta;\n\n    const linker = childCollectionNode.linker;\n    const isVirtual = linker.isVirtual();\n    const collection = childCollectionNode.collection;\n\n    _.extend(filters, aggregateFilters.create());\n\n    // if it's not virtual then we retrieve them and assemble them here.\n    if (!isVirtual) {\n        const filteredOptions = _.omit(options, 'limit');\n\n        childCollectionNode.results = collection.find(filters, filteredOptions, userId).fetch();\n\n        assemble(childCollectionNode, {\n            ...options,\n            metaFilters\n        });\n    } else {\n        // virtuals arrive here\n        let {pipeline, containsDottedFields} = buildAggregatePipeline(childCollectionNode, filters, options, userId);\n\n        let aggregateResults = collection.aggregate(pipeline, {explains: true});\n\n        /**\n         * If in aggregation it contains '.', we replace it with a custom string '___'\n         * And then after aggregation is complete we need to snap-it back to how it was.\n         */\n        if (containsDottedFields) {\n            snapBackDottedFields(aggregateResults);\n        }\n\n        assembleAggregateResults(childCollectionNode, aggregateResults, metaFilters);\n    }\n}\n"]},"hash":"424075c1329dc4da193b36b8aac51a6095fbe26c"}
