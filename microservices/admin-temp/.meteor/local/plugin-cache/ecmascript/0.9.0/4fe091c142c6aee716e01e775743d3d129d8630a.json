{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]},{"source":"./lib/cleanObjectForMetaFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanObjectForMetaFilters"}]}],"exports":{"exported":["childCollectionNode","aggregateResults","metaFilters"],"specifiers":[{"kind":"local","local":"childCollectionNode","exported":"default"},{"kind":"local","local":"aggregateResults","exported":"default"},{"kind":"local","local":"metaFilters","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"assembleAggregateResults"},"ignored":false,"code":"var sift = void 0;\nmodule.watch(require(\"sift\"), {\n    \"default\": function (v) {\n        sift = v;\n    }\n}, 0);\nvar cleanObjectForMetaFilters = void 0;\nmodule.watch(require(\"./lib/cleanObjectForMetaFilters\"), {\n    \"default\": function (v) {\n        cleanObjectForMetaFilters = v;\n    }\n}, 1);\nmodule.exportDefault(function (childCollectionNode, aggregateResults, metaFilters) {\n    var linker = childCollectionNode.linker;\n    var linkStorageField = linker.linkStorageField;\n    var linkName = childCollectionNode.linkName;\n    var isMeta = linker.isMeta();\n    var allResults = [];\n\n    if (isMeta && metaFilters) {\n        var metaFiltersTest = sift(metaFilters);\n\n        _.each(childCollectionNode.parent.results, function (parentResult) {\n            cleanObjectForMetaFilters(parentResult, linkStorageField, metaFiltersTest);\n        });\n    }\n\n    if (isMeta && linker.isMany()) {\n        // This case is treated differently because we get an array response from the pipeline.\n        _.each(childCollectionNode.parent.results, function (parentResult) {\n            parentResult[linkName] = parentResult[linkName] || [];\n\n            var eligibleAggregateResults = _.filter(aggregateResults, function (aggregateResult) {\n                return _.contains(aggregateResult._id, parentResult._id);\n            });\n\n            if (eligibleAggregateResults.length) {\n                var datas = _.pluck(eligibleAggregateResults, 'data'); /// [ [x1, x2], [x2, x3] ]\n\n\n                _.each(datas, function (data) {\n                    _.each(data, function (item) {\n                        parentResult[linkName].push(item);\n                    });\n                });\n            }\n        });\n\n        _.each(aggregateResults, function (aggregateResult) {\n            _.each(aggregateResult.data, function (item) {\n                return allResults.push(item);\n            });\n        });\n    } else {\n        _.each(aggregateResults, function (aggregateResult) {\n            var parentResult = _.find(childCollectionNode.parent.results, function (result) {\n                return result._id == aggregateResult._id;\n            });\n\n            if (parentResult) {\n                parentResult[childCollectionNode.linkName] = aggregateResult.data;\n            }\n\n            _.each(aggregateResult.data, function (item) {\n                allResults.push(item);\n            });\n        });\n    }\n\n    childCollectionNode.results = allResults;\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js"],"names":["sift","module","watch","require","v","cleanObjectForMetaFilters","exportDefault","childCollectionNode","aggregateResults","metaFilters","linker","linkStorageField","linkName","isMeta","allResults","metaFiltersTest","_","each","parent","results","parentResult","isMany","eligibleAggregateResults","filter","contains","aggregateResult","_id","length","datas","pluck","data","push","item","find","result"],"mappings":"AAAA,IAAIA,aAAJ;AAASC,OAAOC,KAAP,CAAaC,QAAQ,MAAR,CAAb,EAA6B;AAAA,yBAASC,CAAT,EAAW;AAACJ,eAAKI,CAAL;AAAO;AAAnB,CAA7B,EAAkD,CAAlD;AAAqD,IAAIC,kCAAJ;AAA8BJ,OAAOC,KAAP,CAAaC,QAAQ,iCAAR,CAAb,EAAwD;AAAA,yBAASC,CAAT,EAAW;AAACC,oCAA0BD,CAA1B;AAA4B;AAAxC,CAAxD,EAAkG,CAAlG;AAA5FH,OAAOK,aAAP,CAMe,UAAUC,mBAAV,EAA+BC,gBAA/B,EAAiDC,WAAjD,EAA8D;AACzE,QAAMC,SAASH,oBAAoBG,MAAnC;AACA,QAAMC,mBAAmBD,OAAOC,gBAAhC;AACA,QAAMC,WAAWL,oBAAoBK,QAArC;AACA,QAAMC,SAASH,OAAOG,MAAP,EAAf;AAEA,QAAIC,aAAa,EAAjB;;AAEA,QAAID,UAAUJ,WAAd,EAA2B;AACvB,YAAMM,kBAAkBf,KAAKS,WAAL,CAAxB;;AACAO,UAAEC,IAAF,CAAOV,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA2C,wBAAgB;AACvDd,sCAA0Be,YAA1B,EAAwCT,gBAAxC,EAA0DI,eAA1D;AACH,SAFD;AAGH;;AAED,QAAIF,UAAUH,OAAOW,MAAP,EAAd,EAA+B;AAC3B;AAEAL,UAAEC,IAAF,CAAOV,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA2C,wBAAgB;AACvDC,yBAAaR,QAAb,IAAyBQ,aAAaR,QAAb,KAA0B,EAAnD;;AAEA,gBAAMU,2BAA2BN,EAAEO,MAAF,CAASf,gBAAT,EAA2B,2BAAmB;AAC3E,uBAAOQ,EAAEQ,QAAF,CAAWC,gBAAgBC,GAA3B,EAAgCN,aAAaM,GAA7C,CAAP;AACH,aAFgC,CAAjC;;AAIA,gBAAIJ,yBAAyBK,MAA7B,EAAqC;AACjC,oBAAMC,QAAQZ,EAAEa,KAAF,CAAQP,wBAAR,EAAkC,MAAlC,CAAd,CADiC,CACwB;;;AAEzDN,kBAAEC,IAAF,CAAOW,KAAP,EAAc,gBAAQ;AAClBZ,sBAAEC,IAAF,CAAOa,IAAP,EAAa,gBAAQ;AACjBV,qCAAaR,QAAb,EAAuBmB,IAAvB,CAA4BC,IAA5B;AACH,qBAFD;AAGH,iBAJD;AAKH;AACJ,SAhBD;;AAkBAhB,UAAEC,IAAF,CAAOT,gBAAP,EAAyB,2BAAmB;AACxCQ,cAAEC,IAAF,CAAOQ,gBAAgBK,IAAvB,EAA6B;AAAA,uBAAQhB,WAAWiB,IAAX,CAAgBC,IAAhB,CAAR;AAAA,aAA7B;AACH,SAFD;AAGH,KAxBD,MAwBO;AACHhB,UAAEC,IAAF,CAAOT,gBAAP,EAAyB,2BAAmB;AACxC,gBAAIY,eAAeJ,EAAEiB,IAAF,CAAO1B,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA2C,UAACe,MAAD,EAAY;AACtE,uBAAOA,OAAOR,GAAP,IAAcD,gBAAgBC,GAArC;AACH,aAFkB,CAAnB;;AAIA,gBAAIN,YAAJ,EAAkB;AACdA,6BAAab,oBAAoBK,QAAjC,IAA6Ca,gBAAgBK,IAA7D;AACH;;AAEDd,cAAEC,IAAF,CAAOQ,gBAAgBK,IAAvB,EAA6B,gBAAQ;AACjChB,2BAAWiB,IAAX,CAAgBC,IAAhB;AACH,aAFD;AAGH,SAZD;AAaH;;AAEDzB,wBAAoBY,OAApB,GAA8BL,UAA9B;AACH,CA9DD","file":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js.map","sourcesContent":["import sift from 'sift';\nimport cleanObjectForMetaFilters from './lib/cleanObjectForMetaFilters';\n\n/**\n * This only applies to inversed links. It will assemble the data in a correct manner.\n */\nexport default function (childCollectionNode, aggregateResults, metaFilters) {\n    const linker = childCollectionNode.linker;\n    const linkStorageField = linker.linkStorageField;\n    const linkName = childCollectionNode.linkName;\n    const isMeta = linker.isMeta();\n\n    let allResults = [];\n\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n        _.each(childCollectionNode.parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, linkStorageField, metaFiltersTest);\n        })\n    }\n\n    if (isMeta && linker.isMany()) {\n        // This case is treated differently because we get an array response from the pipeline.\n\n        _.each(childCollectionNode.parent.results, parentResult => {\n            parentResult[linkName] = parentResult[linkName] || [];\n\n            const eligibleAggregateResults = _.filter(aggregateResults, aggregateResult => {\n                return _.contains(aggregateResult._id, parentResult._id)\n            });\n\n            if (eligibleAggregateResults.length) {\n                const datas = _.pluck(eligibleAggregateResults, 'data'); /// [ [x1, x2], [x2, x3] ]\n\n                _.each(datas, data => {\n                    _.each(data, item => {\n                        parentResult[linkName].push(item)\n                    })\n                });\n            }\n        });\n\n        _.each(aggregateResults, aggregateResult => {\n            _.each(aggregateResult.data, item => allResults.push(item))\n        });\n    } else {\n        _.each(aggregateResults, aggregateResult => {\n            let parentResult = _.find(childCollectionNode.parent.results, (result) => {\n                return result._id == aggregateResult._id;\n            });\n\n            if (parentResult) {\n                parentResult[childCollectionNode.linkName] = aggregateResult.data;\n            }\n\n            _.each(aggregateResult.data, item => {\n                allResults.push(item)\n            });\n        });\n    }\n\n    childCollectionNode.results = allResults;\n}"]},"hash":"4fe091c142c6aee716e01e775743d3d129d8630a"}
