{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/reactive-var","imported":["ReactiveVar"],"specifiers":[{"kind":"named","imported":"ReactiveVar","local":"ReactiveVar"}]},{"source":"meteor/tracker","imported":["Tracker"],"specifiers":[{"kind":"named","imported":"Tracker","local":"Tracker"}]},{"source":"./collection","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Counts"}]},{"source":"./createFauxSubscription","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createFauxSubscription"}]},{"source":"../lib/prepareForProcess.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"prepareForProcess"}]},{"source":"../../namedQuery/namedQuery.base","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"NamedQueryBase"}]}],"exports":{"exported":["CountSubscription"],"specifiers":[{"kind":"local","local":"CountSubscription","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"countSubscription"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n    \"default\": function () {\n        return CountSubscription;\n    }\n});\nvar EJSON = void 0;\nmodule.watch(require(\"meteor/ejson\"), {\n    EJSON: function (v) {\n        EJSON = v;\n    }\n}, 0);\nvar Meteor = void 0;\nmodule.watch(require(\"meteor/meteor\"), {\n    Meteor: function (v) {\n        Meteor = v;\n    }\n}, 1);\nvar ReactiveVar = void 0;\nmodule.watch(require(\"meteor/reactive-var\"), {\n    ReactiveVar: function (v) {\n        ReactiveVar = v;\n    }\n}, 2);\nvar Tracker = void 0;\nmodule.watch(require(\"meteor/tracker\"), {\n    Tracker: function (v) {\n        Tracker = v;\n    }\n}, 3);\nvar Counts = void 0;\nmodule.watch(require(\"./collection\"), {\n    \"default\": function (v) {\n        Counts = v;\n    }\n}, 4);\nvar createFauxSubscription = void 0;\nmodule.watch(require(\"./createFauxSubscription\"), {\n    \"default\": function (v) {\n        createFauxSubscription = v;\n    }\n}, 5);\nvar prepareForProcess = void 0;\nmodule.watch(require(\"../lib/prepareForProcess.js\"), {\n    \"default\": function (v) {\n        prepareForProcess = v;\n    }\n}, 6);\nvar NamedQueryBase = void 0;\nmodule.watch(require(\"../../namedQuery/namedQuery.base\"), {\n    \"default\": function (v) {\n        NamedQueryBase = v;\n    }\n}, 7);\n\nvar CountSubscription = function () {\n    /**\n     * @param {*} query - The query to use when fetching counts\n     */function CountSubscription(query) {\n        (0, _classCallCheck3.default)(this, CountSubscription);\n        this.accessToken = new ReactiveVar(null);\n        this.fauxHandle = null;\n        this.query = query;\n    } /**\n       * Starts a subscription request for reactive counts.\n       *\n       * @param {*} arg - The argument to pass to {name}.count.subscribe\n       * @param {*} callback\n       */\n\n    CountSubscription.prototype.subscribe = function () {\n        function subscribe(arg, callback) {\n            var _this = this;\n\n            // Don't try to resubscribe if arg hasn't changed\n            if (EJSON.equals(this.lastArgs, arg) && this.fauxHandle) {\n                return this.fauxHandle;\n            }\n\n            this.accessToken.set(null);\n            this.lastArgs = arg;\n            Meteor.call(this.query.name + '.count.subscribe', arg, function (error, token) {\n                if (!_this._markedForUnsubscribe) {\n                    _this.subscriptionHandle = Meteor.subscribe(_this.query.name + '.count', token, callback);\n\n                    _this.accessToken.set(token);\n\n                    _this.disconnectComputation = Tracker.autorun(function () {\n                        return _this.handleDisconnect();\n                    });\n                }\n\n                _this._markedForUnsubscribe = false;\n            });\n            this.fauxHandle = createFauxSubscription(this);\n            return this.fauxHandle;\n        }\n\n        return subscribe;\n    }(); /**\n          * Unsubscribes from the count endpoint, if there is such a subscription.\n          */\n\n    CountSubscription.prototype.unsubscribe = function () {\n        function unsubscribe() {\n            if (this.subscriptionHandle) {\n                this.disconnectComputation.stop();\n                this.subscriptionHandle.stop();\n            } else {\n                // If we hit this branch, then Meteor.call in subscribe hasn't finished yet\n                // so set a flag to stop the subscription from being created\n                this._markedForUnsubscribe = true;\n            }\n\n            this.accessToken.set(null);\n            this.fauxHandle = null;\n            this.subscriptionHandle = null;\n        }\n\n        return unsubscribe;\n    }(); /**\n          * Reactively fetch current document count. Returns null if the subscription is not ready yet.\n          *\n          * @returns {Number|null} - Current document count\n          */\n\n    CountSubscription.prototype.getCount = function () {\n        function getCount() {\n            var id = this.accessToken.get();\n            if (id === null) return null;\n            var doc = Counts.findOne(id);\n            return doc.count;\n        }\n\n        return getCount;\n    }(); /**\n          * All session info gets deleted when the server goes down, so when the client attempts to\n          * optimistically resume the '.count' publication, the server will throw a 'no-request' error.\n          *\n          * This function prevents that by manually stopping and restarting the subscription when the\n          * connection to the server is lost.\n          */\n\n    CountSubscription.prototype.handleDisconnect = function () {\n        function handleDisconnect() {\n            var status = Meteor.status();\n\n            if (!status.connected) {\n                this._markedForResume = true;\n                this.fauxHandle = null;\n                this.subscriptionHandle.stop();\n            }\n\n            if (status.connected && this._markedForResume) {\n                this._markedForResume = false;\n                this.subscribe(this.lastArgs);\n            }\n        }\n\n        return handleDisconnect;\n    }(); /**\n          * Returns whether or not a subscription request has been made.\n          */\n\n    CountSubscription.prototype.isSubscribed = function () {\n        function isSubscribed() {\n            return this.accessToken.get() !== null;\n        }\n\n        return isSubscribed;\n    }();\n\n    return CountSubscription;\n}();","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/counts/countSubscription.js"],"names":["module","export","CountSubscription","EJSON","watch","require","v","Meteor","ReactiveVar","Tracker","Counts","createFauxSubscription","prepareForProcess","NamedQueryBase","query","accessToken","fauxHandle","subscribe","arg","callback","equals","lastArgs","set","call","name","error","token","_markedForUnsubscribe","subscriptionHandle","disconnectComputation","autorun","handleDisconnect","unsubscribe","stop","getCount","id","get","doc","findOne","count","status","connected","_markedForResume","isSubscribed"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js.map","sourcesContent":["import { EJSON } from 'meteor/ejson';\nimport { Meteor } from 'meteor/meteor';\nimport { ReactiveVar } from 'meteor/reactive-var';\nimport { Tracker } from 'meteor/tracker';\n\nimport Counts from './collection';\nimport createFauxSubscription from './createFauxSubscription';\nimport prepareForProcess from '../lib/prepareForProcess.js';\nimport NamedQueryBase from '../../namedQuery/namedQuery.base';\n\nexport default class CountSubscription {\n    /**\n     * @param {*} query - The query to use when fetching counts\n     */\n    constructor(query) {\n        this.accessToken = new ReactiveVar(null);\n        this.fauxHandle = null;\n        this.query = query;\n    }\n\n    /**\n     * Starts a subscription request for reactive counts.\n     *\n     * @param {*} arg - The argument to pass to {name}.count.subscribe\n     * @param {*} callback\n     */\n    subscribe(arg, callback) {\n        // Don't try to resubscribe if arg hasn't changed\n        if (EJSON.equals(this.lastArgs, arg) && this.fauxHandle) {\n            return this.fauxHandle;\n        }\n\n        this.accessToken.set(null);\n        this.lastArgs = arg;\n\n        Meteor.call(this.query.name + '.count.subscribe', arg, (error, token) => {\n            if (!this._markedForUnsubscribe) {\n                this.subscriptionHandle = Meteor.subscribe(this.query.name + '.count', token, callback);\n                this.accessToken.set(token);\n\n                this.disconnectComputation = Tracker.autorun(() => this.handleDisconnect());\n            }\n\n            this._markedForUnsubscribe = false;\n        });\n\n        this.fauxHandle = createFauxSubscription(this);\n        return this.fauxHandle;\n    }\n\n    /**\n     * Unsubscribes from the count endpoint, if there is such a subscription.\n     */\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.disconnectComputation.stop();\n            this.subscriptionHandle.stop();\n        } else {\n            // If we hit this branch, then Meteor.call in subscribe hasn't finished yet\n            // so set a flag to stop the subscription from being created\n            this._markedForUnsubscribe = true;\n        }\n\n        this.accessToken.set(null);\n        this.fauxHandle = null;\n        this.subscriptionHandle = null;\n    }\n\n    /**\n     * Reactively fetch current document count. Returns null if the subscription is not ready yet.\n     *\n     * @returns {Number|null} - Current document count\n     */\n    getCount() {\n        const id = this.accessToken.get();\n        if (id === null) return null;\n\n        const doc = Counts.findOne(id);\n        return doc.count;\n    }\n\n    /**\n     * All session info gets deleted when the server goes down, so when the client attempts to\n     * optimistically resume the '.count' publication, the server will throw a 'no-request' error.\n     *\n     * This function prevents that by manually stopping and restarting the subscription when the\n     * connection to the server is lost.\n     */\n    handleDisconnect() {\n        const status = Meteor.status();\n        if (!status.connected) {\n            this._markedForResume = true;\n            this.fauxHandle = null;\n            this.subscriptionHandle.stop();\n        }\n\n        if (status.connected && this._markedForResume) {\n            this._markedForResume = false;\n            this.subscribe(this.lastArgs);\n        }\n    }\n\n    /**\n     * Returns whether or not a subscription request has been made.\n     */\n    isSubscribed() {\n        return this.accessToken.get() !== null;\n    }\n}\n"]},"hash":"8f569c835939536a38c3139924c7591303eb7c38"}
