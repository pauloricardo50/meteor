{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../reducers/lib/applyReducers","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"applyReducers"}]},{"source":"../reducers/lib/cleanReducerLeftovers","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanReducerLeftovers"}]},{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]},{"source":"meteor/minimongo","imported":["Minimongo"],"specifiers":[{"kind":"named","imported":"Minimongo","local":"Minimongo"}]}],"exports":{"exported":["applyPostFilters","node","applyPostOptions","node","removeLinkStorages","node","sameLevelResults","storeOneResults","node","sameLevelResults","assembleMetadata","node","parentResults"],"specifiers":[{"kind":"local","local":"applyPostFilters","exported":"applyPostFilters"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"applyPostOptions","exported":"applyPostOptions"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"removeLinkStorages","exported":"removeLinkStorages"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"sameLevelResults","exported":"sameLevelResults"},{"kind":"local","local":"storeOneResults","exported":"storeOneResults"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"sameLevelResults","exported":"sameLevelResults"},{"kind":"local","local":"assembleMetadata","exported":"assembleMetadata"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"parentResults","exported":"parentResults"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"prepareForDelivery"},"ignored":false,"code":"module.export({\n    applyPostFilters: function () {\n        return applyPostFilters;\n    },\n    applyPostOptions: function () {\n        return applyPostOptions;\n    },\n    removeLinkStorages: function () {\n        return removeLinkStorages;\n    },\n    storeOneResults: function () {\n        return storeOneResults;\n    },\n    assembleMetadata: function () {\n        return assembleMetadata;\n    }\n});\nvar applyReducers = void 0;\nmodule.watch(require(\"../reducers/lib/applyReducers\"), {\n    \"default\": function (v) {\n        applyReducers = v;\n    }\n}, 0);\nvar cleanReducerLeftovers = void 0;\nmodule.watch(require(\"../reducers/lib/cleanReducerLeftovers\"), {\n    \"default\": function (v) {\n        cleanReducerLeftovers = v;\n    }\n}, 1);\nvar sift = void 0;\nmodule.watch(require(\"sift\"), {\n    \"default\": function (v) {\n        sift = v;\n    }\n}, 2);\nvar Minimongo = void 0;\nmodule.watch(require(\"meteor/minimongo\"), {\n    Minimongo: function (v) {\n        Minimongo = v;\n    }\n}, 3);\nmodule.exportDefault(function (node, params) {\n    snapBackCaches(node);\n    applyReducers(node, params);\n    cleanReducerLeftovers(node);\n\n    _.each(node.collectionNodes, function (collectionNode) {\n        cloneMetaChildren(collectionNode, node.results);\n    });\n\n    _.each(node.collectionNodes, function (collectionNode) {\n        assembleMetadata(collectionNode, node.results);\n    });\n\n    removeLinkStorages(node, node.results);\n    storeOneResults(node, node.results);\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n});\n\nfunction applyPostFilters(node) {\n    var postFilters = node.props.$postFilters;\n\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nfunction applyPostOptions(node) {\n    var options = node.props.$postOptions;\n\n    if (options) {\n        if (options.sort) {\n            var sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n\n        if (options.limit || options.skip) {\n            var start = options.skip || 0;\n            var end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n/**\n * Optionally applies a post filtering option\n */function applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        var filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(function (f) {\n                node.results = f(node.results, params);\n            });\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\nfunction removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    _.each(node.collectionNodes, function (collectionNode) {\n        var removeStorageField = collectionNode.shouldCleanStorage;\n\n        _.each(sameLevelResults, function (result) {\n            if (removeStorageField) {\n                delete result[collectionNode.linkStorageField];\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        });\n    });\n}\n\nfunction storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(function (collectionNode) {\n        _.each(sameLevelResults, function (result) {\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            sameLevelResults.forEach(function (result) {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName] ? _.first(result[collectionNode.linkName]) : undefined;\n                }\n            });\n        }\n    });\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    var linkName = node.linkName;\n    var isMeta = node.isMeta;\n    parentResults.forEach(function (parentResult) {\n        if (isMeta && parentResult[linkName]) {\n            parentResult[linkName] = parentResult[linkName].map(function (object) {\n                return Object.assign({}, object);\n            });\n        }\n\n        node.collectionNodes.forEach(function (collectionNode) {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nfunction assembleMetadata(node, parentResults) {\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(function (collectionNode) {\n        _.each(parentResults, function (result) {\n            assembleMetadata(collectionNode, result[node.linkName]);\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, function (parentResult) {\n                var childResult = parentResult[node.linkName];\n\n                _.each(childResult, function (object) {\n                    var storage = object[node.linkStorageField];\n                    storeMetadata(object, parentResult, storage, true);\n                });\n            });\n        } else {\n            _.each(parentResults, function (parentResult) {\n                var childResult = parentResult[node.linkName];\n                var storage = parentResult[node.linkStorageField];\n\n                _.each(childResult, function (object) {\n                    storeMetadata(object, parentResult, storage, false);\n                });\n            });\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        var $metadata = void 0;\n\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, function (storageItem) {\n                return storageItem._id == parentElement._id;\n            });\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    } else {\n        var _$metadata = void 0;\n\n        if (_.isArray(storage)) {\n            _$metadata = _.find(storage, function (storageItem) {\n                return storageItem._id == element._id;\n            });\n        } else {\n            _$metadata = storage;\n        }\n\n        element.$metadata = _.omit(_$metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(function (collectionNode) {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, function (linkName, cacheField) {\n            var isSingle = _.contains(node.snapCachesSingles, cacheField);\n\n            var linker = node.collection.getLinker(linkName); // we do this because for one direct and one meta direct, id is not stored\n\n            var shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n            node.results.forEach(function (result) {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta() ? result[linker.linkStorageField]._id : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            });\n        });\n    }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"],"names":["module","export","applyPostFilters","applyPostOptions","removeLinkStorages","storeOneResults","assembleMetadata","applyReducers","watch","require","v","cleanReducerLeftovers","sift","Minimongo","exportDefault","node","params","snapBackCaches","_","each","collectionNodes","cloneMetaChildren","collectionNode","results","applyPostFilter","postFilters","props","$postFilters","options","$postOptions","sort","sorter","Sorter","getComparator","limit","skip","start","end","length","slice","$postFilter","filter","isArray","forEach","f","sameLevelResults","removeStorageField","shouldCleanStorage","result","linkStorageField","linkName","isOneResult","first","undefined","parentResults","isMeta","parentResult","map","Object","assign","object","isVirtual","childResult","storage","storeMetadata","element","parentElement","$metadata","find","storageItem","_id","omit","isEmpty","snapCaches","cacheField","isSingle","contains","snapCachesSingles","linker","collection","getLinker","shoudStoreLinkStorage","isMany"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js.map","sourcesContent":["// 1. Clone children with meta relationships\n// 2. Apply $metadata to children\n// 3. Removes link storage (if not specified)\n// 4. Stores oneResult links as a single object instead of array\nimport applyReducers from '../reducers/lib/applyReducers';\nimport cleanReducerLeftovers from '../reducers/lib/cleanReducerLeftovers';\nimport sift from 'sift';\nimport {Minimongo} from 'meteor/minimongo';\n\nexport default (node, params) => {\n    snapBackCaches(node);\n    applyReducers(node, params);\n    cleanReducerLeftovers(node);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results)\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results)\n    });\n\n    removeLinkStorages(node, node.results);\n    storeOneResults(node, node.results);\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n}\n\nexport function applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nexport function applyPostOptions(node) {\n    const options = node.props.$postOptions;\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            })\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\nexport function removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                delete result[collectionNode.linkStorageField];\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        })\n    })\n}\n\nexport function storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            sameLevelResults.forEach(result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName]\n                        ? _.first(result[collectionNode.linkName])\n                        : undefined;\n                }\n            })\n        }\n    })\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            parentResult[linkName] = parentResult[linkName].map(object => {\n                return Object.assign({}, object);\n            });\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nexport function assembleMetadata(node, parentResults) {\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName])\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                _.each(childResult, object => {\n                    const storage = object[node.linkStorageField];\n\n                    storeMetadata(object, parentResult, storage, true);\n                });\n            })\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                _.each(childResult, object => {\n                    storeMetadata(object, parentResult, storage, false);\n                });\n            })\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id')\n    } else {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n            const linker = node.collection.getLinker(linkName);\n            // we do this because for one direct and one meta direct, id is not stored\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta()\n                                ? result[linker.linkStorageField]._id\n                                : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            })\n        })\n    }\n}\n"]},"hash":"2ff11b6fb5971b355dc2b5673bd1f38e0fa0cc07"}
