{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../../lib/restrictFields.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"restrictFields"}]},{"source":"../../lib/enforceMaxLimit.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxLimit"}]},{"source":"../../lib/cleanBody.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanBody"}]},{"source":"../../lib/cleanSelectors.js","imported":["cleanOptions","cleanFilters"],"specifiers":[{"kind":"named","imported":"cleanOptions","local":"cleanOptions"},{"kind":"named","imported":"cleanFilters","local":"cleanFilters"}]},{"source":"../../lib/enforceMaxDepth.js","imported":["default","getDepth"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxDepth"},{"kind":"named","imported":"getDepth","local":"getDepth"}]},{"source":"../../../query/nodes/collectionNode.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"CollectionNode"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/exposure/testing/units/units.js","filenameRelative":"packages/cultofcoders:grapher/lib/exposure/testing/units/units.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/exposure/testing/units/units.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/exposure/testing/units/units.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"units"},"ignored":false,"code":"let restrictFields;\nmodule.watch(require(\"../../lib/restrictFields.js\"), {\n    default(v) {\n        restrictFields = v;\n    }\n\n}, 0);\nlet enforceMaxLimit;\nmodule.watch(require(\"../../lib/enforceMaxLimit.js\"), {\n    default(v) {\n        enforceMaxLimit = v;\n    }\n\n}, 1);\nlet cleanBody;\nmodule.watch(require(\"../../lib/cleanBody.js\"), {\n    default(v) {\n        cleanBody = v;\n    }\n\n}, 2);\nlet cleanOptions, cleanFilters;\nmodule.watch(require(\"../../lib/cleanSelectors.js\"), {\n    cleanOptions(v) {\n        cleanOptions = v;\n    },\n\n    cleanFilters(v) {\n        cleanFilters = v;\n    }\n\n}, 3);\nlet enforceMaxDepth, getDepth;\nmodule.watch(require(\"../../lib/enforceMaxDepth.js\"), {\n    default(v) {\n        enforceMaxDepth = v;\n    },\n\n    getDepth(v) {\n        getDepth = v;\n    }\n\n}, 4);\nlet CollectionNode;\nmodule.watch(require(\"../../../query/nodes/collectionNode.js\"), {\n    default(v) {\n        CollectionNode = v;\n    }\n\n}, 5);\ndescribe('Unit Tests', function () {\n    it('Should be able to restrict fields', function () {\n        let filters = {\n            test: 1,\n            shouldRestrict: 1,\n            'shouldRestrict.this': 1,\n            shouldRestrict2: 1,\n            $and: [{\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1,\n                test: 1\n            }, {\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }],\n            $or: [{\n                $and: [{\n                    test: 1,\n                    shouldRestrict: 1,\n                    'shouldRestrict.this': 1\n                }]\n            }],\n            $nor: [{\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }],\n            $not: {\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }\n        };\n        let options = {\n            sort: {\n                test: 1,\n                shouldRestrict: 1,\n                shouldRestrict2: 1,\n                'shouldRestrict.this': 1\n            },\n            fields: {\n                test: 1,\n                shouldRestrict: 1,\n                shouldRestrict2: 1,\n                'shouldRestrict.this': 1\n            }\n        };\n        restrictFields(filters, options, ['shouldRestrict', 'shouldRestrict2']);\n        assert.lengthOf(_.keys(filters), 5);\n        assert.equal(filters.test, 1);\n        assert.isUndefined(filters.shouldRestrict);\n        assert.isUndefined(filters['shouldRestrict.this']);\n        assert.lengthOf(_.keys(options.sort), 1);\n        assert.equal(options.sort.test, 1);\n        assert.isUndefined(options.sort.shouldRestrict, 1);\n        assert.isUndefined(options.sort['shouldRestrict.this']);\n        assert.lengthOf(_.keys(options.fields), 1);\n        assert.equal(options.fields.test, 1);\n        assert.isUndefined(options.fields['shouldRestrict.this']);\n        assert.isUndefined(options.fields['shouldRestrict']);\n        assert.isDefined(filters.$not.test);\n        assert.isUndefined(filters.$not.shouldRestrict);\n        assert.isUndefined(filters.$not['shouldRestrict.this']);\n        assert.isDefined(filters.$nor[0].test);\n        assert.isUndefined(filters.$nor[0].shouldRestrict);\n        assert.isUndefined(filters.$nor[0]['shouldRestrict.this']);\n        assert.isDefined(filters.$and[0].test);\n        assert.isUndefined(filters.$and[0].shouldRestrict);\n        assert.isUndefined(filters.$and[0]['shouldRestrict.this']);\n        assert.isDefined(filters.$and[1].test);\n        assert.isUndefined(filters.$and[1].shouldRestrict);\n        assert.isUndefined(filters.$and[1]['shouldRestrict.this']);\n        assert.isDefined(filters.$or[0].$and[0].test);\n        assert.isUndefined(filters.$or[0].$and[0].shouldRestrict);\n        assert.isUndefined(filters.$or[0].$and[0]['shouldRestrict.this']);\n        let options2 = {\n            fields: {\n                test: 1\n            }\n        };\n        restrictFields({}, options2, ['test']);\n        assert.isUndefined(options2.fields.test);\n        assert.isDefined(options2.fields._id);\n    });\n    it('Should restrict links # getLinks', function () {\n        let getLinks;\n        module.watch(require(\"../../lib/restrictLinks.js\"), {\n            getLinks(v) {\n                getLinks = v;\n            }\n\n        }, 6);\n        let data = getLinks({\n            collection: {\n                __exposure: {\n                    config: {\n                        restrictLinks: ['1', '2']\n                    }\n                }\n            }\n        });\n        assert.lengthOf(data, 2);\n        data = getLinks({\n            collection: {\n                __exposure: {\n                    config: {\n                        restrictLinks: function () {\n                            return ['1', '2'];\n                        }\n                    }\n                }\n            }\n        });\n        assert.lengthOf(data, 2);\n    });\n    it('Should be able to enforce a maxLimit', function () {\n        let options = {};\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 100);\n        options = {\n            limit: 101\n        };\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 100);\n        options = {\n            limit: 99\n        };\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 99);\n    });\n    it('Should be able to get the propper depth of a node', function () {\n        let root = new CollectionNode();\n        let subroot1 = new CollectionNode();\n        let subroot2 = new CollectionNode();\n        root.add(subroot1);\n        root.add(subroot2);\n        let subsubroot1 = new CollectionNode();\n        subroot1.add(subsubroot1);\n        subsubroot1.add(new CollectionNode());\n        subroot2.add(new CollectionNode());\n        assert.equal(4, getDepth(root));\n    });\n    it('Should be able to enforce depth of a node', function () {\n        let root = new CollectionNode();\n        let subroot1 = new CollectionNode();\n        let subroot2 = new CollectionNode();\n        root.add(subroot1);\n        root.add(subroot2);\n        let subsubroot1 = new CollectionNode();\n        subroot1.add(subsubroot1);\n        subsubroot1.add(new CollectionNode());\n        subroot2.add(new CollectionNode());\n        assert.equal(4, getDepth(root));\n\n        const fn = () => {\n            enforceMaxDepth(root, 3);\n        };\n\n        assert.throws(fn, /graph request is too deep/);\n    });\n    it('Should work intersect with computation and with infinite recursion avoidance', function () {\n        const link2 = item => {\n            return {\n                item,\n                link1\n            };\n        };\n\n        const link1 = item => {\n            return {\n                item,\n                link2\n            };\n        };\n\n        const obj1 = {\n            a: 1,\n            link1\n        };\n        const obj2 = {\n            $filters: {\n                a: {\n                    $gt: 2\n                },\n                b: {\n                    $gt: 2\n                },\n                $and: [{\n                    a: {\n                        $gt: 2\n                    },\n                    b: {\n                        $gt: 2\n                    }\n                }, {\n                    b: {\n                        $gt: 2\n                    }\n                }],\n                $not: {\n                    a: {\n                        $gt: 2\n                    },\n                    b: {\n                        $gt: 2\n                    }\n                }\n            },\n            a: {\n                a1: 1\n            },\n            link1: {\n                item: 1,\n                link2: {\n                    item: 1,\n                    link1: {\n                        item: 1\n                    }\n                }\n            }\n        };\n        const result = cleanBody(obj1, obj2, 'test');\n        assert.isObject(result.a);\n        assert.isDefined(result.a.a1);\n        assert.isObject(result.link1);\n        assert.equal(result.link1.item, 'test');\n        assert.isObject(result.link1.link2);\n        assert.equal(result.link1.link2.item, 'test');\n        assert.isObject(result.link1.link2.link1);\n        assert.equal(result.link1.link2.link1.item, 'test');\n        assert.isObject(result.$filters);\n        assert.isObject(result.$filters.a);\n        assert.isUndefined(result.$filters.b);\n        assert.equal(result.$filters.a.$gt, 2);\n        assert.isArray(result.$filters.$and);\n        assert.equal(result.$filters.$and[0].a.$gt, 2);\n        assert.isUndefined(result.$filters.$and[0].b);\n        assert.isUndefined(result.$filters.$and[1].b);\n        assert.equal(result.$filters.$and[0].a.$gt, 2);\n        assert.isObject(result.$filters.$not);\n        assert.isUndefined(result.$filters.$not.b);\n        assert.equal(result.$filters.$not.a.$gt, 2);\n    });\n    it('Should work with cleanBody allow all method', function () {\n        const body = cleanBody({\n            a: true\n        }, {\n            a: {\n                b: {\n                    c: 1\n                }\n            }\n        });\n        assert.isObject(body.a);\n        assert.isObject(body.a.b);\n        assert.equal(body.a.b.c, 1);\n    });\n    it('Should properly clean selectors', function () {\n        let filters = {\n            'profile.firstName': 'Theodor'\n        };\n        cleanFilters(filters, ['profile']);\n        assert.equal(filters['profile.firstName'], 'Theodor');\n    });\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/testing/units/units.js"],"names":["restrictFields","module","watch","require","default","v","enforceMaxLimit","cleanBody","cleanOptions","cleanFilters","enforceMaxDepth","getDepth","CollectionNode","describe","it","filters","test","shouldRestrict","shouldRestrict2","$and","$or","$nor","$not","options","sort","fields","assert","lengthOf","_","keys","equal","isUndefined","isDefined","options2","_id","getLinks","data","collection","__exposure","config","restrictLinks","limit","root","subroot1","subroot2","add","subsubroot1","fn","throws","link2","item","link1","obj1","a","obj2","$filters","$gt","b","a1","result","isObject","isArray","body","c"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/exposure/testing/units/units.js.map","sourcesContent":["import restrictFields from '../../lib/restrictFields.js';\nimport enforceMaxLimit from '../../lib/enforceMaxLimit.js';\nimport cleanBody from '../../lib/cleanBody.js';\nimport { cleanOptions, cleanFilters } from '../../lib/cleanSelectors.js';\nimport enforceMaxDepth, {getDepth} from '../../lib/enforceMaxDepth.js';\nimport CollectionNode from '../../../query/nodes/collectionNode.js';\n\ndescribe('Unit Tests', function () {\n    it('Should be able to restrict fields', function () {\n        let filters = {\n            test: 1,\n            shouldRestrict: 1,\n            'shouldRestrict.this': 1,\n            shouldRestrict2: 1,\n            $and: [{\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1,\n                test: 1,\n            }, {\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }],\n            $or: [{\n                $and: [{\n                    test: 1,\n                    shouldRestrict: 1,\n                    'shouldRestrict.this': 1\n                }]\n            }],\n            $nor: [{\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }],\n            $not: {\n                test: 1,\n                shouldRestrict: 1,\n                'shouldRestrict.this': 1\n            }\n        };\n\n        let options = {\n            sort: {\n                test: 1,\n                shouldRestrict: 1,\n                shouldRestrict2: 1,\n                'shouldRestrict.this': 1\n            },\n            fields: {\n                test: 1,\n                shouldRestrict: 1,\n                shouldRestrict2: 1,\n                'shouldRestrict.this': 1\n            }\n        };\n\n        restrictFields(filters, options, ['shouldRestrict', 'shouldRestrict2']);\n\n        assert.lengthOf(_.keys(filters), 5);\n        assert.equal(filters.test, 1);\n        assert.isUndefined(filters.shouldRestrict);\n        assert.isUndefined(filters['shouldRestrict.this']);\n\n        assert.lengthOf(_.keys(options.sort), 1);\n        assert.equal(options.sort.test, 1);\n        assert.isUndefined(options.sort.shouldRestrict, 1);\n        assert.isUndefined(options.sort['shouldRestrict.this']);\n\n        assert.lengthOf(_.keys(options.fields), 1);\n        assert.equal(options.fields.test, 1);\n        assert.isUndefined(options.fields['shouldRestrict.this']);\n        assert.isUndefined(options.fields['shouldRestrict']);\n\n        assert.isDefined(filters.$not.test);\n        assert.isUndefined(filters.$not.shouldRestrict);\n        assert.isUndefined(filters.$not['shouldRestrict.this']);\n        assert.isDefined(filters.$nor[0].test);\n        assert.isUndefined(filters.$nor[0].shouldRestrict);\n        assert.isUndefined(filters.$nor[0]['shouldRestrict.this']);\n        assert.isDefined(filters.$and[0].test);\n        assert.isUndefined(filters.$and[0].shouldRestrict);\n        assert.isUndefined(filters.$and[0]['shouldRestrict.this']);\n        assert.isDefined(filters.$and[1].test);\n        assert.isUndefined(filters.$and[1].shouldRestrict);\n        assert.isUndefined(filters.$and[1]['shouldRestrict.this']);\n        assert.isDefined(filters.$or[0].$and[0].test);\n        assert.isUndefined(filters.$or[0].$and[0].shouldRestrict);\n        assert.isUndefined(filters.$or[0].$and[0]['shouldRestrict.this']);\n\n        let options2 = {fields: {test: 1}};\n        restrictFields({}, options2, ['test']);\n        assert.isUndefined(options2.fields.test);\n        assert.isDefined(options2.fields._id);\n    });\n\n    it('Should restrict links # getLinks', function () {\n        import { getLinks } from '../../lib/restrictLinks.js';\n\n        let data = getLinks({\n            collection: {\n                __exposure: {\n                    config: {\n                        restrictLinks: ['1', '2']\n                    }\n                }\n            }\n        });\n\n        assert.lengthOf(data, 2);\n\n        data = getLinks({\n            collection: {\n                __exposure: {\n                    config: {\n                        restrictLinks: function() {\n                            return ['1', '2']\n                        }\n                    }\n                }\n            }\n        });\n\n        assert.lengthOf(data, 2);\n    });\n\n    it('Should be able to enforce a maxLimit', function () {\n        let options = {};\n\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 100);\n\n        options = {limit: 101};\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 100);\n\n        options = {limit: 99};\n        enforceMaxLimit(options, 100);\n        assert.equal(options.limit, 99);\n    });\n\n    it('Should be able to get the propper depth of a node', function () {\n        let root = new CollectionNode();\n\n        let subroot1 = new CollectionNode();\n        let subroot2 = new CollectionNode();\n        root.add(subroot1);\n        root.add(subroot2);\n\n        let subsubroot1 = new CollectionNode();\n        subroot1.add(subsubroot1);\n\n        subsubroot1.add(new CollectionNode());\n\n        subroot2.add(new CollectionNode());\n\n        assert.equal(4, getDepth(root));\n    });\n\n    it('Should be able to enforce depth of a node', function () {\n        let root = new CollectionNode();\n\n        let subroot1 = new CollectionNode();\n        let subroot2 = new CollectionNode();\n        root.add(subroot1);\n        root.add(subroot2);\n\n        let subsubroot1 = new CollectionNode();\n        subroot1.add(subsubroot1);\n\n        subsubroot1.add(new CollectionNode());\n\n        subroot2.add(new CollectionNode());\n\n        assert.equal(4, getDepth(root));\n\n        const fn = () => {\n            enforceMaxDepth(root, 3);\n        };\n\n        assert.throws(fn, /graph request is too deep/);\n    });\n\n    it('Should work intersect with computation and with infinite recursion avoidance', function () {\n        const link2 = (item) => {\n            return {\n                item,\n                link1\n            }\n        };\n\n        const link1 = (item) => {\n            return {\n                item,\n                link2\n            }\n        };\n\n        const obj1 = {\n            a: 1,\n            link1\n        };\n\n        const obj2 = {\n            $filters: {\n                a: {$gt: 2},\n                b: {$gt: 2},\n                $and: [\n                    {\n                        a: {$gt: 2},\n                        b: {$gt: 2}\n                    },\n                    {\n                        b: {$gt: 2}\n                    }\n                ],\n                $not: {\n                    a: {$gt: 2},\n                    b: {$gt: 2}\n                }\n            },\n            a: {\n                a1: 1\n            },\n            link1: {\n                item: 1,\n                link2: {\n                    item: 1,\n                    link1: {\n                        item: 1\n                    }\n                }\n            }\n        };\n\n        const result = cleanBody(obj1, obj2, 'test');\n\n        assert.isObject(result.a);\n        assert.isDefined(result.a.a1);\n        assert.isObject(result.link1);\n        assert.equal(result.link1.item, 'test');\n        assert.isObject(result.link1.link2);\n        assert.equal(result.link1.link2.item, 'test');\n        assert.isObject(result.link1.link2.link1);\n        assert.equal(result.link1.link2.link1.item, 'test');\n\n        assert.isObject(result.$filters);\n        assert.isObject(result.$filters.a);\n        assert.isUndefined(result.$filters.b);\n        assert.equal(result.$filters.a.$gt, 2);\n\n        assert.isArray(result.$filters.$and);\n        assert.equal(result.$filters.$and[0].a.$gt, 2);\n        assert.isUndefined(result.$filters.$and[0].b);\n        assert.isUndefined(result.$filters.$and[1].b);\n        assert.equal(result.$filters.$and[0].a.$gt, 2);\n        assert.isObject(result.$filters.$not);\n        assert.isUndefined(result.$filters.$not.b);\n        assert.equal(result.$filters.$not.a.$gt, 2);\n    });\n\n    it('Should work with cleanBody allow all method', function () {\n        const body = cleanBody({\n            a: true\n        }, {\n            a: {\n                b: {\n                    c: 1\n                }\n            }\n        });\n\n        assert.isObject(body.a);\n        assert.isObject(body.a.b);\n        assert.equal(body.a.b.c, 1);\n    });\n\n    it('Should properly clean selectors', function () {\n        let filters = {\n            'profile.firstName': 'Theodor'\n        };\n\n        cleanFilters(filters, ['profile'])\n\n        assert.equal(filters['profile.firstName'], 'Theodor');\n    })\n});"]},"hash":"17f3e874591a812c21751656ef4f9cc08f67226b"}
