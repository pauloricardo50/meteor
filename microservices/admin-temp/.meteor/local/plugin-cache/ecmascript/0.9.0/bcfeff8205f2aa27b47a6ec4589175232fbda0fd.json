{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":["getClosestStations","getNearbyPlace","getLocations"],"specifiers":[{"kind":"local","local":"getClosestStations","exported":"getClosestStations"},{"kind":"local","local":"getNearbyPlace","exported":"getNearbyPlace"},{"kind":"local","local":"getLocations","exported":"getLocations"}]}}},"options":{"filename":"imports/js/helpers/APIs.js","filenameRelative":"imports/js/helpers/APIs.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"imports/js/helpers/APIs.js.map","sourceFileName":"imports/js/helpers/APIs.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"APIs"},"ignored":false,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nmodule.export({\n  getClosestStations: function getClosestStations() {\n    return _getClosestStations;\n  },\n  getNearbyPlace: function getNearbyPlace() {\n    return _getNearbyPlace;\n  },\n  getLocations: function getLocations() {\n    return _getLocations;\n  }\n});\n\nvar _Meteor = void 0;\n\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor: function Meteor(v) {\n    _Meteor = v;\n  }\n}, 0);\nvar fetch = void 0;\nexports.getClosestStations = _getClosestStations;\n\nif (_Meteor.isServer) {\n  fetch = require('node-fetch');\n} else {\n  fetch = global.fetch;\n}\n\nvar _getClosestStations = function _getClosestStations(latitude, longitude) {\n  return fetch(\"https://transport.opendata.ch/v1/locations?x=\" + latitude + \"&y=\" + longitude + \"&type=station\").then(function (response) {\n    if (response.status !== 200) {\n      throw new Error('error code: ', response.status);\n    } else {\n      return response.json();\n    }\n  }).then(function (data) {\n    return data.stations;\n  });\n}; /**\n    * getPlace - Description\n    *\n    * @param {Object} origin {lat: Number, lng: Number}\n    * @param {String} type   type of place to search for\n    *\n    * @return {type} returns a promise with object {name: String, distance: Object}\n    */\n\nvar _getNearbyPlace = function _getNearbyPlace(latitude, longitude, type, byDistance) {\n  var location = new window.google.maps.LatLng(latitude, longitude);\n  return new Promise(function (resolve, reject) {\n    var div = document.createElement('div');\n    var service = new window.google.maps.places.PlacesService(div);\n    service.nearbySearch({\n      location: location,\n      radius: byDistance ? undefined : 5000,\n      rankBy: byDistance ? window.google.maps.places.RankBy.DISTANCE : window.google.maps.places.RankBy.PROMINENCE,\n      type: [type]\n    }, function (places, status) {\n      if (status === window.google.maps.places.PlacesServiceStatus.OK) {\n        resolve(places[0]);\n      } else {\n        reject(status);\n      }\n    });\n  }).then(function (place) {\n    var lat = place.geometry.location.lat();\n    var lng = place.geometry.location.lng();\n    var name = place.name;\n    return new Promise(function (resolve, reject) {\n      var distanceService = new window.google.maps.DistanceMatrixService();\n      distanceService.getDistanceMatrix({\n        origins: [location],\n        destinations: [new window.google.maps.LatLng(lat, lng)],\n        travelMode: 'WALKING'\n      }, function (result, status) {\n        if (status !== 'OK') {\n          reject(status);\n        }\n\n        resolve({\n          distance: result.rows[0].elements[0].distance,\n          name: name\n        });\n      });\n    });\n  });\n};\n\nvar google_key = 'AIzaSyCdoi6BxlTf7GgxqAGAsd1ADM_UwgqWUP8';\n\nvar _getLocations = function _getLocations(zipCode) {\n  return fetch(\"https://maps.googleapis.com/maps/api/geocode/json?address=\" + zipCode + \"&components=country:CH&language=fr&key=\" + google_key).then(function (result) {\n    return result.json();\n  }).then(function (result) {\n    var array = result.results[0].postcode_localities || [];\n    var localities = result.results[0].address_components.filter(function (obj) {\n      return obj.types.indexOf('locality') >= 0;\n    });\n\n    if (localities && localities.length) {\n      localities.forEach(function (l) {\n        return array.push(l.long_name);\n      });\n    } // filter duplicates\n\n\n    return array.filter(function (value, index) {\n      return array.indexOf(value) === index;\n    });\n  });\n};","map":{"version":3,"sources":["imports/js/helpers/APIs.js"],"names":["module","export","getClosestStations","getNearbyPlace","getLocations","Meteor","watch","require","v","fetch","isServer","global","latitude","longitude","then","response","status","Error","json","data","stations","type","byDistance","location","window","google","maps","LatLng","Promise","resolve","reject","div","document","createElement","service","places","PlacesService","nearbySearch","radius","undefined","rankBy","RankBy","DISTANCE","PROMINENCE","PlacesServiceStatus","OK","place","lat","geometry","lng","name","distanceService","DistanceMatrixService","getDistanceMatrix","origins","destinations","travelMode","result","distance","rows","elements","google_key","zipCode","array","results","postcode_localities","localities","address_components","filter","obj","types","indexOf","length","forEach","push","l","long_name","value","index"],"mappings":"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","file":"imports/js/helpers/APIs.js.map","sourcesContent":["import { Meteor } from 'meteor/meteor';\n\nlet fetch;\nif (Meteor.isServer) {\n  fetch = require('node-fetch');\n} else {\n  fetch = global.fetch;\n}\n\nexport const getClosestStations = (latitude, longitude) =>\n  fetch(`https://transport.opendata.ch/v1/locations?x=${latitude}&y=${longitude}&type=station`)\n    .then((response) => {\n      if (response.status !== 200) {\n        throw new Error('error code: ', response.status);\n      } else {\n        return response.json();\n      }\n    })\n    .then(data => data.stations);\n\n/**\n * getPlace - Description\n *\n * @param {Object} origin {lat: Number, lng: Number}\n * @param {String} type   type of place to search for\n *\n * @return {type} returns a promise with object {name: String, distance: Object}\n */\nexport const getNearbyPlace = (latitude, longitude, type, byDistance) => {\n  const location = new window.google.maps.LatLng(latitude, longitude);\n\n  return new Promise((resolve, reject) => {\n    const div = document.createElement('div');\n    const service = new window.google.maps.places.PlacesService(div);\n    service.nearbySearch(\n      {\n        location,\n        radius: byDistance ? undefined : 5000,\n        rankBy: byDistance\n          ? window.google.maps.places.RankBy.DISTANCE\n          : window.google.maps.places.RankBy.PROMINENCE,\n        type: [type],\n      },\n      (places, status) => {\n        if (status === window.google.maps.places.PlacesServiceStatus.OK) {\n          resolve(places[0]);\n        } else {\n          reject(status);\n        }\n      },\n    );\n  }).then((place) => {\n    const lat = place.geometry.location.lat();\n    const lng = place.geometry.location.lng();\n    const name = place.name;\n\n    return new Promise((resolve, reject) => {\n      const distanceService = new window.google.maps.DistanceMatrixService();\n\n      distanceService.getDistanceMatrix(\n        {\n          origins: [location],\n          destinations: [new window.google.maps.LatLng(lat, lng)],\n          travelMode: 'WALKING',\n        },\n        (result, status) => {\n          if (status !== 'OK') {\n            reject(status);\n          }\n          resolve({ distance: result.rows[0].elements[0].distance, name });\n        },\n      );\n    });\n  });\n};\n\nconst google_key = 'AIzaSyCdoi6BxlTf7GgxqAGAsd1ADM_UwgqWUP8';\nexport const getLocations = zipCode =>\n  fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${zipCode}&components=country:CH&language=fr&key=${google_key}`)\n    .then(result => result.json())\n    .then((result) => {\n      const array = result.results[0].postcode_localities || [];\n      const localities = result.results[0].address_components.filter(obj => obj.types.indexOf('locality') >= 0);\n      if (localities && localities.length) {\n        localities.forEach(l => array.push(l.long_name));\n      }\n      // filter duplicates\n      return array.filter((value, index) => array.indexOf(value) === index);\n    });\n"]},"hash":"bcfeff8205f2aa27b47a6ec4589175232fbda0fd"}
