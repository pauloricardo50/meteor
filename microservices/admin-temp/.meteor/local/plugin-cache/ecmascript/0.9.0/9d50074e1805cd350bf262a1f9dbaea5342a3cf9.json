{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash.clonedeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"deepClone"}]},{"source":"./cleanSelectors","imported":["cleanFilters","cleanOptions"],"specifiers":[{"kind":"named","imported":"cleanFilters","local":"cleanFilters"},{"kind":"named","imported":"cleanOptions","local":"cleanOptions"}]},{"source":"../../query/lib/dotize","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"dotize"}]}],"exports":{"exported":["cleanBody","main","second","args"],"specifiers":[{"kind":"local","local":"cleanBody","exported":"default"},{"kind":"local","local":"main","exported":"default"},{"kind":"local","local":"second","exported":"default"},{"kind":"local","local":"args","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","filenameRelative":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cleanBody"},"ignored":false,"code":"module.export({\n    \"default\": function () {\n        return cleanBody;\n    }\n});\nvar deepClone = void 0;\nmodule.watch(require(\"lodash.clonedeep\"), {\n    \"default\": function (v) {\n        deepClone = v;\n    }\n}, 0);\nvar cleanFilters = void 0,\n    cleanOptions = void 0;\nmodule.watch(require(\"./cleanSelectors\"), {\n    cleanFilters: function (v) {\n        cleanFilters = v;\n    },\n    cleanOptions: function (v) {\n        cleanOptions = v;\n    }\n}, 1);\nvar dotize = void 0;\nmodule.watch(require(\"../../query/lib/dotize\"), {\n    \"default\": function (v) {\n        dotize = v;\n    }\n}, 2);\n\nfunction cleanBody(main, second) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n\n    var object = {};\n\n    if (second.$filters || second.$options) {\n        var fields = getFields(main);\n        cleanFilters(second.$filters, fields);\n        cleanOptions(second.$options, fields);\n    }\n\n    _.each(second, function (secondValue, key) {\n        if (key === '$filters' || key === '$options') {\n            object[key] = secondValue;\n            return;\n        }\n\n        var value = main[key];\n\n        if (value === undefined) {\n            return;\n        } // if the main value is a function, we run it.\n\n\n        if (_.isFunction(value)) {\n            var _value;\n\n            value = (_value = value).call.apply(_value, [null].concat(args));\n        } // if the main value is undefined or false, we skip the merge\n\n\n        if (value === undefined || value === false) {\n            return;\n        } // we treat this specially, if the value is true\n\n\n        if (value === true) {\n            object[key] = _.isObject(secondValue) ? deepClone(secondValue) : value;\n            return;\n        } // if the main value is an object\n\n\n        if (_.isObject(value)) {\n            if (_.isObject(secondValue)) {\n                // if the second one is an object as well we run recursively run the intersection\n                object[key] = cleanBody.apply(undefined, [value, secondValue].concat(args));\n            } // if it is not, then we will ignore it, because it won't make sense.\n            // to merge {a: 1} with 1.\n\n\n            return;\n        } // if the main value is not an object, it should be a truthy value like 1\n\n\n        if (_.isObject(secondValue)) {\n            // if the second value is an object, then we will keep it.\n            // this won't cause problem with deep nesting because\n            // when you specify links you will have the main value as an object, otherwise it will fail\n            // this is used for things like when you have a hash object like profile with multiple nesting fields, you can allow the client to specify only what he needs\n            object[key] = deepClone(secondValue);\n        } else {\n            // if the second value is not an object, we just store the first value\n            object[key] = value;\n        }\n    });\n\n    return object;\n}\n\nfunction getFields(body) {\n    return _.keys(dotize.convert(body));\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js"],"names":["module","export","cleanBody","deepClone","watch","require","v","cleanFilters","cleanOptions","dotize","main","second","args","object","$filters","$options","fields","getFields","_","each","secondValue","key","value","undefined","isFunction","call","isObject","body","keys","convert"],"mappings":"AAAAA,OAAOC,MAAP,CAAc;AAAC,eAAQ;AAAA,eAAIC,SAAJ;AAAA;AAAT,CAAd;AAAuC,IAAIC,kBAAJ;AAAcH,OAAOI,KAAP,CAAaC,QAAQ,kBAAR,CAAb,EAAyC;AAAA,yBAASC,CAAT,EAAW;AAACH,oBAAUG,CAAV;AAAY;AAAxB,CAAzC,EAAmE,CAAnE;AAAsE,IAAIC,qBAAJ;AAAA,IAAiBC,qBAAjB;AAA8BR,OAAOI,KAAP,CAAaC,QAAQ,kBAAR,CAAb,EAAyC;AAACE,gBAAD,YAAcD,CAAd,EAAgB;AAACC,uBAAaD,CAAb;AAAe,KAAhC;AAAiCE,gBAAjC,YAA8CF,CAA9C,EAAgD;AAACE,uBAAaF,CAAb;AAAe;AAAhE,CAAzC,EAA2G,CAA3G;AAA8G,IAAIG,eAAJ;AAAWT,OAAOI,KAAP,CAAaC,QAAQ,wBAAR,CAAb,EAA+C;AAAA,yBAASC,CAAT,EAAW;AAACG,iBAAOH,CAAP;AAAS;AAArB,CAA/C,EAAsE,CAAtE;;AAOnQ,SAASJ,SAAT,CAAmBQ,IAAnB,EAAyBC,MAAzB,EAA0C;AAAA,sCAANC,IAAM;AAANA,YAAM;AAAA;;AACrD,QAAIC,SAAS,EAAb;;AAEA,QAAIF,OAAOG,QAAP,IAAmBH,OAAOI,QAA9B,EAAwC;AACpC,YAAMC,SAASC,UAAUP,IAAV,CAAf;AAEAH,qBAAaI,OAAOG,QAApB,EAA8BE,MAA9B;AACAR,qBAAaG,OAAOI,QAApB,EAA8BC,MAA9B;AACH;;AAEDE,MAAEC,IAAF,CAAOR,MAAP,EAAe,UAACS,WAAD,EAAcC,GAAd,EAAsB;AACjC,YAAIA,QAAQ,UAAR,IAAsBA,QAAQ,UAAlC,EAA8C;AAC1CR,mBAAOQ,GAAP,IAAcD,WAAd;AACA;AACH;;AAED,YAAIE,QAAQZ,KAAKW,GAAL,CAAZ;;AAEA,YAAIC,UAAUC,SAAd,EAAyB;AACrB;AACH,SAVgC,CAYjC;;;AACA,YAAIL,EAAEM,UAAF,CAAaF,KAAb,CAAJ,EAAyB;AAAA;;AACrBA,oBAAQ,iBAAMG,IAAN,gBAAW,IAAX,SAAoBb,IAApB,EAAR;AACH,SAfgC,CAiBjC;;;AACA,YAAIU,UAAUC,SAAV,IAAuBD,UAAU,KAArC,EAA4C;AACxC;AACH,SApBgC,CAsBjC;;;AACA,YAAIA,UAAU,IAAd,EAAoB;AAChBT,mBAAOQ,GAAP,IAAcH,EAAEQ,QAAF,CAAWN,WAAX,IAA0BjB,UAAUiB,WAAV,CAA1B,GAAmDE,KAAjE;AACA;AACH,SA1BgC,CA4BjC;;;AACA,YAAIJ,EAAEQ,QAAF,CAAWJ,KAAX,CAAJ,EAAuB;AACnB,gBAAIJ,EAAEQ,QAAF,CAAWN,WAAX,CAAJ,EAA6B;AACzB;AACAP,uBAAOQ,GAAP,IAAcnB,4BAAUoB,KAAV,EAAiBF,WAAjB,SAAiCR,IAAjC,EAAd;AACH,aAJkB,CAKnB;AACA;;;AAEA;AACH,SAtCgC,CAwCjC;;;AACA,YAAIM,EAAEQ,QAAF,CAAWN,WAAX,CAAJ,EAA6B;AACzB;AACA;AACA;AACA;AAEAP,mBAAOQ,GAAP,IAAclB,UAAUiB,WAAV,CAAd;AACH,SAPD,MAOO;AACH;AACAP,mBAAOQ,GAAP,IAAcC,KAAd;AACH;AACJ,KApDD;;AAsDA,WAAOT,MAAP;AACH;;AAED,SAASI,SAAT,CAAmBU,IAAnB,EAAyB;AACrB,WAAOT,EAAEU,IAAF,CAAOnB,OAAOoB,OAAP,CAAeF,IAAf,CAAP,CAAP;AACH","file":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js.map","sourcesContent":["import deepClone from 'lodash.clonedeep';\nimport {cleanFilters, cleanOptions} from './cleanSelectors';\nimport dotize from '../../query/lib/dotize';\n\n/**\n * Deep Inter Computation\n */\nexport default function cleanBody(main, second, ...args) {\n    let object = {};\n\n    if (second.$filters || second.$options) {\n        const fields = getFields(main);\n\n        cleanFilters(second.$filters, fields);\n        cleanOptions(second.$options, fields);\n    }\n\n    _.each(second, (secondValue, key) => {\n        if (key === '$filters' || key === '$options') {\n            object[key] = secondValue;\n            return;\n        }\n\n        let value = main[key];\n\n        if (value === undefined) {\n            return;\n        }\n\n        // if the main value is a function, we run it.\n        if (_.isFunction(value)) {\n            value = value.call(null, ...args);\n        }\n\n        // if the main value is undefined or false, we skip the merge\n        if (value === undefined || value === false) {\n            return;\n        }\n\n        // we treat this specially, if the value is true\n        if (value === true) {\n            object[key] = _.isObject(secondValue) ? deepClone(secondValue) : value;\n            return;\n        }\n\n        // if the main value is an object\n        if (_.isObject(value)) {\n            if (_.isObject(secondValue)) {\n                // if the second one is an object as well we run recursively run the intersection\n                object[key] = cleanBody(value, secondValue, ...args);\n            }\n            // if it is not, then we will ignore it, because it won't make sense.\n            // to merge {a: 1} with 1.\n\n            return;\n        }\n\n        // if the main value is not an object, it should be a truthy value like 1\n        if (_.isObject(secondValue)) {\n            // if the second value is an object, then we will keep it.\n            // this won't cause problem with deep nesting because\n            // when you specify links you will have the main value as an object, otherwise it will fail\n            // this is used for things like when you have a hash object like profile with multiple nesting fields, you can allow the client to specify only what he needs\n\n            object[key] = deepClone(secondValue);\n        } else {\n            // if the second value is not an object, we just store the first value\n            object[key] = value;\n        }\n    });\n\n    return object;\n}\n\nfunction getFields(body) {\n    return _.keys(dotize.convert(body));\n}"]},"hash":"9d50074e1805cd350bf262a1f9dbaea5342a3cf9"}
