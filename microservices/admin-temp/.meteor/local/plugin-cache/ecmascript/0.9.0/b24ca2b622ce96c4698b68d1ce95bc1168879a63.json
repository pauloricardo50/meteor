{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"./counts/countSubscription","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"CountSubscription"}]},{"source":"./lib/createGraph.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createGraph"}]},{"source":"./lib/recursiveFetch.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"recursiveFetch"}]},{"source":"./lib/prepareForProcess.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"prepareForProcess"}]},{"source":"./lib/callWithPromise","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"callWithPromise"}]},{"source":"./query.base","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Base"}]}],"exports":{"exported":["Query"],"specifiers":[{"kind":"local","local":"Query","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/query.client.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/query.client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/query.client.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/query.client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"query.client"},"ignored":false,"code":"module.export({\n    default: () => Query\n});\n\nlet _;\n\nmodule.watch(require(\"meteor/underscore\"), {\n    _(v) {\n        _ = v;\n    }\n\n}, 0);\nlet CountSubscription;\nmodule.watch(require(\"./counts/countSubscription\"), {\n    default(v) {\n        CountSubscription = v;\n    }\n\n}, 1);\nlet createGraph;\nmodule.watch(require(\"./lib/createGraph.js\"), {\n    default(v) {\n        createGraph = v;\n    }\n\n}, 2);\nlet recursiveFetch;\nmodule.watch(require(\"./lib/recursiveFetch.js\"), {\n    default(v) {\n        recursiveFetch = v;\n    }\n\n}, 3);\nlet prepareForProcess;\nmodule.watch(require(\"./lib/prepareForProcess.js\"), {\n    default(v) {\n        prepareForProcess = v;\n    }\n\n}, 4);\nlet callWithPromise;\nmodule.watch(require(\"./lib/callWithPromise\"), {\n    default(v) {\n        callWithPromise = v;\n    }\n\n}, 5);\nlet Base;\nmodule.watch(require(\"./query.base\"), {\n    default(v) {\n        Base = v;\n    }\n\n}, 6);\n\nclass Query extends Base {\n    /**\n     * Subscribe\n     *\n     * @param callback {Function} optional\n     * @returns {null|any|*}\n     */subscribe(callback) {\n        this.doValidateParams();\n        this.subscriptionHandle = Meteor.subscribe(this.name, prepareForProcess(this.body, this.params), callback);\n        return this.subscriptionHandle;\n    } /**\n       * Subscribe to the counts for this query\n       *\n       * @param callback\n       * @returns {Object}\n       */\n\n    subscribeCount(callback) {\n        this.doValidateParams();\n\n        if (!this._counter) {\n            this._counter = new CountSubscription(this);\n        }\n\n        return this._counter.subscribe(prepareForProcess(this.body, this.params), callback);\n    } /**\n       * Unsubscribe if an existing subscription exists\n       */\n\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.subscriptionHandle.stop();\n        }\n\n        this.subscriptionHandle = null;\n    } /**\n       * Unsubscribe to the counts if a subscription exists.\n       */\n\n    unsubscribeCount() {\n        if (this._counter) {\n            this._counter.unsubscribe();\n\n            this._counter = null;\n        }\n    } /**\n       * Fetches elements in sync using promises\n       * @return {*}\n       */\n\n    fetchSync() {\n        return Promise.asyncApply(() => {\n            this.doValidateParams();\n\n            if (this.subscriptionHandle) {\n                throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n            }\n\n            return Promise.await(callWithPromise(this.name, prepareForProcess(this.body, this.params)));\n        });\n    } /**\n       * Fetches one element in sync\n       * @return {*}\n       */\n\n    fetchOneSync() {\n        return Promise.asyncApply(() => {\n            return _.first(Promise.await(this.fetchSync()));\n        });\n    } /**\n       * Retrieves the data.\n       * @param callbackOrOptions\n       * @returns {*}\n       */\n\n    fetch(callbackOrOptions) {\n        this.doValidateParams();\n\n        if (!this.subscriptionHandle) {\n            return this._fetchStatic(callbackOrOptions);\n        } else {\n            return this._fetchReactive(callbackOrOptions);\n        }\n    } /**\n       * @param args\n       * @returns {*}\n       */\n\n    fetchOne(...args) {\n        if (!this.subscriptionHandle) {\n            const callback = args[0];\n\n            if (!_.isFunction(callback)) {\n                throw new Meteor.Error('You did not provide a valid callback');\n            }\n\n            this.fetch((err, res) => {\n                callback(err, res ? _.first(res) : null);\n            });\n        } else {\n            return _.first(this.fetch(...args));\n        }\n    } /**\n       * Gets the count of matching elements in sync.\n       * @returns {any}\n       */\n\n    getCountSync() {\n        return Promise.asyncApply(() => {\n            if (this._counter) {\n                throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n            }\n\n            return Promise.await(callWithPromise(this.name + '.count', prepareForProcess(this.body, this.params)));\n        });\n    } /**\n       * Gets the count of matching elements.\n       * @param callback\n       * @returns {any}\n       */\n\n    getCount(callback) {\n        if (this._counter) {\n            return this._counter.getCount();\n        } else {\n            if (!callback) {\n                throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the count or subscribe first.');\n            } else {\n                return Meteor.call(this.name + '.count', prepareForProcess(this.body, this.params), callback);\n            }\n        }\n    } /**\n       * Fetching non-reactive queries\n       * @param callback\n       * @private\n       */\n\n    _fetchStatic(callback) {\n        if (!callback) {\n            throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the data or subscribe first.');\n        }\n\n        Meteor.call(this.name, prepareForProcess(this.body, this.params), callback);\n    } /**\n       * Fetching when we've got an active publication\n       *\n       * @param options\n       * @returns {*}\n       * @private\n       */\n\n    _fetchReactive(options = {}) {\n        let body = prepareForProcess(this.body, this.params);\n\n        if (!options.allowSkip && body.$options && body.$options.skip) {\n            delete body.$options.skip;\n        }\n\n        return recursiveFetch(createGraph(this.collection, body), this.params);\n    }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/query.client.js"],"names":["module","export","default","Query","_","watch","require","v","CountSubscription","createGraph","recursiveFetch","prepareForProcess","callWithPromise","Base","subscribe","callback","doValidateParams","subscriptionHandle","Meteor","name","body","params","subscribeCount","_counter","unsubscribe","stop","unsubscribeCount","fetchSync","Error","fetchOneSync","first","fetch","callbackOrOptions","_fetchStatic","_fetchReactive","fetchOne","args","isFunction","err","res","getCountSync","getCount","call","options","allowSkip","$options","skip","collection"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/query.client.js.map","sourcesContent":["import { _ } from 'meteor/underscore';\nimport CountSubscription from './counts/countSubscription';\nimport createGraph from './lib/createGraph.js';\nimport recursiveFetch from './lib/recursiveFetch.js';\nimport prepareForProcess from './lib/prepareForProcess.js';\nimport callWithPromise from './lib/callWithPromise';\nimport Base from './query.base';\n\nexport default class Query extends Base {\n    /**\n     * Subscribe\n     *\n     * @param callback {Function} optional\n     * @returns {null|any|*}\n     */\n    subscribe(callback) {\n        this.doValidateParams();\n\n        this.subscriptionHandle = Meteor.subscribe(\n            this.name,\n            prepareForProcess(this.body, this.params),\n            callback\n        );\n\n        return this.subscriptionHandle;\n    }\n\n    /**\n     * Subscribe to the counts for this query\n     *\n     * @param callback\n     * @returns {Object}\n     */\n    subscribeCount(callback) {\n        this.doValidateParams();\n\n        if (!this._counter) {\n            this._counter = new CountSubscription(this);\n        }\n\n        return this._counter.subscribe(\n            prepareForProcess(this.body, this.params),\n            callback\n        );\n    }\n\n    /**\n     * Unsubscribe if an existing subscription exists\n     */\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.subscriptionHandle.stop();\n        }\n\n        this.subscriptionHandle = null;\n    }\n\n    /**\n     * Unsubscribe to the counts if a subscription exists.\n     */\n    unsubscribeCount() {\n        if (this._counter) {\n            this._counter.unsubscribe();\n            this._counter = null;\n        }\n    }\n\n    /**\n     * Fetches elements in sync using promises\n     * @return {*}\n     */\n    async fetchSync() {\n        this.doValidateParams();\n\n        if (this.subscriptionHandle) {\n            throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n        }\n\n        return await callWithPromise(this.name, prepareForProcess(this.body, this.params));\n    }\n\n    /**\n     * Fetches one element in sync\n     * @return {*}\n     */\n    async fetchOneSync() {\n        return _.first(await this.fetchSync())\n    }\n\n    /**\n     * Retrieves the data.\n     * @param callbackOrOptions\n     * @returns {*}\n     */\n    fetch(callbackOrOptions) {\n        this.doValidateParams();\n\n        if (!this.subscriptionHandle) {\n            return this._fetchStatic(callbackOrOptions)\n        } else {\n            return this._fetchReactive(callbackOrOptions);\n        }\n    }\n\n    /**\n     * @param args\n     * @returns {*}\n     */\n    fetchOne(...args) {\n        if (!this.subscriptionHandle) {\n            const callback = args[0];\n            if (!_.isFunction(callback)) {\n                throw new Meteor.Error('You did not provide a valid callback');\n            }\n\n            this.fetch((err, res) => {\n                callback(err, res ? _.first(res) : null);\n            })\n        } else {\n            return _.first(this.fetch(...args));\n        }\n    }\n\n    /**\n     * Gets the count of matching elements in sync.\n     * @returns {any}\n     */\n    async getCountSync() {\n        if (this._counter) {\n            throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n        }\n\n        return await callWithPromise(this.name + '.count', prepareForProcess(this.body, this.params));\n    }\n\n    /**\n     * Gets the count of matching elements.\n     * @param callback\n     * @returns {any}\n     */\n    getCount(callback) {\n        if (this._counter) {\n            return this._counter.getCount();\n        } else {\n            if (!callback) {\n                throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the count or subscribe first.');\n            } else {\n                return Meteor.call(\n                    this.name + '.count',\n                    prepareForProcess(this.body, this.params),\n                    callback\n                );\n            }\n        }\n    }\n\n    /**\n     * Fetching non-reactive queries\n     * @param callback\n     * @private\n     */\n    _fetchStatic(callback) {\n        if (!callback) {\n            throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the data or subscribe first.');\n        }\n\n        Meteor.call(this.name, prepareForProcess(this.body, this.params), callback);\n    }\n\n    /**\n     * Fetching when we've got an active publication\n     *\n     * @param options\n     * @returns {*}\n     * @private\n     */\n    _fetchReactive(options = {}) {\n        let body = prepareForProcess(this.body, this.params);\n        if (!options.allowSkip && body.$options && body.$options.skip) {\n            delete body.$options.skip;\n        }\n\n        return recursiveFetch(\n            createGraph(this.collection, body),\n            this.params\n        );\n    }\n}\n"]},"hash":"b24ca2b622ce96c4698b68d1ce95bc1168879a63"}
