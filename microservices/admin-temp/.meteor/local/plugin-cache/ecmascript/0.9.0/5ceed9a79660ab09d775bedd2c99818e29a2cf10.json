{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../query/counts/genEndpoint.server.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"genCountEndpoint"}]},{"source":"../query/lib/createGraph.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createGraph"}]},{"source":"../query/lib/recursiveCompose.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"recursiveCompose"}]},{"source":"../query/hypernova/hypernova.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"hypernova"}]},{"source":"./exposure.config.schema.js","imported":["ExposureSchema","ExposureDefaults","validateBody"],"specifiers":[{"kind":"named","imported":"ExposureSchema","local":"ExposureSchema"},{"kind":"named","imported":"ExposureDefaults","local":"ExposureDefaults"},{"kind":"named","imported":"validateBody","local":"validateBody"}]},{"source":"./lib/enforceMaxDepth.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxDepth"}]},{"source":"./lib/enforceMaxLimit.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxLimit"}]},{"source":"./lib/cleanBody.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanBody"}]},{"source":"lodash.clonedeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"deepClone"}]},{"source":"./lib/restrictFields.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"restrictFieldsFn"}]},{"source":"./lib/restrictLinks.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"restrictLinks"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]}],"exports":{"exported":["Exposure"],"specifiers":[{"kind":"local","local":"Exposure","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/exposure/exposure.js","filenameRelative":"packages/cultofcoders:grapher/lib/exposure/exposure.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/exposure/exposure.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/exposure/exposure.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"exposure"},"ignored":false,"code":"module.export({\n    default: () => Exposure\n});\nlet genCountEndpoint;\nmodule.watch(require(\"../query/counts/genEndpoint.server.js\"), {\n    default(v) {\n        genCountEndpoint = v;\n    }\n\n}, 0);\nlet createGraph;\nmodule.watch(require(\"../query/lib/createGraph.js\"), {\n    default(v) {\n        createGraph = v;\n    }\n\n}, 1);\nlet recursiveCompose;\nmodule.watch(require(\"../query/lib/recursiveCompose.js\"), {\n    default(v) {\n        recursiveCompose = v;\n    }\n\n}, 2);\nlet hypernova;\nmodule.watch(require(\"../query/hypernova/hypernova.js\"), {\n    default(v) {\n        hypernova = v;\n    }\n\n}, 3);\nlet ExposureSchema, ExposureDefaults, validateBody;\nmodule.watch(require(\"./exposure.config.schema.js\"), {\n    ExposureSchema(v) {\n        ExposureSchema = v;\n    },\n\n    ExposureDefaults(v) {\n        ExposureDefaults = v;\n    },\n\n    validateBody(v) {\n        validateBody = v;\n    }\n\n}, 4);\nlet enforceMaxDepth;\nmodule.watch(require(\"./lib/enforceMaxDepth.js\"), {\n    default(v) {\n        enforceMaxDepth = v;\n    }\n\n}, 5);\nlet enforceMaxLimit;\nmodule.watch(require(\"./lib/enforceMaxLimit.js\"), {\n    default(v) {\n        enforceMaxLimit = v;\n    }\n\n}, 6);\nlet cleanBody;\nmodule.watch(require(\"./lib/cleanBody.js\"), {\n    default(v) {\n        cleanBody = v;\n    }\n\n}, 7);\nlet deepClone;\nmodule.watch(require(\"lodash.clonedeep\"), {\n    default(v) {\n        deepClone = v;\n    }\n\n}, 8);\nlet restrictFieldsFn;\nmodule.watch(require(\"./lib/restrictFields.js\"), {\n    default(v) {\n        restrictFieldsFn = v;\n    }\n\n}, 9);\nlet restrictLinks;\nmodule.watch(require(\"./lib/restrictLinks.js\"), {\n    default(v) {\n        restrictLinks = v;\n    }\n\n}, 10);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n    check(v) {\n        check = v;\n    }\n\n}, 11);\nlet globalConfig = {};\n\nclass Exposure {\n    static setConfig(config) {\n        Object.assign(globalConfig, config);\n    }\n\n    static getConfig() {\n        return globalConfig;\n    }\n\n    static restrictFields(...args) {\n        return restrictFieldsFn(...args);\n    }\n\n    constructor(collection, config = {}) {\n        collection.__isExposedForGrapher = true;\n        collection.__exposure = this;\n        this.collection = collection;\n        this.name = `exposure_${collection._name}`;\n        this.config = config;\n\n        this._validateAndClean();\n\n        this.initSecurity();\n\n        if (this.config.publication) {\n            this.initPublication();\n        }\n\n        if (this.config.method) {\n            this.initMethod();\n        }\n\n        if (!this.config.method && !this.config.publication) {\n            throw new Meteor.Error('weird', 'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true');\n        }\n\n        this.initCountMethod();\n        this.initCountPublication();\n    }\n\n    _validateAndClean() {\n        if (typeof this.config === 'function') {\n            const firewall = this.config;\n            this.config = {\n                firewall\n            };\n        }\n\n        this.config = Object.assign({}, ExposureDefaults, Exposure.getConfig(), this.config);\n        check(this.config, ExposureSchema);\n\n        if (this.config.body) {\n            validateBody(this.collection, this.config.body);\n        }\n    } /**\n       * Takes the body and intersects it with the exposure body, if it exists.\n       *\n       * @param body\n       * @param userId\n       * @returns {*}\n       */\n\n    getTransformedBody(body, userId) {\n        if (!this.config.body) {\n            return body;\n        }\n\n        const processedBody = this.getBody(userId);\n\n        if (processedBody === true) {\n            return;\n        }\n\n        return cleanBody(processedBody, body);\n    } /**\n       * Gets the exposure body\n       */\n\n    getBody(userId) {\n        if (!this.config.body) {\n            throw new Meteor.Error('missing-body', 'Cannot get exposure body because it was not defined.');\n        }\n\n        let body;\n\n        if (_.isFunction(this.config.body)) {\n            body = this.config.body.call(this, userId);\n        } else {\n            body = this.config.body;\n        } // it means we allow everything, no need for cloning.\n\n\n        if (body === true) {\n            return true;\n        }\n\n        return deepClone(body, userId);\n    } /**\n       * Initializing the publication for reactive query fetching\n       */\n\n    initPublication() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n        Meteor.publishComposite(this.name, function (body) {\n            let transformedBody = getTransformedBody(body);\n            const rootNode = createGraph(collection, transformedBody);\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n            return recursiveCompose(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        });\n    } /**\n       * Initializez the method to retrieve the data via Meteor.call\n       */\n\n    initMethod() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        const methodBody = function (body) {\n            if (!config.blocking) {\n                this.unblock();\n            }\n\n            let transformedBody = getTransformedBody(body);\n            const rootNode = createGraph(collection, transformedBody);\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId); // if there is no exposure body defined, then we need to apply firewalls\n\n            return hypernova(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        };\n\n        Meteor.methods({\n            [this.name]: methodBody\n        });\n    } /**\n       * Initializes the method to retrieve the count of the data via Meteor.call\n       * @returns {*}\n       */\n\n    initCountMethod() {\n        const collection = this.collection;\n        Meteor.methods({\n            [this.name + '.count'](body) {\n                this.unblock();\n                return collection.find(body.$filters || {}, {}, this.userId).count();\n            }\n\n        });\n    } /**\n       * Initializes the reactive endpoint to retrieve the count of the data.\n       */\n\n    initCountPublication() {\n        const collection = this.collection;\n        genCountEndpoint(this.name, {\n            getCursor(session) {\n                return collection.find(session.filters, {\n                    fields: {\n                        _id: 1\n                    }\n                }, this.userId);\n            },\n\n            getSession(body) {\n                return {\n                    filters: body.$filters || {}\n                };\n            }\n\n        });\n    } /**\n       * Initializes security enforcement\n       * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n       */\n\n    initSecurity() {\n        const collection = this.collection;\n        const {\n            firewall,\n            maxLimit,\n            restrictedFields\n        } = this.config;\n        const find = collection.find.bind(collection);\n        const findOne = collection.findOne.bind(collection);\n\n        collection.firewall = (filters, options, userId) => {\n            if (userId !== undefined) {\n                this._callFirewall({\n                    collection: collection\n                }, filters, options, userId);\n\n                enforceMaxLimit(options, maxLimit);\n\n                if (restrictedFields) {\n                    Exposure.restrictFields(filters, options, restrictedFields);\n                }\n            }\n        };\n\n        collection.find = function (filters, options = {}, userId = undefined) {\n            if (arguments.length == 0) {\n                filters = {};\n            } // If filters is undefined it should return an empty item\n\n\n            if (arguments.length > 0 && filters === undefined) {\n                return find(undefined, options);\n            }\n\n            collection.firewall(filters, options, userId);\n            return find(filters, options);\n        };\n\n        collection.findOne = function (filters, options = {}, userId = undefined) {\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return null;\n            }\n\n            if (typeof filters === 'string') {\n                filters = {\n                    _id: filters\n                };\n            }\n\n            collection.firewall(filters, options, userId);\n            return findOne(filters, options);\n        };\n    } /**\n       * @private\n       */\n\n    _callFirewall(...args) {\n        const {\n            firewall\n        } = this.config;\n\n        if (!firewall) {\n            return;\n        }\n\n        if (_.isArray(firewall)) {\n            firewall.forEach(fire => {\n                fire.call(...args);\n            });\n        } else {\n            firewall.call(...args);\n        }\n    }\n\n}\n\n;","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/exposure.js"],"names":["module","export","default","Exposure","genCountEndpoint","watch","require","v","createGraph","recursiveCompose","hypernova","ExposureSchema","ExposureDefaults","validateBody","enforceMaxDepth","enforceMaxLimit","cleanBody","deepClone","restrictFieldsFn","restrictLinks","check","globalConfig","setConfig","config","Object","assign","getConfig","restrictFields","args","constructor","collection","__isExposedForGrapher","__exposure","name","_name","_validateAndClean","initSecurity","publication","initPublication","method","initMethod","Meteor","Error","initCountMethod","initCountPublication","firewall","body","getTransformedBody","userId","processedBody","getBody","_","isFunction","call","bind","publishComposite","transformedBody","rootNode","maxDepth","bypassFirewalls","methodBody","blocking","unblock","methods","find","$filters","count","getCursor","session","filters","fields","_id","getSession","maxLimit","restrictedFields","findOne","options","undefined","_callFirewall","arguments","length","isArray","forEach","fire"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/exposure/exposure.js.map","sourcesContent":["import genCountEndpoint from '../query/counts/genEndpoint.server.js';\nimport createGraph from '../query/lib/createGraph.js';\nimport recursiveCompose from '../query/lib/recursiveCompose.js';\nimport hypernova from '../query/hypernova/hypernova.js';\nimport {ExposureSchema, ExposureDefaults, validateBody} from './exposure.config.schema.js';\nimport enforceMaxDepth from './lib/enforceMaxDepth.js';\nimport enforceMaxLimit from './lib/enforceMaxLimit.js';\nimport cleanBody from './lib/cleanBody.js';\nimport deepClone from 'lodash.clonedeep';\nimport restrictFieldsFn from './lib/restrictFields.js';\nimport restrictLinks from './lib/restrictLinks.js';\nimport {check} from 'meteor/check';\n\nlet globalConfig = {};\n\nexport default class Exposure {\n    static setConfig(config) {\n        Object.assign(globalConfig, config);\n    }\n\n    static getConfig() {\n        return globalConfig;\n    }\n\n    static restrictFields(...args) {\n        return restrictFieldsFn(...args);\n    }\n\n    constructor(collection, config = {}) {\n        collection.__isExposedForGrapher = true;\n        collection.__exposure = this;\n\n        this.collection = collection;\n        this.name = `exposure_${collection._name}`;\n\n        this.config = config;\n        this._validateAndClean();\n\n        this.initSecurity();\n\n        if (this.config.publication) {\n            this.initPublication();\n        }\n\n        if (this.config.method) {\n            this.initMethod();\n        }\n\n        if (!this.config.method && !this.config.publication) {\n            throw new Meteor.Error('weird', 'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true')\n        }\n\n        this.initCountMethod();\n        this.initCountPublication();\n    }\n\n    _validateAndClean() {\n        if (typeof(this.config) === 'function') {\n            const firewall = this.config;\n            this.config = {firewall};\n        }\n\n        this.config = Object.assign({}, ExposureDefaults, Exposure.getConfig(), this.config);\n        check(this.config, ExposureSchema);\n\n        if (this.config.body) {\n            validateBody(this.collection, this.config.body);\n        }\n    }\n\n    /**\n     * Takes the body and intersects it with the exposure body, if it exists.\n     *\n     * @param body\n     * @param userId\n     * @returns {*}\n     */\n    getTransformedBody(body, userId) {\n        if (!this.config.body) {\n            return body;\n        }\n\n        const processedBody = this.getBody(userId);\n\n        if (processedBody === true) {\n            return;\n        }\n\n        return cleanBody(processedBody, body);\n    }\n\n    /**\n     * Gets the exposure body\n     */\n    getBody(userId) {\n        if (!this.config.body) {\n            throw new Meteor.Error('missing-body', 'Cannot get exposure body because it was not defined.');\n        }\n\n        let body;\n        if (_.isFunction(this.config.body)) {\n            body = this.config.body.call(this, userId);\n        } else {\n            body = this.config.body;\n        }\n\n        // it means we allow everything, no need for cloning.\n        if (body === true) {\n            return true;\n        }\n\n        return deepClone(\n            body,\n            userId\n        );\n    }\n\n    /**\n     * Initializing the publication for reactive query fetching\n     */\n    initPublication() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        Meteor.publishComposite(this.name, function (body) {\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            return recursiveCompose(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        });\n    }\n\n    /**\n     * Initializez the method to retrieve the data via Meteor.call\n     */\n    initMethod() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        const methodBody = function(body) {\n            if (!config.blocking) {\n                this.unblock();\n            }\n\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            // if there is no exposure body defined, then we need to apply firewalls\n            return hypernova(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        };\n\n        Meteor.methods({\n            [this.name]: methodBody\n        });\n    }\n\n    /**\n     * Initializes the method to retrieve the count of the data via Meteor.call\n     * @returns {*}\n     */\n    initCountMethod() {\n        const collection = this.collection;\n\n        Meteor.methods({\n            [this.name + '.count'](body) {\n                this.unblock();\n\n                return collection.find(body.$filters || {}, {}, this.userId).count();\n            }\n        })\n    }\n\n    /**\n     * Initializes the reactive endpoint to retrieve the count of the data.\n     */\n    initCountPublication() {\n        const collection = this.collection;\n\n        genCountEndpoint(this.name, {\n            getCursor(session) {\n                return collection.find(session.filters, {\n                    fields: {_id: 1},\n                }, this.userId);\n            },\n\n            getSession(body) {\n                return { filters: body.$filters || {} };\n            },\n        });\n    }\n\n    /**\n     * Initializes security enforcement\n     * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n     */\n    initSecurity() {\n        const collection = this.collection;\n        const {firewall, maxLimit, restrictedFields} = this.config;\n        const find = collection.find.bind(collection);\n        const findOne = collection.findOne.bind(collection);\n\n        collection.firewall = (filters, options, userId) => {\n            if (userId !== undefined) {\n                this._callFirewall({collection: collection}, filters, options, userId);\n\n                enforceMaxLimit(options, maxLimit);\n\n                if (restrictedFields) {\n                    Exposure.restrictFields(filters, options, restrictedFields);\n                }\n            }\n        };\n\n        collection.find = function (filters, options = {}, userId = undefined) {\n            if (arguments.length == 0) {\n                filters = {};\n            }\n\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return find(undefined, options);\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return find(filters, options);\n        };\n\n        collection.findOne = function (filters, options = {}, userId = undefined) {\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return null;\n            }\n\n            if (typeof(filters) === 'string') {\n                filters = {_id: filters};\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return findOne(filters, options);\n        }\n    }\n\n    /**\n     * @private\n     */\n    _callFirewall(...args) {\n        const {firewall} = this.config;\n        if (!firewall) {\n            return;\n        }\n\n        if (_.isArray(firewall)) {\n            firewall.forEach(fire => {\n                fire.call(...args);\n            })\n        } else {\n            firewall.call(...args);\n        }\n    }\n};\n"]},"hash":"5ceed9a79660ab09d775bedd2c99818e29a2cf10"}
