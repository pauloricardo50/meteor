{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../../links/lib/createSearchFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createSearchFilters"}]},{"source":"./lib/cleanObjectForMetaFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanObjectForMetaFilters"}]},{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"assembler"},"ignored":false,"code":"let createSearchFilters;\nmodule.watch(require(\"../../links/lib/createSearchFilters\"), {\n    default(v) {\n        createSearchFilters = v;\n    }\n\n}, 0);\nlet cleanObjectForMetaFilters;\nmodule.watch(require(\"./lib/cleanObjectForMetaFilters\"), {\n    default(v) {\n        cleanObjectForMetaFilters = v;\n    }\n\n}, 1);\nlet sift;\nmodule.watch(require(\"sift\"), {\n    default(v) {\n        sift = v;\n    }\n\n}, 2);\nmodule.exportDefault((childCollectionNode, {\n    limit,\n    skip,\n    metaFilters\n}) => {\n    const parent = childCollectionNode.parent;\n    const linker = childCollectionNode.linker;\n    const strategy = linker.strategy;\n    const isSingle = linker.isSingle();\n    const isMeta = linker.isMeta();\n    const fieldStorage = linker.linkStorageField; // cleaning the parent results from a child\n    // this may be the wrong approach but it works for now\n\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n\n        _.each(parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, fieldStorage, metaFiltersTest);\n        });\n    }\n\n    _.each(parent.results, result => {\n        let data = assembleData(childCollectionNode, result, {\n            fieldStorage,\n            strategy,\n            isSingle\n        });\n        result[childCollectionNode.linkName] = filterAssembledData(data, {\n            limit,\n            skip\n        });\n    });\n});\n\nfunction filterAssembledData(data, {\n    limit,\n    skip\n}) {\n    if (limit) {\n        return data.slice(skip, limit);\n    }\n\n    return data;\n}\n\nfunction assembleData(childCollectionNode, result, {\n    fieldStorage,\n    strategy\n}) {\n    const filters = createSearchFilters(result, fieldStorage, strategy, false);\n    return sift(filters, childCollectionNode.results);\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/assembler.js"],"names":["createSearchFilters","module","watch","require","default","v","cleanObjectForMetaFilters","sift","exportDefault","childCollectionNode","limit","skip","metaFilters","parent","linker","strategy","isSingle","isMeta","fieldStorage","linkStorageField","metaFiltersTest","_","each","results","parentResult","result","data","assembleData","linkName","filterAssembledData","slice","filters"],"mappings":"AAAA,IAAIA,mBAAJ;AAAwBC,OAAOC,KAAP,CAAaC,QAAQ,qCAAR,CAAb,EAA4D;AAACC,YAAQC,CAAR,EAAU;AAACL,8BAAoBK,CAApB;AAAsB;;AAAlC,CAA5D,EAAgG,CAAhG;AAAmG,IAAIC,yBAAJ;AAA8BL,OAAOC,KAAP,CAAaC,QAAQ,iCAAR,CAAb,EAAwD;AAACC,YAAQC,CAAR,EAAU;AAACC,oCAA0BD,CAA1B;AAA4B;;AAAxC,CAAxD,EAAkG,CAAlG;AAAqG,IAAIE,IAAJ;AAASN,OAAOC,KAAP,CAAaC,QAAQ,MAAR,CAAb,EAA6B;AAACC,YAAQC,CAAR,EAAU;AAACE,eAAKF,CAAL;AAAO;;AAAnB,CAA7B,EAAkD,CAAlD;AAAvQJ,OAAOO,aAAP,CAIe,CAACC,mBAAD,EAAsB;AAACC,SAAD;AAAQC,QAAR;AAAcC;AAAd,CAAtB,KAAqD;AAChE,UAAMC,SAASJ,oBAAoBI,MAAnC;AACA,UAAMC,SAASL,oBAAoBK,MAAnC;AAEA,UAAMC,WAAWD,OAAOC,QAAxB;AACA,UAAMC,WAAWF,OAAOE,QAAP,EAAjB;AACA,UAAMC,SAASH,OAAOG,MAAP,EAAf;AACA,UAAMC,eAAeJ,OAAOK,gBAA5B,CAPgE,CAShE;AACA;;AACA,QAAIF,UAAUL,WAAd,EAA2B;AACvB,cAAMQ,kBAAkBb,KAAKK,WAAL,CAAxB;;AACAS,UAAEC,IAAF,CAAOT,OAAOU,OAAd,EAAuBC,gBAAgB;AACnClB,sCAA0BkB,YAA1B,EAAwCN,YAAxC,EAAsDE,eAAtD;AACH,SAFD;AAGH;;AAEDC,MAAEC,IAAF,CAAOT,OAAOU,OAAd,EAAuBE,UAAU;AAC7B,YAAIC,OAAOC,aAAalB,mBAAb,EAAkCgB,MAAlC,EAA0C;AACjDP,wBADiD;AACnCH,oBADmC;AACzBC;AADyB,SAA1C,CAAX;AAIAS,eAAOhB,oBAAoBmB,QAA3B,IAAuCC,oBAAoBH,IAApB,EAA0B;AAAChB,iBAAD;AAAQC;AAAR,SAA1B,CAAvC;AACH,KAND;AAOH,CA7BD;;AA+BA,SAASkB,mBAAT,CAA6BH,IAA7B,EAAmC;AAAChB,SAAD;AAAQC;AAAR,CAAnC,EAAkD;AAC9C,QAAID,KAAJ,EAAW;AACP,eAAOgB,KAAKI,KAAL,CAAWnB,IAAX,EAAiBD,KAAjB,CAAP;AACH;;AAED,WAAOgB,IAAP;AACH;;AAED,SAASC,YAAT,CAAsBlB,mBAAtB,EAA2CgB,MAA3C,EAAmD;AAACP,gBAAD;AAAeH;AAAf,CAAnD,EAA6E;AACzE,UAAMgB,UAAU/B,oBAAoByB,MAApB,EAA4BP,YAA5B,EAA0CH,QAA1C,EAAoD,KAApD,CAAhB;AAEA,WAAOR,KAAKwB,OAAL,EAActB,oBAAoBc,OAAlC,CAAP;AACH","file":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js.map","sourcesContent":["import createSearchFilters from '../../links/lib/createSearchFilters';\nimport cleanObjectForMetaFilters from './lib/cleanObjectForMetaFilters';\nimport sift from 'sift';\n\nexport default (childCollectionNode, {limit, skip, metaFilters}) => {\n    const parent = childCollectionNode.parent;\n    const linker = childCollectionNode.linker;\n\n    const strategy = linker.strategy;\n    const isSingle = linker.isSingle();\n    const isMeta = linker.isMeta();\n    const fieldStorage = linker.linkStorageField;\n\n    // cleaning the parent results from a child\n    // this may be the wrong approach but it works for now\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n        _.each(parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, fieldStorage, metaFiltersTest);\n        })\n    }\n\n    _.each(parent.results, result => {\n        let data = assembleData(childCollectionNode, result, {\n            fieldStorage, strategy, isSingle\n        });\n\n        result[childCollectionNode.linkName] = filterAssembledData(data, {limit, skip})\n    });\n}\n\nfunction filterAssembledData(data, {limit, skip}) {\n    if (limit) {\n        return data.slice(skip, limit);\n    }\n\n    return data;\n}\n\nfunction assembleData(childCollectionNode, result, {fieldStorage, strategy}) {\n    const filters = createSearchFilters(result, fieldStorage, strategy, false);\n\n    return sift(filters, childCollectionNode.results);\n}\n"]},"hash":"3db9d9ead4326108df7db238e00165978939f269"}
