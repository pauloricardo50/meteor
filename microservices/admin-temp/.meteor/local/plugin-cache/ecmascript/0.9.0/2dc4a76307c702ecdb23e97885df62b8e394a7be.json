{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":["cleanReducerLeftovers","root"],"specifiers":[{"kind":"local","local":"cleanReducerLeftovers","exported":"default"},{"kind":"local","local":"root","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cleanReducerLeftovers"},"ignored":false,"code":"module.export({\n    default: () => cleanReducerLeftovers\n});\n\nfunction cleanReducerLeftovers(root) {\n    _.each(root.collectionNodes, node => {\n        if (node.scheduledForDeletion) {\n            root.results.forEach(result => {\n                delete result[node.linkName];\n            });\n        }\n    });\n\n    _.each(root.collectionNodes, node => {\n        cleanReducerLeftovers(node);\n    });\n\n    _.each(root.fieldNodes, node => {\n        if (node.scheduledForDeletion) {\n            cleanNestedFields(node.name.split('.'), root.results);\n        }\n    });\n\n    _.each(root.reducerNodes, node => {\n        if (node.scheduledForDeletion) {\n            root.results.forEach(result => {\n                delete result[node.name];\n            });\n        }\n    });\n}\n\n// if we store a field like: 'profile.firstName'\n// then we need to delete profile: { firstName }\n// if profile will have empty keys, we need to delete profile.\n/**\n *\n * @param parts\n * @param results\n */function cleanNestedFields(parts, results) {\n    const fieldName = parts[0];\n\n    if (parts.length === 1) {\n        results.forEach(result => {\n            if (fieldName !== '_id') {\n                delete result[fieldName];\n            }\n        });\n        return;\n    }\n\n    parts.shift();\n    cleanNestedFields(parts, results.map(result => result[fieldName]));\n    results.forEach(result => {\n        if (_.keys(result[fieldName]).length === 0) {\n            if (fieldName !== '_id') {\n                delete result[fieldName];\n            }\n        }\n    });\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js"],"names":["module","export","default","cleanReducerLeftovers","root","_","each","collectionNodes","node","scheduledForDeletion","results","forEach","result","linkName","fieldNodes","cleanNestedFields","name","split","reducerNodes","parts","fieldName","length","shift","map","keys"],"mappings":"AAAAA,OAAOC,MAAP,CAAc;AAACC,aAAQ,MAAIC;AAAb,CAAd;;AAGe,SAASA,qBAAT,CAA+BC,IAA/B,EAAqC;AAChDC,MAAEC,IAAF,CAAOF,KAAKG,eAAZ,EAA6BC,QAAQ;AACjC,YAAIA,KAAKC,oBAAT,EAA+B;AAC3BL,iBAAKM,OAAL,CAAaC,OAAb,CAAqBC,UAAU;AAC3B,uBAAOA,OAAOJ,KAAKK,QAAZ,CAAP;AACH,aAFD;AAGH;AACJ,KAND;;AAQAR,MAAEC,IAAF,CAAOF,KAAKG,eAAZ,EAA6BC,QAAQ;AACjCL,8BAAsBK,IAAtB;AACH,KAFD;;AAIAH,MAAEC,IAAF,CAAOF,KAAKU,UAAZ,EAAwBN,QAAQ;AAC5B,YAAIA,KAAKC,oBAAT,EAA+B;AAC3BM,8BAAkBP,KAAKQ,IAAL,CAAUC,KAAV,CAAgB,GAAhB,CAAlB,EAAwCb,KAAKM,OAA7C;AACH;AACJ,KAJD;;AAMAL,MAAEC,IAAF,CAAOF,KAAKc,YAAZ,EAA0BV,QAAQ;AAC9B,YAAIA,KAAKC,oBAAT,EAA+B;AAC3BL,iBAAKM,OAAL,CAAaC,OAAb,CAAqBC,UAAU;AAC3B,uBAAOA,OAAOJ,KAAKQ,IAAZ,CAAP;AACH,aAFD;AAGH;AACJ,KAND;AAOH;;AAED;AACA;AACA;AAEA;;;;GAKA,SAASD,iBAAT,CAA2BI,KAA3B,EAAkCT,OAAlC,EAA2C;AACvC,UAAMU,YAAYD,MAAM,CAAN,CAAlB;;AACA,QAAIA,MAAME,MAAN,KAAiB,CAArB,EAAwB;AAEpBX,gBAAQC,OAAR,CAAgBC,UAAU;AACtB,gBAAIQ,cAAc,KAAlB,EAAyB;AACrB,uBAAOR,OAAOQ,SAAP,CAAP;AACH;AACJ,SAJD;AAMA;AACH;;AAEDD,UAAMG,KAAN;AACAP,sBAAkBI,KAAlB,EAAyBT,QAAQa,GAAR,CAAYX,UAAUA,OAAOQ,SAAP,CAAtB,CAAzB;AAEAV,YAAQC,OAAR,CAAgBC,UAAU;AACtB,YAAIP,EAAEmB,IAAF,CAAOZ,OAAOQ,SAAP,CAAP,EAA0BC,MAA1B,KAAqC,CAAzC,EAA4C;AACxC,gBAAID,cAAc,KAAlB,EAAyB;AACrB,uBAAOR,OAAOQ,SAAP,CAAP;AACH;AACJ;AACJ,KAND;AAOH","file":"packages/cultofcoders:grapher/lib/query/reducers/lib/cleanReducerLeftovers.js.map","sourcesContent":["/**\n * @param root\n */\nexport default function cleanReducerLeftovers(root) {\n    _.each(root.collectionNodes, node => {\n        if (node.scheduledForDeletion) {\n            root.results.forEach(result => {\n                delete result[node.linkName];\n            })\n        }\n    });\n\n    _.each(root.collectionNodes, node => {\n        cleanReducerLeftovers(node);\n    });\n\n    _.each(root.fieldNodes, node => {\n        if (node.scheduledForDeletion) {\n            cleanNestedFields(node.name.split('.'), root.results);\n        }\n    });\n\n    _.each(root.reducerNodes, node => {\n        if (node.scheduledForDeletion) {\n            root.results.forEach(result => {\n                delete result[node.name];\n            })\n        }\n    });\n}\n\n// if we store a field like: 'profile.firstName'\n// then we need to delete profile: { firstName }\n// if profile will have empty keys, we need to delete profile.\n\n/**\n *\n * @param parts\n * @param results\n */\nfunction cleanNestedFields(parts, results) {\n    const fieldName = parts[0];\n    if (parts.length === 1) {\n\n        results.forEach(result => {\n            if (fieldName !== '_id') {\n                delete result[fieldName];\n            }\n        });\n\n        return;\n    }\n\n    parts.shift();\n    cleanNestedFields(parts, results.map(result => result[fieldName]));\n\n    results.forEach(result => {\n        if (_.keys(result[fieldName]).length === 0) {\n            if (fieldName !== '_id') {\n                delete result[fieldName];\n            }\n        }\n    })\n}\n"]},"hash":"2dc4a76307c702ecdb23e97885df62b8e394a7be"}
