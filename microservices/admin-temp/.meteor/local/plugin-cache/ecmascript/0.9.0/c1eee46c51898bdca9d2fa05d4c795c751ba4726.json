{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"createFauxSubscription"},"ignored":false,"code":"module.exportDefault(countManager => ({\n  ready: () => countManager.accessToken.get() !== null && countManager.subscriptionHandle.ready(),\n  stop: () => countManager.unsubscribe()\n}));","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js"],"names":["module","exportDefault","countManager","ready","accessToken","get","subscriptionHandle","stop","unsubscribe"],"mappings":"AAAAA,OAAOC,aAAP,CAMgBC,YAAD,KAAmB;AAC9BC,SAAO,MAAMD,aAAaE,WAAb,CAAyBC,GAAzB,OAAmC,IAAnC,IAA2CH,aAAaI,kBAAb,CAAgCH,KAAhC,EAD1B;AAE9BI,QAAM,MAAML,aAAaM,WAAb;AAFkB,CAAnB,CANf","file":"packages/cultofcoders:grapher/lib/query/counts/createFauxSubscription.js.map","sourcesContent":["/**\n * This method creates a \"fake\" subscription handle so that users of CountSubscription#subscribe\n * have an interface consistent with normal subscriptions.\n *\n * @param {CountSubscription} countManager\n */\nexport default (countManager) => ({\n    ready: () => countManager.accessToken.get() !== null && countManager.subscriptionHandle.ready(),\n    stop: () => countManager.unsubscribe(),\n});\n"]},"hash":"c1eee46c51898bdca9d2fa05d4c795c751ba4726"}
