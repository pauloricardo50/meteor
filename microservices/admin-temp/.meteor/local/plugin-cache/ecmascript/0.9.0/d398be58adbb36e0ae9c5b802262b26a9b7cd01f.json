{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/reactive-var","imported":["ReactiveVar"],"specifiers":[{"kind":"named","imported":"ReactiveVar","local":"ReactiveVar"}]},{"source":"meteor/tracker","imported":["Tracker"],"specifiers":[{"kind":"named","imported":"Tracker","local":"Tracker"}]},{"source":"./collection","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Counts"}]},{"source":"./createFauxSubscription","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createFauxSubscription"}]},{"source":"../lib/prepareForProcess.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"prepareForProcess"}]},{"source":"../../namedQuery/namedQuery.base","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"NamedQueryBase"}]}],"exports":{"exported":["CountSubscription"],"specifiers":[{"kind":"local","local":"CountSubscription","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"countSubscription"},"ignored":false,"code":"module.export({\n    default: () => CountSubscription\n});\nlet EJSON;\nmodule.watch(require(\"meteor/ejson\"), {\n    EJSON(v) {\n        EJSON = v;\n    }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n    Meteor(v) {\n        Meteor = v;\n    }\n\n}, 1);\nlet ReactiveVar;\nmodule.watch(require(\"meteor/reactive-var\"), {\n    ReactiveVar(v) {\n        ReactiveVar = v;\n    }\n\n}, 2);\nlet Tracker;\nmodule.watch(require(\"meteor/tracker\"), {\n    Tracker(v) {\n        Tracker = v;\n    }\n\n}, 3);\nlet Counts;\nmodule.watch(require(\"./collection\"), {\n    default(v) {\n        Counts = v;\n    }\n\n}, 4);\nlet createFauxSubscription;\nmodule.watch(require(\"./createFauxSubscription\"), {\n    default(v) {\n        createFauxSubscription = v;\n    }\n\n}, 5);\nlet prepareForProcess;\nmodule.watch(require(\"../lib/prepareForProcess.js\"), {\n    default(v) {\n        prepareForProcess = v;\n    }\n\n}, 6);\nlet NamedQueryBase;\nmodule.watch(require(\"../../namedQuery/namedQuery.base\"), {\n    default(v) {\n        NamedQueryBase = v;\n    }\n\n}, 7);\n\nclass CountSubscription {\n    /**\n     * @param {*} query - The query to use when fetching counts\n     */constructor(query) {\n        this.accessToken = new ReactiveVar(null);\n        this.fauxHandle = null;\n        this.query = query;\n    } /**\n       * Starts a subscription request for reactive counts.\n       *\n       * @param {*} arg - The argument to pass to {name}.count.subscribe\n       * @param {*} callback\n       */\n\n    subscribe(arg, callback) {\n        // Don't try to resubscribe if arg hasn't changed\n        if (EJSON.equals(this.lastArgs, arg) && this.fauxHandle) {\n            return this.fauxHandle;\n        }\n\n        this.accessToken.set(null);\n        this.lastArgs = arg;\n        Meteor.call(this.query.name + '.count.subscribe', arg, (error, token) => {\n            if (!this._markedForUnsubscribe) {\n                this.subscriptionHandle = Meteor.subscribe(this.query.name + '.count', token, callback);\n                this.accessToken.set(token);\n                this.disconnectComputation = Tracker.autorun(() => this.handleDisconnect());\n            }\n\n            this._markedForUnsubscribe = false;\n        });\n        this.fauxHandle = createFauxSubscription(this);\n        return this.fauxHandle;\n    } /**\n       * Unsubscribes from the count endpoint, if there is such a subscription.\n       */\n\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.disconnectComputation.stop();\n            this.subscriptionHandle.stop();\n        } else {\n            // If we hit this branch, then Meteor.call in subscribe hasn't finished yet\n            // so set a flag to stop the subscription from being created\n            this._markedForUnsubscribe = true;\n        }\n\n        this.accessToken.set(null);\n        this.fauxHandle = null;\n        this.subscriptionHandle = null;\n    } /**\n       * Reactively fetch current document count. Returns null if the subscription is not ready yet.\n       *\n       * @returns {Number|null} - Current document count\n       */\n\n    getCount() {\n        const id = this.accessToken.get();\n        if (id === null) return null;\n        const doc = Counts.findOne(id);\n        return doc.count;\n    } /**\n       * All session info gets deleted when the server goes down, so when the client attempts to\n       * optimistically resume the '.count' publication, the server will throw a 'no-request' error.\n       *\n       * This function prevents that by manually stopping and restarting the subscription when the\n       * connection to the server is lost.\n       */\n\n    handleDisconnect() {\n        const status = Meteor.status();\n\n        if (!status.connected) {\n            this._markedForResume = true;\n            this.fauxHandle = null;\n            this.subscriptionHandle.stop();\n        }\n\n        if (status.connected && this._markedForResume) {\n            this._markedForResume = false;\n            this.subscribe(this.lastArgs);\n        }\n    } /**\n       * Returns whether or not a subscription request has been made.\n       */\n\n    isSubscribed() {\n        return this.accessToken.get() !== null;\n    }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/counts/countSubscription.js"],"names":["module","export","default","CountSubscription","EJSON","watch","require","v","Meteor","ReactiveVar","Tracker","Counts","createFauxSubscription","prepareForProcess","NamedQueryBase","constructor","query","accessToken","fauxHandle","subscribe","arg","callback","equals","lastArgs","set","call","name","error","token","_markedForUnsubscribe","subscriptionHandle","disconnectComputation","autorun","handleDisconnect","unsubscribe","stop","getCount","id","get","doc","findOne","count","status","connected","_markedForResume","isSubscribed"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/counts/countSubscription.js.map","sourcesContent":["import { EJSON } from 'meteor/ejson';\nimport { Meteor } from 'meteor/meteor';\nimport { ReactiveVar } from 'meteor/reactive-var';\nimport { Tracker } from 'meteor/tracker';\n\nimport Counts from './collection';\nimport createFauxSubscription from './createFauxSubscription';\nimport prepareForProcess from '../lib/prepareForProcess.js';\nimport NamedQueryBase from '../../namedQuery/namedQuery.base';\n\nexport default class CountSubscription {\n    /**\n     * @param {*} query - The query to use when fetching counts\n     */\n    constructor(query) {\n        this.accessToken = new ReactiveVar(null);\n        this.fauxHandle = null;\n        this.query = query;\n    }\n\n    /**\n     * Starts a subscription request for reactive counts.\n     *\n     * @param {*} arg - The argument to pass to {name}.count.subscribe\n     * @param {*} callback\n     */\n    subscribe(arg, callback) {\n        // Don't try to resubscribe if arg hasn't changed\n        if (EJSON.equals(this.lastArgs, arg) && this.fauxHandle) {\n            return this.fauxHandle;\n        }\n\n        this.accessToken.set(null);\n        this.lastArgs = arg;\n\n        Meteor.call(this.query.name + '.count.subscribe', arg, (error, token) => {\n            if (!this._markedForUnsubscribe) {\n                this.subscriptionHandle = Meteor.subscribe(this.query.name + '.count', token, callback);\n                this.accessToken.set(token);\n\n                this.disconnectComputation = Tracker.autorun(() => this.handleDisconnect());\n            }\n\n            this._markedForUnsubscribe = false;\n        });\n\n        this.fauxHandle = createFauxSubscription(this);\n        return this.fauxHandle;\n    }\n\n    /**\n     * Unsubscribes from the count endpoint, if there is such a subscription.\n     */\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.disconnectComputation.stop();\n            this.subscriptionHandle.stop();\n        } else {\n            // If we hit this branch, then Meteor.call in subscribe hasn't finished yet\n            // so set a flag to stop the subscription from being created\n            this._markedForUnsubscribe = true;\n        }\n\n        this.accessToken.set(null);\n        this.fauxHandle = null;\n        this.subscriptionHandle = null;\n    }\n\n    /**\n     * Reactively fetch current document count. Returns null if the subscription is not ready yet.\n     *\n     * @returns {Number|null} - Current document count\n     */\n    getCount() {\n        const id = this.accessToken.get();\n        if (id === null) return null;\n\n        const doc = Counts.findOne(id);\n        return doc.count;\n    }\n\n    /**\n     * All session info gets deleted when the server goes down, so when the client attempts to\n     * optimistically resume the '.count' publication, the server will throw a 'no-request' error.\n     *\n     * This function prevents that by manually stopping and restarting the subscription when the\n     * connection to the server is lost.\n     */\n    handleDisconnect() {\n        const status = Meteor.status();\n        if (!status.connected) {\n            this._markedForResume = true;\n            this.fauxHandle = null;\n            this.subscriptionHandle.stop();\n        }\n\n        if (status.connected && this._markedForResume) {\n            this._markedForResume = false;\n            this.subscribe(this.lastArgs);\n        }\n    }\n\n    /**\n     * Returns whether or not a subscription request has been made.\n     */\n    isSubscribed() {\n        return this.accessToken.get() !== null;\n    }\n}\n"]},"hash":"d398be58adbb36e0ae9c5b802262b26a9b7cd01f"}
