{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"imports/core/api/email/server/email-methods.js","filenameRelative":"imports/core/api/email/server/email-methods.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"imports/core/api/email/server/email-methods.js.map","sourceFileName":"imports/core/api/email/server/email-methods.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"email-methods"},"ignored":false,"code":"// import { Meteor } from 'meteor/meteor';\n// import { Mandrill } from 'meteor/wylio:mandrill';\n// import { ValidatedMethod } from 'meteor/mdg:validated-method';\n// import { check, Match } from 'meteor/check';\n// import { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\n// import rateLimit from 'core/utils/rate-limit.js';\n// import {\n//   from,\n//   fromEmail,\n//   defaultCTA_URL,\n//   emailFooter,\n//   getEmailContent,\n// } from '../email-defaults';\n// import { addEmail, modifyEmail } from 'core/api/loans/server/methods';\n// export const sendEmail = new ValidatedMethod({\n//   name: 'sendEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({\n//     emailId,\n//     loanId,\n//     template = 'notification',\n//     CTA_URL,\n//     sendAt,\n//     userId,\n//     intlValues,\n//   }) {\n//     check(emailId, String);\n//     check(loanId, String);\n//     check(template, Match.Optional(String));\n//     check(CTA_URL, Match.Optional(String));\n//     check(sendAt, Match.Optional(Date));\n//     check(userId, Match.Optional(String));\n//     check(intlValues, Match.Optional(Object));\n//   },\n//   run({\n//     emailId,\n//     loanId,\n//     template = 'notification',\n//     CTA_URL,\n//     sendAt,\n//     userId,\n//     intlValues,\n//   }) {\n//     const { email, subject, title, body, CTA } = getEmailContent(\n//       emailId,\n//       intlValues,\n//     );\n//     let toEmail;\n//     // When this is sent by an admin, use the userId to find the email to whom this should be sent to\n//     if (userId) {\n//       toEmail = Meteor.users.findOne(userId).emails[0].address;\n//     }\n//     toEmail = toEmail || email;\n//     // If this is a demo site, do not send emails\n//     if (\n//       this.connection &&\n//       this.connection.httpHeaders &&\n//       this.connection.httpHeaders.host.indexOf('demo') !== -1\n//     ) {\n//       return false;\n//     }\n//     const options = {\n//       template_name: template,\n//       template_content: [{ name: 'footer', content: emailFooter() }],\n//       message: {\n//         from_email: fromEmail,\n//         from_name: from,\n//         subject,\n//         to: [\n//           {\n//             email: toEmail,\n//             // name: 'Jon Snow',\n//             type: 'to',\n//           },\n//         ],\n//         merge_vars: [\n//           {\n//             rcpt: toEmail,\n//             vars: [\n//               { name: 'title', content: title },\n//               { name: 'body', content: body },\n//               { name: 'CTA', content: CTA },\n//               { name: 'CTA_URL', content: CTA_URL || defaultCTA_URL }, // overrides the global_merge_vars if it is set}\n//             ],\n//           },\n//         ],\n//         metadata: [{ userId: Meteor.userId(), loanId }],\n//       },\n//     };\n//     if (sendAt) {\n//       options.send_at = sendAt.toISOString();\n//     }\n//     // FIXME Mandrill can't be tested currently\n//     // https://github.com/Wylio/meteor-mandrill/issues/23\n//     if (Meteor.isTest) {\n//       return;\n//     }\n//     this.unblock();\n//     Mandrill.messages.sendTemplate(options, (error, result) => {\n//       if (error) {\n//         throw new Meteor.Error(error);\n//       }\n//       const content = JSON.parse(result.content)[0];\n//       return addEmail.call(\n//         {\n//           loanId,\n//           emailId,\n//           _id: content._id,\n//           status: content.status,\n//           sendAt,\n//         },\n//         (err) => {\n//           throw new Meteor.Error(err);\n//         },\n//       );\n//     });\n//   },\n// });\n// export const cancelScheduledEmail = new ValidatedMethod({\n//   name: 'cancelScheduledEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({ id, loanId }) {\n//     check(id, String);\n//     check(loanId, String);\n//   },\n//   run({ id, loanId }) {\n//     this.unblock();\n//     Mandrill.messages.cancelScheduled({ id }, (error, result) => {\n//       if (error) {\n//         throw new Meteor.Error(error);\n//       }\n//       const content = JSON.parse(result.content);\n//       return modifyEmail.call(\n//         { loanId, _id: content._id, status: 'cancelled' },\n//         (err) => {\n//           throw new Meteor.Error(err);\n//         },\n//       );\n//     });\n//   },\n// });\n// export const rescheduleEmail = new ValidatedMethod({\n//   name: 'rescheduleEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({ id, loanId, date }) {\n//     check(id, String);\n//     check(loanId, String);\n//     check(date, Date);\n//   },\n//   run({ id, loanId, date }) {\n//     this.unblock();\n//     Mandrill.messages.reschedule(\n//       { id, send_at: date.toISOString() },\n//       (error, result) => {\n//         if (error) {\n//           throw new Meteor.Error(error);\n//         }\n//         const content = JSON.parse(result.content);\n//         return modifyEmail.call({ loanId, _id: content._id, sendAt }, (err) => {\n//           throw new Meteor.Error(err);\n//         });\n//       },\n//     );\n//   },\n// });\n// // Send max 1 email per second\n// rateLimit({\n//   methods: [sendEmail, cancelScheduledEmail, rescheduleEmail],\n//   limit: 1,\n//   timeRange: 1000,\n// });\n\"use strict\";","map":{"version":3,"sources":["imports/core/api/email/server/email-methods.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","file":"imports/core/api/email/server/email-methods.js.map","sourcesContent":["// import { Meteor } from 'meteor/meteor';\n// import { Mandrill } from 'meteor/wylio:mandrill';\n// import { ValidatedMethod } from 'meteor/mdg:validated-method';\n// import { check, Match } from 'meteor/check';\n// import { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\n\n// import rateLimit from 'core/utils/rate-limit.js';\n// import {\n//   from,\n//   fromEmail,\n//   defaultCTA_URL,\n//   emailFooter,\n//   getEmailContent,\n// } from '../email-defaults';\n// import { addEmail, modifyEmail } from 'core/api/loans/server/methods';\n\n// export const sendEmail = new ValidatedMethod({\n//   name: 'sendEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({\n//     emailId,\n//     loanId,\n//     template = 'notification',\n//     CTA_URL,\n//     sendAt,\n//     userId,\n//     intlValues,\n//   }) {\n//     check(emailId, String);\n//     check(loanId, String);\n//     check(template, Match.Optional(String));\n//     check(CTA_URL, Match.Optional(String));\n//     check(sendAt, Match.Optional(Date));\n//     check(userId, Match.Optional(String));\n//     check(intlValues, Match.Optional(Object));\n//   },\n//   run({\n//     emailId,\n//     loanId,\n//     template = 'notification',\n//     CTA_URL,\n//     sendAt,\n//     userId,\n//     intlValues,\n//   }) {\n//     const { email, subject, title, body, CTA } = getEmailContent(\n//       emailId,\n//       intlValues,\n//     );\n//     let toEmail;\n\n//     // When this is sent by an admin, use the userId to find the email to whom this should be sent to\n//     if (userId) {\n//       toEmail = Meteor.users.findOne(userId).emails[0].address;\n//     }\n//     toEmail = toEmail || email;\n\n//     // If this is a demo site, do not send emails\n//     if (\n//       this.connection &&\n//       this.connection.httpHeaders &&\n//       this.connection.httpHeaders.host.indexOf('demo') !== -1\n//     ) {\n//       return false;\n//     }\n\n//     const options = {\n//       template_name: template,\n//       template_content: [{ name: 'footer', content: emailFooter() }],\n//       message: {\n//         from_email: fromEmail,\n//         from_name: from,\n//         subject,\n//         to: [\n//           {\n//             email: toEmail,\n//             // name: 'Jon Snow',\n//             type: 'to',\n//           },\n//         ],\n//         merge_vars: [\n//           {\n//             rcpt: toEmail,\n//             vars: [\n//               { name: 'title', content: title },\n//               { name: 'body', content: body },\n//               { name: 'CTA', content: CTA },\n//               { name: 'CTA_URL', content: CTA_URL || defaultCTA_URL }, // overrides the global_merge_vars if it is set}\n//             ],\n//           },\n//         ],\n//         metadata: [{ userId: Meteor.userId(), loanId }],\n//       },\n//     };\n\n//     if (sendAt) {\n//       options.send_at = sendAt.toISOString();\n//     }\n\n//     // FIXME Mandrill can't be tested currently\n//     // https://github.com/Wylio/meteor-mandrill/issues/23\n//     if (Meteor.isTest) {\n//       return;\n//     }\n\n//     this.unblock();\n//     Mandrill.messages.sendTemplate(options, (error, result) => {\n//       if (error) {\n//         throw new Meteor.Error(error);\n//       }\n\n//       const content = JSON.parse(result.content)[0];\n//       return addEmail.call(\n//         {\n//           loanId,\n//           emailId,\n//           _id: content._id,\n//           status: content.status,\n//           sendAt,\n//         },\n//         (err) => {\n//           throw new Meteor.Error(err);\n//         },\n//       );\n//     });\n//   },\n// });\n\n// export const cancelScheduledEmail = new ValidatedMethod({\n//   name: 'cancelScheduledEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({ id, loanId }) {\n//     check(id, String);\n//     check(loanId, String);\n//   },\n//   run({ id, loanId }) {\n//     this.unblock();\n//     Mandrill.messages.cancelScheduled({ id }, (error, result) => {\n//       if (error) {\n//         throw new Meteor.Error(error);\n//       }\n\n//       const content = JSON.parse(result.content);\n//       return modifyEmail.call(\n//         { loanId, _id: content._id, status: 'cancelled' },\n//         (err) => {\n//           throw new Meteor.Error(err);\n//         },\n//       );\n//     });\n//   },\n// });\n\n// export const rescheduleEmail = new ValidatedMethod({\n//   name: 'rescheduleEmail',\n//   mixins: [CallPromiseMixin],\n//   validate({ id, loanId, date }) {\n//     check(id, String);\n//     check(loanId, String);\n//     check(date, Date);\n//   },\n//   run({ id, loanId, date }) {\n//     this.unblock();\n//     Mandrill.messages.reschedule(\n//       { id, send_at: date.toISOString() },\n//       (error, result) => {\n//         if (error) {\n//           throw new Meteor.Error(error);\n//         }\n\n//         const content = JSON.parse(result.content);\n//         return modifyEmail.call({ loanId, _id: content._id, sendAt }, (err) => {\n//           throw new Meteor.Error(err);\n//         });\n//       },\n//     );\n//   },\n// });\n\n// // Send max 1 email per second\n// rateLimit({\n//   methods: [sendEmail, cancelScheduledEmail, rescheduleEmail],\n//   limit: 1,\n//   timeRange: 1000,\n// });\n"]},"hash":"098d14ad676efe947815beb30a093f554b866dd8"}
