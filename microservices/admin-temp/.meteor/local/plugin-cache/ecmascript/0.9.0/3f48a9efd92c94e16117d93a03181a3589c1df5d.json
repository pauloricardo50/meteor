{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../../links/lib/createSearchFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createSearchFilters"}]},{"source":"./lib/cleanObjectForMetaFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanObjectForMetaFilters"}]},{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"assembler"},"ignored":false,"code":"var createSearchFilters = void 0;\nmodule.watch(require(\"../../links/lib/createSearchFilters\"), {\n    \"default\": function (v) {\n        createSearchFilters = v;\n    }\n}, 0);\nvar cleanObjectForMetaFilters = void 0;\nmodule.watch(require(\"./lib/cleanObjectForMetaFilters\"), {\n    \"default\": function (v) {\n        cleanObjectForMetaFilters = v;\n    }\n}, 1);\nvar sift = void 0;\nmodule.watch(require(\"sift\"), {\n    \"default\": function (v) {\n        sift = v;\n    }\n}, 2);\nmodule.exportDefault(function (childCollectionNode, _ref) {\n    var limit = _ref.limit,\n        skip = _ref.skip,\n        metaFilters = _ref.metaFilters;\n    var parent = childCollectionNode.parent;\n    var linker = childCollectionNode.linker;\n    var strategy = linker.strategy;\n    var isSingle = linker.isSingle();\n    var isMeta = linker.isMeta();\n    var fieldStorage = linker.linkStorageField; // cleaning the parent results from a child\n    // this may be the wrong approach but it works for now\n\n    if (isMeta && metaFilters) {\n        var metaFiltersTest = sift(metaFilters);\n\n        _.each(parent.results, function (parentResult) {\n            cleanObjectForMetaFilters(parentResult, fieldStorage, metaFiltersTest);\n        });\n    }\n\n    _.each(parent.results, function (result) {\n        var data = assembleData(childCollectionNode, result, {\n            fieldStorage: fieldStorage,\n            strategy: strategy,\n            isSingle: isSingle\n        });\n        result[childCollectionNode.linkName] = filterAssembledData(data, {\n            limit: limit,\n            skip: skip\n        });\n    });\n});\n\nfunction filterAssembledData(data, _ref2) {\n    var limit = _ref2.limit,\n        skip = _ref2.skip;\n\n    if (limit) {\n        return data.slice(skip, limit);\n    }\n\n    return data;\n}\n\nfunction assembleData(childCollectionNode, result, _ref3) {\n    var fieldStorage = _ref3.fieldStorage,\n        strategy = _ref3.strategy;\n    var filters = createSearchFilters(result, fieldStorage, strategy, false);\n    return sift(filters, childCollectionNode.results);\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/assembler.js"],"names":["createSearchFilters","module","watch","require","v","cleanObjectForMetaFilters","sift","exportDefault","childCollectionNode","limit","skip","metaFilters","parent","linker","strategy","isSingle","isMeta","fieldStorage","linkStorageField","metaFiltersTest","_","each","results","parentResult","data","assembleData","result","linkName","filterAssembledData","slice","filters"],"mappings":"AAAA,IAAIA,4BAAJ;AAAwBC,OAAOC,KAAP,CAAaC,QAAQ,qCAAR,CAAb,EAA4D;AAAA,yBAASC,CAAT,EAAW;AAACJ,8BAAoBI,CAApB;AAAsB;AAAlC,CAA5D,EAAgG,CAAhG;AAAmG,IAAIC,kCAAJ;AAA8BJ,OAAOC,KAAP,CAAaC,QAAQ,iCAAR,CAAb,EAAwD;AAAA,yBAASC,CAAT,EAAW;AAACC,oCAA0BD,CAA1B;AAA4B;AAAxC,CAAxD,EAAkG,CAAlG;AAAqG,IAAIE,aAAJ;AAASL,OAAOC,KAAP,CAAaC,QAAQ,MAAR,CAAb,EAA6B;AAAA,yBAASC,CAAT,EAAW;AAACE,eAAKF,CAAL;AAAO;AAAnB,CAA7B,EAAkD,CAAlD;AAAvQH,OAAOM,aAAP,CAIe,UAACC,mBAAD,QAAqD;AAAA,QAA9BC,KAA8B,QAA9BA,KAA8B;AAAA,QAAvBC,IAAuB,QAAvBA,IAAuB;AAAA,QAAjBC,WAAiB,QAAjBA,WAAiB;AAChE,QAAMC,SAASJ,oBAAoBI,MAAnC;AACA,QAAMC,SAASL,oBAAoBK,MAAnC;AAEA,QAAMC,WAAWD,OAAOC,QAAxB;AACA,QAAMC,WAAWF,OAAOE,QAAP,EAAjB;AACA,QAAMC,SAASH,OAAOG,MAAP,EAAf;AACA,QAAMC,eAAeJ,OAAOK,gBAA5B,CAPgE,CAShE;AACA;;AACA,QAAIF,UAAUL,WAAd,EAA2B;AACvB,YAAMQ,kBAAkBb,KAAKK,WAAL,CAAxB;;AACAS,UAAEC,IAAF,CAAOT,OAAOU,OAAd,EAAuB,wBAAgB;AACnCjB,sCAA0BkB,YAA1B,EAAwCN,YAAxC,EAAsDE,eAAtD;AACH,SAFD;AAGH;;AAEDC,MAAEC,IAAF,CAAOT,OAAOU,OAAd,EAAuB,kBAAU;AAC7B,YAAIE,OAAOC,aAAajB,mBAAb,EAAkCkB,MAAlC,EAA0C;AACjDT,sCADiD;AACnCH,8BADmC;AACzBC;AADyB,SAA1C,CAAX;AAIAW,eAAOlB,oBAAoBmB,QAA3B,IAAuCC,oBAAoBJ,IAApB,EAA0B;AAACf,wBAAD;AAAQC;AAAR,SAA1B,CAAvC;AACH,KAND;AAOH,CA7BD;;AA+BA,SAASkB,mBAAT,CAA6BJ,IAA7B,SAAkD;AAAA,QAAdf,KAAc,SAAdA,KAAc;AAAA,QAAPC,IAAO,SAAPA,IAAO;;AAC9C,QAAID,KAAJ,EAAW;AACP,eAAOe,KAAKK,KAAL,CAAWnB,IAAX,EAAiBD,KAAjB,CAAP;AACH;;AAED,WAAOe,IAAP;AACH;;AAED,SAASC,YAAT,CAAsBjB,mBAAtB,EAA2CkB,MAA3C,SAA6E;AAAA,QAAzBT,YAAyB,SAAzBA,YAAyB;AAAA,QAAXH,QAAW,SAAXA,QAAW;AACzE,QAAMgB,UAAU9B,oBAAoB0B,MAApB,EAA4BT,YAA5B,EAA0CH,QAA1C,EAAoD,KAApD,CAAhB;AAEA,WAAOR,KAAKwB,OAAL,EAActB,oBAAoBc,OAAlC,CAAP;AACH","file":"packages/cultofcoders:grapher/lib/query/hypernova/assembler.js.map","sourcesContent":["import createSearchFilters from '../../links/lib/createSearchFilters';\nimport cleanObjectForMetaFilters from './lib/cleanObjectForMetaFilters';\nimport sift from 'sift';\n\nexport default (childCollectionNode, {limit, skip, metaFilters}) => {\n    const parent = childCollectionNode.parent;\n    const linker = childCollectionNode.linker;\n\n    const strategy = linker.strategy;\n    const isSingle = linker.isSingle();\n    const isMeta = linker.isMeta();\n    const fieldStorage = linker.linkStorageField;\n\n    // cleaning the parent results from a child\n    // this may be the wrong approach but it works for now\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n        _.each(parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, fieldStorage, metaFiltersTest);\n        })\n    }\n\n    _.each(parent.results, result => {\n        let data = assembleData(childCollectionNode, result, {\n            fieldStorage, strategy, isSingle\n        });\n\n        result[childCollectionNode.linkName] = filterAssembledData(data, {limit, skip})\n    });\n}\n\nfunction filterAssembledData(data, {limit, skip}) {\n    if (limit) {\n        return data.slice(skip, limit);\n    }\n\n    return data;\n}\n\nfunction assembleData(childCollectionNode, result, {fieldStorage, strategy}) {\n    const filters = createSearchFilters(result, fieldStorage, strategy, false);\n\n    return sift(filters, childCollectionNode.results);\n}\n"]},"hash":"3f48a9efd92c94e16117d93a03181a3589c1df5d"}
