{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../query/lib/prepareForProcess.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"prepareForProcess"}]},{"source":"./namedQuery.base","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Base"}]},{"source":"lodash.clonedeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"deepClone"}]},{"source":"./cache/MemoryResultCacher","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"MemoryResultCacher"}]},{"source":"../query/lib/intersectDeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"intersectDeep"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js","filenameRelative":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"namedQuery.server"},"ignored":false,"code":"let prepareForProcess;\nmodule.watch(require(\"../query/lib/prepareForProcess.js\"), {\n    default(v) {\n        prepareForProcess = v;\n    }\n\n}, 0);\nlet Base;\nmodule.watch(require(\"./namedQuery.base\"), {\n    default(v) {\n        Base = v;\n    }\n\n}, 1);\nlet deepClone;\nmodule.watch(require(\"lodash.clonedeep\"), {\n    default(v) {\n        deepClone = v;\n    }\n\n}, 2);\nlet MemoryResultCacher;\nmodule.watch(require(\"./cache/MemoryResultCacher\"), {\n    default(v) {\n        MemoryResultCacher = v;\n    }\n\n}, 3);\nlet intersectDeep;\nmodule.watch(require(\"../query/lib/intersectDeep\"), {\n    default(v) {\n        intersectDeep = v;\n    }\n\n}, 4);\nmodule.exportDefault(class extends Base {\n    /**\n     * Retrieves the data.\n     * @returns {*}\n     */fetch(context) {\n        this._performSecurityChecks(context, this.params);\n\n        if (this.isResolver) {\n            return this._fetchResolverData(context);\n        } else {\n            body = deepClone(this.body);\n\n            if (this.params.$body) {\n                body = intersectDeep(body, this.params.$body);\n            } // we must apply emobdyment here\n\n\n            this.doEmbodimentIfItApplies(body);\n            const query = this.collection.createQuery(deepClone(body), {\n                params: deepClone(this.params)\n            });\n\n            if (this.cacher) {\n                const cacheId = this.cacher.generateQueryId(this.queryName, this.params);\n                return this.cacher.fetch(cacheId, {\n                    query\n                });\n            }\n\n            return query.fetch();\n        }\n    } /**\n       * @param args\n       * @returns {*}\n       */\n\n    fetchOne(...args) {\n        return _.first(this.fetch(...args));\n    } /**\n       * Gets the count of matching elements.\n       *\n       * @returns {any}\n       */\n\n    getCount(context) {\n        this._performSecurityChecks(context, this.params);\n\n        const countCursor = this.getCursorForCounting();\n\n        if (this.cacher) {\n            const cacheId = 'count::' + this.cacher.generateQueryId(this.queryName, this.params);\n            return this.cacher.fetch(cacheId, {\n                countCursor\n            });\n        }\n\n        return countCursor.count();\n    } /**\n       * Returns the cursor for counting\n       * This is most likely used for counts cursor\n       */\n\n    getCursorForCounting() {\n        let body = deepClone(this.body);\n        this.doEmbodimentIfItApplies(body);\n        body = prepareForProcess(body, this.params);\n        return this.collection.find(body.$filters || {}, {\n            fields: {\n                _id: 1\n            }\n        });\n    } /**\n       * @param cacher\n       */\n\n    cacheResults(cacher) {\n        if (!cacher) {\n            cacher = new MemoryResultCacher();\n        }\n\n        this.cacher = cacher;\n    } /**\n       * Configure resolve. This doesn't actually call the resolver, it just sets it\n       * @param fn\n       */\n\n    resolve(fn) {\n        if (!this.isResolver) {\n            throw new Meteor.Error('invalid-call', `You cannot use resolve() on a non resolver NamedQuery`);\n        }\n\n        this.resolver = fn;\n    } /**\n       * @returns {*}\n       * @private\n       */\n\n    _fetchResolverData(context) {\n        const resolver = this.resolver;\n        const self = this;\n        const query = {\n            fetch() {\n                return resolver.call(context, self.params);\n            }\n\n        };\n\n        if (this.cacher) {\n            const cacheId = this.cacher.generateQueryId(this.queryName, this.params);\n            return this.cacher.fetch(cacheId, {\n                query\n            });\n        }\n\n        return query.fetch();\n    } /**\n       * @param context Meteor method/publish context\n       * @param params\n       *\n       * @private\n       */\n\n    _performSecurityChecks(context, params) {\n        if (context && this.exposeConfig) {\n            this._callFirewall(context, context.userId, params);\n        }\n\n        this.doValidateParams(params);\n    }\n\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js"],"names":["prepareForProcess","module","watch","require","default","v","Base","deepClone","MemoryResultCacher","intersectDeep","exportDefault","fetch","context","_performSecurityChecks","params","isResolver","_fetchResolverData","body","$body","doEmbodimentIfItApplies","query","collection","createQuery","cacher","cacheId","generateQueryId","queryName","fetchOne","args","_","first","getCount","countCursor","getCursorForCounting","count","find","$filters","fields","_id","cacheResults","resolve","fn","Meteor","Error","resolver","self","call","exposeConfig","_callFirewall","userId","doValidateParams"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.server.js.map","sourcesContent":["import prepareForProcess from '../query/lib/prepareForProcess.js';\nimport Base from './namedQuery.base';\nimport deepClone from 'lodash.clonedeep';\nimport MemoryResultCacher from './cache/MemoryResultCacher';\nimport intersectDeep from '../query/lib/intersectDeep';\n\nexport default class extends Base {\n    /**\n     * Retrieves the data.\n     * @returns {*}\n     */\n    fetch(context) {\n        this._performSecurityChecks(context, this.params);\n\n        if (this.isResolver) {\n            return this._fetchResolverData(context);\n        } else {\n            body = deepClone(this.body);\n            if (this.params.$body) {\n                body = intersectDeep(body, this.params.$body);\n            }\n            \n            // we must apply emobdyment here\n            this.doEmbodimentIfItApplies(body);\n\n            const query = this.collection.createQuery(\n                deepClone(body),\n                {\n                    params: deepClone(this.params)\n                }\n            );\n\n            if (this.cacher) {\n                const cacheId = this.cacher.generateQueryId(this.queryName, this.params);\n                return this.cacher.fetch(cacheId, {query});\n            }\n\n            return query.fetch();\n        }\n    }\n\n    /**\n     * @param args\n     * @returns {*}\n     */\n    fetchOne(...args) {\n        return _.first(this.fetch(...args));\n    }\n\n    /**\n     * Gets the count of matching elements.\n     *\n     * @returns {any}\n     */\n    getCount(context) {\n        this._performSecurityChecks(context, this.params);\n\n        const countCursor = this.getCursorForCounting();\n\n        if (this.cacher) {\n            const cacheId = 'count::' + this.cacher.generateQueryId(this.queryName, this.params);\n\n            return this.cacher.fetch(cacheId, {countCursor});\n        }\n\n        return countCursor.count();\n    }\n\n    /**\n     * Returns the cursor for counting\n     * This is most likely used for counts cursor\n     */\n    getCursorForCounting() {\n        let body = deepClone(this.body);\n        this.doEmbodimentIfItApplies(body);\n        body = prepareForProcess(body, this.params);\n\n        return this.collection.find(body.$filters || {}, {fields: {_id: 1}});\n    }\n\n    /**\n     * @param cacher\n     */\n    cacheResults(cacher) {\n        if (!cacher) {\n            cacher = new MemoryResultCacher();\n        }\n\n        this.cacher = cacher;\n    }\n\n    /**\n     * Configure resolve. This doesn't actually call the resolver, it just sets it\n     * @param fn\n     */\n    resolve(fn) {\n        if (!this.isResolver) {\n            throw new Meteor.Error('invalid-call', `You cannot use resolve() on a non resolver NamedQuery`);\n        }\n\n        this.resolver = fn;\n    }\n\n    /**\n     * @returns {*}\n     * @private\n     */\n    _fetchResolverData(context) {\n        const resolver = this.resolver;\n        const self = this;\n        const query = {\n            fetch() {\n                return resolver.call(context, self.params);\n            }\n        };\n\n        if (this.cacher) {\n            const cacheId = this.cacher.generateQueryId(this.queryName, this.params);\n            return this.cacher.fetch(cacheId, {query});\n        }\n\n        return query.fetch();\n    }\n\n    /**\n     * @param context Meteor method/publish context\n     * @param params\n     *\n     * @private\n     */\n    _performSecurityChecks(context, params) {\n        if (context && this.exposeConfig) {\n            this._callFirewall(context, context.userId, params);\n        }\n\n        this.doValidateParams(params);\n    }\n}"]},"hash":"8b5813cdb2cc54ed2b3eb1a27675dc2fbbd8d270"}
