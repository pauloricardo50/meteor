{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash.clonedeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"deepClone"}]},{"source":"./cleanSelectors","imported":["cleanFilters","cleanOptions"],"specifiers":[{"kind":"named","imported":"cleanFilters","local":"cleanFilters"},{"kind":"named","imported":"cleanOptions","local":"cleanOptions"}]},{"source":"../../query/lib/dotize","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"dotize"}]}],"exports":{"exported":["cleanBody","main","second","args"],"specifiers":[{"kind":"local","local":"cleanBody","exported":"default"},{"kind":"local","local":"main","exported":"default"},{"kind":"local","local":"second","exported":"default"},{"kind":"local","local":"args","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","filenameRelative":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cleanBody"},"ignored":false,"code":"module.export({\n    default: () => cleanBody\n});\nlet deepClone;\nmodule.watch(require(\"lodash.clonedeep\"), {\n    default(v) {\n        deepClone = v;\n    }\n\n}, 0);\nlet cleanFilters, cleanOptions;\nmodule.watch(require(\"./cleanSelectors\"), {\n    cleanFilters(v) {\n        cleanFilters = v;\n    },\n\n    cleanOptions(v) {\n        cleanOptions = v;\n    }\n\n}, 1);\nlet dotize;\nmodule.watch(require(\"../../query/lib/dotize\"), {\n    default(v) {\n        dotize = v;\n    }\n\n}, 2);\n\nfunction cleanBody(main, second, ...args) {\n    let object = {};\n\n    if (second.$filters || second.$options) {\n        const fields = getFields(main);\n        cleanFilters(second.$filters, fields);\n        cleanOptions(second.$options, fields);\n    }\n\n    _.each(second, (secondValue, key) => {\n        if (key === '$filters' || key === '$options') {\n            object[key] = secondValue;\n            return;\n        }\n\n        let value = main[key];\n\n        if (value === undefined) {\n            return;\n        } // if the main value is a function, we run it.\n\n\n        if (_.isFunction(value)) {\n            value = value.call(null, ...args);\n        } // if the main value is undefined or false, we skip the merge\n\n\n        if (value === undefined || value === false) {\n            return;\n        } // we treat this specially, if the value is true\n\n\n        if (value === true) {\n            object[key] = _.isObject(secondValue) ? deepClone(secondValue) : value;\n            return;\n        } // if the main value is an object\n\n\n        if (_.isObject(value)) {\n            if (_.isObject(secondValue)) {\n                // if the second one is an object as well we run recursively run the intersection\n                object[key] = cleanBody(value, secondValue, ...args);\n            } // if it is not, then we will ignore it, because it won't make sense.\n            // to merge {a: 1} with 1.\n\n\n            return;\n        } // if the main value is not an object, it should be a truthy value like 1\n\n\n        if (_.isObject(secondValue)) {\n            // if the second value is an object, then we will keep it.\n            // this won't cause problem with deep nesting because\n            // when you specify links you will have the main value as an object, otherwise it will fail\n            // this is used for things like when you have a hash object like profile with multiple nesting fields, you can allow the client to specify only what he needs\n            object[key] = deepClone(secondValue);\n        } else {\n            // if the second value is not an object, we just store the first value\n            object[key] = value;\n        }\n    });\n\n    return object;\n}\n\nfunction getFields(body) {\n    return _.keys(dotize.convert(body));\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js"],"names":["module","export","default","cleanBody","deepClone","watch","require","v","cleanFilters","cleanOptions","dotize","main","second","args","object","$filters","$options","fields","getFields","_","each","secondValue","key","value","undefined","isFunction","call","isObject","body","keys","convert"],"mappings":"AAAAA,OAAOC,MAAP,CAAc;AAACC,aAAQ,MAAIC;AAAb,CAAd;AAAuC,IAAIC,SAAJ;AAAcJ,OAAOK,KAAP,CAAaC,QAAQ,kBAAR,CAAb,EAAyC;AAACJ,YAAQK,CAAR,EAAU;AAACH,oBAAUG,CAAV;AAAY;;AAAxB,CAAzC,EAAmE,CAAnE;AAAsE,IAAIC,YAAJ,EAAiBC,YAAjB;AAA8BT,OAAOK,KAAP,CAAaC,QAAQ,kBAAR,CAAb,EAAyC;AAACE,iBAAaD,CAAb,EAAe;AAACC,uBAAaD,CAAb;AAAe,KAAhC;;AAAiCE,iBAAaF,CAAb,EAAe;AAACE,uBAAaF,CAAb;AAAe;;AAAhE,CAAzC,EAA2G,CAA3G;AAA8G,IAAIG,MAAJ;AAAWV,OAAOK,KAAP,CAAaC,QAAQ,wBAAR,CAAb,EAA+C;AAACJ,YAAQK,CAAR,EAAU;AAACG,iBAAOH,CAAP;AAAS;;AAArB,CAA/C,EAAsE,CAAtE;;AAOnQ,SAASJ,SAAT,CAAmBQ,IAAnB,EAAyBC,MAAzB,EAAiC,GAAGC,IAApC,EAA0C;AACrD,QAAIC,SAAS,EAAb;;AAEA,QAAIF,OAAOG,QAAP,IAAmBH,OAAOI,QAA9B,EAAwC;AACpC,cAAMC,SAASC,UAAUP,IAAV,CAAf;AAEAH,qBAAaI,OAAOG,QAApB,EAA8BE,MAA9B;AACAR,qBAAaG,OAAOI,QAApB,EAA8BC,MAA9B;AACH;;AAEDE,MAAEC,IAAF,CAAOR,MAAP,EAAe,CAACS,WAAD,EAAcC,GAAd,KAAsB;AACjC,YAAIA,QAAQ,UAAR,IAAsBA,QAAQ,UAAlC,EAA8C;AAC1CR,mBAAOQ,GAAP,IAAcD,WAAd;AACA;AACH;;AAED,YAAIE,QAAQZ,KAAKW,GAAL,CAAZ;;AAEA,YAAIC,UAAUC,SAAd,EAAyB;AACrB;AACH,SAVgC,CAYjC;;;AACA,YAAIL,EAAEM,UAAF,CAAaF,KAAb,CAAJ,EAAyB;AACrBA,oBAAQA,MAAMG,IAAN,CAAW,IAAX,EAAiB,GAAGb,IAApB,CAAR;AACH,SAfgC,CAiBjC;;;AACA,YAAIU,UAAUC,SAAV,IAAuBD,UAAU,KAArC,EAA4C;AACxC;AACH,SApBgC,CAsBjC;;;AACA,YAAIA,UAAU,IAAd,EAAoB;AAChBT,mBAAOQ,GAAP,IAAcH,EAAEQ,QAAF,CAAWN,WAAX,IAA0BjB,UAAUiB,WAAV,CAA1B,GAAmDE,KAAjE;AACA;AACH,SA1BgC,CA4BjC;;;AACA,YAAIJ,EAAEQ,QAAF,CAAWJ,KAAX,CAAJ,EAAuB;AACnB,gBAAIJ,EAAEQ,QAAF,CAAWN,WAAX,CAAJ,EAA6B;AACzB;AACAP,uBAAOQ,GAAP,IAAcnB,UAAUoB,KAAV,EAAiBF,WAAjB,EAA8B,GAAGR,IAAjC,CAAd;AACH,aAJkB,CAKnB;AACA;;;AAEA;AACH,SAtCgC,CAwCjC;;;AACA,YAAIM,EAAEQ,QAAF,CAAWN,WAAX,CAAJ,EAA6B;AACzB;AACA;AACA;AACA;AAEAP,mBAAOQ,GAAP,IAAclB,UAAUiB,WAAV,CAAd;AACH,SAPD,MAOO;AACH;AACAP,mBAAOQ,GAAP,IAAcC,KAAd;AACH;AACJ,KApDD;;AAsDA,WAAOT,MAAP;AACH;;AAED,SAASI,SAAT,CAAmBU,IAAnB,EAAyB;AACrB,WAAOT,EAAEU,IAAF,CAAOnB,OAAOoB,OAAP,CAAeF,IAAf,CAAP,CAAP;AACH","file":"packages/cultofcoders:grapher/lib/exposure/lib/cleanBody.js.map","sourcesContent":["import deepClone from 'lodash.clonedeep';\nimport {cleanFilters, cleanOptions} from './cleanSelectors';\nimport dotize from '../../query/lib/dotize';\n\n/**\n * Deep Inter Computation\n */\nexport default function cleanBody(main, second, ...args) {\n    let object = {};\n\n    if (second.$filters || second.$options) {\n        const fields = getFields(main);\n\n        cleanFilters(second.$filters, fields);\n        cleanOptions(second.$options, fields);\n    }\n\n    _.each(second, (secondValue, key) => {\n        if (key === '$filters' || key === '$options') {\n            object[key] = secondValue;\n            return;\n        }\n\n        let value = main[key];\n\n        if (value === undefined) {\n            return;\n        }\n\n        // if the main value is a function, we run it.\n        if (_.isFunction(value)) {\n            value = value.call(null, ...args);\n        }\n\n        // if the main value is undefined or false, we skip the merge\n        if (value === undefined || value === false) {\n            return;\n        }\n\n        // we treat this specially, if the value is true\n        if (value === true) {\n            object[key] = _.isObject(secondValue) ? deepClone(secondValue) : value;\n            return;\n        }\n\n        // if the main value is an object\n        if (_.isObject(value)) {\n            if (_.isObject(secondValue)) {\n                // if the second one is an object as well we run recursively run the intersection\n                object[key] = cleanBody(value, secondValue, ...args);\n            }\n            // if it is not, then we will ignore it, because it won't make sense.\n            // to merge {a: 1} with 1.\n\n            return;\n        }\n\n        // if the main value is not an object, it should be a truthy value like 1\n        if (_.isObject(secondValue)) {\n            // if the second value is an object, then we will keep it.\n            // this won't cause problem with deep nesting because\n            // when you specify links you will have the main value as an object, otherwise it will fail\n            // this is used for things like when you have a hash object like profile with multiple nesting fields, you can allow the client to specify only what he needs\n\n            object[key] = deepClone(secondValue);\n        } else {\n            // if the second value is not an object, we just store the first value\n            object[key] = value;\n        }\n    });\n\n    return object;\n}\n\nfunction getFields(body) {\n    return _.keys(dotize.convert(body));\n}"]},"hash":"1df48dfea6ccaa47ebe5a7e471aabb1f68316c7f"}
