{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/accounts-base","imported":["Accounts"],"specifiers":[{"kind":"named","imported":"Accounts","local":"Accounts"}]},{"source":"./helpers.js","imported":["redirect","validatePassword","validateEmail","validateUsername"],"specifiers":[{"kind":"named","imported":"redirect","local":"redirect"},{"kind":"named","imported":"validatePassword","local":"validatePassword"},{"kind":"named","imported":"validateEmail","local":"validateEmail"},{"kind":"named","imported":"validateUsername","local":"validateUsername"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/std:accounts-ui/imports/accounts_ui.js","filenameRelative":"packages/std:accounts-ui/imports/accounts_ui.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/std:accounts-ui/imports/accounts_ui.js.map","sourceFileName":"packages/std:accounts-ui/imports/accounts_ui.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts_ui"},"ignored":false,"code":"let Accounts;\nmodule.watch(require(\"meteor/accounts-base\"), {\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 0);\nlet redirect, validatePassword, validateEmail, validateUsername;\nmodule.watch(require(\"./helpers.js\"), {\n  redirect(v) {\n    redirect = v;\n  },\n\n  validatePassword(v) {\n    validatePassword = v;\n  },\n\n  validateEmail(v) {\n    validateEmail = v;\n  },\n\n  validateUsername(v) {\n    validateUsername = v;\n  }\n\n}, 1);\n/**\n * @summary Accounts UI\n * @namespace\n * @memberOf Accounts\n */Accounts.ui = {};\nAccounts.ui._options = {\n  requestPermissions: [],\n  requestOfflineToken: {},\n  forceApprovalPrompt: {},\n  requireEmailVerification: false,\n  passwordSignupFields: 'EMAIL_ONLY_NO_PASSWORD',\n  minimumPasswordLength: 7,\n  loginPath: '/',\n  signUpPath: null,\n  resetPasswordPath: null,\n  profilePath: '/',\n  changePasswordPath: null,\n  homeRoutePath: '/',\n  onSubmitHook: () => {},\n  onPreSignUpHook: () => new Promise(resolve => resolve()),\n  onPostSignUpHook: () => {},\n  onEnrollAccountHook: () => redirect(`${Accounts.ui._options.loginPath}`),\n  onResetPasswordHook: () => redirect(`${Accounts.ui._options.loginPath}`),\n  onVerifyEmailHook: () => redirect(`${Accounts.ui._options.profilePath}`),\n  onSignedInHook: () => redirect(`${Accounts.ui._options.homeRoutePath}`),\n  onSignedOutHook: () => redirect(`${Accounts.ui._options.homeRoutePath}`),\n  emailPattern: new RegExp('[^@]+@[^@\\.]{2,}\\.[^\\.@]+')\n}; /**\n    * @summary Configure the behavior of [`<Accounts.ui.LoginForm />`](#react-accounts-ui).\n    * @anywhere\n    * @param {Object} options\n    * @param {Object} options.requestPermissions Which [permissions](#requestpermissions) to request from the user for each external service.\n    * @param {Object} options.requestOfflineToken To ask the user for permission to act on their behalf when offline, map the relevant external service to `true`. Currently only supported with Google. See [Meteor.loginWithExternalService](#meteor_loginwithexternalservice) for more details.\n    * @param {Object} options.forceApprovalPrompt If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.\n    * @param {String} options.passwordSignupFields Which fields to display in the user creation form. One of '`USERNAME_AND_EMAIL`', '`USERNAME_AND_OPTIONAL_EMAIL`', '`USERNAME_ONLY`', '`EMAIL_ONLY`', or '`NO_PASSWORD`' (default).\n    */\n\nAccounts.ui.config = function (options) {\n  // validate options keys\n  const VALID_KEYS = ['passwordSignupFields', 'requestPermissions', 'requestOfflineToken', 'forbidClientAccountCreation', 'requireEmailVerification', 'minimumPasswordLength', 'loginPath', 'signUpPath', 'resetPasswordPath', 'profilePath', 'changePasswordPath', 'homeRoutePath', 'onSubmitHook', 'onPreSignUpHook', 'onPostSignUpHook', 'onEnrollAccountHook', 'onResetPasswordHook', 'onVerifyEmailHook', 'onSignedInHook', 'onSignedOutHook', 'validateField', 'emailPattern'];\n  Object.keys(options).forEach(function (key) {\n    if (!VALID_KEYS.includes(key)) throw new Error(\"Accounts.ui.config: Invalid key: \" + key);\n  }); // Deal with `passwordSignupFields`\n\n  if (options.passwordSignupFields) {\n    if ([\"USERNAME_AND_EMAIL\", \"USERNAME_AND_OPTIONAL_EMAIL\", \"USERNAME_ONLY\", \"EMAIL_ONLY\", \"EMAIL_ONLY_NO_PASSWORD\", \"USERNAME_AND_EMAIL_NO_PASSWORD\"].includes(options.passwordSignupFields)) {\n      Accounts.ui._options.passwordSignupFields = options.passwordSignupFields;\n    } else {\n      throw new Error(\"Accounts.ui.config: Invalid option for `passwordSignupFields`: \" + options.passwordSignupFields);\n    }\n  } // Deal with `requestPermissions`\n\n\n  if (options.requestPermissions) {\n    Object.keys(options.requestPermissions).forEach(service => {\n      const score = options.requestPermissions[service];\n\n      if (Accounts.ui._options.requestPermissions[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `requestPermissions` more than once for \" + service);\n      } else if (!(scope instanceof Array)) {\n        throw new Error(\"Accounts.ui.config: Value for `requestPermissions` must be an array\");\n      } else {\n        Accounts.ui._options.requestPermissions[service] = scope;\n      }\n    });\n  } // Deal with `requestOfflineToken`\n\n\n  if (options.requestOfflineToken) {\n    Object.keys(options.requestOfflineToken).forEach(service => {\n      const value = options.requestOfflineToken[service];\n      if (service !== 'google') throw new Error(\"Accounts.ui.config: `requestOfflineToken` only supported for Google login at the moment.\");\n\n      if (Accounts.ui._options.requestOfflineToken[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `requestOfflineToken` more than once for \" + service);\n      } else {\n        Accounts.ui._options.requestOfflineToken[service] = value;\n      }\n    });\n  } // Deal with `forceApprovalPrompt`\n\n\n  if (options.forceApprovalPrompt) {\n    Object.keys(options.forceApprovalPrompt).forEach(service => {\n      const value = options.forceApprovalPrompt[service];\n      if (service !== 'google') throw new Error(\"Accounts.ui.config: `forceApprovalPrompt` only supported for Google login at the moment.\");\n\n      if (Accounts.ui._options.forceApprovalPrompt[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `forceApprovalPrompt` more than once for \" + service);\n      } else {\n        Accounts.ui._options.forceApprovalPrompt[service] = value;\n      }\n    });\n  } // Deal with `requireEmailVerification`\n\n\n  if (options.requireEmailVerification) {\n    if (typeof options.requireEmailVerification != 'boolean') {\n      throw new Error(`Accounts.ui.config: \"requireEmailVerification\" not a boolean`);\n    } else {\n      Accounts.ui._options.requireEmailVerification = options.requireEmailVerification;\n    }\n  } // Deal with `minimumPasswordLength`\n\n\n  if (options.minimumPasswordLength) {\n    if (typeof options.minimumPasswordLength != 'number') {\n      throw new Error(`Accounts.ui.config: \"minimumPasswordLength\" not a number`);\n    } else {\n      Accounts.ui._options.minimumPasswordLength = options.minimumPasswordLength;\n    }\n  } // Deal with the hooks.\n\n\n  for (let hook of ['onSubmitHook', 'onPreSignUpHook', 'onPostSignUpHook']) {\n    if (options[hook]) {\n      if (typeof options[hook] != 'function') {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a function`);\n      } else {\n        Accounts.ui._options[hook] = options[hook];\n      }\n    }\n  } // Deal with pattern.\n\n\n  for (let hook of ['emailPattern']) {\n    if (options[hook]) {\n      if (!(options[hook] instanceof RegExp)) {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a Regular Expression`);\n      } else {\n        Accounts.ui._options[hook] = options[hook];\n      }\n    }\n  } // deal with the paths.\n\n\n  for (let path of ['loginPath', 'signUpPath', 'resetPasswordPath', 'profilePath', 'changePasswordPath', 'homeRoutePath']) {\n    if (typeof options[path] !== 'undefined') {\n      if (options[path] !== null && typeof options[path] !== 'string') {\n        throw new Error(`Accounts.ui.config: ${path} is not a string or null`);\n      } else {\n        Accounts.ui._options[path] = options[path];\n      }\n    }\n  } // deal with redirect hooks.\n\n\n  for (let hook of ['onEnrollAccountHook', 'onResetPasswordHook', 'onVerifyEmailHook', 'onSignedInHook', 'onSignedOutHook']) {\n    if (options[hook]) {\n      if (typeof options[hook] == 'function') {\n        Accounts.ui._options[hook] = options[hook];\n      } else if (typeof options[hook] == 'string') {\n        Accounts.ui._options[hook] = () => redirect(options[hook]);\n      } else {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a function or an absolute or relative path`);\n      }\n    }\n  }\n};\n\nmodule.exportDefault(Accounts);","map":{"version":3,"sources":["packages/std:accounts-ui/imports/accounts_ui.js"],"names":["Accounts","module","watch","require","v","redirect","validatePassword","validateEmail","validateUsername","ui","_options","requestPermissions","requestOfflineToken","forceApprovalPrompt","requireEmailVerification","passwordSignupFields","minimumPasswordLength","loginPath","signUpPath","resetPasswordPath","profilePath","changePasswordPath","homeRoutePath","onSubmitHook","onPreSignUpHook","Promise","resolve","onPostSignUpHook","onEnrollAccountHook","onResetPasswordHook","onVerifyEmailHook","onSignedInHook","onSignedOutHook","emailPattern","RegExp","config","options","VALID_KEYS","Object","keys","forEach","key","includes","Error","service","score","scope","Array","value","hook","path","exportDefault"],"mappings":"AAAA,IAAIA,QAAJ;AAAaC,OAAOC,KAAP,CAAaC,QAAQ,sBAAR,CAAb,EAA6C;AAACH,WAASI,CAAT,EAAW;AAACJ,eAASI,CAAT;AAAW;;AAAxB,CAA7C,EAAuE,CAAvE;AAA0E,IAAIC,QAAJ,EAAaC,gBAAb,EAA8BC,aAA9B,EAA4CC,gBAA5C;AAA6DP,OAAOC,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACE,WAASD,CAAT,EAAW;AAACC,eAASD,CAAT;AAAW,GAAxB;;AAAyBE,mBAAiBF,CAAjB,EAAmB;AAACE,uBAAiBF,CAAjB;AAAmB,GAAhE;;AAAiEG,gBAAcH,CAAd,EAAgB;AAACG,oBAAcH,CAAd;AAAgB,GAAlG;;AAAmGI,mBAAiBJ,CAAjB,EAAmB;AAACI,uBAAiBJ,CAAjB;AAAmB;;AAA1I,CAArC,EAAiL,CAAjL;AAQpJ;;;;GAKAJ,SAASS,EAAT,GAAc,EAAd;AAEAT,SAASS,EAAT,CAAYC,QAAZ,GAAuB;AACrBC,sBAAoB,EADC;AAErBC,uBAAqB,EAFA;AAGrBC,uBAAqB,EAHA;AAIrBC,4BAA0B,KAJL;AAKrBC,wBAAsB,wBALD;AAMrBC,yBAAuB,CANF;AAOrBC,aAAW,GAPU;AAQrBC,cAAY,IARS;AASrBC,qBAAmB,IATE;AAUrBC,eAAa,GAVQ;AAWrBC,sBAAoB,IAXC;AAYrBC,iBAAe,GAZM;AAarBC,gBAAc,MAAM,CAAE,CAbD;AAcrBC,mBAAiB,MAAM,IAAIC,OAAJ,CAAYC,WAAWA,SAAvB,CAdF;AAerBC,oBAAkB,MAAM,CAAE,CAfL;AAgBrBC,uBAAqB,MAAMvB,SAAU,GAAEL,SAASS,EAAT,CAAYC,QAAZ,CAAqBO,SAAU,EAA3C,CAhBN;AAiBrBY,uBAAqB,MAAMxB,SAAU,GAAEL,SAASS,EAAT,CAAYC,QAAZ,CAAqBO,SAAU,EAA3C,CAjBN;AAkBrBa,qBAAmB,MAAMzB,SAAU,GAAEL,SAASS,EAAT,CAAYC,QAAZ,CAAqBU,WAAY,EAA7C,CAlBJ;AAmBrBW,kBAAgB,MAAM1B,SAAU,GAAEL,SAASS,EAAT,CAAYC,QAAZ,CAAqBY,aAAc,EAA/C,CAnBD;AAoBrBU,mBAAiB,MAAM3B,SAAU,GAAEL,SAASS,EAAT,CAAYC,QAAZ,CAAqBY,aAAc,EAA/C,CApBF;AAqBrBW,gBAAc,IAAIC,MAAJ,CAAW,2BAAX;AArBO,CAAvB,C,CAwBA;;;;;;;;;;AASAlC,SAASS,EAAT,CAAY0B,MAAZ,GAAqB,UAASC,OAAT,EAAkB;AACrC;AACA,QAAMC,aAAa,CACjB,sBADiB,EAEjB,oBAFiB,EAGjB,qBAHiB,EAIjB,6BAJiB,EAKjB,0BALiB,EAMjB,uBANiB,EAOjB,WAPiB,EAQjB,YARiB,EASjB,mBATiB,EAUjB,aAViB,EAWjB,oBAXiB,EAYjB,eAZiB,EAajB,cAbiB,EAcjB,iBAdiB,EAejB,kBAfiB,EAgBjB,qBAhBiB,EAiBjB,qBAjBiB,EAkBjB,mBAlBiB,EAmBjB,gBAnBiB,EAoBjB,iBApBiB,EAqBjB,eArBiB,EAsBjB,cAtBiB,CAAnB;AAyBAC,SAAOC,IAAP,CAAYH,OAAZ,EAAqBI,OAArB,CAA6B,UAAUC,GAAV,EAAe;AAC1C,QAAI,CAACJ,WAAWK,QAAX,CAAoBD,GAApB,CAAL,EACE,MAAM,IAAIE,KAAJ,CAAU,sCAAsCF,GAAhD,CAAN;AACH,GAHD,EA3BqC,CAgCrC;;AACA,MAAIL,QAAQrB,oBAAZ,EAAkC;AAChC,QAAI,CACF,oBADE,EAEF,6BAFE,EAGF,eAHE,EAIF,YAJE,EAKF,wBALE,EAMF,gCANE,EAOF2B,QAPE,CAOON,QAAQrB,oBAPf,CAAJ,EAO0C;AACxCf,eAASS,EAAT,CAAYC,QAAZ,CAAqBK,oBAArB,GAA4CqB,QAAQrB,oBAApD;AACD,KATD,MAUK;AACH,YAAM,IAAI4B,KAAJ,CAAU,oEAAoEP,QAAQrB,oBAAtF,CAAN;AACD;AACF,GA/CoC,CAiDrC;;;AACA,MAAIqB,QAAQzB,kBAAZ,EAAgC;AAC9B2B,WAAOC,IAAP,CAAYH,QAAQzB,kBAApB,EAAwC6B,OAAxC,CAAgDI,WAAW;AACzD,YAAMC,QAAQT,QAAQzB,kBAAR,CAA2BiC,OAA3B,CAAd;;AACA,UAAI5C,SAASS,EAAT,CAAYC,QAAZ,CAAqBC,kBAArB,CAAwCiC,OAAxC,CAAJ,EAAsD;AACpD,cAAM,IAAID,KAAJ,CAAU,2EAA2EC,OAArF,CAAN;AACD,OAFD,MAGK,IAAI,EAAEE,iBAAiBC,KAAnB,CAAJ,EAA+B;AAClC,cAAM,IAAIJ,KAAJ,CAAU,qEAAV,CAAN;AACD,OAFI,MAGA;AACH3C,iBAASS,EAAT,CAAYC,QAAZ,CAAqBC,kBAArB,CAAwCiC,OAAxC,IAAmDE,KAAnD;AACD;AACF,KAXD;AAYD,GA/DoC,CAiErC;;;AACA,MAAIV,QAAQxB,mBAAZ,EAAiC;AAC/B0B,WAAOC,IAAP,CAAYH,QAAQxB,mBAApB,EAAyC4B,OAAzC,CAAiDI,WAAW;AAC1D,YAAMI,QAAQZ,QAAQxB,mBAAR,CAA4BgC,OAA5B,CAAd;AACA,UAAIA,YAAY,QAAhB,EACE,MAAM,IAAID,KAAJ,CAAU,0FAAV,CAAN;;AAEF,UAAI3C,SAASS,EAAT,CAAYC,QAAZ,CAAqBE,mBAArB,CAAyCgC,OAAzC,CAAJ,EAAuD;AACrD,cAAM,IAAID,KAAJ,CAAU,4EAA4EC,OAAtF,CAAN;AACD,OAFD,MAGK;AACH5C,iBAASS,EAAT,CAAYC,QAAZ,CAAqBE,mBAArB,CAAyCgC,OAAzC,IAAoDI,KAApD;AACD;AACF,KAXD;AAYD,GA/EoC,CAiFrC;;;AACA,MAAIZ,QAAQvB,mBAAZ,EAAiC;AAC/ByB,WAAOC,IAAP,CAAYH,QAAQvB,mBAApB,EAAyC2B,OAAzC,CAAiDI,WAAW;AAC1D,YAAMI,QAAQZ,QAAQvB,mBAAR,CAA4B+B,OAA5B,CAAd;AACA,UAAIA,YAAY,QAAhB,EACE,MAAM,IAAID,KAAJ,CAAU,0FAAV,CAAN;;AAEF,UAAI3C,SAASS,EAAT,CAAYC,QAAZ,CAAqBG,mBAArB,CAAyC+B,OAAzC,CAAJ,EAAuD;AACrD,cAAM,IAAID,KAAJ,CAAU,4EAA4EC,OAAtF,CAAN;AACD,OAFD,MAGK;AACH5C,iBAASS,EAAT,CAAYC,QAAZ,CAAqBG,mBAArB,CAAyC+B,OAAzC,IAAoDI,KAApD;AACD;AACF,KAXD;AAYD,GA/FoC,CAiGrC;;;AACA,MAAIZ,QAAQtB,wBAAZ,EAAsC;AACpC,QAAI,OAAOsB,QAAQtB,wBAAf,IAA2C,SAA/C,EAA0D;AACxD,YAAM,IAAI6B,KAAJ,CAAW,8DAAX,CAAN;AACD,KAFD,MAGK;AACH3C,eAASS,EAAT,CAAYC,QAAZ,CAAqBI,wBAArB,GAAgDsB,QAAQtB,wBAAxD;AACD;AACF,GAzGoC,CA2GrC;;;AACA,MAAIsB,QAAQpB,qBAAZ,EAAmC;AACjC,QAAI,OAAOoB,QAAQpB,qBAAf,IAAwC,QAA5C,EAAsD;AACpD,YAAM,IAAI2B,KAAJ,CAAW,0DAAX,CAAN;AACD,KAFD,MAGK;AACH3C,eAASS,EAAT,CAAYC,QAAZ,CAAqBM,qBAArB,GAA6CoB,QAAQpB,qBAArD;AACD;AACF,GAnHoC,CAqHrC;;;AACA,OAAK,IAAIiC,IAAT,IAAiB,CACf,cADe,EAEf,iBAFe,EAGf,kBAHe,CAAjB,EAIG;AACD,QAAIb,QAAQa,IAAR,CAAJ,EAAmB;AACjB,UAAI,OAAOb,QAAQa,IAAR,CAAP,IAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIN,KAAJ,CAAW,wBAAuBM,IAAK,kBAAvC,CAAN;AACD,OAFD,MAGK;AACHjD,iBAASS,EAAT,CAAYC,QAAZ,CAAqBuC,IAArB,IAA6Bb,QAAQa,IAAR,CAA7B;AACD;AACF;AACF,GAnIoC,CAqIrC;;;AACA,OAAK,IAAIA,IAAT,IAAiB,CACf,cADe,CAAjB,EAEG;AACD,QAAIb,QAAQa,IAAR,CAAJ,EAAmB;AACjB,UAAI,EAAEb,QAAQa,IAAR,aAAyBf,MAA3B,CAAJ,EAAwC;AACtC,cAAM,IAAIS,KAAJ,CAAW,wBAAuBM,IAAK,4BAAvC,CAAN;AACD,OAFD,MAGK;AACHjD,iBAASS,EAAT,CAAYC,QAAZ,CAAqBuC,IAArB,IAA6Bb,QAAQa,IAAR,CAA7B;AACD;AACF;AACF,GAjJoC,CAmJrC;;;AACA,OAAK,IAAIC,IAAT,IAAiB,CACf,WADe,EAEf,YAFe,EAGf,mBAHe,EAIf,aAJe,EAKf,oBALe,EAMf,eANe,CAAjB,EAOG;AACD,QAAI,OAAOd,QAAQc,IAAR,CAAP,KAAyB,WAA7B,EAA0C;AACxC,UAAId,QAAQc,IAAR,MAAkB,IAAlB,IAA0B,OAAOd,QAAQc,IAAR,CAAP,KAAyB,QAAvD,EAAiE;AAC/D,cAAM,IAAIP,KAAJ,CAAW,uBAAsBO,IAAK,0BAAtC,CAAN;AACD,OAFD,MAGK;AACHlD,iBAASS,EAAT,CAAYC,QAAZ,CAAqBwC,IAArB,IAA6Bd,QAAQc,IAAR,CAA7B;AACD;AACF;AACF,GApKoC,CAsKrC;;;AACA,OAAK,IAAID,IAAT,IAAiB,CACb,qBADa,EAEb,qBAFa,EAGb,mBAHa,EAIb,gBAJa,EAKb,iBALa,CAAjB,EAKwB;AACtB,QAAIb,QAAQa,IAAR,CAAJ,EAAmB;AACjB,UAAI,OAAOb,QAAQa,IAAR,CAAP,IAAwB,UAA5B,EAAwC;AACtCjD,iBAASS,EAAT,CAAYC,QAAZ,CAAqBuC,IAArB,IAA6Bb,QAAQa,IAAR,CAA7B;AACD,OAFD,MAGK,IAAI,OAAOb,QAAQa,IAAR,CAAP,IAAwB,QAA5B,EAAsC;AACzCjD,iBAASS,EAAT,CAAYC,QAAZ,CAAqBuC,IAArB,IAA6B,MAAM5C,SAAS+B,QAAQa,IAAR,CAAT,CAAnC;AACD,OAFI,MAGA;AACH,cAAM,IAAIN,KAAJ,CAAW,wBAAuBM,IAAK,kDAAvC,CAAN;AACD;AACF;AACF;AACF,CAzLD;;AAhDAhD,OAAOkD,aAAP,CA2OenD,QA3Of","file":"packages/std:accounts-ui/imports/accounts_ui.js.map","sourcesContent":["import { Accounts } from 'meteor/accounts-base';\nimport {\n  redirect,\n  validatePassword,\n  validateEmail,\n  validateUsername,\n} from './helpers.js';\n\n/**\n * @summary Accounts UI\n * @namespace\n * @memberOf Accounts\n */\nAccounts.ui = {};\n\nAccounts.ui._options = {\n  requestPermissions: [],\n  requestOfflineToken: {},\n  forceApprovalPrompt: {},\n  requireEmailVerification: false,\n  passwordSignupFields: 'EMAIL_ONLY_NO_PASSWORD',\n  minimumPasswordLength: 7,\n  loginPath: '/',\n  signUpPath: null,\n  resetPasswordPath: null,\n  profilePath: '/',\n  changePasswordPath: null,\n  homeRoutePath: '/',\n  onSubmitHook: () => {},\n  onPreSignUpHook: () => new Promise(resolve => resolve()),\n  onPostSignUpHook: () => {},\n  onEnrollAccountHook: () => redirect(`${Accounts.ui._options.loginPath}`),\n  onResetPasswordHook: () => redirect(`${Accounts.ui._options.loginPath}`),\n  onVerifyEmailHook: () => redirect(`${Accounts.ui._options.profilePath}`),\n  onSignedInHook: () => redirect(`${Accounts.ui._options.homeRoutePath}`),\n  onSignedOutHook: () => redirect(`${Accounts.ui._options.homeRoutePath}`),\n  emailPattern: new RegExp('[^@]+@[^@\\.]{2,}\\.[^\\.@]+'),\n};\n\n/**\n * @summary Configure the behavior of [`<Accounts.ui.LoginForm />`](#react-accounts-ui).\n * @anywhere\n * @param {Object} options\n * @param {Object} options.requestPermissions Which [permissions](#requestpermissions) to request from the user for each external service.\n * @param {Object} options.requestOfflineToken To ask the user for permission to act on their behalf when offline, map the relevant external service to `true`. Currently only supported with Google. See [Meteor.loginWithExternalService](#meteor_loginwithexternalservice) for more details.\n * @param {Object} options.forceApprovalPrompt If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.\n * @param {String} options.passwordSignupFields Which fields to display in the user creation form. One of '`USERNAME_AND_EMAIL`', '`USERNAME_AND_OPTIONAL_EMAIL`', '`USERNAME_ONLY`', '`EMAIL_ONLY`', or '`NO_PASSWORD`' (default).\n */\nAccounts.ui.config = function(options) {\n  // validate options keys\n  const VALID_KEYS = [\n    'passwordSignupFields',\n    'requestPermissions',\n    'requestOfflineToken',\n    'forbidClientAccountCreation',\n    'requireEmailVerification',\n    'minimumPasswordLength',\n    'loginPath',\n    'signUpPath',\n    'resetPasswordPath',\n    'profilePath',\n    'changePasswordPath',\n    'homeRoutePath',\n    'onSubmitHook',\n    'onPreSignUpHook',\n    'onPostSignUpHook',\n    'onEnrollAccountHook',\n    'onResetPasswordHook',\n    'onVerifyEmailHook',\n    'onSignedInHook',\n    'onSignedOutHook',\n    'validateField',\n    'emailPattern',\n  ];\n\n  Object.keys(options).forEach(function (key) {\n    if (!VALID_KEYS.includes(key))\n      throw new Error(\"Accounts.ui.config: Invalid key: \" + key);\n  });\n\n  // Deal with `passwordSignupFields`\n  if (options.passwordSignupFields) {\n    if ([\n      \"USERNAME_AND_EMAIL\",\n      \"USERNAME_AND_OPTIONAL_EMAIL\",\n      \"USERNAME_ONLY\",\n      \"EMAIL_ONLY\",\n      \"EMAIL_ONLY_NO_PASSWORD\",\n      \"USERNAME_AND_EMAIL_NO_PASSWORD\"\n    ].includes(options.passwordSignupFields)) {\n      Accounts.ui._options.passwordSignupFields = options.passwordSignupFields;\n    }\n    else {\n      throw new Error(\"Accounts.ui.config: Invalid option for `passwordSignupFields`: \" + options.passwordSignupFields);\n    }\n  }\n\n  // Deal with `requestPermissions`\n  if (options.requestPermissions) {\n    Object.keys(options.requestPermissions).forEach(service => {\n      const score = options.requestPermissions[service];\n      if (Accounts.ui._options.requestPermissions[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `requestPermissions` more than once for \" + service);\n      }\n      else if (!(scope instanceof Array)) {\n        throw new Error(\"Accounts.ui.config: Value for `requestPermissions` must be an array\");\n      }\n      else {\n        Accounts.ui._options.requestPermissions[service] = scope;\n      }\n    });\n  }\n\n  // Deal with `requestOfflineToken`\n  if (options.requestOfflineToken) {\n    Object.keys(options.requestOfflineToken).forEach(service => {\n      const value = options.requestOfflineToken[service];\n      if (service !== 'google')\n        throw new Error(\"Accounts.ui.config: `requestOfflineToken` only supported for Google login at the moment.\");\n\n      if (Accounts.ui._options.requestOfflineToken[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `requestOfflineToken` more than once for \" + service);\n      }\n      else {\n        Accounts.ui._options.requestOfflineToken[service] = value;\n      }\n    });\n  }\n\n  // Deal with `forceApprovalPrompt`\n  if (options.forceApprovalPrompt) {\n    Object.keys(options.forceApprovalPrompt).forEach(service => {\n      const value = options.forceApprovalPrompt[service];\n      if (service !== 'google')\n        throw new Error(\"Accounts.ui.config: `forceApprovalPrompt` only supported for Google login at the moment.\");\n\n      if (Accounts.ui._options.forceApprovalPrompt[service]) {\n        throw new Error(\"Accounts.ui.config: Can't set `forceApprovalPrompt` more than once for \" + service);\n      }\n      else {\n        Accounts.ui._options.forceApprovalPrompt[service] = value;\n      }\n    });\n  }\n\n  // Deal with `requireEmailVerification`\n  if (options.requireEmailVerification) {\n    if (typeof options.requireEmailVerification != 'boolean') {\n      throw new Error(`Accounts.ui.config: \"requireEmailVerification\" not a boolean`);\n    }\n    else {\n      Accounts.ui._options.requireEmailVerification = options.requireEmailVerification;\n    }\n  }\n\n  // Deal with `minimumPasswordLength`\n  if (options.minimumPasswordLength) {\n    if (typeof options.minimumPasswordLength != 'number') {\n      throw new Error(`Accounts.ui.config: \"minimumPasswordLength\" not a number`);\n    }\n    else {\n      Accounts.ui._options.minimumPasswordLength = options.minimumPasswordLength;\n    }\n  }\n\n  // Deal with the hooks.\n  for (let hook of [\n    'onSubmitHook',\n    'onPreSignUpHook',\n    'onPostSignUpHook',\n  ]) {\n    if (options[hook]) {\n      if (typeof options[hook] != 'function') {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a function`);\n      }\n      else {\n        Accounts.ui._options[hook] = options[hook];\n      }\n    }\n  }\n\n  // Deal with pattern.\n  for (let hook of [\n    'emailPattern',\n  ]) {\n    if (options[hook]) {\n      if (!(options[hook] instanceof RegExp)) {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a Regular Expression`);\n      }\n      else {\n        Accounts.ui._options[hook] = options[hook];\n      }\n    }\n  }\n\n  // deal with the paths.\n  for (let path of [\n    'loginPath',\n    'signUpPath',\n    'resetPasswordPath',\n    'profilePath',\n    'changePasswordPath',\n    'homeRoutePath'\n  ]) {\n    if (typeof options[path] !== 'undefined') {\n      if (options[path] !== null && typeof options[path] !== 'string') {\n        throw new Error(`Accounts.ui.config: ${path} is not a string or null`);\n      }\n      else {\n        Accounts.ui._options[path] = options[path];\n      }\n    }\n  }\n\n  // deal with redirect hooks.\n  for (let hook of [\n      'onEnrollAccountHook',\n      'onResetPasswordHook',\n      'onVerifyEmailHook',\n      'onSignedInHook',\n      'onSignedOutHook']) {\n    if (options[hook]) {\n      if (typeof options[hook] == 'function') {\n        Accounts.ui._options[hook] = options[hook];\n      }\n      else if (typeof options[hook] == 'string') {\n        Accounts.ui._options[hook] = () => redirect(options[hook]);\n      }\n      else {\n        throw new Error(`Accounts.ui.config: \"${hook}\" not a function or an absolute or relative path`);\n      }\n    }\n  }\n};\n\nexport default Accounts;\n"]},"hash":"702b89ed9d5d29f8c24f096361f44ceba64856ef"}
