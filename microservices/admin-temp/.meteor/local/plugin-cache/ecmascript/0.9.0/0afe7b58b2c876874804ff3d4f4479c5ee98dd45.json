{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../reducers/lib/applyReducers","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"applyReducers"}]},{"source":"../reducers/lib/cleanReducerLeftovers","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanReducerLeftovers"}]},{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]},{"source":"meteor/minimongo","imported":["Minimongo"],"specifiers":[{"kind":"named","imported":"Minimongo","local":"Minimongo"}]}],"exports":{"exported":["applyPostFilters","node","applyPostOptions","node","removeLinkStorages","node","sameLevelResults","storeOneResults","node","sameLevelResults","assembleMetadata","node","parentResults"],"specifiers":[{"kind":"local","local":"applyPostFilters","exported":"applyPostFilters"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"applyPostOptions","exported":"applyPostOptions"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"removeLinkStorages","exported":"removeLinkStorages"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"sameLevelResults","exported":"sameLevelResults"},{"kind":"local","local":"storeOneResults","exported":"storeOneResults"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"sameLevelResults","exported":"sameLevelResults"},{"kind":"local","local":"assembleMetadata","exported":"assembleMetadata"},{"kind":"local","local":"node","exported":"node"},{"kind":"local","local":"parentResults","exported":"parentResults"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"prepareForDelivery"},"ignored":false,"code":"module.export({\n    applyPostFilters: () => applyPostFilters,\n    applyPostOptions: () => applyPostOptions,\n    removeLinkStorages: () => removeLinkStorages,\n    storeOneResults: () => storeOneResults,\n    assembleMetadata: () => assembleMetadata\n});\nlet applyReducers;\nmodule.watch(require(\"../reducers/lib/applyReducers\"), {\n    default(v) {\n        applyReducers = v;\n    }\n\n}, 0);\nlet cleanReducerLeftovers;\nmodule.watch(require(\"../reducers/lib/cleanReducerLeftovers\"), {\n    default(v) {\n        cleanReducerLeftovers = v;\n    }\n\n}, 1);\nlet sift;\nmodule.watch(require(\"sift\"), {\n    default(v) {\n        sift = v;\n    }\n\n}, 2);\nlet Minimongo;\nmodule.watch(require(\"meteor/minimongo\"), {\n    Minimongo(v) {\n        Minimongo = v;\n    }\n\n}, 3);\nmodule.exportDefault((node, params) => {\n    snapBackCaches(node);\n    applyReducers(node, params);\n    cleanReducerLeftovers(node);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results);\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results);\n    });\n\n    removeLinkStorages(node, node.results);\n    storeOneResults(node, node.results);\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n});\n\nfunction applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nfunction applyPostOptions(node) {\n    const options = node.props.$postOptions;\n\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n/**\n * Optionally applies a post filtering option\n */function applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            });\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\nfunction removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n\n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                delete result[collectionNode.linkStorageField];\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        });\n    });\n}\n\nfunction storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            sameLevelResults.forEach(result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName] ? _.first(result[collectionNode.linkName]) : undefined;\n                }\n            });\n        }\n    });\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            parentResult[linkName] = parentResult[linkName].map(object => {\n                return Object.assign({}, object);\n            });\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nfunction assembleMetadata(node, parentResults) {\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName]);\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                _.each(childResult, object => {\n                    const storage = object[node.linkStorageField];\n                    storeMetadata(object, parentResult, storage, true);\n                });\n            });\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                _.each(childResult, object => {\n                    storeMetadata(object, parentResult, storage, false);\n                });\n            });\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    } else {\n        let $metadata;\n\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n\n            const linker = node.collection.getLinker(linkName); // we do this because for one direct and one meta direct, id is not stored\n\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta() ? result[linker.linkStorageField]._id : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            });\n        });\n    }\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js"],"names":["module","export","applyPostFilters","applyPostOptions","removeLinkStorages","storeOneResults","assembleMetadata","applyReducers","watch","require","default","v","cleanReducerLeftovers","sift","Minimongo","exportDefault","node","params","snapBackCaches","_","each","collectionNodes","collectionNode","cloneMetaChildren","results","applyPostFilter","postFilters","props","$postFilters","options","$postOptions","sort","sorter","Sorter","getComparator","limit","skip","start","end","length","slice","$postFilter","filter","isArray","forEach","f","sameLevelResults","removeStorageField","shouldCleanStorage","result","linkStorageField","linkName","isOneResult","first","undefined","parentResults","isMeta","parentResult","map","object","Object","assign","isVirtual","childResult","storage","storeMetadata","element","parentElement","$metadata","find","storageItem","_id","omit","isEmpty","snapCaches","cacheField","isSingle","contains","snapCachesSingles","linker","collection","getLinker","shoudStoreLinkStorage","isMany"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/lib/prepareForDelivery.js.map","sourcesContent":["// 1. Clone children with meta relationships\n// 2. Apply $metadata to children\n// 3. Removes link storage (if not specified)\n// 4. Stores oneResult links as a single object instead of array\nimport applyReducers from '../reducers/lib/applyReducers';\nimport cleanReducerLeftovers from '../reducers/lib/cleanReducerLeftovers';\nimport sift from 'sift';\nimport {Minimongo} from 'meteor/minimongo';\n\nexport default (node, params) => {\n    snapBackCaches(node);\n    applyReducers(node, params);\n    cleanReducerLeftovers(node);\n\n    _.each(node.collectionNodes, collectionNode => {\n        cloneMetaChildren(collectionNode, node.results)\n    });\n\n    _.each(node.collectionNodes, collectionNode => {\n        assembleMetadata(collectionNode, node.results)\n    });\n\n    removeLinkStorages(node, node.results);\n    storeOneResults(node, node.results);\n    applyPostFilters(node);\n    applyPostOptions(node);\n    applyPostFilter(node, params);\n}\n\nexport function applyPostFilters(node) {\n    const postFilters = node.props.$postFilters;\n    if (postFilters) {\n        node.results = sift(postFilters, node.results);\n    }\n}\n\nexport function applyPostOptions(node) {\n    const options = node.props.$postOptions;\n    if (options) {\n        if (options.sort) {\n            const sorter = new Minimongo.Sorter(options.sort);\n            node.results.sort(sorter.getComparator());\n        }\n        if (options.limit || options.skip) {\n            const start = options.skip || 0;\n            const end = options.limit ? options.limit + start : node.results.length;\n            node.results = node.results.slice(start, end);\n        }\n    }\n}\n\n\n/**\n * Optionally applies a post filtering option\n */\nfunction applyPostFilter(node, params) {\n    if (node.props.$postFilter) {\n        const filter = node.props.$postFilter;\n\n        if (_.isArray(filter)) {\n            filter.forEach(f => {\n                node.results = f(node.results, params);\n            })\n        } else {\n            node.results = filter(node.results, params);\n        }\n    }\n}\n\nexport function removeLinkStorages(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    _.each(node.collectionNodes, collectionNode => {\n        const removeStorageField = collectionNode.shouldCleanStorage;\n        _.each(sameLevelResults, result => {\n            if (removeStorageField) {\n                delete result[collectionNode.linkStorageField];\n            }\n\n            removeLinkStorages(collectionNode, result[collectionNode.linkName]);\n        })\n    })\n}\n\nexport function storeOneResults(node, sameLevelResults) {\n    if (!sameLevelResults) {\n        return;\n    }\n\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(sameLevelResults, result => {\n            storeOneResults(collectionNode, result[collectionNode.linkName]);\n        });\n\n        if (collectionNode.isOneResult) {\n            sameLevelResults.forEach(result => {\n                if (result[collectionNode.linkName] && _.isArray(result[collectionNode.linkName])) {\n                    result[collectionNode.linkName] = result[collectionNode.linkName]\n                        ? _.first(result[collectionNode.linkName])\n                        : undefined;\n                }\n            })\n        }\n    })\n}\n\nfunction cloneMetaChildren(node, parentResults) {\n    if (!parentResults) {\n        return;\n    }\n\n    const linkName = node.linkName;\n    const isMeta = node.isMeta;\n\n    parentResults.forEach(parentResult => {\n        if (isMeta && parentResult[linkName]) {\n            parentResult[linkName] = parentResult[linkName].map(object => {\n                return Object.assign({}, object);\n            });\n        }\n\n        node.collectionNodes.forEach(collectionNode => {\n            cloneMetaChildren(collectionNode, parentResult[linkName]);\n        });\n    });\n}\n\nexport function assembleMetadata(node, parentResults) {\n    // assembling metadata is depth first\n    node.collectionNodes.forEach(collectionNode => {\n        _.each(parentResults, result => {\n            assembleMetadata(collectionNode, result[node.linkName])\n        });\n    });\n\n    if (node.isMeta) {\n        if (node.isVirtual) {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n\n                _.each(childResult, object => {\n                    const storage = object[node.linkStorageField];\n\n                    storeMetadata(object, parentResult, storage, true);\n                });\n            })\n        } else {\n            _.each(parentResults, parentResult => {\n                const childResult = parentResult[node.linkName];\n                const storage = parentResult[node.linkStorageField];\n\n                _.each(childResult, object => {\n                    storeMetadata(object, parentResult, storage, false);\n                });\n            })\n        }\n    }\n}\n\nfunction storeMetadata(element, parentElement, storage, isVirtual) {\n    if (isVirtual) {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == parentElement._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id')\n    } else {\n        let $metadata;\n        if (_.isArray(storage)) {\n            $metadata = _.find(storage, storageItem => storageItem._id == element._id);\n        } else {\n            $metadata = storage;\n        }\n\n        element.$metadata = _.omit($metadata, '_id');\n    }\n}\n\nfunction snapBackCaches(node) {\n    node.collectionNodes.forEach(collectionNode => {\n        snapBackCaches(collectionNode);\n    });\n\n    if (!_.isEmpty(node.snapCaches)) {\n        // process stuff\n        _.each(node.snapCaches, (linkName, cacheField) => {\n            const isSingle = _.contains(node.snapCachesSingles, cacheField);\n            const linker = node.collection.getLinker(linkName);\n            // we do this because for one direct and one meta direct, id is not stored\n            const shoudStoreLinkStorage = !linker.isMany() && !linker.isVirtual();\n\n            node.results.forEach(result => {\n                if (result[cacheField]) {\n                    if (shoudStoreLinkStorage) {\n                        Object.assign(result[cacheField], {\n                            _id: linker.isMeta()\n                                ? result[linker.linkStorageField]._id\n                                : result[linker.linkStorageField]\n                        });\n                    }\n\n                    if (isSingle && _.isArray(result[cacheField])) {\n                        result[linkName] = _.first(result[cacheField]);\n                    } else {\n                        result[linkName] = result[cacheField];\n                    }\n\n                    delete result[cacheField];\n                }\n            })\n        })\n    }\n}\n"]},"hash":"0afe7b58b2c876874804ff3d4f4479c5ee98dd45"}
