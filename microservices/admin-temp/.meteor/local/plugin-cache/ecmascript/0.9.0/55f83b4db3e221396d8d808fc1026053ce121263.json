{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]},{"source":"./lib/cleanObjectForMetaFilters","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanObjectForMetaFilters"}]}],"exports":{"exported":["childCollectionNode","aggregateResults","metaFilters"],"specifiers":[{"kind":"local","local":"childCollectionNode","exported":"default"},{"kind":"local","local":"aggregateResults","exported":"default"},{"kind":"local","local":"metaFilters","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"assembleAggregateResults"},"ignored":false,"code":"let sift;\nmodule.watch(require(\"sift\"), {\n    default(v) {\n        sift = v;\n    }\n\n}, 0);\nlet cleanObjectForMetaFilters;\nmodule.watch(require(\"./lib/cleanObjectForMetaFilters\"), {\n    default(v) {\n        cleanObjectForMetaFilters = v;\n    }\n\n}, 1);\nmodule.exportDefault(function (childCollectionNode, aggregateResults, metaFilters) {\n    const linker = childCollectionNode.linker;\n    const linkStorageField = linker.linkStorageField;\n    const linkName = childCollectionNode.linkName;\n    const isMeta = linker.isMeta();\n    let allResults = [];\n\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n\n        _.each(childCollectionNode.parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, linkStorageField, metaFiltersTest);\n        });\n    }\n\n    if (isMeta && linker.isMany()) {\n        // This case is treated differently because we get an array response from the pipeline.\n        _.each(childCollectionNode.parent.results, parentResult => {\n            parentResult[linkName] = parentResult[linkName] || [];\n\n            const eligibleAggregateResults = _.filter(aggregateResults, aggregateResult => {\n                return _.contains(aggregateResult._id, parentResult._id);\n            });\n\n            if (eligibleAggregateResults.length) {\n                const datas = _.pluck(eligibleAggregateResults, 'data'); /// [ [x1, x2], [x2, x3] ]\n\n\n                _.each(datas, data => {\n                    _.each(data, item => {\n                        parentResult[linkName].push(item);\n                    });\n                });\n            }\n        });\n\n        _.each(aggregateResults, aggregateResult => {\n            _.each(aggregateResult.data, item => allResults.push(item));\n        });\n    } else {\n        _.each(aggregateResults, aggregateResult => {\n            let parentResult = _.find(childCollectionNode.parent.results, result => {\n                return result._id == aggregateResult._id;\n            });\n\n            if (parentResult) {\n                parentResult[childCollectionNode.linkName] = aggregateResult.data;\n            }\n\n            _.each(aggregateResult.data, item => {\n                allResults.push(item);\n            });\n        });\n    }\n\n    childCollectionNode.results = allResults;\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js"],"names":["sift","module","watch","require","default","v","cleanObjectForMetaFilters","exportDefault","childCollectionNode","aggregateResults","metaFilters","linker","linkStorageField","linkName","isMeta","allResults","metaFiltersTest","_","each","parent","results","parentResult","isMany","eligibleAggregateResults","filter","aggregateResult","contains","_id","length","datas","pluck","data","item","push","find","result"],"mappings":"AAAA,IAAIA,IAAJ;AAASC,OAAOC,KAAP,CAAaC,QAAQ,MAAR,CAAb,EAA6B;AAACC,YAAQC,CAAR,EAAU;AAACL,eAAKK,CAAL;AAAO;;AAAnB,CAA7B,EAAkD,CAAlD;AAAqD,IAAIC,yBAAJ;AAA8BL,OAAOC,KAAP,CAAaC,QAAQ,iCAAR,CAAb,EAAwD;AAACC,YAAQC,CAAR,EAAU;AAACC,oCAA0BD,CAA1B;AAA4B;;AAAxC,CAAxD,EAAkG,CAAlG;AAA5FJ,OAAOM,aAAP,CAMe,UAAUC,mBAAV,EAA+BC,gBAA/B,EAAiDC,WAAjD,EAA8D;AACzE,UAAMC,SAASH,oBAAoBG,MAAnC;AACA,UAAMC,mBAAmBD,OAAOC,gBAAhC;AACA,UAAMC,WAAWL,oBAAoBK,QAArC;AACA,UAAMC,SAASH,OAAOG,MAAP,EAAf;AAEA,QAAIC,aAAa,EAAjB;;AAEA,QAAID,UAAUJ,WAAd,EAA2B;AACvB,cAAMM,kBAAkBhB,KAAKU,WAAL,CAAxB;;AACAO,UAAEC,IAAF,CAAOV,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA2CC,gBAAgB;AACvDf,sCAA0Be,YAA1B,EAAwCT,gBAAxC,EAA0DI,eAA1D;AACH,SAFD;AAGH;;AAED,QAAIF,UAAUH,OAAOW,MAAP,EAAd,EAA+B;AAC3B;AAEAL,UAAEC,IAAF,CAAOV,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA2CC,gBAAgB;AACvDA,yBAAaR,QAAb,IAAyBQ,aAAaR,QAAb,KAA0B,EAAnD;;AAEA,kBAAMU,2BAA2BN,EAAEO,MAAF,CAASf,gBAAT,EAA2BgB,mBAAmB;AAC3E,uBAAOR,EAAES,QAAF,CAAWD,gBAAgBE,GAA3B,EAAgCN,aAAaM,GAA7C,CAAP;AACH,aAFgC,CAAjC;;AAIA,gBAAIJ,yBAAyBK,MAA7B,EAAqC;AACjC,sBAAMC,QAAQZ,EAAEa,KAAF,CAAQP,wBAAR,EAAkC,MAAlC,CAAd,CADiC,CACwB;;;AAEzDN,kBAAEC,IAAF,CAAOW,KAAP,EAAcE,QAAQ;AAClBd,sBAAEC,IAAF,CAAOa,IAAP,EAAaC,QAAQ;AACjBX,qCAAaR,QAAb,EAAuBoB,IAAvB,CAA4BD,IAA5B;AACH,qBAFD;AAGH,iBAJD;AAKH;AACJ,SAhBD;;AAkBAf,UAAEC,IAAF,CAAOT,gBAAP,EAAyBgB,mBAAmB;AACxCR,cAAEC,IAAF,CAAOO,gBAAgBM,IAAvB,EAA6BC,QAAQjB,WAAWkB,IAAX,CAAgBD,IAAhB,CAArC;AACH,SAFD;AAGH,KAxBD,MAwBO;AACHf,UAAEC,IAAF,CAAOT,gBAAP,EAAyBgB,mBAAmB;AACxC,gBAAIJ,eAAeJ,EAAEiB,IAAF,CAAO1B,oBAAoBW,MAApB,CAA2BC,OAAlC,EAA4Ce,MAAD,IAAY;AACtE,uBAAOA,OAAOR,GAAP,IAAcF,gBAAgBE,GAArC;AACH,aAFkB,CAAnB;;AAIA,gBAAIN,YAAJ,EAAkB;AACdA,6BAAab,oBAAoBK,QAAjC,IAA6CY,gBAAgBM,IAA7D;AACH;;AAEDd,cAAEC,IAAF,CAAOO,gBAAgBM,IAAvB,EAA6BC,QAAQ;AACjCjB,2BAAWkB,IAAX,CAAgBD,IAAhB;AACH,aAFD;AAGH,SAZD;AAaH;;AAEDxB,wBAAoBY,OAApB,GAA8BL,UAA9B;AACH,CA9DD","file":"packages/cultofcoders:grapher/lib/query/hypernova/assembleAggregateResults.js.map","sourcesContent":["import sift from 'sift';\nimport cleanObjectForMetaFilters from './lib/cleanObjectForMetaFilters';\n\n/**\n * This only applies to inversed links. It will assemble the data in a correct manner.\n */\nexport default function (childCollectionNode, aggregateResults, metaFilters) {\n    const linker = childCollectionNode.linker;\n    const linkStorageField = linker.linkStorageField;\n    const linkName = childCollectionNode.linkName;\n    const isMeta = linker.isMeta();\n\n    let allResults = [];\n\n    if (isMeta && metaFilters) {\n        const metaFiltersTest = sift(metaFilters);\n        _.each(childCollectionNode.parent.results, parentResult => {\n            cleanObjectForMetaFilters(parentResult, linkStorageField, metaFiltersTest);\n        })\n    }\n\n    if (isMeta && linker.isMany()) {\n        // This case is treated differently because we get an array response from the pipeline.\n\n        _.each(childCollectionNode.parent.results, parentResult => {\n            parentResult[linkName] = parentResult[linkName] || [];\n\n            const eligibleAggregateResults = _.filter(aggregateResults, aggregateResult => {\n                return _.contains(aggregateResult._id, parentResult._id)\n            });\n\n            if (eligibleAggregateResults.length) {\n                const datas = _.pluck(eligibleAggregateResults, 'data'); /// [ [x1, x2], [x2, x3] ]\n\n                _.each(datas, data => {\n                    _.each(data, item => {\n                        parentResult[linkName].push(item)\n                    })\n                });\n            }\n        });\n\n        _.each(aggregateResults, aggregateResult => {\n            _.each(aggregateResult.data, item => allResults.push(item))\n        });\n    } else {\n        _.each(aggregateResults, aggregateResult => {\n            let parentResult = _.find(childCollectionNode.parent.results, (result) => {\n                return result._id == aggregateResult._id;\n            });\n\n            if (parentResult) {\n                parentResult[childCollectionNode.linkName] = aggregateResult.data;\n            }\n\n            _.each(aggregateResult.data, item => {\n                allResults.push(item)\n            });\n        });\n    }\n\n    childCollectionNode.results = allResults;\n}"]},"hash":"55f83b4db3e221396d8d808fc1026053ce121263"}
