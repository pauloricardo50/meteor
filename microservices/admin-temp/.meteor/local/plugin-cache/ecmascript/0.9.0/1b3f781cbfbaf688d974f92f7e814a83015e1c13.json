{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"sift","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"sift"}]}],"exports":{"exported":["AggregateFilters"],"specifiers":[{"kind":"local","local":"AggregateFilters","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"aggregateSearchFilters"},"ignored":false,"code":"module.export({\n    default: () => AggregateFilters\n});\nlet sift;\nmodule.watch(require(\"sift\"), {\n    default(v) {\n        sift = v;\n    }\n\n}, 0);\n\nclass AggregateFilters {\n    constructor(collectionNode, metaFilters) {\n        this.collectionNode = collectionNode;\n        this.linker = collectionNode.linker;\n        this.metaFilters = metaFilters;\n        this.isVirtual = this.linker.isVirtual();\n        this.linkStorageField = this.linker.linkStorageField;\n    }\n\n    get parentObjects() {\n        return this.collectionNode.parent.results;\n    }\n\n    create() {\n        switch (this.linker.strategy) {\n            case 'one':\n                return this.createOne();\n\n            case 'one-meta':\n                return this.createOneMeta();\n\n            case 'many':\n                return this.createMany();\n\n            case 'many-meta':\n                return this.createManyMeta();\n\n            default:\n                throw new Meteor.Error(`Invalid linker type: ${this.linker.type}`);\n        }\n    }\n\n    createOne() {\n        if (!this.isVirtual) {\n            return {\n                _id: {\n                    $in: _.uniq(_.pluck(this.parentObjects, this.linkStorageField))\n                }\n            };\n        } else {\n            return {\n                [this.linkStorageField]: {\n                    $in: _.uniq(_.pluck(this.parentObjects, '_id'))\n                }\n            };\n        }\n    }\n\n    createOneMeta() {\n        if (!this.isVirtual) {\n            let eligibleObjects = this.parentObjects;\n\n            if (this.metaFilters) {\n                eligibleObjects = _.filter(this.parentObjects, object => {\n                    return sift(this.metaFilters)(object[this.linkStorageField]);\n                });\n            }\n\n            const storages = _.pluck(eligibleObjects, this.linkStorageField);\n\n            let ids = [];\n\n            _.each(storages, storage => {\n                if (storage) {\n                    ids.push(storage._id);\n                }\n            });\n\n            return {\n                _id: {\n                    $in: _.uniq(ids)\n                }\n            };\n        } else {\n            let filters = {};\n\n            if (this.metaFilters) {\n                _.each(this.metaFilters, (value, key) => {\n                    filters[this.linkStorageField + '.' + key] = value;\n                });\n            }\n\n            filters[this.linkStorageField + '._id'] = {\n                $in: _.uniq(_.pluck(this.parentObjects, '_id'))\n            };\n            return filters;\n        }\n    }\n\n    createMany() {\n        if (!this.isVirtual) {\n            const arrayOfIds = _.pluck(this.parentObjects, this.linkStorageField);\n\n            return {\n                _id: {\n                    $in: _.uniq(_.union(...arrayOfIds))\n                }\n            };\n        } else {\n            const arrayOfIds = _.pluck(this.parentObjects, '_id');\n\n            return {\n                [this.linkStorageField]: {\n                    $in: _.uniq(_.union(...arrayOfIds))\n                }\n            };\n        }\n    }\n\n    createManyMeta() {\n        if (!this.isVirtual) {\n            let ids = [];\n\n            _.each(this.parentObjects, object => {\n                if (object[this.linkStorageField]) {\n                    if (this.metaFilters) {\n                        const isValid = sift(this.metaFilters);\n\n                        _.each(object[this.linkStorageField], object => {\n                            if (isValid(object)) {\n                                ids.push(object._id);\n                            }\n                        });\n                    } else {\n                        _.each(object[this.linkStorageField], object => {\n                            ids.push(object._id);\n                        });\n                    }\n                }\n            });\n\n            return {\n                _id: {\n                    $in: _.uniq(ids)\n                }\n            };\n        } else {\n            let filters = {};\n\n            if (this.metaFilters) {\n                _.each(this.metaFilters, (value, key) => {\n                    filters[key] = value;\n                });\n            }\n\n            filters._id = {\n                $in: _.uniq(_.pluck(this.parentObjects, '_id'))\n            };\n            return {\n                [this.linkStorageField]: {\n                    $elemMatch: filters\n                }\n            };\n        }\n    }\n\n}","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js"],"names":["module","export","default","AggregateFilters","sift","watch","require","v","constructor","collectionNode","metaFilters","linker","isVirtual","linkStorageField","parentObjects","parent","results","create","strategy","createOne","createOneMeta","createMany","createManyMeta","Meteor","Error","type","_id","$in","_","uniq","pluck","eligibleObjects","filter","object","storages","ids","each","storage","push","filters","value","key","arrayOfIds","union","isValid","$elemMatch"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/query/hypernova/aggregateSearchFilters.js.map","sourcesContent":["import sift from 'sift';\n\n/**\n * Its purpose is to create filters to get the related data in one request.\n */\nexport default class AggregateFilters {\n    constructor(collectionNode, metaFilters) {\n        this.collectionNode = collectionNode;\n        this.linker = collectionNode.linker;\n        this.metaFilters = metaFilters;\n        this.isVirtual = this.linker.isVirtual();\n\n        this.linkStorageField = this.linker.linkStorageField;\n    }\n\n    get parentObjects() {\n        return this.collectionNode.parent.results;\n    }\n\n    create() {\n        switch (this.linker.strategy) {\n            case 'one':\n                return this.createOne();\n            case 'one-meta':\n                return this.createOneMeta();\n            case 'many':\n                return this.createMany();\n            case 'many-meta':\n                return this.createManyMeta();\n            default:\n                throw new Meteor.Error(`Invalid linker type: ${this.linker.type}`);\n        }\n    }\n\n    createOne() {\n        if (!this.isVirtual) {\n            return {\n                _id: {\n                    $in: _.uniq(\n                        _.pluck(this.parentObjects, this.linkStorageField)\n                    )\n                }\n            };\n        } else {\n            return {\n                [this.linkStorageField]: {\n                    $in: _.uniq(\n                        _.pluck(this.parentObjects, '_id')\n                    )\n                }\n            };\n        }\n    }\n\n    createOneMeta() {\n        if (!this.isVirtual) {\n            let eligibleObjects = this.parentObjects;\n\n            if (this.metaFilters) {\n                eligibleObjects = _.filter(this.parentObjects, object => {\n                    return sift(this.metaFilters)(object[this.linkStorageField]);\n                });\n            }\n\n            const storages = _.pluck(eligibleObjects, this.linkStorageField);\n            let ids = [];\n            _.each(storages, storage => {\n                if (storage) {\n                    ids.push(storage._id);\n                }\n            });\n\n            return {\n                _id: {$in: _.uniq(ids)}\n            };\n        } else {\n            let filters = {};\n            if (this.metaFilters) {\n                _.each(this.metaFilters, (value, key) => {\n                    filters[this.linkStorageField + '.' + key] = value;\n                })\n            }\n\n            filters[this.linkStorageField + '._id'] = {\n                $in: _.uniq(\n                    _.pluck(this.parentObjects, '_id')\n                )\n            };\n\n            return filters;\n        }\n    }\n\n    createMany() {\n        if (!this.isVirtual) {\n            const arrayOfIds = _.pluck(this.parentObjects, this.linkStorageField);\n            return {\n                _id: {\n                    $in: _.uniq(\n                        _.union(...arrayOfIds)\n                    )\n                }\n            };\n        } else {\n            const arrayOfIds = _.pluck(this.parentObjects, '_id');\n            return {\n                [this.linkStorageField]: {\n                    $in: _.uniq(\n                        _.union(...arrayOfIds)\n                    )\n                }\n            };\n        }\n    }\n\n    createManyMeta() {\n        if (!this.isVirtual) {\n            let ids = [];\n\n            _.each(this.parentObjects, object => {\n                if (object[this.linkStorageField]) {\n                    if (this.metaFilters) {\n                        const isValid = sift(this.metaFilters);\n                        _.each(object[this.linkStorageField], object => {\n                            if (isValid(object)) {\n                                ids.push(object._id);\n                            }\n                        });\n                    } else {\n                        _.each(object[this.linkStorageField], object => {\n                            ids.push(object._id);\n                        });\n                    }\n                }\n            });\n\n            return {\n                _id: {$in: _.uniq(ids)}\n            };\n        } else {\n            let filters = {};\n            if (this.metaFilters) {\n                _.each(this.metaFilters, (value, key) => {\n                    filters[key] = value;\n                })\n            }\n\n            filters._id = {\n                $in: _.uniq(\n                    _.pluck(this.parentObjects, '_id')\n                )\n            };\n\n            return {\n                [this.linkStorageField]: {\n                    $elemMatch: filters\n                }\n            };\n        }\n    }\n}"]},"hash":"1b3f781cbfbaf688d974f92f7e814a83015e1c13"}
