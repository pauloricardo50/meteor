{"metadata":{"usedHelpers":["extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/mongo","imported":["Mongo"],"specifiers":[{"kind":"named","imported":"Mongo","local":"Mongo"}]},{"source":"./constants","imported":["COUNTS_COLLECTION_CLIENT"],"specifiers":[{"kind":"named","imported":"COUNTS_COLLECTION_CLIENT","local":"COUNTS_COLLECTION_CLIENT"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js","filenameRelative":"packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"genEndpoint.server"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n    check(v) {\n        check = v;\n    }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n    Meteor(v) {\n        Meteor = v;\n    }\n\n}, 1);\nlet Mongo;\nmodule.watch(require(\"meteor/mongo\"), {\n    Mongo(v) {\n        Mongo = v;\n    }\n\n}, 2);\nlet COUNTS_COLLECTION_CLIENT;\nmodule.watch(require(\"./constants\"), {\n    COUNTS_COLLECTION_CLIENT(v) {\n        COUNTS_COLLECTION_CLIENT = v;\n    }\n\n}, 3);\n// XXX: Should this persist between server restarts?\nconst collection = new Mongo.Collection(null); /**\n                                                * This method generates a reactive count endpoint (a method and publication) for a collection or named query.\n                                                *\n                                                * @param {String} name - Name of the query or collection\n                                                * @param {Function} getCursor - Takes in the user's session document as an argument, and turns that into a Mongo cursor.\n                                                * @param {Function} getSession - Takes the subscribe method's argument as its parameter. Should enforce any necessary security constraints. The return value of this function is stored in the session document.\n                                                */\nmodule.exportDefault((name, {\n    getCursor,\n    getSession\n}) => {\n    Meteor.methods({\n        [name + '.count.subscribe'](paramsOrBody) {\n            const session = getSession.call(this, paramsOrBody);\n            const existingSession = collection.findOne((0, _extends3.default)({}, session, {\n                userId: this.userId\n            })); // Try to reuse sessions if the user subscribes multiple times with the same data\n\n            if (existingSession) {\n                return existingSession._id;\n            }\n\n            const token = collection.insert((0, _extends3.default)({}, session, {\n                query: name,\n                userId: this.userId\n            }));\n            return token;\n        }\n\n    });\n    Meteor.publish(name + '.count', function (token) {\n        check(token, String);\n        const self = this;\n        const request = collection.findOne({\n            _id: token,\n            userId: self.userId\n        });\n\n        if (!request) {\n            throw new Error('no-request', `You must acquire a request token via the \"${name}.count.subscribe\" method first.`);\n        }\n\n        const cursor = getCursor.call(this, request); // Start counting\n\n        let count = 0;\n        self.added(COUNTS_COLLECTION_CLIENT, token, {\n            count\n        });\n        const handle = cursor.observeChanges({\n            added(id) {\n                count++;\n                self.changed(COUNTS_COLLECTION_CLIENT, token, {\n                    count\n                });\n            },\n\n            removed(id) {\n                count--;\n                self.changed(COUNTS_COLLECTION_CLIENT, token, {\n                    count\n                });\n            }\n\n        });\n        self.onStop(() => {\n            handle.stop();\n            collection.remove(token);\n        });\n        self.ready();\n    });\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js"],"names":["check","module","watch","require","v","Meteor","Mongo","COUNTS_COLLECTION_CLIENT","collection","Collection","exportDefault","name","getCursor","getSession","methods","paramsOrBody","session","call","existingSession","findOne","userId","_id","token","insert","query","publish","String","self","request","Error","cursor","count","added","handle","observeChanges","id","changed","removed","onStop","stop","remove","ready"],"mappings":";;;;;;AAAA,IAAIA,KAAJ;AAAUC,OAAOC,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACH,UAAMI,CAAN,EAAQ;AAACJ,gBAAMI,CAAN;AAAQ;;AAAlB,CAArC,EAAyD,CAAzD;AAA4D,IAAIC,MAAJ;AAAWJ,OAAOC,KAAP,CAAaC,QAAQ,eAAR,CAAb,EAAsC;AAACE,WAAOD,CAAP,EAAS;AAACC,iBAAOD,CAAP;AAAS;;AAApB,CAAtC,EAA4D,CAA5D;AAA+D,IAAIE,KAAJ;AAAUL,OAAOC,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACG,UAAMF,CAAN,EAAQ;AAACE,gBAAMF,CAAN;AAAQ;;AAAlB,CAArC,EAAyD,CAAzD;AAA4D,IAAIG,wBAAJ;AAA6BN,OAAOC,KAAP,CAAaC,QAAQ,aAAR,CAAb,EAAoC;AAACI,6BAAyBH,CAAzB,EAA2B;AAACG,mCAAyBH,CAAzB;AAA2B;;AAAxD,CAApC,EAA8F,CAA9F;AAMnP;AACA,MAAMI,aAAa,IAAIF,MAAMG,UAAV,CAAqB,IAArB,CAAnB,C,CAEA;;;;;;;AATAR,OAAOS,aAAP,CAgBe,CAACC,IAAD,EAAO;AAAEC,aAAF;AAAaC;AAAb,CAAP,KAAqC;AAChDR,WAAOS,OAAP,CAAe;AACX,SAACH,OAAO,kBAAR,EAA4BI,YAA5B,EAA0C;AACtC,kBAAMC,UAAUH,WAAWI,IAAX,CAAgB,IAAhB,EAAsBF,YAAtB,CAAhB;AACA,kBAAMG,kBAAkBV,WAAWW,OAAX,4BAAwBH,OAAxB;AAAiCI,wBAAQ,KAAKA;AAA9C,eAAxB,CAFsC,CAItC;;AACA,gBAAIF,eAAJ,EAAqB;AACjB,uBAAOA,gBAAgBG,GAAvB;AACH;;AAED,kBAAMC,QAAQd,WAAWe,MAAX,4BACPP,OADO;AAEVQ,uBAAOb,IAFG;AAGVS,wBAAQ,KAAKA;AAHH,eAAd;AAMA,mBAAOE,KAAP;AACH;;AAjBU,KAAf;AAoBAjB,WAAOoB,OAAP,CAAed,OAAO,QAAtB,EAAgC,UAASW,KAAT,EAAgB;AAC5CtB,cAAMsB,KAAN,EAAaI,MAAb;AACA,cAAMC,OAAO,IAAb;AACA,cAAMC,UAAUpB,WAAWW,OAAX,CAAmB;AAAEE,iBAAKC,KAAP;AAAcF,oBAAQO,KAAKP;AAA3B,SAAnB,CAAhB;;AAEA,YAAI,CAACQ,OAAL,EAAc;AACV,kBAAM,IAAIC,KAAJ,CAAU,YAAV,EAAyB,6CAA4ClB,IAAK,iCAA1E,CAAN;AACH;;AAED,cAAMmB,SAASlB,UAAUK,IAAV,CAAe,IAAf,EAAqBW,OAArB,CAAf,CAT4C,CAW5C;;AACA,YAAIG,QAAQ,CAAZ;AACAJ,aAAKK,KAAL,CAAWzB,wBAAX,EAAqCe,KAArC,EAA4C;AAAES;AAAF,SAA5C;AACA,cAAME,SAASH,OAAOI,cAAP,CAAsB;AACjCF,kBAAMG,EAAN,EAAU;AACNJ;AACAJ,qBAAKS,OAAL,CAAa7B,wBAAb,EAAuCe,KAAvC,EAA8C;AAAES;AAAF,iBAA9C;AACH,aAJgC;;AAMjCM,oBAAQF,EAAR,EAAY;AACRJ;AACAJ,qBAAKS,OAAL,CAAa7B,wBAAb,EAAuCe,KAAvC,EAA8C;AAAES;AAAF,iBAA9C;AACH;;AATgC,SAAtB,CAAf;AAYAJ,aAAKW,MAAL,CAAY,MAAM;AACdL,mBAAOM,IAAP;AACA/B,uBAAWgC,MAAX,CAAkBlB,KAAlB;AACH,SAHD;AAIAK,aAAKc,KAAL;AACH,KA/BD;AAgCH,CArED","file":"packages/cultofcoders:grapher/lib/query/counts/genEndpoint.server.js.map","sourcesContent":["import { check } from 'meteor/check';\nimport { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\n\nimport { COUNTS_COLLECTION_CLIENT } from './constants';\n\n// XXX: Should this persist between server restarts?\nconst collection = new Mongo.Collection(null);\n\n/**\n * This method generates a reactive count endpoint (a method and publication) for a collection or named query.\n *\n * @param {String} name - Name of the query or collection\n * @param {Function} getCursor - Takes in the user's session document as an argument, and turns that into a Mongo cursor.\n * @param {Function} getSession - Takes the subscribe method's argument as its parameter. Should enforce any necessary security constraints. The return value of this function is stored in the session document.\n */\nexport default (name, { getCursor, getSession }) => {\n    Meteor.methods({\n        [name + '.count.subscribe'](paramsOrBody) {\n            const session = getSession.call(this, paramsOrBody);\n            const existingSession = collection.findOne({ ...session, userId: this.userId });\n\n            // Try to reuse sessions if the user subscribes multiple times with the same data\n            if (existingSession) {\n                return existingSession._id;\n            }\n\n            const token = collection.insert({\n                ...session,\n                query: name,\n                userId: this.userId,\n            });\n\n            return token;\n        },\n    });\n\n    Meteor.publish(name + '.count', function(token) {\n        check(token, String);\n        const self = this;\n        const request = collection.findOne({ _id: token, userId: self.userId });\n\n        if (!request) {\n            throw new Error('no-request', `You must acquire a request token via the \"${name}.count.subscribe\" method first.`);\n        }\n\n        const cursor = getCursor.call(this, request);\n\n        // Start counting\n        let count = 0;\n        self.added(COUNTS_COLLECTION_CLIENT, token, { count });\n        const handle = cursor.observeChanges({\n            added(id) {\n                count++;\n                self.changed(COUNTS_COLLECTION_CLIENT, token, { count });\n            },\n\n            removed(id) {\n                count--;\n                self.changed(COUNTS_COLLECTION_CLIENT, token, { count });\n            },\n        });\n\n        self.onStop(() => {\n            handle.stop();\n            collection.remove(token);\n        });\n        self.ready();\n    });\n};\n"]},"hash":"e04c2ec73a4fa3fce82261f92f0ea1b536773161"}
