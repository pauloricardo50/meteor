{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"../query/counts/genEndpoint.server.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"genCountEndpoint"}]},{"source":"../query/lib/createGraph.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createGraph"}]},{"source":"../query/lib/recursiveCompose.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"recursiveCompose"}]},{"source":"../query/hypernova/hypernova.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"hypernova"}]},{"source":"./exposure.config.schema.js","imported":["ExposureSchema","ExposureDefaults","validateBody"],"specifiers":[{"kind":"named","imported":"ExposureSchema","local":"ExposureSchema"},{"kind":"named","imported":"ExposureDefaults","local":"ExposureDefaults"},{"kind":"named","imported":"validateBody","local":"validateBody"}]},{"source":"./lib/enforceMaxDepth.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxDepth"}]},{"source":"./lib/enforceMaxLimit.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"enforceMaxLimit"}]},{"source":"./lib/cleanBody.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cleanBody"}]},{"source":"lodash.clonedeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"deepClone"}]},{"source":"./lib/restrictFields.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"restrictFieldsFn"}]},{"source":"./lib/restrictLinks.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"restrictLinks"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]}],"exports":{"exported":["Exposure"],"specifiers":[{"kind":"local","local":"Exposure","exported":"default"}]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/exposure/exposure.js","filenameRelative":"packages/cultofcoders:grapher/lib/exposure/exposure.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/exposure/exposure.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/exposure/exposure.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"exposure"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n    \"default\": function () {\n        return Exposure;\n    }\n});\nvar genCountEndpoint = void 0;\nmodule.watch(require(\"../query/counts/genEndpoint.server.js\"), {\n    \"default\": function (v) {\n        genCountEndpoint = v;\n    }\n}, 0);\nvar createGraph = void 0;\nmodule.watch(require(\"../query/lib/createGraph.js\"), {\n    \"default\": function (v) {\n        createGraph = v;\n    }\n}, 1);\nvar recursiveCompose = void 0;\nmodule.watch(require(\"../query/lib/recursiveCompose.js\"), {\n    \"default\": function (v) {\n        recursiveCompose = v;\n    }\n}, 2);\nvar hypernova = void 0;\nmodule.watch(require(\"../query/hypernova/hypernova.js\"), {\n    \"default\": function (v) {\n        hypernova = v;\n    }\n}, 3);\nvar ExposureSchema = void 0,\n    ExposureDefaults = void 0,\n    validateBody = void 0;\nmodule.watch(require(\"./exposure.config.schema.js\"), {\n    ExposureSchema: function (v) {\n        ExposureSchema = v;\n    },\n    ExposureDefaults: function (v) {\n        ExposureDefaults = v;\n    },\n    validateBody: function (v) {\n        validateBody = v;\n    }\n}, 4);\nvar enforceMaxDepth = void 0;\nmodule.watch(require(\"./lib/enforceMaxDepth.js\"), {\n    \"default\": function (v) {\n        enforceMaxDepth = v;\n    }\n}, 5);\nvar enforceMaxLimit = void 0;\nmodule.watch(require(\"./lib/enforceMaxLimit.js\"), {\n    \"default\": function (v) {\n        enforceMaxLimit = v;\n    }\n}, 6);\nvar cleanBody = void 0;\nmodule.watch(require(\"./lib/cleanBody.js\"), {\n    \"default\": function (v) {\n        cleanBody = v;\n    }\n}, 7);\nvar deepClone = void 0;\nmodule.watch(require(\"lodash.clonedeep\"), {\n    \"default\": function (v) {\n        deepClone = v;\n    }\n}, 8);\nvar restrictFieldsFn = void 0;\nmodule.watch(require(\"./lib/restrictFields.js\"), {\n    \"default\": function (v) {\n        restrictFieldsFn = v;\n    }\n}, 9);\nvar restrictLinks = void 0;\nmodule.watch(require(\"./lib/restrictLinks.js\"), {\n    \"default\": function (v) {\n        restrictLinks = v;\n    }\n}, 10);\nvar check = void 0;\nmodule.watch(require(\"meteor/check\"), {\n    check: function (v) {\n        check = v;\n    }\n}, 11);\nvar globalConfig = {};\n\nvar Exposure = function () {\n    Exposure.setConfig = function () {\n        function setConfig(config) {\n            Object.assign(globalConfig, config);\n        }\n\n        return setConfig;\n    }();\n\n    Exposure.getConfig = function () {\n        function getConfig() {\n            return globalConfig;\n        }\n\n        return getConfig;\n    }();\n\n    Exposure.restrictFields = function () {\n        function restrictFields() {\n            return restrictFieldsFn.apply(undefined, arguments);\n        }\n\n        return restrictFields;\n    }();\n\n    function Exposure(collection) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        (0, _classCallCheck3.default)(this, Exposure);\n        collection.__isExposedForGrapher = true;\n        collection.__exposure = this;\n        this.collection = collection;\n        this.name = \"exposure_\" + collection._name;\n        this.config = config;\n\n        this._validateAndClean();\n\n        this.initSecurity();\n\n        if (this.config.publication) {\n            this.initPublication();\n        }\n\n        if (this.config.method) {\n            this.initMethod();\n        }\n\n        if (!this.config.method && !this.config.publication) {\n            throw new Meteor.Error('weird', 'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true');\n        }\n\n        this.initCountMethod();\n        this.initCountPublication();\n    }\n\n    Exposure.prototype._validateAndClean = function () {\n        function _validateAndClean() {\n            if (typeof this.config === 'function') {\n                var firewall = this.config;\n                this.config = {\n                    firewall: firewall\n                };\n            }\n\n            this.config = Object.assign({}, ExposureDefaults, Exposure.getConfig(), this.config);\n            check(this.config, ExposureSchema);\n\n            if (this.config.body) {\n                validateBody(this.collection, this.config.body);\n            }\n        }\n\n        return _validateAndClean;\n    }(); /**\n          * Takes the body and intersects it with the exposure body, if it exists.\n          *\n          * @param body\n          * @param userId\n          * @returns {*}\n          */\n\n    Exposure.prototype.getTransformedBody = function () {\n        function getTransformedBody(body, userId) {\n            if (!this.config.body) {\n                return body;\n            }\n\n            var processedBody = this.getBody(userId);\n\n            if (processedBody === true) {\n                return;\n            }\n\n            return cleanBody(processedBody, body);\n        }\n\n        return getTransformedBody;\n    }(); /**\n          * Gets the exposure body\n          */\n\n    Exposure.prototype.getBody = function () {\n        function getBody(userId) {\n            if (!this.config.body) {\n                throw new Meteor.Error('missing-body', 'Cannot get exposure body because it was not defined.');\n            }\n\n            var body = void 0;\n\n            if (_.isFunction(this.config.body)) {\n                body = this.config.body.call(this, userId);\n            } else {\n                body = this.config.body;\n            } // it means we allow everything, no need for cloning.\n\n\n            if (body === true) {\n                return true;\n            }\n\n            return deepClone(body, userId);\n        }\n\n        return getBody;\n    }(); /**\n          * Initializing the publication for reactive query fetching\n          */\n\n    Exposure.prototype.initPublication = function () {\n        function initPublication() {\n            var collection = this.collection;\n            var config = this.config;\n            var getTransformedBody = this.getTransformedBody.bind(this);\n            Meteor.publishComposite(this.name, function (body) {\n                var transformedBody = getTransformedBody(body);\n                var rootNode = createGraph(collection, transformedBody);\n                enforceMaxDepth(rootNode, config.maxDepth);\n                restrictLinks(rootNode, this.userId);\n                return recursiveCompose(rootNode, this.userId, {\n                    bypassFirewalls: !!config.body\n                });\n            });\n        }\n\n        return initPublication;\n    }(); /**\n          * Initializez the method to retrieve the data via Meteor.call\n          */\n\n    Exposure.prototype.initMethod = function () {\n        function initMethod() {\n            var _Meteor$methods;\n\n            var collection = this.collection;\n            var config = this.config;\n            var getTransformedBody = this.getTransformedBody.bind(this);\n\n            var methodBody = function (body) {\n                if (!config.blocking) {\n                    this.unblock();\n                }\n\n                var transformedBody = getTransformedBody(body);\n                var rootNode = createGraph(collection, transformedBody);\n                enforceMaxDepth(rootNode, config.maxDepth);\n                restrictLinks(rootNode, this.userId); // if there is no exposure body defined, then we need to apply firewalls\n\n                return hypernova(rootNode, this.userId, {\n                    bypassFirewalls: !!config.body\n                });\n            };\n\n            Meteor.methods((_Meteor$methods = {}, _Meteor$methods[this.name] = methodBody, _Meteor$methods));\n        }\n\n        return initMethod;\n    }(); /**\n          * Initializes the method to retrieve the count of the data via Meteor.call\n          * @returns {*}\n          */\n\n    Exposure.prototype.initCountMethod = function () {\n        function initCountMethod() {\n            var _Meteor$methods2;\n\n            var collection = this.collection;\n            Meteor.methods((_Meteor$methods2 = {}, _Meteor$methods2[this.name + '.count'] = function (body) {\n                this.unblock();\n                return collection.find(body.$filters || {}, {}, this.userId).count();\n            }, _Meteor$methods2));\n        }\n\n        return initCountMethod;\n    }(); /**\n          * Initializes the reactive endpoint to retrieve the count of the data.\n          */\n\n    Exposure.prototype.initCountPublication = function () {\n        function initCountPublication() {\n            var collection = this.collection;\n            genCountEndpoint(this.name, {\n                getCursor: function (session) {\n                    return collection.find(session.filters, {\n                        fields: {\n                            _id: 1\n                        }\n                    }, this.userId);\n                },\n                getSession: function (body) {\n                    return {\n                        filters: body.$filters || {}\n                    };\n                }\n            });\n        }\n\n        return initCountPublication;\n    }(); /**\n          * Initializes security enforcement\n          * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n          */\n\n    Exposure.prototype.initSecurity = function () {\n        function initSecurity() {\n            var _this = this;\n\n            var collection = this.collection;\n            var _config = this.config,\n                firewall = _config.firewall,\n                maxLimit = _config.maxLimit,\n                restrictedFields = _config.restrictedFields;\n            var find = collection.find.bind(collection);\n            var findOne = collection.findOne.bind(collection);\n\n            collection.firewall = function (filters, options, userId) {\n                if (userId !== undefined) {\n                    _this._callFirewall({\n                        collection: collection\n                    }, filters, options, userId);\n\n                    enforceMaxLimit(options, maxLimit);\n\n                    if (restrictedFields) {\n                        Exposure.restrictFields(filters, options, restrictedFields);\n                    }\n                }\n            };\n\n            collection.find = function (filters) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var userId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n                if (arguments.length == 0) {\n                    filters = {};\n                } // If filters is undefined it should return an empty item\n\n\n                if (arguments.length > 0 && filters === undefined) {\n                    return find(undefined, options);\n                }\n\n                collection.firewall(filters, options, userId);\n                return find(filters, options);\n            };\n\n            collection.findOne = function (filters) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var userId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n                // If filters is undefined it should return an empty item\n                if (arguments.length > 0 && filters === undefined) {\n                    return null;\n                }\n\n                if (typeof filters === 'string') {\n                    filters = {\n                        _id: filters\n                    };\n                }\n\n                collection.firewall(filters, options, userId);\n                return findOne(filters, options);\n            };\n        }\n\n        return initSecurity;\n    }(); /**\n          * @private\n          */\n\n    Exposure.prototype._callFirewall = function () {\n        function _callFirewall() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var firewall = this.config.firewall;\n\n            if (!firewall) {\n                return;\n            }\n\n            if (_.isArray(firewall)) {\n                firewall.forEach(function (fire) {\n                    fire.call.apply(fire, args);\n                });\n            } else {\n                firewall.call.apply(firewall, args);\n            }\n        }\n\n        return _callFirewall;\n    }();\n\n    return Exposure;\n}();\n\n;","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/exposure/exposure.js"],"names":["module","export","Exposure","genCountEndpoint","watch","require","v","createGraph","recursiveCompose","hypernova","ExposureSchema","ExposureDefaults","validateBody","enforceMaxDepth","enforceMaxLimit","cleanBody","deepClone","restrictFieldsFn","restrictLinks","check","globalConfig","setConfig","config","Object","assign","getConfig","restrictFields","collection","__isExposedForGrapher","__exposure","name","_name","_validateAndClean","initSecurity","publication","initPublication","method","initMethod","Meteor","Error","initCountMethod","initCountPublication","firewall","body","getTransformedBody","userId","processedBody","getBody","_","isFunction","call","bind","publishComposite","transformedBody","rootNode","maxDepth","bypassFirewalls","methodBody","blocking","unblock","methods","find","$filters","count","getCursor","session","filters","fields","_id","getSession","maxLimit","restrictedFields","findOne","options","undefined","_callFirewall","arguments","length","args","isArray","forEach","fire"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/exposure/exposure.js.map","sourcesContent":["import genCountEndpoint from '../query/counts/genEndpoint.server.js';\nimport createGraph from '../query/lib/createGraph.js';\nimport recursiveCompose from '../query/lib/recursiveCompose.js';\nimport hypernova from '../query/hypernova/hypernova.js';\nimport {ExposureSchema, ExposureDefaults, validateBody} from './exposure.config.schema.js';\nimport enforceMaxDepth from './lib/enforceMaxDepth.js';\nimport enforceMaxLimit from './lib/enforceMaxLimit.js';\nimport cleanBody from './lib/cleanBody.js';\nimport deepClone from 'lodash.clonedeep';\nimport restrictFieldsFn from './lib/restrictFields.js';\nimport restrictLinks from './lib/restrictLinks.js';\nimport {check} from 'meteor/check';\n\nlet globalConfig = {};\n\nexport default class Exposure {\n    static setConfig(config) {\n        Object.assign(globalConfig, config);\n    }\n\n    static getConfig() {\n        return globalConfig;\n    }\n\n    static restrictFields(...args) {\n        return restrictFieldsFn(...args);\n    }\n\n    constructor(collection, config = {}) {\n        collection.__isExposedForGrapher = true;\n        collection.__exposure = this;\n\n        this.collection = collection;\n        this.name = `exposure_${collection._name}`;\n\n        this.config = config;\n        this._validateAndClean();\n\n        this.initSecurity();\n\n        if (this.config.publication) {\n            this.initPublication();\n        }\n\n        if (this.config.method) {\n            this.initMethod();\n        }\n\n        if (!this.config.method && !this.config.publication) {\n            throw new Meteor.Error('weird', 'If you want to expose your collection you need to specify at least one of [\"method\", \"publication\"] options to true')\n        }\n\n        this.initCountMethod();\n        this.initCountPublication();\n    }\n\n    _validateAndClean() {\n        if (typeof(this.config) === 'function') {\n            const firewall = this.config;\n            this.config = {firewall};\n        }\n\n        this.config = Object.assign({}, ExposureDefaults, Exposure.getConfig(), this.config);\n        check(this.config, ExposureSchema);\n\n        if (this.config.body) {\n            validateBody(this.collection, this.config.body);\n        }\n    }\n\n    /**\n     * Takes the body and intersects it with the exposure body, if it exists.\n     *\n     * @param body\n     * @param userId\n     * @returns {*}\n     */\n    getTransformedBody(body, userId) {\n        if (!this.config.body) {\n            return body;\n        }\n\n        const processedBody = this.getBody(userId);\n\n        if (processedBody === true) {\n            return;\n        }\n\n        return cleanBody(processedBody, body);\n    }\n\n    /**\n     * Gets the exposure body\n     */\n    getBody(userId) {\n        if (!this.config.body) {\n            throw new Meteor.Error('missing-body', 'Cannot get exposure body because it was not defined.');\n        }\n\n        let body;\n        if (_.isFunction(this.config.body)) {\n            body = this.config.body.call(this, userId);\n        } else {\n            body = this.config.body;\n        }\n\n        // it means we allow everything, no need for cloning.\n        if (body === true) {\n            return true;\n        }\n\n        return deepClone(\n            body,\n            userId\n        );\n    }\n\n    /**\n     * Initializing the publication for reactive query fetching\n     */\n    initPublication() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        Meteor.publishComposite(this.name, function (body) {\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            return recursiveCompose(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        });\n    }\n\n    /**\n     * Initializez the method to retrieve the data via Meteor.call\n     */\n    initMethod() {\n        const collection = this.collection;\n        const config = this.config;\n        const getTransformedBody = this.getTransformedBody.bind(this);\n\n        const methodBody = function(body) {\n            if (!config.blocking) {\n                this.unblock();\n            }\n\n            let transformedBody = getTransformedBody(body);\n\n            const rootNode = createGraph(collection, transformedBody);\n\n            enforceMaxDepth(rootNode, config.maxDepth);\n            restrictLinks(rootNode, this.userId);\n\n            // if there is no exposure body defined, then we need to apply firewalls\n            return hypernova(rootNode, this.userId, {\n                bypassFirewalls: !!config.body\n            });\n        };\n\n        Meteor.methods({\n            [this.name]: methodBody\n        });\n    }\n\n    /**\n     * Initializes the method to retrieve the count of the data via Meteor.call\n     * @returns {*}\n     */\n    initCountMethod() {\n        const collection = this.collection;\n\n        Meteor.methods({\n            [this.name + '.count'](body) {\n                this.unblock();\n\n                return collection.find(body.$filters || {}, {}, this.userId).count();\n            }\n        })\n    }\n\n    /**\n     * Initializes the reactive endpoint to retrieve the count of the data.\n     */\n    initCountPublication() {\n        const collection = this.collection;\n\n        genCountEndpoint(this.name, {\n            getCursor(session) {\n                return collection.find(session.filters, {\n                    fields: {_id: 1},\n                }, this.userId);\n            },\n\n            getSession(body) {\n                return { filters: body.$filters || {} };\n            },\n        });\n    }\n\n    /**\n     * Initializes security enforcement\n     * THINK: Maybe instead of overriding .find, I could store this data of security inside the collection object.\n     */\n    initSecurity() {\n        const collection = this.collection;\n        const {firewall, maxLimit, restrictedFields} = this.config;\n        const find = collection.find.bind(collection);\n        const findOne = collection.findOne.bind(collection);\n\n        collection.firewall = (filters, options, userId) => {\n            if (userId !== undefined) {\n                this._callFirewall({collection: collection}, filters, options, userId);\n\n                enforceMaxLimit(options, maxLimit);\n\n                if (restrictedFields) {\n                    Exposure.restrictFields(filters, options, restrictedFields);\n                }\n            }\n        };\n\n        collection.find = function (filters, options = {}, userId = undefined) {\n            if (arguments.length == 0) {\n                filters = {};\n            }\n\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return find(undefined, options);\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return find(filters, options);\n        };\n\n        collection.findOne = function (filters, options = {}, userId = undefined) {\n            // If filters is undefined it should return an empty item\n            if (arguments.length > 0 && filters === undefined) {\n                return null;\n            }\n\n            if (typeof(filters) === 'string') {\n                filters = {_id: filters};\n            }\n\n            collection.firewall(filters, options, userId);\n\n            return findOne(filters, options);\n        }\n    }\n\n    /**\n     * @private\n     */\n    _callFirewall(...args) {\n        const {firewall} = this.config;\n        if (!firewall) {\n            return;\n        }\n\n        if (_.isArray(firewall)) {\n            firewall.forEach(fire => {\n                fire.call(...args);\n            })\n        } else {\n            firewall.call(...args);\n        }\n    }\n};\n"]},"hash":"62f018c6a88e39c41f559b2c7760a86e0e4ceb10"}
