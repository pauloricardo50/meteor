{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../query/counts/countSubscription","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"CountSubscription"}]},{"source":"../query/lib/createGraph.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createGraph"}]},{"source":"../query/lib/recursiveFetch.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"recursiveFetch"}]},{"source":"../query/lib/prepareForProcess.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"prepareForProcess"}]},{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"../query/lib/callWithPromise","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"callWithPromise"}]},{"source":"./namedQuery.base","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Base"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js","filenameRelative":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js.map","sourceFileName":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"namedQuery.client"},"ignored":false,"code":"let CountSubscription;\nmodule.watch(require(\"../query/counts/countSubscription\"), {\n    default(v) {\n        CountSubscription = v;\n    }\n\n}, 0);\nlet createGraph;\nmodule.watch(require(\"../query/lib/createGraph.js\"), {\n    default(v) {\n        createGraph = v;\n    }\n\n}, 1);\nlet recursiveFetch;\nmodule.watch(require(\"../query/lib/recursiveFetch.js\"), {\n    default(v) {\n        recursiveFetch = v;\n    }\n\n}, 2);\nlet prepareForProcess;\nmodule.watch(require(\"../query/lib/prepareForProcess.js\"), {\n    default(v) {\n        prepareForProcess = v;\n    }\n\n}, 3);\n\nlet _;\n\nmodule.watch(require(\"meteor/underscore\"), {\n    _(v) {\n        _ = v;\n    }\n\n}, 4);\nlet callWithPromise;\nmodule.watch(require(\"../query/lib/callWithPromise\"), {\n    default(v) {\n        callWithPromise = v;\n    }\n\n}, 5);\nlet Base;\nmodule.watch(require(\"./namedQuery.base\"), {\n    default(v) {\n        Base = v;\n    }\n\n}, 6);\nmodule.exportDefault(class extends Base {\n    /**\n     * Subscribe\n     *\n     * @param callback\n     * @returns {null|any|*}\n     */subscribe(callback) {\n        if (this.isResolver) {\n            throw new Meteor.Error('not-allowed', `You cannot subscribe to a resolver query`);\n        }\n\n        this.subscriptionHandle = Meteor.subscribe(this.name, this.params, callback);\n        return this.subscriptionHandle;\n    } /**\n       * Subscribe to the counts for this query\n       *\n       * @param callback\n       * @returns {Object}\n       */\n\n    subscribeCount(callback) {\n        if (this.isResolver) {\n            throw new Meteor.Error('not-allowed', `You cannot subscribe to a resolver query`);\n        }\n\n        if (!this._counter) {\n            this._counter = new CountSubscription(this);\n        }\n\n        return this._counter.subscribe(this.params, callback);\n    } /**\n       * Unsubscribe if an existing subscription exists\n       */\n\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.subscriptionHandle.stop();\n        }\n\n        this.subscriptionHandle = null;\n    } /**\n       * Unsubscribe to the counts if a subscription exists.\n       */\n\n    unsubscribeCount() {\n        if (this._counter) {\n            this._counter.unsubscribe();\n\n            this._counter = null;\n        }\n    } /**\n       * Fetches elements in sync using promises\n       * @return {*}\n       */\n\n    fetchSync() {\n        return Promise.asyncApply(() => {\n            if (this.subscriptionHandle) {\n                throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n            }\n\n            return Promise.await(callWithPromise(this.name, prepareForProcess(this.body, this.params)));\n        });\n    } /**\n       * Fetches one element in sync\n       * @return {*}\n       */\n\n    fetchOneSync() {\n        return Promise.asyncApply(() => {\n            return _.first(Promise.await(this.fetchSync()));\n        });\n    } /**\n       * Retrieves the data.\n       * @param callbackOrOptions\n       * @returns {*}\n       */\n\n    fetch(callbackOrOptions) {\n        if (!this.subscriptionHandle) {\n            return this._fetchStatic(callbackOrOptions);\n        } else {\n            return this._fetchReactive(callbackOrOptions);\n        }\n    } /**\n       * @param args\n       * @returns {*}\n       */\n\n    fetchOne(...args) {\n        if (!this.subscriptionHandle) {\n            const callback = args[0];\n\n            if (!_.isFunction(callback)) {\n                throw new Meteor.Error('You did not provide a valid callback');\n            }\n\n            this.fetch((err, res) => {\n                callback(err, res ? _.first(res) : null);\n            });\n        } else {\n            return _.first(this.fetch(...args));\n        }\n    } /**\n       * Gets the count of matching elements in sync.\n       * @returns {any}\n       */\n\n    getCountSync() {\n        return Promise.asyncApply(() => {\n            if (this._counter) {\n                throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n            }\n\n            return Promise.await(callWithPromise(this.name + '.count', prepareForProcess(this.body, this.params)));\n        });\n    } /**\n       * Gets the count of matching elements.\n       * @param callback\n       * @returns {any}\n       */\n\n    getCount(callback) {\n        if (this._counter) {\n            return this._counter.getCount();\n        } else {\n            if (!callback) {\n                throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the count or subscribe first.');\n            } else {\n                return Meteor.call(this.name + '.count', this.params, callback);\n            }\n        }\n    } /**\n       * Fetching non-reactive queries\n       * @param callback\n       * @private\n       */\n\n    _fetchStatic(callback) {\n        if (!callback) {\n            throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the data or subscribe first.');\n        }\n\n        Meteor.call(this.name, this.params, callback);\n    } /**\n       * Fetching when we've got an active publication\n       *\n       * @param options\n       * @returns {*}\n       * @private\n       */\n\n    _fetchReactive(options = {}) {\n        let body = this.body;\n\n        if (this.params.$body) {\n            body = intersectDeep(body, this.params.$body);\n        }\n\n        body = prepareForProcess(body, this.params);\n\n        if (!options.allowSkip && body.$options && body.$options.skip) {\n            delete body.$options.skip;\n        }\n\n        return recursiveFetch(createGraph(this.collection, body));\n    }\n\n});","map":{"version":3,"sources":["packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js"],"names":["CountSubscription","module","watch","require","default","v","createGraph","recursiveFetch","prepareForProcess","_","callWithPromise","Base","exportDefault","subscribe","callback","isResolver","Meteor","Error","subscriptionHandle","name","params","subscribeCount","_counter","unsubscribe","stop","unsubscribeCount","fetchSync","body","fetchOneSync","first","fetch","callbackOrOptions","_fetchStatic","_fetchReactive","fetchOne","args","isFunction","err","res","getCountSync","getCount","call","options","$body","intersectDeep","allowSkip","$options","skip","collection"],"mappings":"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","file":"packages/cultofcoders:grapher/lib/namedQuery/namedQuery.client.js.map","sourcesContent":["import CountSubscription from '../query/counts/countSubscription';\nimport createGraph from '../query/lib/createGraph.js';\nimport recursiveFetch from '../query/lib/recursiveFetch.js';\nimport prepareForProcess from '../query/lib/prepareForProcess.js';\nimport { _ } from 'meteor/underscore';\nimport callWithPromise from '../query/lib/callWithPromise';\nimport Base from './namedQuery.base';\n\nexport default class extends Base {\n    /**\n     * Subscribe\n     *\n     * @param callback\n     * @returns {null|any|*}\n     */\n    subscribe(callback) {\n        if (this.isResolver) {\n            throw new Meteor.Error('not-allowed', `You cannot subscribe to a resolver query`);\n        }\n\n        this.subscriptionHandle = Meteor.subscribe(\n            this.name,\n            this.params,\n            callback\n        );\n\n        return this.subscriptionHandle;\n    }\n\n    /**\n     * Subscribe to the counts for this query\n     *\n     * @param callback\n     * @returns {Object}\n     */\n    subscribeCount(callback) {\n        if (this.isResolver) {\n            throw new Meteor.Error('not-allowed', `You cannot subscribe to a resolver query`);\n        }\n\n        if (!this._counter) {\n            this._counter = new CountSubscription(this);\n        }\n\n        return this._counter.subscribe(this.params, callback);\n    }\n\n    /**\n     * Unsubscribe if an existing subscription exists\n     */\n    unsubscribe() {\n        if (this.subscriptionHandle) {\n            this.subscriptionHandle.stop();\n        }\n\n        this.subscriptionHandle = null;\n    }\n\n    /**\n     * Unsubscribe to the counts if a subscription exists.\n     */\n    unsubscribeCount() {\n        if (this._counter) {\n            this._counter.unsubscribe();\n            this._counter = null;\n        }\n    }\n\n    /**\n     * Fetches elements in sync using promises\n     * @return {*}\n     */\n    async fetchSync() {\n        if (this.subscriptionHandle) {\n            throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n        }\n\n        return await callWithPromise(this.name, prepareForProcess(this.body, this.params));\n    }\n\n    /**\n     * Fetches one element in sync\n     * @return {*}\n     */\n    async fetchOneSync() {\n        return _.first(await this.fetchSync())\n    }\n\n    /**\n     * Retrieves the data.\n     * @param callbackOrOptions\n     * @returns {*}\n     */\n    fetch(callbackOrOptions) {\n        if (!this.subscriptionHandle) {\n            return this._fetchStatic(callbackOrOptions)\n        } else {\n            return this._fetchReactive(callbackOrOptions);\n        }\n    }\n\n    /**\n     * @param args\n     * @returns {*}\n     */\n    fetchOne(...args) {\n        if (!this.subscriptionHandle) {\n            const callback = args[0];\n            if (!_.isFunction(callback)) {\n                throw new Meteor.Error('You did not provide a valid callback');\n            }\n\n            this.fetch((err, res) => {\n                callback(err, res ? _.first(res) : null);\n            })\n        } else {\n            return _.first(this.fetch(...args));\n        }\n    }\n\n    /**\n     * Gets the count of matching elements in sync.\n     * @returns {any}\n     */\n    async getCountSync() {\n        if (this._counter) {\n            throw new Meteor.Error('This query is reactive, meaning you cannot use promises to fetch the data.');\n        }\n\n        return await callWithPromise(this.name + '.count', prepareForProcess(this.body, this.params));\n    }\n\n    /**\n     * Gets the count of matching elements.\n     * @param callback\n     * @returns {any}\n     */\n    getCount(callback) {\n        if (this._counter) {\n            return this._counter.getCount();\n        } else {\n            if (!callback) {\n                throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the count or subscribe first.');\n            } else {\n                return Meteor.call(this.name + '.count', this.params, callback);\n            }\n        }\n    }\n\n    /**\n     * Fetching non-reactive queries\n     * @param callback\n     * @private\n     */\n    _fetchStatic(callback) {\n        if (!callback) {\n            throw new Meteor.Error('not-allowed', 'You are on client so you must either provide a callback to get the data or subscribe first.');\n        }\n\n        Meteor.call(this.name, this.params, callback);\n    }\n\n    /**\n     * Fetching when we've got an active publication\n     *\n     * @param options\n     * @returns {*}\n     * @private\n     */\n    _fetchReactive(options = {}) {\n        let body = this.body;\n        if (this.params.$body) {\n            body = intersectDeep(body, this.params.$body);\n        }\n\n        body = prepareForProcess(body, this.params);\n        if (!options.allowSkip && body.$options && body.$options.skip) {\n            delete body.$options.skip;\n        }\n\n        return recursiveFetch(\n            createGraph(this.collection, body)\n        );\n    }\n}\n"]},"hash":"c6d736719adf7c987342141af46819dd8e51c63d"}
