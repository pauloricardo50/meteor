{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../api/constants","imported":["USAGE_TYPE"],"specifiers":[{"kind":"named","imported":"USAGE_TYPE","local":"USAGE_TYPE"}]}],"exports":{"exported":["fortuneLimitedProperty","incomeLimitedProperty","calculatePrimaryProperty"],"specifiers":[{"kind":"local","local":"fortuneLimitedProperty","exported":"fortuneLimitedProperty"},{"kind":"local","local":"incomeLimitedProperty","exported":"incomeLimitedProperty"},{"kind":"local","local":"calculatePrimaryProperty","exported":"calculatePrimaryProperty"}]}}},"options":{"filename":"imports/core/config/constants.js","filenameRelative":"imports/core/config/constants.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],{"spec":false,"loose":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"imports/core/config/constants.js.map","sourceFileName":"imports/core/config/constants.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"constants"},"ignored":false,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nmodule.export({\n  fortuneLimitedProperty: function fortuneLimitedProperty() {\n    return _fortuneLimitedProperty;\n  },\n  incomeLimitedProperty: function incomeLimitedProperty() {\n    return _incomeLimitedProperty;\n  },\n  calculatePrimaryProperty: function calculatePrimaryProperty() {\n    return _calculatePrimaryProperty;\n  }\n});\n\nvar _USAGE_TYPE = void 0;\n\nmodule.watch(require(\"../api/constants\"), {\n  USAGE_TYPE: function USAGE_TYPE(v) {\n    _USAGE_TYPE = v;\n  }\n}, 0);\nexports.fortuneLimitedProperty = _fortuneLimitedProperty;\nvar constants = {\n  cpsLimit: 300,\n  // Average characters typed per second\n  amortization: 0.0125,\n  interests: 0.05,\n  interestsReal: 0.015,\n  maintenance: 0.01,\n  maintenanceReal: 0.005,\n  notaryFees: 0.05,\n  lppFees: 0.1,\n  maxRatio: 0.38,\n  minCash: 0.1,\n  getCurrency: function getCurrency() {\n    return 'CHF';\n  },\n  loanCost: function loanCost(borrowRatio, toRetirement) {\n    return this.interests + this.getAmortization(borrowRatio, toRetirement);\n  },\n  loanCostReal: function loanCostReal(borrowRatio, toRetirement, interestRate) {\n    return (interestRate || this.interestsReal) + this.getAmortization(borrowRatio, toRetirement);\n  },\n  propertyToIncome: function propertyToIncome() {\n    var usageType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _USAGE_TYPE.PRIMARY;\n    var borrowRatio = arguments[1];\n    var toRetirement = arguments[2];\n    return 3 * (this.maintenance + this.maxLoan(usageType, toRetirement) * this.loanCost(borrowRatio, toRetirement));\n  },\n  propertyToIncomeReal: function propertyToIncomeReal() {\n    var usageType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _USAGE_TYPE.PRIMARY;\n    var borrowRatio = arguments[1];\n    var toRetirement = arguments[2];\n    return 3 * (this.maintenanceReal + this.maxLoan(usageType, toRetirement) * this.loanCostReal(borrowRatio, toRetirement));\n  },\n  maxProperty: function maxProperty(income, fortune) {\n    var insuranceFortune = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var usageType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _USAGE_TYPE.PRIMARY;\n    var toRetirement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 15;\n    var r = toRetirement; // Make sure toRetirement is capped between 0 and 15 years\n\n    if (toRetirement < 0) {\n      r = 0;\n    } else if (toRetirement > 15) {\n      r = 15;\n    }\n\n    var fortuneLimited = _fortuneLimitedProperty(income, fortune, insuranceFortune, usageType, r);\n\n    var incomeLimited = _incomeLimitedProperty(income, fortune, insuranceFortune, usageType, r); // Use floor to make sure the ratios are respected and avoid edge cases\n\n\n    return Math.round(Math.min(fortuneLimited, incomeLimited));\n  },\n  maxLoan: function maxLoan() {\n    var usageType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _USAGE_TYPE.PRIMARY;\n    var toRetirement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;\n\n    if (toRetirement <= 0) {\n      return 0.65;\n    }\n\n    if (usageType === _USAGE_TYPE.SECONDARY) {\n      return 0.7;\n    }\n\n    return 0.8;\n  },\n  getAmortization: function getAmortization() {\n    var borrowRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.8;\n    var toRetirement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;\n\n    if (borrowRatio > 0.65) {\n      var toAmortize = borrowRatio - 0.65;\n\n      if (toRetirement > 15) {\n        // use parseFloat, to round to 15 decimals, which is the maximal guaranteed precision of floating pt. numbers\n        return Math.max(parseFloat(toAmortize / borrowRatio / 15).toPrecision(15));\n      } else if (toRetirement >= 0) {\n        // use parseFloat, to round to 15 decimals, which is the maximal guaranteed precision of floating pt. numbers\n        return Math.max(parseFloat(toAmortize / borrowRatio / toRetirement).toPrecision(15));\n      }\n\n      return parseFloat(toAmortize / borrowRatio).toPrecision(15);\n    }\n\n    return 0;\n  }\n};\n\nvar _fortuneLimitedProperty = function _fortuneLimitedProperty(income, fortune) {\n  var insuranceFortune = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var usageType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _USAGE_TYPE.PRIMARY;\n  var toRetirement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 15;\n  var fortuneLimited = 0;\n\n  if (usageType === _USAGE_TYPE.PRIMARY) {\n    // Use insuranceFortune to calculate more complicated value which\n    // includes lppFees\n    fortuneLimited = _calculatePrimaryProperty(fortune, insuranceFortune);\n  } else {\n    // Fortune should cover 20% and notary fees\n    fortuneLimited = fortune / (1 - constants.maxLoan(usageType, toRetirement) + 0.05);\n  }\n\n  return fortuneLimited;\n};\n\nvar _incomeLimitedProperty = function _incomeLimitedProperty(income, fortune) {\n  var insuranceFortune = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var usageType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _USAGE_TYPE.PRIMARY;\n  var toRetirement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 15;\n  // The arithmetic relation to have the cost of the loan be at exactly the max ratio of income\n  // Derive it like this:\n  // maxRatio * salary >= property * maintenance + loan * loanCost\n  // loan = (property + notaryFees + lppFees) - totalFortune\n  // Extract property from this relation\n  var totalFortune = fortune + insuranceFortune;\n  var lppFees = insuranceFortune * constants.lppFees;\n  var nF = constants.notaryFees;\n  var i = constants.interests;\n  var mR = constants.maxRatio;\n  var m = constants.maintenance;\n  var r = toRetirement; // The first one is with 0 amortization\n\n  var incomeLimited1 = (mR * income + (totalFortune - lppFees) * i) / (m + (1 + nF) * i); // The second is with amortization factored in (and it could be negative due to math)\n\n  var incomeLimited2 = ((1 + r * i) * (totalFortune - lppFees) + mR * r * income) / (r * (m + i) + nF * (1 + r * i) + 0.35); // Therefore, take the minimum value of both, which is the most limiting one\n  // Because of the ratios, round this value down\n\n  return Math.floor(Math.min(incomeLimited1, incomeLimited2));\n};\n\nvar _calculatePrimaryProperty = function _calculatePrimaryProperty(fortune, insuranceFortune) {\n  if (fortune <= 0 || insuranceFortune < 0) {\n    return 0;\n  }\n\n  var lppFees = insuranceFortune * constants.lppFees;\n  var notaryFees = constants.notaryFees; // Make sure cash can pay for lppFees, and fortune can cover notaryfees\n\n  var totalFortuneLimitedValue = (fortune - lppFees + insuranceFortune) / (0.2 + notaryFees); // Make sure cash can pay for lppfees and notaryfees\n\n  var cashLimitedValue = (fortune - lppFees) / (0.1 + notaryFees);\n  return Math.max(Math.round(Math.min(cashLimitedValue, totalFortuneLimitedValue)), 0);\n};\n\nmodule.exportDefault(constants);","map":{"version":3,"sources":["imports/core/config/constants.js"],"names":["module","export","fortuneLimitedProperty","incomeLimitedProperty","calculatePrimaryProperty","USAGE_TYPE","watch","require","v","constants","cpsLimit","amortization","interests","interestsReal","maintenance","maintenanceReal","notaryFees","lppFees","maxRatio","minCash","getCurrency","loanCost","borrowRatio","toRetirement","getAmortization","loanCostReal","interestRate","propertyToIncome","usageType","PRIMARY","maxLoan","propertyToIncomeReal","maxProperty","income","fortune","insuranceFortune","r","fortuneLimited","incomeLimited","Math","round","min","SECONDARY","toAmortize","max","parseFloat","toPrecision","totalFortune","nF","i","mR","m","incomeLimited1","incomeLimited2","floor","totalFortuneLimitedValue","cashLimitedValue","exportDefault"],"mappings":";;;;;AAAAA,OAAOC,MAAP,CAAc;AAACC,0BAAuB;AAAA,WAAIA,uBAAJ;AAAA,GAAxB;AAAmDC,yBAAsB;AAAA,WAAIA,sBAAJ;AAAA,GAAzE;AAAmGC,4BAAyB;AAAA,WAAIA,yBAAJ;AAAA;AAA5H,CAAd;;AAAyK,IAAIC,oBAAJ;;AAAeL,OAAOM,KAAP,CAAaC,QAAQ,kBAAR,CAAb,EAAyC;AAACF,YAAD,sBAAYG,CAAZ,EAAc;AAACH,kBAAWG,CAAX;AAAa;AAA5B,CAAzC,EAAuE,CAAvE;;AAExL,IAAMC,YAAY;AAChBC,YAAU,GADM;AACD;AACfC,gBAAc,MAFE;AAGhBC,aAAW,IAHK;AAIhBC,iBAAe,KAJC;AAKhBC,eAAa,IALG;AAMhBC,mBAAiB,KAND;AAOhBC,cAAY,IAPI;AAQhBC,WAAS,GARO;AAShBC,YAAU,IATM;AAUhBC,WAAS,GAVO;AAWhBC,eAAa;AAAA,WAAM,KAAN;AAAA,GAXG;AAYhBC,UAZgB,oBAYPC,WAZO,EAYMC,YAZN,EAYoB;AAClC,WAAO,KAAKX,SAAL,GAAiB,KAAKY,eAAL,CAAqBF,WAArB,EAAkCC,YAAlC,CAAxB;AACD,GAde;AAehBE,cAfgB,wBAeHH,WAfG,EAeUC,YAfV,EAewBG,YAfxB,EAesC;AACpD,WACE,CAACA,gBAAgB,KAAKb,aAAtB,IACA,KAAKW,eAAL,CAAqBF,WAArB,EAAkCC,YAAlC,CAFF;AAID,GApBe;AAqBhBI,kBArBgB,8BAqB4D;AAAA,QAA3DC,SAA2D,uEAA/CvB,YAAWwB,OAAoC;AAAA,QAA3BP,WAA2B;AAAA,QAAdC,YAAc;AAC1E,WACE,KACC,KAAKT,WAAL,GACC,KAAKgB,OAAL,CAAaF,SAAb,EAAwBL,YAAxB,IACE,KAAKF,QAAL,CAAcC,WAAd,EAA2BC,YAA3B,CAHJ,CADF;AAMD,GA5Be;AA6BhBQ,sBA7BgB,kCAiCd;AAAA,QAHAH,SAGA,uEAHYvB,YAAWwB,OAGvB;AAAA,QAFAP,WAEA;AAAA,QADAC,YACA;AACA,WACE,KACC,KAAKR,eAAL,GACC,KAAKe,OAAL,CAAaF,SAAb,EAAwBL,YAAxB,IACE,KAAKE,YAAL,CAAkBH,WAAlB,EAA+BC,YAA/B,CAHJ,CADF;AAMD,GAxCe;AAyChBS,aAzCgB,uBA0CdC,MA1Cc,EA2CdC,OA3Cc,EA+Cd;AAAA,QAHAC,gBAGA,uEAHmB,CAGnB;AAAA,QAFAP,SAEA,uEAFYvB,YAAWwB,OAEvB;AAAA,QADAN,YACA,uEADe,EACf;AACA,QAAIa,IAAIb,YAAR,CADA,CAEA;;AACA,QAAIA,eAAe,CAAnB,EAAsB;AACpBa,UAAI,CAAJ;AACD,KAFD,MAEO,IAAIb,eAAe,EAAnB,EAAuB;AAC5Ba,UAAI,EAAJ;AACD;;AAED,QAAMC,iBAAiBnC,wBACrB+B,MADqB,EAErBC,OAFqB,EAGrBC,gBAHqB,EAIrBP,SAJqB,EAKrBQ,CALqB,CAAvB;;AAOA,QAAME,gBAAgBnC,uBACpB8B,MADoB,EAEpBC,OAFoB,EAGpBC,gBAHoB,EAIpBP,SAJoB,EAKpBQ,CALoB,CAAtB,CAhBA,CAwBA;;;AACA,WAAOG,KAAKC,KAAL,CAAWD,KAAKE,GAAL,CAASJ,cAAT,EAAyBC,aAAzB,CAAX,CAAP;AACD,GAzEe;AA0EhBR,SA1EgB,qBA0E2C;AAAA,QAAnDF,SAAmD,uEAAvCvB,YAAWwB,OAA4B;AAAA,QAAnBN,YAAmB,uEAAJ,EAAI;;AACzD,QAAIA,gBAAgB,CAApB,EAAuB;AACrB,aAAO,IAAP;AACD;;AACD,QAAIK,cAAcvB,YAAWqC,SAA7B,EAAwC;AACtC,aAAO,GAAP;AACD;;AAED,WAAO,GAAP;AACD,GAnFe;AAoFhBlB,mBAAiB,2BAA0C;AAAA,QAAzCF,WAAyC,uEAA3B,GAA2B;AAAA,QAAtBC,YAAsB,uEAAP,EAAO;;AACzD,QAAID,cAAc,IAAlB,EAAwB;AACtB,UAAMqB,aAAarB,cAAc,IAAjC;;AACA,UAAIC,eAAe,EAAnB,EAAuB;AACrB;AACA,eAAOgB,KAAKK,GAAL,CAASC,WAAWF,aAAarB,WAAb,GAA2B,EAAtC,EAA0CwB,WAA1C,CAAsD,EAAtD,CAAT,CAAP;AACD,OAHD,MAGO,IAAIvB,gBAAgB,CAApB,EAAuB;AAC5B;AACA,eAAOgB,KAAKK,GAAL,CAASC,WAAWF,aAAarB,WAAb,GAA2BC,YAAtC,EAAoDuB,WAApD,CAAgE,EAAhE,CAAT,CAAP;AACD;;AACD,aAAOD,WAAWF,aAAarB,WAAxB,EAAqCwB,WAArC,CAAiD,EAAjD,CAAP;AACD;;AAED,WAAO,CAAP;AACD;AAlGe,CAAlB;;AAqGO,IAAM5C,0BAAyB,SAAzBA,uBAAyB,CACpC+B,MADoC,EAEpCC,OAFoC,EAMjC;AAAA,MAHHC,gBAGG,uEAHgB,CAGhB;AAAA,MAFHP,SAEG,uEAFSvB,YAAWwB,OAEpB;AAAA,MADHN,YACG,uEADY,EACZ;AACH,MAAIc,iBAAiB,CAArB;;AAEA,MAAIT,cAAcvB,YAAWwB,OAA7B,EAAsC;AACpC;AACA;AACAQ,qBAAiBjC,0BAAyB8B,OAAzB,EAAkCC,gBAAlC,CAAjB;AACD,GAJD,MAIO;AACL;AACAE,qBACEH,WAAW,IAAIzB,UAAUqB,OAAV,CAAkBF,SAAlB,EAA6BL,YAA7B,CAAJ,GAAiD,IAA5D,CADF;AAED;;AACD,SAAOc,cAAP;AACD,CAnBM;;AAqBA,IAAMlC,yBAAwB,SAAxBA,sBAAwB,CACnC8B,MADmC,EAEnCC,OAFmC,EAMhC;AAAA,MAHHC,gBAGG,uEAHgB,CAGhB;AAAA,MAFHP,SAEG,uEAFSvB,YAAWwB,OAEpB;AAAA,MADHN,YACG,uEADY,EACZ;AACH;AACA;AACA;AACA;AACA;AACA,MAAMwB,eAAeb,UAAUC,gBAA/B;AACA,MAAMlB,UAAUkB,mBAAmB1B,UAAUQ,OAA7C;AACA,MAAM+B,KAAKvC,UAAUO,UAArB;AACA,MAAMiC,IAAIxC,UAAUG,SAApB;AACA,MAAMsC,KAAKzC,UAAUS,QAArB;AACA,MAAMiC,IAAI1C,UAAUK,WAApB;AACA,MAAMsB,IAAIb,YAAV,CAZG,CAcH;;AACA,MAAM6B,iBACJ,CAACF,KAAKjB,MAAL,GAAc,CAACc,eAAe9B,OAAhB,IAA2BgC,CAA1C,KAAgDE,IAAI,CAAC,IAAIH,EAAL,IAAWC,CAA/D,CADF,CAfG,CAkBH;;AACA,MAAMI,iBACJ,CAAC,CAAC,IAAIjB,IAAIa,CAAT,KAAeF,eAAe9B,OAA9B,IAAyCiC,KAAKd,CAAL,GAASH,MAAnD,KACCG,KAAKe,IAAIF,CAAT,IAAcD,MAAM,IAAIZ,IAAIa,CAAd,CAAd,GAAiC,IADlC,CADF,CAnBG,CAuBH;AACA;;AACA,SAAOV,KAAKe,KAAL,CAAWf,KAAKE,GAAL,CAASW,cAAT,EAAyBC,cAAzB,CAAX,CAAP;AACD,CAhCM;;AAkCA,IAAMjD,4BAA2B,SAA3BA,yBAA2B,CAAC8B,OAAD,EAAUC,gBAAV,EAA+B;AACrE,MAAID,WAAW,CAAX,IAAgBC,mBAAmB,CAAvC,EAA0C;AACxC,WAAO,CAAP;AACD;;AAED,MAAMlB,UAAUkB,mBAAmB1B,UAAUQ,OAA7C;AACA,MAAMD,aAAaP,UAAUO,UAA7B,CANqE,CAQrE;;AACA,MAAMuC,2BACJ,CAACrB,UAAUjB,OAAV,GAAoBkB,gBAArB,KAA0C,MAAMnB,UAAhD,CADF,CATqE,CAYrE;;AACA,MAAMwC,mBAAmB,CAACtB,UAAUjB,OAAX,KAAuB,MAAMD,UAA7B,CAAzB;AAEA,SAAOuB,KAAKK,GAAL,CACLL,KAAKC,KAAL,CAAWD,KAAKE,GAAL,CAASe,gBAAT,EAA2BD,wBAA3B,CAAX,CADK,EAEL,CAFK,CAAP;AAID,CAnBM;;AA9JPvD,OAAOyD,aAAP,CAmLehD,SAnLf","file":"imports/core/config/constants.js.map","sourcesContent":["import { USAGE_TYPE } from 'core/api/constants';\n\nconst constants = {\n  cpsLimit: 300, // Average characters typed per second\n  amortization: 0.0125,\n  interests: 0.05,\n  interestsReal: 0.015,\n  maintenance: 0.01,\n  maintenanceReal: 0.005,\n  notaryFees: 0.05,\n  lppFees: 0.1,\n  maxRatio: 0.38,\n  minCash: 0.1,\n  getCurrency: () => 'CHF',\n  loanCost(borrowRatio, toRetirement) {\n    return this.interests + this.getAmortization(borrowRatio, toRetirement);\n  },\n  loanCostReal(borrowRatio, toRetirement, interestRate) {\n    return (\n      (interestRate || this.interestsReal) +\n      this.getAmortization(borrowRatio, toRetirement)\n    );\n  },\n  propertyToIncome(usageType = USAGE_TYPE.PRIMARY, borrowRatio, toRetirement) {\n    return (\n      3 *\n      (this.maintenance +\n        this.maxLoan(usageType, toRetirement) *\n          this.loanCost(borrowRatio, toRetirement))\n    );\n  },\n  propertyToIncomeReal(\n    usageType = USAGE_TYPE.PRIMARY,\n    borrowRatio,\n    toRetirement,\n  ) {\n    return (\n      3 *\n      (this.maintenanceReal +\n        this.maxLoan(usageType, toRetirement) *\n          this.loanCostReal(borrowRatio, toRetirement))\n    );\n  },\n  maxProperty(\n    income,\n    fortune,\n    insuranceFortune = 0,\n    usageType = USAGE_TYPE.PRIMARY,\n    toRetirement = 15,\n  ) {\n    let r = toRetirement;\n    // Make sure toRetirement is capped between 0 and 15 years\n    if (toRetirement < 0) {\n      r = 0;\n    } else if (toRetirement > 15) {\n      r = 15;\n    }\n\n    const fortuneLimited = fortuneLimitedProperty(\n      income,\n      fortune,\n      insuranceFortune,\n      usageType,\n      r,\n    );\n    const incomeLimited = incomeLimitedProperty(\n      income,\n      fortune,\n      insuranceFortune,\n      usageType,\n      r,\n    );\n\n    // Use floor to make sure the ratios are respected and avoid edge cases\n    return Math.round(Math.min(fortuneLimited, incomeLimited));\n  },\n  maxLoan(usageType = USAGE_TYPE.PRIMARY, toRetirement = 15) {\n    if (toRetirement <= 0) {\n      return 0.65;\n    }\n    if (usageType === USAGE_TYPE.SECONDARY) {\n      return 0.7;\n    }\n\n    return 0.8;\n  },\n  getAmortization: (borrowRatio = 0.8, toRetirement = 15) => {\n    if (borrowRatio > 0.65) {\n      const toAmortize = borrowRatio - 0.65;\n      if (toRetirement > 15) {\n        // use parseFloat, to round to 15 decimals, which is the maximal guaranteed precision of floating pt. numbers\n        return Math.max(parseFloat(toAmortize / borrowRatio / 15).toPrecision(15));\n      } else if (toRetirement >= 0) {\n        // use parseFloat, to round to 15 decimals, which is the maximal guaranteed precision of floating pt. numbers\n        return Math.max(parseFloat(toAmortize / borrowRatio / toRetirement).toPrecision(15));\n      }\n      return parseFloat(toAmortize / borrowRatio).toPrecision(15);\n    }\n\n    return 0;\n  },\n};\n\nexport const fortuneLimitedProperty = (\n  income,\n  fortune,\n  insuranceFortune = 0,\n  usageType = USAGE_TYPE.PRIMARY,\n  toRetirement = 15,\n) => {\n  let fortuneLimited = 0;\n\n  if (usageType === USAGE_TYPE.PRIMARY) {\n    // Use insuranceFortune to calculate more complicated value which\n    // includes lppFees\n    fortuneLimited = calculatePrimaryProperty(fortune, insuranceFortune);\n  } else {\n    // Fortune should cover 20% and notary fees\n    fortuneLimited =\n      fortune / (1 - constants.maxLoan(usageType, toRetirement) + 0.05);\n  }\n  return fortuneLimited;\n};\n\nexport const incomeLimitedProperty = (\n  income,\n  fortune,\n  insuranceFortune = 0,\n  usageType = USAGE_TYPE.PRIMARY,\n  toRetirement = 15,\n) => {\n  // The arithmetic relation to have the cost of the loan be at exactly the max ratio of income\n  // Derive it like this:\n  // maxRatio * salary >= property * maintenance + loan * loanCost\n  // loan = (property + notaryFees + lppFees) - totalFortune\n  // Extract property from this relation\n  const totalFortune = fortune + insuranceFortune;\n  const lppFees = insuranceFortune * constants.lppFees;\n  const nF = constants.notaryFees;\n  const i = constants.interests;\n  const mR = constants.maxRatio;\n  const m = constants.maintenance;\n  const r = toRetirement;\n\n  // The first one is with 0 amortization\n  const incomeLimited1 =\n    (mR * income + (totalFortune - lppFees) * i) / (m + (1 + nF) * i);\n\n  // The second is with amortization factored in (and it could be negative due to math)\n  const incomeLimited2 =\n    ((1 + r * i) * (totalFortune - lppFees) + mR * r * income) /\n    (r * (m + i) + nF * (1 + r * i) + 0.35);\n\n  // Therefore, take the minimum value of both, which is the most limiting one\n  // Because of the ratios, round this value down\n  return Math.floor(Math.min(incomeLimited1, incomeLimited2));\n};\n\nexport const calculatePrimaryProperty = (fortune, insuranceFortune) => {\n  if (fortune <= 0 || insuranceFortune < 0) {\n    return 0;\n  }\n\n  const lppFees = insuranceFortune * constants.lppFees;\n  const notaryFees = constants.notaryFees;\n\n  // Make sure cash can pay for lppFees, and fortune can cover notaryfees\n  const totalFortuneLimitedValue =\n    (fortune - lppFees + insuranceFortune) / (0.2 + notaryFees);\n\n  // Make sure cash can pay for lppfees and notaryfees\n  const cashLimitedValue = (fortune - lppFees) / (0.1 + notaryFees);\n\n  return Math.max(\n    Math.round(Math.min(cashLimitedValue, totalFortuneLimitedValue)),\n    0,\n  );\n};\n\nexport default constants;\n"]},"hash":"7bc3fe87c97fb7bd9904902e2e2eea35650eb756"}
