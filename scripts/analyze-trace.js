/**
 * Script to output a tree for traces. Traces are generated by the
 * backend microservice when the env var SAVE_TRACE_PATH is set
 * usage:
 *   node analyze-trace.js ./path/to/trace.json
 */

const [, , tracePath] = process.argv;
// eslint-disable-next-line import/no-dynamic-require
const trace = require(tracePath);

console.log('Loaded trace with id', trace._id);

function showEvents(events, depth = 0, path = []) {
  const prefix = ''.padStart(depth * 3, '|  ');

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    // Exclude async events without children since we only care
    // about the db events that cause publish composite to be slow
    if (event.type === 'async' && event.nested.length === 0) {
      // eslint-disable-next-line no-continue
      continue;
    }

    console.log(
      `${prefix}|- ${i} - ${event.type} - ${event._duration} - ${event.data &&
        event.data.coll} - ${event.data && event.data.selector} - ${path.join(
        '->',
      )}`,
    );

    if (event.nested && event.nested.length) {
      // Ignore nested events when they are all async and have no nested events
      // since they are unhelpful.
      if (
        !event.nested.every(
          nestedEvent =>
            nestedEvent.type === 'async' &&
            nestedEvent.nested &&
            nestedEvent.nested.length,
        )
      ) {
        const newPath = [...path];
        const coll = event.data && event.data.coll ? event.data.coll : ' ';

        // In publish composite, there are frequently two db events for the same collection,
        // one nested in the other. Since the second one adds nothing new, we ignore it.
        if (coll !== path[path.length - 1]) {
          newPath.push(coll);
        }
        showEvents(event.nested, depth + 1, newPath);
      }
    }
  }
}

showEvents(trace.events);
